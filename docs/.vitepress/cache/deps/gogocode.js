import {
  __commonJS,
  __require
} from "./chunk-BQWMX7FD.js";

// node_modules/gogocode/umd/gogocode.js
var require_gogocode = __commonJS({
  "node_modules/gogocode/umd/gogocode.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.gogocode = factory());
    })(exports, function() {
      "use strict";
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getAugmentedNamespace(n2) {
        if (n2.__esModule)
          return n2;
        var a = Object.defineProperty({}, "__esModule", { value: true });
        Object.keys(n2).forEach(function(k) {
          var d = Object.getOwnPropertyDescriptor(n2, k);
          Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return n2[k];
            }
          });
        });
        return a;
      }
      var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            args[i2 - 1] = arguments[i2];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      var title = "browser";
      var platform$1 = "browser";
      var browser$2 = true;
      var env = {};
      var argv = [];
      var version$1 = "";
      var versions = {};
      var release$1 = {};
      var config$1 = {};
      function noop() {
      }
      var on = noop;
      var addListener = noop;
      var once = noop;
      var off = noop;
      var removeListener = noop;
      var removeAllListeners = noop;
      var emit = noop;
      function binding(name2) {
        throw new Error("process.binding is not supported");
      }
      function cwd() {
        return "/";
      }
      function chdir(dir) {
        throw new Error("process.chdir is not supported");
      }
      function umask() {
        return 0;
      }
      var performance = global$1.performance || {};
      var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      function hrtime(previousTimestamp) {
        var clocktime = performanceNow.call(performance) * 1e-3;
        var seconds = Math.floor(clocktime);
        var nanoseconds = Math.floor(clocktime % 1 * 1e9);
        if (previousTimestamp) {
          seconds = seconds - previousTimestamp[0];
          nanoseconds = nanoseconds - previousTimestamp[1];
          if (nanoseconds < 0) {
            seconds--;
            nanoseconds += 1e9;
          }
        }
        return [seconds, nanoseconds];
      }
      var startTime = /* @__PURE__ */ new Date();
      function uptime$1() {
        var currentTime = /* @__PURE__ */ new Date();
        var dif = currentTime - startTime;
        return dif / 1e3;
      }
      var browser$1$1 = {
        nextTick,
        title,
        browser: browser$2,
        env,
        argv,
        version: version$1,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform: platform$1,
        release: release$1,
        config: config$1,
        uptime: uptime$1
      };
      var main$3 = {};
      var _nodeResolve_empty = {};
      var _nodeResolve_empty$1 = Object.freeze({
        __proto__: null,
        "default": _nodeResolve_empty
      });
      var require$$4$1 = getAugmentedNamespace(_nodeResolve_empty$1);
      var main$2 = {};
      var extendStatics = function(d, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics(d, b2);
      };
      function __extends(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      }
      var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign2(t2) {
          for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s = arguments[i2];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t2[p] = s[p];
          }
          return t2;
        };
        return __assign$1.apply(this, arguments);
      };
      function __rest(s, e) {
        var t2 = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t2[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
            if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
              t2[p[i2]] = s[p[i2]];
          }
        return t2;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result2) {
            result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      var __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      function __exportStar(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n2) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i2 = m.call(o), r, ar = [], e;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r = i2.next()).done)
            ar.push(r.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r && !r.done && (m = i2["return"]))
              m.call(i2);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s += arguments[i2].length;
        for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      }
      function __spreadArray(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i2);
              ar[i2] = from2[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      }
      function __await(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a, b2) {
                q.push([n2, v2, a, b2]) > 1 || resume2(n2, v2);
              });
            };
        }
        function resume2(n2, v2) {
          try {
            step(g[n2](v2));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f, v2) {
          if (f(v2), q.shift(), q.length)
            resume2(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f) {
          i2[n2] = o[n2] ? function(v2) {
            return (p = !p) ? { value: __await(o[n2](v2)), done: n2 === "return" } : f ? f(v2) : v2;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i2;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o[n2] && function(v2) {
            return new Promise(function(resolve2, reject) {
              v2 = o[n2](v2), settle(resolve2, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve2, reject, d, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve2({ value: v3, done: d });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      var __setModuleDefault = Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      };
      function __importStar$7(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result2, mod, k);
        }
        __setModuleDefault(result2, mod);
        return result2;
      }
      function __importDefault$9(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      }
      function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      }
      function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      }
      function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }
      var tslib_es6 = Object.freeze({
        __proto__: null,
        __extends,
        get __assign() {
          return __assign$1;
        },
        __rest,
        __decorate,
        __param,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar: __importStar$7,
        __importDefault: __importDefault$9,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn
      });
      var require$$0$5 = getAugmentedNamespace(tslib_es6);
      var fork = { exports: {} };
      var types$b = {};
      Object.defineProperty(types$b, "__esModule", { value: true });
      types$b.Def = void 0;
      var tslib_1 = require$$0$5;
      var Op = Object.prototype;
      var objToStr = Op.toString;
      var hasOwn$9 = Op.hasOwnProperty;
      var BaseType = (
        /** @class */
        function() {
          function BaseType2() {
          }
          BaseType2.prototype.assert = function(value, deep) {
            if (!this.check(value, deep)) {
              var str2 = shallowStringify(value);
              throw new Error(str2 + " does not match type " + this);
            }
            return true;
          };
          BaseType2.prototype.arrayOf = function() {
            var elemType = this;
            return new ArrayType(elemType);
          };
          return BaseType2;
        }()
      );
      var ArrayType = (
        /** @class */
        function(_super) {
          tslib_1.__extends(ArrayType2, _super);
          function ArrayType2(elemType) {
            var _this = _super.call(this) || this;
            _this.elemType = elemType;
            _this.kind = "ArrayType";
            return _this;
          }
          ArrayType2.prototype.toString = function() {
            return "[" + this.elemType + "]";
          };
          ArrayType2.prototype.check = function(value, deep) {
            var _this = this;
            return Array.isArray(value) && value.every(function(elem) {
              return _this.elemType.check(elem, deep);
            });
          };
          return ArrayType2;
        }(BaseType)
      );
      var IdentityType = (
        /** @class */
        function(_super) {
          tslib_1.__extends(IdentityType2, _super);
          function IdentityType2(value) {
            var _this = _super.call(this) || this;
            _this.value = value;
            _this.kind = "IdentityType";
            return _this;
          }
          IdentityType2.prototype.toString = function() {
            return String(this.value);
          };
          IdentityType2.prototype.check = function(value, deep) {
            var result2 = value === this.value;
            if (!result2 && typeof deep === "function") {
              deep(this, value);
            }
            return result2;
          };
          return IdentityType2;
        }(BaseType)
      );
      var ObjectType = (
        /** @class */
        function(_super) {
          tslib_1.__extends(ObjectType2, _super);
          function ObjectType2(fields) {
            var _this = _super.call(this) || this;
            _this.fields = fields;
            _this.kind = "ObjectType";
            return _this;
          }
          ObjectType2.prototype.toString = function() {
            return "{ " + this.fields.join(", ") + " }";
          };
          ObjectType2.prototype.check = function(value, deep) {
            return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
              return field.type.check(value[field.name], deep);
            });
          };
          return ObjectType2;
        }(BaseType)
      );
      var OrType = (
        /** @class */
        function(_super) {
          tslib_1.__extends(OrType2, _super);
          function OrType2(types2) {
            var _this = _super.call(this) || this;
            _this.types = types2;
            _this.kind = "OrType";
            return _this;
          }
          OrType2.prototype.toString = function() {
            return this.types.join(" | ");
          };
          OrType2.prototype.check = function(value, deep) {
            return this.types.some(function(type2) {
              return type2.check(value, deep);
            });
          };
          return OrType2;
        }(BaseType)
      );
      var PredicateType = (
        /** @class */
        function(_super) {
          tslib_1.__extends(PredicateType2, _super);
          function PredicateType2(name2, predicate) {
            var _this = _super.call(this) || this;
            _this.name = name2;
            _this.predicate = predicate;
            _this.kind = "PredicateType";
            return _this;
          }
          PredicateType2.prototype.toString = function() {
            return this.name;
          };
          PredicateType2.prototype.check = function(value, deep) {
            var result2 = this.predicate(value, deep);
            if (!result2 && typeof deep === "function") {
              deep(this, value);
            }
            return result2;
          };
          return PredicateType2;
        }(BaseType)
      );
      var Def = (
        /** @class */
        function() {
          function Def2(type2, typeName) {
            this.type = type2;
            this.typeName = typeName;
            this.baseNames = [];
            this.ownFields = /* @__PURE__ */ Object.create(null);
            this.allSupertypes = /* @__PURE__ */ Object.create(null);
            this.supertypeList = [];
            this.allFields = /* @__PURE__ */ Object.create(null);
            this.fieldNames = [];
            this.finalized = false;
            this.buildable = false;
            this.buildParams = [];
          }
          Def2.prototype.isSupertypeOf = function(that) {
            if (that instanceof Def2) {
              if (this.finalized !== true || that.finalized !== true) {
                throw new Error("");
              }
              return hasOwn$9.call(that.allSupertypes, this.typeName);
            } else {
              throw new Error(that + " is not a Def");
            }
          };
          Def2.prototype.checkAllFields = function(value, deep) {
            var allFields = this.allFields;
            if (this.finalized !== true) {
              throw new Error("" + this.typeName);
            }
            function checkFieldByName(name2) {
              var field = allFields[name2];
              var type2 = field.type;
              var child = field.getValue(value);
              return type2.check(child, deep);
            }
            return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
          };
          Def2.prototype.bases = function() {
            var supertypeNames = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              supertypeNames[_i] = arguments[_i];
            }
            var bases = this.baseNames;
            if (this.finalized) {
              if (supertypeNames.length !== bases.length) {
                throw new Error("");
              }
              for (var i2 = 0; i2 < supertypeNames.length; i2++) {
                if (supertypeNames[i2] !== bases[i2]) {
                  throw new Error("");
                }
              }
              return this;
            }
            supertypeNames.forEach(function(baseName) {
              if (bases.indexOf(baseName) < 0) {
                bases.push(baseName);
              }
            });
            return this;
          };
          return Def2;
        }()
      );
      types$b.Def = Def;
      var Field = (
        /** @class */
        function() {
          function Field2(name2, type2, defaultFn, hidden) {
            this.name = name2;
            this.type = type2;
            this.defaultFn = defaultFn;
            this.hidden = !!hidden;
          }
          Field2.prototype.toString = function() {
            return JSON.stringify(this.name) + ": " + this.type;
          };
          Field2.prototype.getValue = function(obj) {
            var value = obj[this.name];
            if (typeof value !== "undefined") {
              return value;
            }
            if (typeof this.defaultFn === "function") {
              value = this.defaultFn.call(obj);
            }
            return value;
          };
          return Field2;
        }()
      );
      function shallowStringify(value) {
        if (Array.isArray(value)) {
          return "[" + value.map(shallowStringify).join(", ") + "]";
        }
        if (value && typeof value === "object") {
          return "{ " + Object.keys(value).map(function(key) {
            return key + ": " + value[key];
          }).join(", ") + " }";
        }
        return JSON.stringify(value);
      }
      function typesPlugin(_fork) {
        var Type = {
          or: function() {
            var types2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              types2[_i] = arguments[_i];
            }
            return new OrType(types2.map(function(type2) {
              return Type.from(type2);
            }));
          },
          from: function(value, name2) {
            if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {
              return value;
            }
            if (value instanceof Def) {
              return value.type;
            }
            if (isArray2.check(value)) {
              if (value.length !== 1) {
                throw new Error("only one element type is permitted for typed arrays");
              }
              return new ArrayType(Type.from(value[0]));
            }
            if (isObject2.check(value)) {
              return new ObjectType(Object.keys(value).map(function(name3) {
                return new Field(name3, Type.from(value[name3], name3));
              }));
            }
            if (typeof value === "function") {
              var bicfIndex = builtInCtorFns.indexOf(value);
              if (bicfIndex >= 0) {
                return builtInCtorTypes[bicfIndex];
              }
              if (typeof name2 !== "string") {
                throw new Error("missing name");
              }
              return new PredicateType(name2, value);
            }
            return new IdentityType(value);
          },
          // Define a type whose name is registered in a namespace (the defCache) so
          // that future definitions will return the same type given the same name.
          // In particular, this system allows for circular and forward definitions.
          // The Def object d returned from Type.def may be used to configure the
          // type d.type by calling methods such as d.bases, d.build, and d.field.
          def: function(typeName) {
            return hasOwn$9.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
          },
          hasDef: function(typeName) {
            return hasOwn$9.call(defCache, typeName);
          }
        };
        var builtInCtorFns = [];
        var builtInCtorTypes = [];
        function defBuiltInType(name2, example) {
          var objStr = objToStr.call(example);
          var type2 = new PredicateType(name2, function(value) {
            return objToStr.call(value) === objStr;
          });
          if (example && typeof example.constructor === "function") {
            builtInCtorFns.push(example.constructor);
            builtInCtorTypes.push(type2);
          }
          return type2;
        }
        var isString2 = defBuiltInType("string", "truthy");
        var isFunction2 = defBuiltInType("function", function() {
        });
        var isArray2 = defBuiltInType("array", []);
        var isObject2 = defBuiltInType("object", {});
        var isRegExp2 = defBuiltInType("RegExp", /./);
        var isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date());
        var isNumber2 = defBuiltInType("number", 3);
        var isBoolean2 = defBuiltInType("boolean", true);
        var isNull2 = defBuiltInType("null", null);
        var isUndefined2 = defBuiltInType("undefined", void 0);
        var builtInTypes = {
          string: isString2,
          function: isFunction2,
          array: isArray2,
          object: isObject2,
          RegExp: isRegExp2,
          Date: isDate2,
          number: isNumber2,
          boolean: isBoolean2,
          null: isNull2,
          undefined: isUndefined2
        };
        var defCache = /* @__PURE__ */ Object.create(null);
        function defFromValue(value) {
          if (value && typeof value === "object") {
            var type2 = value.type;
            if (typeof type2 === "string" && hasOwn$9.call(defCache, type2)) {
              var d = defCache[type2];
              if (d.finalized) {
                return d;
              }
            }
          }
          return null;
        }
        var DefImpl = (
          /** @class */
          function(_super) {
            tslib_1.__extends(DefImpl2, _super);
            function DefImpl2(typeName) {
              var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
                return _this.check(value, deep);
              }), typeName) || this;
              return _this;
            }
            DefImpl2.prototype.check = function(value, deep) {
              if (this.finalized !== true) {
                throw new Error("prematurely checking unfinalized type " + this.typeName);
              }
              if (value === null || typeof value !== "object") {
                return false;
              }
              var vDef = defFromValue(value);
              if (!vDef) {
                if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                  return this.checkAllFields(value, deep);
                }
                return false;
              }
              if (deep && vDef === this) {
                return this.checkAllFields(value, deep);
              }
              if (!this.isSupertypeOf(vDef)) {
                return false;
              }
              if (!deep) {
                return true;
              }
              return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
            };
            DefImpl2.prototype.build = function() {
              var _this = this;
              var buildParams = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                buildParams[_i] = arguments[_i];
              }
              this.buildParams = buildParams;
              if (this.buildable) {
                return this;
              }
              this.field("type", String, function() {
                return _this.typeName;
              });
              this.buildable = true;
              var addParam = function(built, param, arg, isArgAvailable) {
                if (hasOwn$9.call(built, param))
                  return;
                var all = _this.allFields;
                if (!hasOwn$9.call(all, param)) {
                  throw new Error("" + param);
                }
                var field = all[param];
                var type2 = field.type;
                var value;
                if (isArgAvailable) {
                  value = arg;
                } else if (field.defaultFn) {
                  value = field.defaultFn.call(built);
                } else {
                  var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name2) {
                    return all[name2];
                  }).join(", ") + ")";
                  throw new Error(message);
                }
                if (!type2.check(value)) {
                  throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                }
                built[param] = value;
              };
              var builder = function() {
                var args = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  args[_i2] = arguments[_i2];
                }
                var argc = args.length;
                if (!_this.finalized) {
                  throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                }
                var built = Object.create(nodePrototype);
                _this.buildParams.forEach(function(param, i2) {
                  if (i2 < argc) {
                    addParam(built, param, args[i2], true);
                  } else {
                    addParam(built, param, null, false);
                  }
                });
                Object.keys(_this.allFields).forEach(function(param) {
                  addParam(built, param, null, false);
                });
                if (built.type !== _this.typeName) {
                  throw new Error("");
                }
                return built;
              };
              builder.from = function(obj) {
                if (!_this.finalized) {
                  throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
                }
                var built = Object.create(nodePrototype);
                Object.keys(_this.allFields).forEach(function(param) {
                  if (hasOwn$9.call(obj, param)) {
                    addParam(built, param, obj[param], true);
                  } else {
                    addParam(built, param, null, false);
                  }
                });
                if (built.type !== _this.typeName) {
                  throw new Error("");
                }
                return built;
              };
              Object.defineProperty(builders, getBuilderName(this.typeName), {
                enumerable: true,
                value: builder
              });
              return this;
            };
            DefImpl2.prototype.field = function(name2, type2, defaultFn, hidden) {
              if (this.finalized) {
                console.error("Ignoring attempt to redefine field " + JSON.stringify(name2) + " of finalized type " + JSON.stringify(this.typeName));
                return this;
              }
              this.ownFields[name2] = new Field(name2, Type.from(type2), defaultFn, hidden);
              return this;
            };
            DefImpl2.prototype.finalize = function() {
              var _this = this;
              if (!this.finalized) {
                var allFields = this.allFields;
                var allSupertypes = this.allSupertypes;
                this.baseNames.forEach(function(name2) {
                  var def2 = defCache[name2];
                  if (def2 instanceof Def) {
                    def2.finalize();
                    extend2(allFields, def2.allFields);
                    extend2(allSupertypes, def2.allSupertypes);
                  } else {
                    var message = "unknown supertype name " + JSON.stringify(name2) + " for subtype " + JSON.stringify(_this.typeName);
                    throw new Error(message);
                  }
                });
                extend2(allFields, this.ownFields);
                allSupertypes[this.typeName] = this;
                this.fieldNames.length = 0;
                for (var fieldName in allFields) {
                  if (hasOwn$9.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                    this.fieldNames.push(fieldName);
                  }
                }
                Object.defineProperty(namedTypes2, this.typeName, {
                  enumerable: true,
                  value: this.type
                });
                this.finalized = true;
                populateSupertypeList(this.typeName, this.supertypeList);
                if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
                  wrapExpressionBuilderWithStatement(this.typeName);
                }
              }
            };
            return DefImpl2;
          }(Def)
        );
        function getSupertypeNames(typeName) {
          if (!hasOwn$9.call(defCache, typeName)) {
            throw new Error("");
          }
          var d = defCache[typeName];
          if (d.finalized !== true) {
            throw new Error("");
          }
          return d.supertypeList.slice(1);
        }
        function computeSupertypeLookupTable(candidates) {
          var table = {};
          var typeNames = Object.keys(defCache);
          var typeNameCount = typeNames.length;
          for (var i2 = 0; i2 < typeNameCount; ++i2) {
            var typeName = typeNames[i2];
            var d = defCache[typeName];
            if (d.finalized !== true) {
              throw new Error("" + typeName);
            }
            for (var j = 0; j < d.supertypeList.length; ++j) {
              var superTypeName = d.supertypeList[j];
              if (hasOwn$9.call(candidates, superTypeName)) {
                table[typeName] = superTypeName;
                break;
              }
            }
          }
          return table;
        }
        var builders = /* @__PURE__ */ Object.create(null);
        var nodePrototype = {};
        function defineMethod(name2, func) {
          var old = nodePrototype[name2];
          if (isUndefined2.check(func)) {
            delete nodePrototype[name2];
          } else {
            isFunction2.assert(func);
            Object.defineProperty(nodePrototype, name2, {
              enumerable: true,
              configurable: true,
              value: func
            });
          }
          return old;
        }
        function getBuilderName(typeName) {
          return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
            var len = upperCasePrefix.length;
            switch (len) {
              case 0:
                return "";
              case 1:
                return upperCasePrefix.toLowerCase();
              default:
                return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
            }
          });
        }
        function getStatementBuilderName(typeName) {
          typeName = getBuilderName(typeName);
          return typeName.replace(/(Expression)?$/, "Statement");
        }
        var namedTypes2 = {};
        function getFieldNames(object2) {
          var d = defFromValue(object2);
          if (d) {
            return d.fieldNames.slice(0);
          }
          if ("type" in object2) {
            throw new Error("did not recognize object of type " + JSON.stringify(object2.type));
          }
          return Object.keys(object2);
        }
        function getFieldValue(object2, fieldName) {
          var d = defFromValue(object2);
          if (d) {
            var field = d.allFields[fieldName];
            if (field) {
              return field.getValue(object2);
            }
          }
          return object2 && object2[fieldName];
        }
        function eachField(object2, callback, context) {
          getFieldNames(object2).forEach(function(name2) {
            callback.call(this, name2, getFieldValue(object2, name2));
          }, context);
        }
        function someField(object2, callback, context) {
          return getFieldNames(object2).some(function(name2) {
            return callback.call(this, name2, getFieldValue(object2, name2));
          }, context);
        }
        function wrapExpressionBuilderWithStatement(typeName) {
          var wrapperName = getStatementBuilderName(typeName);
          if (builders[wrapperName])
            return;
          var wrapped = builders[getBuilderName(typeName)];
          if (!wrapped)
            return;
          var builder = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return builders.expressionStatement(wrapped.apply(builders, args));
          };
          builder.from = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return builders.expressionStatement(wrapped.from.apply(builders, args));
          };
          builders[wrapperName] = builder;
        }
        function populateSupertypeList(typeName, list2) {
          list2.length = 0;
          list2.push(typeName);
          var lastSeen = /* @__PURE__ */ Object.create(null);
          for (var pos = 0; pos < list2.length; ++pos) {
            typeName = list2[pos];
            var d = defCache[typeName];
            if (d.finalized !== true) {
              throw new Error("");
            }
            if (hasOwn$9.call(lastSeen, typeName)) {
              delete list2[lastSeen[typeName]];
            }
            lastSeen[typeName] = pos;
            list2.push.apply(list2, d.baseNames);
          }
          for (var to = 0, from2 = to, len = list2.length; from2 < len; ++from2) {
            if (hasOwn$9.call(list2, from2)) {
              list2[to++] = list2[from2];
            }
          }
          list2.length = to;
        }
        function extend2(into, from2) {
          Object.keys(from2).forEach(function(name2) {
            into[name2] = from2[name2];
          });
          return into;
        }
        function finalize() {
          Object.keys(defCache).forEach(function(name2) {
            defCache[name2].finalize();
          });
        }
        return {
          Type,
          builtInTypes,
          getSupertypeNames,
          computeSupertypeLookupTable,
          builders,
          defineMethod,
          getBuilderName,
          getStatementBuilderName,
          namedTypes: namedTypes2,
          getFieldNames,
          getFieldValue,
          eachField,
          someField,
          finalize
        };
      }
      types$b.default = typesPlugin;
      var pathVisitor = { exports: {} };
      var nodePath = { exports: {} };
      var path$5 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var Op2 = Object.prototype;
        var hasOwn2 = Op2.hasOwnProperty;
        function pathPlugin(fork2) {
          var types2 = fork2.use(types_1.default);
          var isArray2 = types2.builtInTypes.array;
          var isNumber2 = types2.builtInTypes.number;
          var Path = function Path2(value, parentPath, name2) {
            if (!(this instanceof Path2)) {
              throw new Error("Path constructor cannot be invoked without 'new'");
            }
            if (parentPath) {
              if (!(parentPath instanceof Path2)) {
                throw new Error("");
              }
            } else {
              parentPath = null;
              name2 = null;
            }
            this.value = value;
            this.parentPath = parentPath;
            this.name = name2;
            this.__childCache = null;
          };
          var Pp2 = Path.prototype;
          function getChildCache(path2) {
            return path2.__childCache || (path2.__childCache = /* @__PURE__ */ Object.create(null));
          }
          function getChildPath(path2, name2) {
            var cache = getChildCache(path2);
            var actualChildValue = path2.getValueProperty(name2);
            var childPath = cache[name2];
            if (!hasOwn2.call(cache, name2) || // Ensure consistency between cache and reality.
            childPath.value !== actualChildValue) {
              childPath = cache[name2] = new path2.constructor(actualChildValue, path2, name2);
            }
            return childPath;
          }
          Pp2.getValueProperty = function getValueProperty(name2) {
            return this.value[name2];
          };
          Pp2.get = function get2() {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              names[_i] = arguments[_i];
            }
            var path2 = this;
            var count = names.length;
            for (var i2 = 0; i2 < count; ++i2) {
              path2 = getChildPath(path2, names[i2]);
            }
            return path2;
          };
          Pp2.each = function each(callback, context) {
            var childPaths = [];
            var len = this.value.length;
            var i2 = 0;
            for (var i2 = 0; i2 < len; ++i2) {
              if (hasOwn2.call(this.value, i2)) {
                childPaths[i2] = this.get(i2);
              }
            }
            context = context || this;
            for (i2 = 0; i2 < len; ++i2) {
              if (hasOwn2.call(childPaths, i2)) {
                callback.call(context, childPaths[i2]);
              }
            }
          };
          Pp2.map = function map2(callback, context) {
            var result2 = [];
            this.each(function(childPath) {
              result2.push(callback.call(this, childPath));
            }, context);
            return result2;
          };
          Pp2.filter = function filter2(callback, context) {
            var result2 = [];
            this.each(function(childPath) {
              if (callback.call(this, childPath)) {
                result2.push(childPath);
              }
            }, context);
            return result2;
          };
          function emptyMoves() {
          }
          function getMoves(path2, offset, start, end) {
            isArray2.assert(path2.value);
            if (offset === 0) {
              return emptyMoves;
            }
            var length = path2.value.length;
            if (length < 1) {
              return emptyMoves;
            }
            var argc = arguments.length;
            if (argc === 2) {
              start = 0;
              end = length;
            } else if (argc === 3) {
              start = Math.max(start, 0);
              end = length;
            } else {
              start = Math.max(start, 0);
              end = Math.min(end, length);
            }
            isNumber2.assert(start);
            isNumber2.assert(end);
            var moves = /* @__PURE__ */ Object.create(null);
            var cache = getChildCache(path2);
            for (var i2 = start; i2 < end; ++i2) {
              if (hasOwn2.call(path2.value, i2)) {
                var childPath = path2.get(i2);
                if (childPath.name !== i2) {
                  throw new Error("");
                }
                var newIndex = i2 + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                delete cache[i2];
              }
            }
            delete cache.length;
            return function() {
              for (var newIndex2 in moves) {
                var childPath2 = moves[newIndex2];
                if (childPath2.name !== +newIndex2) {
                  throw new Error("");
                }
                cache[newIndex2] = childPath2;
                path2.value[newIndex2] = childPath2.value;
              }
            };
          }
          Pp2.shift = function shift() {
            var move = getMoves(this, -1);
            var result2 = this.value.shift();
            move();
            return result2;
          };
          Pp2.unshift = function unshift2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var move = getMoves(this, args.length);
            var result2 = this.value.unshift.apply(this.value, args);
            move();
            return result2;
          };
          Pp2.push = function push2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            isArray2.assert(this.value);
            delete getChildCache(this).length;
            return this.value.push.apply(this.value, args);
          };
          Pp2.pop = function pop() {
            isArray2.assert(this.value);
            var cache = getChildCache(this);
            delete cache[this.value.length - 1];
            delete cache.length;
            return this.value.pop();
          };
          Pp2.insertAt = function insertAt(index) {
            var argc = arguments.length;
            var move = getMoves(this, argc - 1, index);
            if (move === emptyMoves && argc <= 1) {
              return this;
            }
            index = Math.max(index, 0);
            for (var i2 = 1; i2 < argc; ++i2) {
              this.value[index + i2 - 1] = arguments[i2];
            }
            move();
            return this;
          };
          Pp2.insertBefore = function insertBefore() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var pp = this.parentPath;
            var argc = args.length;
            var insertAtArgs = [this.name];
            for (var i2 = 0; i2 < argc; ++i2) {
              insertAtArgs.push(args[i2]);
            }
            return pp.insertAt.apply(pp, insertAtArgs);
          };
          Pp2.insertAfter = function insertAfter() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var pp = this.parentPath;
            var argc = args.length;
            var insertAtArgs = [this.name + 1];
            for (var i2 = 0; i2 < argc; ++i2) {
              insertAtArgs.push(args[i2]);
            }
            return pp.insertAt.apply(pp, insertAtArgs);
          };
          function repairRelationshipWithParent(path2) {
            if (!(path2 instanceof Path)) {
              throw new Error("");
            }
            var pp = path2.parentPath;
            if (!pp) {
              return path2;
            }
            var parentValue = pp.value;
            var parentCache = getChildCache(pp);
            if (parentValue[path2.name] === path2.value) {
              parentCache[path2.name] = path2;
            } else if (isArray2.check(parentValue)) {
              var i2 = parentValue.indexOf(path2.value);
              if (i2 >= 0) {
                parentCache[path2.name = i2] = path2;
              }
            } else {
              parentValue[path2.name] = path2.value;
              parentCache[path2.name] = path2;
            }
            if (parentValue[path2.name] !== path2.value) {
              throw new Error("");
            }
            if (path2.parentPath.get(path2.name) !== path2) {
              throw new Error("");
            }
            return path2;
          }
          Pp2.replace = function replace(replacement) {
            var results = [];
            var parentValue = this.parentPath.value;
            var parentCache = getChildCache(this.parentPath);
            var count = arguments.length;
            repairRelationshipWithParent(this);
            if (isArray2.check(parentValue)) {
              var originalLength = parentValue.length;
              var move = getMoves(this.parentPath, count - 1, this.name + 1);
              var spliceArgs = [this.name, 1];
              for (var i2 = 0; i2 < count; ++i2) {
                spliceArgs.push(arguments[i2]);
              }
              var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
              if (splicedOut[0] !== this.value) {
                throw new Error("");
              }
              if (parentValue.length !== originalLength - 1 + count) {
                throw new Error("");
              }
              move();
              if (count === 0) {
                delete this.value;
                delete parentCache[this.name];
                this.__childCache = null;
              } else {
                if (parentValue[this.name] !== replacement) {
                  throw new Error("");
                }
                if (this.value !== replacement) {
                  this.value = replacement;
                  this.__childCache = null;
                }
                for (i2 = 0; i2 < count; ++i2) {
                  results.push(this.parentPath.get(this.name + i2));
                }
                if (results[0] !== this) {
                  throw new Error("");
                }
              }
            } else if (count === 1) {
              if (this.value !== replacement) {
                this.__childCache = null;
              }
              this.value = parentValue[this.name] = replacement;
              results.push(this);
            } else if (count === 0) {
              delete parentValue[this.name];
              delete this.value;
              this.__childCache = null;
            } else {
              throw new Error("Could not replace path");
            }
            return results;
          };
          return Path;
        }
        exports2.default = pathPlugin;
        module2.exports = exports2["default"];
      })(path$5, path$5.exports);
      var scope = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var hasOwn2 = Object.prototype.hasOwnProperty;
        function scopePlugin(fork2) {
          var types2 = fork2.use(types_1.default);
          var Type = types2.Type;
          var namedTypes2 = types2.namedTypes;
          var Node2 = namedTypes2.Node;
          var Expression2 = namedTypes2.Expression;
          var isArray2 = types2.builtInTypes.array;
          var b2 = types2.builders;
          var Scope2 = function Scope3(path2, parentScope) {
            if (!(this instanceof Scope3)) {
              throw new Error("Scope constructor cannot be invoked without 'new'");
            }
            ScopeType.assert(path2.value);
            var depth;
            if (parentScope) {
              if (!(parentScope instanceof Scope3)) {
                throw new Error("");
              }
              depth = parentScope.depth + 1;
            } else {
              parentScope = null;
              depth = 0;
            }
            Object.defineProperties(this, {
              path: { value: path2 },
              node: { value: path2.value },
              isGlobal: { value: !parentScope, enumerable: true },
              depth: { value: depth },
              parent: { value: parentScope },
              bindings: { value: {} },
              types: { value: {} }
            });
          };
          var scopeTypes = [
            // Program nodes introduce global scopes.
            namedTypes2.Program,
            // Function is the supertype of FunctionExpression,
            // FunctionDeclaration, ArrowExpression, etc.
            namedTypes2.Function,
            // In case you didn't know, the caught parameter shadows any variable
            // of the same name in an outer scope.
            namedTypes2.CatchClause
          ];
          var ScopeType = Type.or.apply(Type, scopeTypes);
          Scope2.isEstablishedBy = function(node2) {
            return ScopeType.check(node2);
          };
          var Sp = Scope2.prototype;
          Sp.didScan = false;
          Sp.declares = function(name2) {
            this.scan();
            return hasOwn2.call(this.bindings, name2);
          };
          Sp.declaresType = function(name2) {
            this.scan();
            return hasOwn2.call(this.types, name2);
          };
          Sp.declareTemporary = function(prefix2) {
            if (prefix2) {
              if (!/^[a-z$_]/i.test(prefix2)) {
                throw new Error("");
              }
            } else {
              prefix2 = "t$";
            }
            prefix2 += this.depth.toString(36) + "$";
            this.scan();
            var index = 0;
            while (this.declares(prefix2 + index)) {
              ++index;
            }
            var name2 = prefix2 + index;
            return this.bindings[name2] = types2.builders.identifier(name2);
          };
          Sp.injectTemporary = function(identifier, init2) {
            identifier || (identifier = this.declareTemporary());
            var bodyPath = this.path.get("body");
            if (namedTypes2.BlockStatement.check(bodyPath.value)) {
              bodyPath = bodyPath.get("body");
            }
            bodyPath.unshift(b2.variableDeclaration("var", [b2.variableDeclarator(identifier, init2 || null)]));
            return identifier;
          };
          Sp.scan = function(force) {
            if (force || !this.didScan) {
              for (var name2 in this.bindings) {
                delete this.bindings[name2];
              }
              scanScope(this.path, this.bindings, this.types);
              this.didScan = true;
            }
          };
          Sp.getBindings = function() {
            this.scan();
            return this.bindings;
          };
          Sp.getTypes = function() {
            this.scan();
            return this.types;
          };
          function scanScope(path2, bindings, scopeTypes2) {
            var node2 = path2.value;
            ScopeType.assert(node2);
            if (namedTypes2.CatchClause.check(node2)) {
              var param = path2.get("param");
              if (param.value) {
                addPattern(param, bindings);
              }
            } else {
              recursiveScanScope(path2, bindings, scopeTypes2);
            }
          }
          function recursiveScanScope(path2, bindings, scopeTypes2) {
            var node2 = path2.value;
            if (path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id) {
              addPattern(path2.parent.get("id"), bindings);
            }
            if (!node2)
              ;
            else if (isArray2.check(node2)) {
              path2.each(function(childPath) {
                recursiveScanChild(childPath, bindings, scopeTypes2);
              });
            } else if (namedTypes2.Function.check(node2)) {
              path2.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
              });
              recursiveScanChild(path2.get("body"), bindings, scopeTypes2);
            } else if (namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2)) {
              addTypePattern(path2.get("id"), scopeTypes2);
            } else if (namedTypes2.VariableDeclarator.check(node2)) {
              var idPath = path2.get("id");
              if (namedTypes2.ObjectPattern.check(idPath.node)) {
                idPath.node.properties.forEach(function(_, index) {
                  addPattern(path2.get("id", "properties", index, "key"), bindings);
                });
              } else {
                addPattern(path2.get("id"), bindings);
              }
              recursiveScanChild(path2.get("init"), bindings, scopeTypes2);
            } else if (node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier") {
              addPattern(
                // Esprima used to use the .name field to refer to the local
                // binding identifier for ImportSpecifier nodes, but .id for
                // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
                // ESTree/Acorn/ESpree use .local for all three node types.
                path2.get(node2.local ? "local" : node2.name ? "name" : "id"),
                bindings
              );
            } else if (Node2.check(node2) && !Expression2.check(node2)) {
              types2.eachField(node2, function(name2, child) {
                var childPath = path2.get(name2);
                if (!pathHasValue(childPath, child)) {
                  throw new Error("");
                }
                recursiveScanChild(childPath, bindings, scopeTypes2);
              });
            }
          }
          function pathHasValue(path2, value) {
            if (path2.value === value) {
              return true;
            }
            if (Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0) {
              return true;
            }
            return false;
          }
          function recursiveScanChild(path2, bindings, scopeTypes2) {
            var node2 = path2.value;
            if (!node2 || Expression2.check(node2))
              ;
            else if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null) {
              addPattern(path2.get("id"), bindings);
            } else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2)) {
              addPattern(path2.get("id"), bindings);
            } else if (ScopeType.check(node2)) {
              if (namedTypes2.CatchClause.check(node2) && // TODO Broaden this to accept any pattern.
              namedTypes2.Identifier.check(node2.param)) {
                var catchParamName = node2.param.name;
                var hadBinding = hasOwn2.call(bindings, catchParamName);
                recursiveScanScope(path2.get("body"), bindings, scopeTypes2);
                if (!hadBinding) {
                  delete bindings[catchParamName];
                }
              }
            } else {
              recursiveScanScope(path2, bindings, scopeTypes2);
            }
          }
          function addPattern(patternPath, bindings) {
            var pattern = patternPath.value;
            namedTypes2.Pattern.assert(pattern);
            if (namedTypes2.Identifier.check(pattern)) {
              if (hasOwn2.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
              } else {
                bindings[pattern.name] = [patternPath];
              }
            } else if (namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern)) {
              addPattern(patternPath.get("left"), bindings);
            } else if (namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern)) {
              patternPath.get("properties").each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes2.Pattern.check(property)) {
                  addPattern(propertyPath, bindings);
                } else if (namedTypes2.Property.check(property)) {
                  addPattern(propertyPath.get("value"), bindings);
                } else if (namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property)) {
                  addPattern(propertyPath.get("argument"), bindings);
                }
              });
            } else if (namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern)) {
              patternPath.get("elements").each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes2.Pattern.check(element)) {
                  addPattern(elementPath, bindings);
                } else if (namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element)) {
                  addPattern(elementPath.get("argument"), bindings);
                }
              });
            } else if (namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern)) {
              addPattern(patternPath.get("pattern"), bindings);
            } else if (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) {
              addPattern(patternPath.get("argument"), bindings);
            }
          }
          function addTypePattern(patternPath, types3) {
            var pattern = patternPath.value;
            namedTypes2.Pattern.assert(pattern);
            if (namedTypes2.Identifier.check(pattern)) {
              if (hasOwn2.call(types3, pattern.name)) {
                types3[pattern.name].push(patternPath);
              } else {
                types3[pattern.name] = [patternPath];
              }
            }
          }
          Sp.lookup = function(name2) {
            for (var scope2 = this; scope2; scope2 = scope2.parent)
              if (scope2.declares(name2))
                break;
            return scope2;
          };
          Sp.lookupType = function(name2) {
            for (var scope2 = this; scope2; scope2 = scope2.parent)
              if (scope2.declaresType(name2))
                break;
            return scope2;
          };
          Sp.getGlobalScope = function() {
            var scope2 = this;
            while (!scope2.isGlobal)
              scope2 = scope2.parent;
            return scope2;
          };
          return Scope2;
        }
        exports2.default = scopePlugin;
        module2.exports = exports2["default"];
      })(scope, scope.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var path_1 = tslib_12.__importDefault(path$5.exports);
        var scope_1 = tslib_12.__importDefault(scope.exports);
        function nodePathPlugin(fork2) {
          var types2 = fork2.use(types_1.default);
          var n2 = types2.namedTypes;
          var b2 = types2.builders;
          var isNumber2 = types2.builtInTypes.number;
          var isArray2 = types2.builtInTypes.array;
          var Path = fork2.use(path_1.default);
          var Scope2 = fork2.use(scope_1.default);
          var NodePath2 = function NodePath3(value, parentPath, name2) {
            if (!(this instanceof NodePath3)) {
              throw new Error("NodePath constructor cannot be invoked without 'new'");
            }
            Path.call(this, value, parentPath, name2);
          };
          var NPp = NodePath2.prototype = Object.create(Path.prototype, {
            constructor: {
              value: NodePath2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          Object.defineProperties(NPp, {
            node: {
              get: function() {
                Object.defineProperty(this, "node", {
                  configurable: true,
                  value: this._computeNode()
                });
                return this.node;
              }
            },
            parent: {
              get: function() {
                Object.defineProperty(this, "parent", {
                  configurable: true,
                  value: this._computeParent()
                });
                return this.parent;
              }
            },
            scope: {
              get: function() {
                Object.defineProperty(this, "scope", {
                  configurable: true,
                  value: this._computeScope()
                });
                return this.scope;
              }
            }
          });
          NPp.replace = function() {
            delete this.node;
            delete this.parent;
            delete this.scope;
            return Path.prototype.replace.apply(this, arguments);
          };
          NPp.prune = function() {
            var remainingNodePath = this.parent;
            this.replace();
            return cleanUpNodesAfterPrune(remainingNodePath);
          };
          NPp._computeNode = function() {
            var value = this.value;
            if (n2.Node.check(value)) {
              return value;
            }
            var pp = this.parentPath;
            return pp && pp.node || null;
          };
          NPp._computeParent = function() {
            var value = this.value;
            var pp = this.parentPath;
            if (!n2.Node.check(value)) {
              while (pp && !n2.Node.check(pp.value)) {
                pp = pp.parentPath;
              }
              if (pp) {
                pp = pp.parentPath;
              }
            }
            while (pp && !n2.Node.check(pp.value)) {
              pp = pp.parentPath;
            }
            return pp || null;
          };
          NPp._computeScope = function() {
            var value = this.value;
            var pp = this.parentPath;
            var scope2 = pp && pp.scope;
            if (n2.Node.check(value) && Scope2.isEstablishedBy(value)) {
              scope2 = new Scope2(this, scope2);
            }
            return scope2 || null;
          };
          NPp.getValueProperty = function(name2) {
            return types2.getFieldValue(this.value, name2);
          };
          NPp.needsParens = function(assumeExpressionContext) {
            var pp = this.parentPath;
            if (!pp) {
              return false;
            }
            var node2 = this.value;
            if (!n2.Expression.check(node2)) {
              return false;
            }
            if (node2.type === "Identifier") {
              return false;
            }
            while (!n2.Node.check(pp.value)) {
              pp = pp.parentPath;
              if (!pp) {
                return false;
              }
            }
            var parent = pp.value;
            switch (node2.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression":
                switch (parent.type) {
                  case "CallExpression":
                    return this.name === "callee" && parent.callee === node2;
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return true;
                  case "MemberExpression":
                    return this.name === "object" && parent.object === node2;
                  case "BinaryExpression":
                  case "LogicalExpression": {
                    var n_1 = node2;
                    var po = parent.operator;
                    var pp_1 = PRECEDENCE2[po];
                    var no = n_1.operator;
                    var np = PRECEDENCE2[no];
                    if (pp_1 > np) {
                      return true;
                    }
                    if (pp_1 === np && this.name === "right") {
                      if (parent.right !== n_1) {
                        throw new Error("Nodes must be equal");
                      }
                      return true;
                    }
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (parent.type) {
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return this.name !== "expression";
                  default:
                    return true;
                }
              case "YieldExpression":
                switch (parent.type) {
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "CallExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ConditionalExpression":
                  case "YieldExpression":
                    return true;
                  default:
                    return false;
                }
              case "Literal":
                return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
              case "AssignmentExpression":
              case "ConditionalExpression":
                switch (parent.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                    return true;
                  case "CallExpression":
                    return this.name === "callee" && parent.callee === node2;
                  case "ConditionalExpression":
                    return this.name === "test" && parent.test === node2;
                  case "MemberExpression":
                    return this.name === "object" && parent.object === node2;
                  default:
                    return false;
                }
              default:
                if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2) {
                  return containsCallExpression2(node2);
                }
            }
            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
              return true;
            return false;
          };
          function isBinary2(node2) {
            return n2.BinaryExpression.check(node2) || n2.LogicalExpression.check(node2);
          }
          var PRECEDENCE2 = {};
          [
            ["||"],
            ["&&"],
            ["|"],
            ["^"],
            ["&"],
            ["==", "===", "!=", "!=="],
            ["<", ">", "<=", ">=", "in", "instanceof"],
            [">>", "<<", ">>>"],
            ["+", "-"],
            ["*", "/", "%"]
          ].forEach(function(tier, i2) {
            tier.forEach(function(op) {
              PRECEDENCE2[op] = i2;
            });
          });
          function containsCallExpression2(node2) {
            if (n2.CallExpression.check(node2)) {
              return true;
            }
            if (isArray2.check(node2)) {
              return node2.some(containsCallExpression2);
            }
            if (n2.Node.check(node2)) {
              return types2.someField(node2, function(_name, child) {
                return containsCallExpression2(child);
              });
            }
            return false;
          }
          NPp.canBeFirstInStatement = function() {
            var node2 = this.node;
            return !n2.FunctionExpression.check(node2) && !n2.ObjectExpression.check(node2);
          };
          NPp.firstInStatement = function() {
            return firstInStatement(this);
          };
          function firstInStatement(path2) {
            for (var node2, parent; path2.parent; path2 = path2.parent) {
              node2 = path2.node;
              parent = path2.parent.node;
              if (n2.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
                if (parent.body[0] !== node2) {
                  throw new Error("Nodes must be equal");
                }
                return true;
              }
              if (n2.ExpressionStatement.check(parent) && path2.name === "expression") {
                if (parent.expression !== node2) {
                  throw new Error("Nodes must be equal");
                }
                return true;
              }
              if (n2.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
                if (parent.expressions[0] !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              if (n2.CallExpression.check(parent) && path2.name === "callee") {
                if (parent.callee !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              if (n2.MemberExpression.check(parent) && path2.name === "object") {
                if (parent.object !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              if (n2.ConditionalExpression.check(parent) && path2.name === "test") {
                if (parent.test !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              if (isBinary2(parent) && path2.name === "left") {
                if (parent.left !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              if (n2.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
                if (parent.argument !== node2) {
                  throw new Error("Nodes must be equal");
                }
                continue;
              }
              return false;
            }
            return true;
          }
          function cleanUpNodesAfterPrune(remainingNodePath) {
            if (n2.VariableDeclaration.check(remainingNodePath.node)) {
              var declarations = remainingNodePath.get("declarations").value;
              if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
              }
            } else if (n2.ExpressionStatement.check(remainingNodePath.node)) {
              if (!remainingNodePath.get("expression").value) {
                return remainingNodePath.prune();
              }
            } else if (n2.IfStatement.check(remainingNodePath.node)) {
              cleanUpIfStatementAfterPrune(remainingNodePath);
            }
            return remainingNodePath;
          }
          function cleanUpIfStatementAfterPrune(ifStatement) {
            var testExpression = ifStatement.get("test").value;
            var alternate = ifStatement.get("alternate").value;
            var consequent = ifStatement.get("consequent").value;
            if (!consequent && !alternate) {
              var testExpressionStatement = b2.expressionStatement(testExpression);
              ifStatement.replace(testExpressionStatement);
            } else if (!consequent && alternate) {
              var negatedTestExpression = b2.unaryExpression("!", testExpression, true);
              if (n2.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
                negatedTestExpression = testExpression.argument;
              }
              ifStatement.get("test").replace(negatedTestExpression);
              ifStatement.get("consequent").replace(alternate);
              ifStatement.get("alternate").replace();
            }
          }
          return NodePath2;
        }
        exports2.default = nodePathPlugin;
        module2.exports = exports2["default"];
      })(nodePath, nodePath.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var node_path_1 = tslib_12.__importDefault(nodePath.exports);
        var hasOwn2 = Object.prototype.hasOwnProperty;
        function pathVisitorPlugin(fork2) {
          var types2 = fork2.use(types_1.default);
          var NodePath2 = fork2.use(node_path_1.default);
          var isArray2 = types2.builtInTypes.array;
          var isObject2 = types2.builtInTypes.object;
          var isFunction2 = types2.builtInTypes.function;
          var undefined$1;
          var PathVisitor = function PathVisitor2() {
            if (!(this instanceof PathVisitor2)) {
              throw new Error("PathVisitor constructor cannot be invoked without 'new'");
            }
            this._reusableContextStack = [];
            this._methodNameTable = computeMethodNameTable(this);
            this._shouldVisitComments = hasOwn2.call(this._methodNameTable, "Block") || hasOwn2.call(this._methodNameTable, "Line");
            this.Context = makeContextConstructor(this);
            this._visiting = false;
            this._changeReported = false;
          };
          function computeMethodNameTable(visitor) {
            var typeNames = /* @__PURE__ */ Object.create(null);
            for (var methodName in visitor) {
              if (/^visit[A-Z]/.test(methodName)) {
                typeNames[methodName.slice("visit".length)] = true;
              }
            }
            var supertypeTable = types2.computeSupertypeLookupTable(typeNames);
            var methodNameTable = /* @__PURE__ */ Object.create(null);
            var typeNameKeys = Object.keys(supertypeTable);
            var typeNameCount = typeNameKeys.length;
            for (var i2 = 0; i2 < typeNameCount; ++i2) {
              var typeName = typeNameKeys[i2];
              methodName = "visit" + supertypeTable[typeName];
              if (isFunction2.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
              }
            }
            return methodNameTable;
          }
          PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
            if (methods instanceof PathVisitor) {
              return methods;
            }
            if (!isObject2.check(methods)) {
              return new PathVisitor();
            }
            var Visitor = function Visitor2() {
              if (!(this instanceof Visitor2)) {
                throw new Error("Visitor constructor cannot be invoked without 'new'");
              }
              PathVisitor.call(this);
            };
            var Vp = Visitor.prototype = Object.create(PVp);
            Vp.constructor = Visitor;
            extend2(Vp, methods);
            extend2(Visitor, PathVisitor);
            isFunction2.assert(Visitor.fromMethodsObject);
            isFunction2.assert(Visitor.visit);
            return new Visitor();
          };
          function extend2(target, source) {
            for (var property in source) {
              if (hasOwn2.call(source, property)) {
                target[property] = source[property];
              }
            }
            return target;
          }
          PathVisitor.visit = function visit2(node2, methods) {
            return PathVisitor.fromMethodsObject(methods).visit(node2);
          };
          var PVp = PathVisitor.prototype;
          PVp.visit = function() {
            if (this._visiting) {
              throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
            }
            this._visiting = true;
            this._changeReported = false;
            this._abortRequested = false;
            var argc = arguments.length;
            var args = new Array(argc);
            for (var i2 = 0; i2 < argc; ++i2) {
              args[i2] = arguments[i2];
            }
            if (!(args[0] instanceof NodePath2)) {
              args[0] = new NodePath2({ root: args[0] }).get("root");
            }
            this.reset.apply(this, args);
            var didNotThrow;
            try {
              var root2 = this.visitWithoutReset(args[0]);
              didNotThrow = true;
            } finally {
              this._visiting = false;
              if (!didNotThrow && this._abortRequested) {
                return args[0].value;
              }
            }
            return root2;
          };
          PVp.AbortRequest = function AbortRequest() {
          };
          PVp.abort = function() {
            var visitor = this;
            visitor._abortRequested = true;
            var request = new visitor.AbortRequest();
            request.cancel = function() {
              visitor._abortRequested = false;
            };
            throw request;
          };
          PVp.reset = function(_path3) {
          };
          PVp.visitWithoutReset = function(path2) {
            if (this instanceof this.Context) {
              return this.visitor.visitWithoutReset(path2);
            }
            if (!(path2 instanceof NodePath2)) {
              throw new Error("");
            }
            var value = path2.value;
            var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
            if (methodName) {
              var context = this.acquireContext(path2);
              try {
                return context.invokeVisitorMethod(methodName);
              } finally {
                this.releaseContext(context);
              }
            } else {
              return visitChildren(path2, this);
            }
          };
          function visitChildren(path2, visitor) {
            if (!(path2 instanceof NodePath2)) {
              throw new Error("");
            }
            if (!(visitor instanceof PathVisitor)) {
              throw new Error("");
            }
            var value = path2.value;
            if (isArray2.check(value)) {
              path2.each(visitor.visitWithoutReset, visitor);
            } else if (!isObject2.check(value))
              ;
            else {
              var childNames = types2.getFieldNames(value);
              if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
                childNames.push("comments");
              }
              var childCount = childNames.length;
              var childPaths = [];
              for (var i2 = 0; i2 < childCount; ++i2) {
                var childName = childNames[i2];
                if (!hasOwn2.call(value, childName)) {
                  value[childName] = types2.getFieldValue(value, childName);
                }
                childPaths.push(path2.get(childName));
              }
              for (var i2 = 0; i2 < childCount; ++i2) {
                visitor.visitWithoutReset(childPaths[i2]);
              }
            }
            return path2.value;
          }
          PVp.acquireContext = function(path2) {
            if (this._reusableContextStack.length === 0) {
              return new this.Context(path2);
            }
            return this._reusableContextStack.pop().reset(path2);
          };
          PVp.releaseContext = function(context) {
            if (!(context instanceof this.Context)) {
              throw new Error("");
            }
            this._reusableContextStack.push(context);
            context.currentPath = null;
          };
          PVp.reportChanged = function() {
            this._changeReported = true;
          };
          PVp.wasChangeReported = function() {
            return this._changeReported;
          };
          function makeContextConstructor(visitor) {
            function Context(path2) {
              if (!(this instanceof Context)) {
                throw new Error("");
              }
              if (!(this instanceof PathVisitor)) {
                throw new Error("");
              }
              if (!(path2 instanceof NodePath2)) {
                throw new Error("");
              }
              Object.defineProperty(this, "visitor", {
                value: visitor,
                writable: false,
                enumerable: true,
                configurable: false
              });
              this.currentPath = path2;
              this.needToCallTraverse = true;
              Object.seal(this);
            }
            if (!(visitor instanceof PathVisitor)) {
              throw new Error("");
            }
            var Cp = Context.prototype = Object.create(visitor);
            Cp.constructor = Context;
            extend2(Cp, sharedContextProtoMethods);
            return Context;
          }
          var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
          sharedContextProtoMethods.reset = function reset(path2) {
            if (!(this instanceof this.Context)) {
              throw new Error("");
            }
            if (!(path2 instanceof NodePath2)) {
              throw new Error("");
            }
            this.currentPath = path2;
            this.needToCallTraverse = true;
            return this;
          };
          sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
            if (!(this instanceof this.Context)) {
              throw new Error("");
            }
            if (!(this.currentPath instanceof NodePath2)) {
              throw new Error("");
            }
            var result2 = this.visitor[methodName].call(this, this.currentPath);
            if (result2 === false) {
              this.needToCallTraverse = false;
            } else if (result2 !== undefined$1) {
              this.currentPath = this.currentPath.replace(result2)[0];
              if (this.needToCallTraverse) {
                this.traverse(this.currentPath);
              }
            }
            if (this.needToCallTraverse !== false) {
              throw new Error("Must either call this.traverse or return false in " + methodName);
            }
            var path2 = this.currentPath;
            return path2 && path2.value;
          };
          sharedContextProtoMethods.traverse = function traverse2(path2, newVisitor) {
            if (!(this instanceof this.Context)) {
              throw new Error("");
            }
            if (!(path2 instanceof NodePath2)) {
              throw new Error("");
            }
            if (!(this.currentPath instanceof NodePath2)) {
              throw new Error("");
            }
            this.needToCallTraverse = false;
            return visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
          };
          sharedContextProtoMethods.visit = function visit2(path2, newVisitor) {
            if (!(this instanceof this.Context)) {
              throw new Error("");
            }
            if (!(path2 instanceof NodePath2)) {
              throw new Error("");
            }
            if (!(this.currentPath instanceof NodePath2)) {
              throw new Error("");
            }
            this.needToCallTraverse = false;
            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
          };
          sharedContextProtoMethods.reportChanged = function reportChanged() {
            this.visitor.reportChanged();
          };
          sharedContextProtoMethods.abort = function abort() {
            this.needToCallTraverse = false;
            this.visitor.abort();
          };
          return PathVisitor;
        }
        exports2.default = pathVisitorPlugin;
        module2.exports = exports2["default"];
      })(pathVisitor, pathVisitor.exports);
      var equiv = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        function default_1(fork2) {
          var types2 = fork2.use(types_1.default);
          var getFieldNames = types2.getFieldNames;
          var getFieldValue = types2.getFieldValue;
          var isArray2 = types2.builtInTypes.array;
          var isObject2 = types2.builtInTypes.object;
          var isDate2 = types2.builtInTypes.Date;
          var isRegExp2 = types2.builtInTypes.RegExp;
          var hasOwn2 = Object.prototype.hasOwnProperty;
          function astNodesAreEquivalent(a, b2, problemPath) {
            if (isArray2.check(problemPath)) {
              problemPath.length = 0;
            } else {
              problemPath = null;
            }
            return areEquivalent(a, b2, problemPath);
          }
          astNodesAreEquivalent.assert = function(a, b2) {
            var problemPath = [];
            if (!astNodesAreEquivalent(a, b2, problemPath)) {
              if (problemPath.length === 0) {
                if (a !== b2) {
                  throw new Error("Nodes must be equal");
                }
              } else {
                throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
              }
            }
          };
          function subscriptForProperty(property) {
            if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
              return "." + property;
            }
            return "[" + JSON.stringify(property) + "]";
          }
          function areEquivalent(a, b2, problemPath) {
            if (a === b2) {
              return true;
            }
            if (isArray2.check(a)) {
              return arraysAreEquivalent(a, b2, problemPath);
            }
            if (isObject2.check(a)) {
              return objectsAreEquivalent(a, b2, problemPath);
            }
            if (isDate2.check(a)) {
              return isDate2.check(b2) && +a === +b2;
            }
            if (isRegExp2.check(a)) {
              return isRegExp2.check(b2) && (a.source === b2.source && a.global === b2.global && a.multiline === b2.multiline && a.ignoreCase === b2.ignoreCase);
            }
            return a == b2;
          }
          function arraysAreEquivalent(a, b2, problemPath) {
            isArray2.assert(a);
            var aLength = a.length;
            if (!isArray2.check(b2) || b2.length !== aLength) {
              if (problemPath) {
                problemPath.push("length");
              }
              return false;
            }
            for (var i2 = 0; i2 < aLength; ++i2) {
              if (problemPath) {
                problemPath.push(i2);
              }
              if (i2 in a !== i2 in b2) {
                return false;
              }
              if (!areEquivalent(a[i2], b2[i2], problemPath)) {
                return false;
              }
              if (problemPath) {
                var problemPathTail = problemPath.pop();
                if (problemPathTail !== i2) {
                  throw new Error("" + problemPathTail);
                }
              }
            }
            return true;
          }
          function objectsAreEquivalent(a, b2, problemPath) {
            isObject2.assert(a);
            if (!isObject2.check(b2)) {
              return false;
            }
            if (a.type !== b2.type) {
              if (problemPath) {
                problemPath.push("type");
              }
              return false;
            }
            var aNames = getFieldNames(a);
            var aNameCount = aNames.length;
            var bNames = getFieldNames(b2);
            var bNameCount = bNames.length;
            if (aNameCount === bNameCount) {
              for (var i2 = 0; i2 < aNameCount; ++i2) {
                var name2 = aNames[i2];
                var aChild = getFieldValue(a, name2);
                var bChild = getFieldValue(b2, name2);
                if (problemPath) {
                  problemPath.push(name2);
                }
                if (!areEquivalent(aChild, bChild, problemPath)) {
                  return false;
                }
                if (problemPath) {
                  var problemPathTail = problemPath.pop();
                  if (problemPathTail !== name2) {
                    throw new Error("" + problemPathTail);
                  }
                }
              }
              return true;
            }
            if (!problemPath) {
              return false;
            }
            var seenNames = /* @__PURE__ */ Object.create(null);
            for (i2 = 0; i2 < aNameCount; ++i2) {
              seenNames[aNames[i2]] = true;
            }
            for (i2 = 0; i2 < bNameCount; ++i2) {
              name2 = bNames[i2];
              if (!hasOwn2.call(seenNames, name2)) {
                problemPath.push(name2);
                return false;
              }
              delete seenNames[name2];
            }
            for (name2 in seenNames) {
              problemPath.push(name2);
              break;
            }
            return false;
          }
          return astNodesAreEquivalent;
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(equiv, equiv.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var path_visitor_1 = tslib_12.__importDefault(pathVisitor.exports);
        var equiv_1 = tslib_12.__importDefault(equiv.exports);
        var path_1 = tslib_12.__importDefault(path$5.exports);
        var node_path_1 = tslib_12.__importDefault(nodePath.exports);
        function default_1(defs) {
          var fork2 = createFork();
          var types2 = fork2.use(types_1.default);
          defs.forEach(fork2.use);
          types2.finalize();
          var PathVisitor = fork2.use(path_visitor_1.default);
          return {
            Type: types2.Type,
            builtInTypes: types2.builtInTypes,
            namedTypes: types2.namedTypes,
            builders: types2.builders,
            defineMethod: types2.defineMethod,
            getFieldNames: types2.getFieldNames,
            getFieldValue: types2.getFieldValue,
            eachField: types2.eachField,
            someField: types2.someField,
            getSupertypeNames: types2.getSupertypeNames,
            getBuilderName: types2.getBuilderName,
            astNodesAreEquivalent: fork2.use(equiv_1.default),
            finalize: types2.finalize,
            Path: fork2.use(path_1.default),
            NodePath: fork2.use(node_path_1.default),
            PathVisitor,
            use: fork2.use,
            visit: PathVisitor.visit
          };
        }
        exports2.default = default_1;
        function createFork() {
          var used = [];
          var usedResult = [];
          function use(plugin2) {
            var idx = used.indexOf(plugin2);
            if (idx === -1) {
              idx = used.length;
              used.push(plugin2);
              usedResult[idx] = plugin2(fork2);
            }
            return usedResult[idx];
          }
          var fork2 = { use };
          return fork2;
        }
        module2.exports = exports2["default"];
      })(fork, fork.exports);
      var core$4 = { exports: {} };
      var coreOperators = {};
      Object.defineProperty(coreOperators, "__esModule", { value: true });
      coreOperators.LogicalOperators = coreOperators.AssignmentOperators = coreOperators.BinaryOperators = void 0;
      coreOperators.BinaryOperators = [
        "==",
        "!=",
        "===",
        "!==",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "&",
        "|",
        "^",
        "in",
        "instanceof"
      ];
      coreOperators.AssignmentOperators = [
        "=",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "<<=",
        ">>=",
        ">>>=",
        "|=",
        "^=",
        "&="
      ];
      coreOperators.LogicalOperators = [
        "||",
        "&&"
      ];
      var shared$2 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        function default_1(fork2) {
          var types2 = fork2.use(types_1.default);
          var Type = types2.Type;
          var builtin = types2.builtInTypes;
          var isNumber2 = builtin.number;
          function geq(than) {
            return Type.from(function(value) {
              return isNumber2.check(value) && value >= than;
            }, isNumber2 + " >= " + than);
          }
          var defaults2 = {
            // Functions were used because (among other reasons) that's the most
            // elegant way to allow for the emptyArray one always to give a new
            // array instance.
            "null": function() {
              return null;
            },
            "emptyArray": function() {
              return [];
            },
            "false": function() {
              return false;
            },
            "true": function() {
              return true;
            },
            "undefined": function() {
            },
            "use strict": function() {
              return "use strict";
            }
          };
          var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
          var isPrimitive2 = Type.from(function(value) {
            if (value === null)
              return true;
            var type2 = typeof value;
            if (type2 === "object" || type2 === "function") {
              return false;
            }
            return true;
          }, naiveIsPrimitive.toString());
          return {
            geq,
            defaults: defaults2,
            isPrimitive: isPrimitive2
          };
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(shared$2, shared$2.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var core_operators_1 = coreOperators;
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          var types2 = fork2.use(types_1.default);
          var Type = types2.Type;
          var def2 = Type.def;
          var or = Type.or;
          var shared2 = fork2.use(shared_1.default);
          var defaults2 = shared2.defaults;
          var geq = shared2.geq;
          def2("Printable").field("loc", or(def2("SourceLocation"), null), defaults2["null"], true);
          def2("Node").bases("Printable").field("type", String).field("comments", or([def2("Comment")], null), defaults2["null"], true);
          def2("SourceLocation").field("start", def2("Position")).field("end", def2("Position")).field("source", or(String, null), defaults2["null"]);
          def2("Position").field("line", geq(1)).field("column", geq(0));
          def2("File").bases("Node").build("program", "name").field("program", def2("Program")).field("name", or(String, null), defaults2["null"]);
          def2("Program").bases("Node").build("body").field("body", [def2("Statement")]);
          def2("Function").bases("Node").field("id", or(def2("Identifier"), null), defaults2["null"]).field("params", [def2("Pattern")]).field("body", def2("BlockStatement")).field("generator", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]);
          def2("Statement").bases("Node");
          def2("EmptyStatement").bases("Statement").build();
          def2("BlockStatement").bases("Statement").build("body").field("body", [def2("Statement")]);
          def2("ExpressionStatement").bases("Statement").build("expression").field("expression", def2("Expression"));
          def2("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def2("Expression")).field("consequent", def2("Statement")).field("alternate", or(def2("Statement"), null), defaults2["null"]);
          def2("LabeledStatement").bases("Statement").build("label", "body").field("label", def2("Identifier")).field("body", def2("Statement"));
          def2("BreakStatement").bases("Statement").build("label").field("label", or(def2("Identifier"), null), defaults2["null"]);
          def2("ContinueStatement").bases("Statement").build("label").field("label", or(def2("Identifier"), null), defaults2["null"]);
          def2("WithStatement").bases("Statement").build("object", "body").field("object", def2("Expression")).field("body", def2("Statement"));
          def2("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def2("Expression")).field("cases", [def2("SwitchCase")]).field("lexical", Boolean, defaults2["false"]);
          def2("ReturnStatement").bases("Statement").build("argument").field("argument", or(def2("Expression"), null));
          def2("ThrowStatement").bases("Statement").build("argument").field("argument", def2("Expression"));
          def2("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def2("BlockStatement")).field("handler", or(def2("CatchClause"), null), function() {
            return this.handlers && this.handlers[0] || null;
          }).field("handlers", [def2("CatchClause")], function() {
            return this.handler ? [this.handler] : [];
          }, true).field("guardedHandlers", [def2("CatchClause")], defaults2.emptyArray).field("finalizer", or(def2("BlockStatement"), null), defaults2["null"]);
          def2("CatchClause").bases("Node").build("param", "guard", "body").field("param", def2("Pattern")).field("guard", or(def2("Expression"), null), defaults2["null"]).field("body", def2("BlockStatement"));
          def2("WhileStatement").bases("Statement").build("test", "body").field("test", def2("Expression")).field("body", def2("Statement"));
          def2("DoWhileStatement").bases("Statement").build("body", "test").field("body", def2("Statement")).field("test", def2("Expression"));
          def2("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def2("VariableDeclaration"), def2("Expression"), null)).field("test", or(def2("Expression"), null)).field("update", or(def2("Expression"), null)).field("body", def2("Statement"));
          def2("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def2("VariableDeclaration"), def2("Expression"))).field("right", def2("Expression")).field("body", def2("Statement"));
          def2("DebuggerStatement").bases("Statement").build();
          def2("Declaration").bases("Statement");
          def2("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def2("Identifier"));
          def2("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
          def2("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def2("VariableDeclarator")]);
          def2("VariableDeclarator").bases("Node").build("id", "init").field("id", def2("Pattern")).field("init", or(def2("Expression"), null), defaults2["null"]);
          def2("Expression").bases("Node");
          def2("ThisExpression").bases("Expression").build();
          def2("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def2("Expression"), null)]);
          def2("ObjectExpression").bases("Expression").build("properties").field("properties", [def2("Property")]);
          def2("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def2("Literal"), def2("Identifier"))).field("value", def2("Expression"));
          def2("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def2("Expression")]);
          var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
          def2("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def2("Expression")).field("prefix", Boolean, defaults2["true"]);
          var BinaryOperator = or.apply(void 0, core_operators_1.BinaryOperators);
          def2("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def2("Expression")).field("right", def2("Expression"));
          var AssignmentOperator = or.apply(void 0, core_operators_1.AssignmentOperators);
          def2("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def2("Pattern"), def2("MemberExpression"))).field("right", def2("Expression"));
          var UpdateOperator = or("++", "--");
          def2("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def2("Expression")).field("prefix", Boolean);
          var LogicalOperator = or.apply(void 0, core_operators_1.LogicalOperators);
          def2("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def2("Expression")).field("right", def2("Expression"));
          def2("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def2("Expression")).field("consequent", def2("Expression")).field("alternate", def2("Expression"));
          def2("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def2("Expression")).field("arguments", [def2("Expression")]);
          def2("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def2("Expression")).field("arguments", [def2("Expression")]);
          def2("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def2("Expression")).field("property", or(def2("Identifier"), def2("Expression"))).field("computed", Boolean, function() {
            var type2 = this.property.type;
            if (type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression") {
              return true;
            }
            return false;
          });
          def2("Pattern").bases("Node");
          def2("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def2("Expression"), null)).field("consequent", [def2("Statement")]);
          def2("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults2["false"]);
          def2("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp)).field("regex", or({
            pattern: String,
            flags: String
          }, null), function() {
            if (this.value instanceof RegExp) {
              var flags = "";
              if (this.value.ignoreCase)
                flags += "i";
              if (this.value.multiline)
                flags += "m";
              if (this.value.global)
                flags += "g";
              return {
                pattern: this.value.source,
                flags
              };
            }
            return null;
          });
          def2("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults2["true"]).field("trailing", Boolean, defaults2["false"]);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(core$4, core$4.exports);
      var es6 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var core_12 = tslib_12.__importDefault(core$4.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(core_12.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("Function").field("generator", Boolean, defaults2["false"]).field("expression", Boolean, defaults2["false"]).field("defaults", [or(def2("Expression"), null)], defaults2.emptyArray).field("rest", or(def2("Identifier"), null), defaults2["null"]);
          def2("RestElement").bases("Pattern").build("argument").field("argument", def2("Pattern")).field(
            "typeAnnotation",
            // for Babylon. Flow parser puts it on the identifier
            or(def2("TypeAnnotation"), def2("TSTypeAnnotation"), null),
            defaults2["null"]
          );
          def2("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def2("Pattern"));
          def2("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def2("Identifier"), null));
          def2("FunctionExpression").build("id", "params", "body", "generator", "expression");
          def2("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults2["null"]).field("body", or(def2("BlockStatement"), def2("Expression"))).field("generator", false, defaults2["false"]);
          def2("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def2("VariableDeclaration"), def2("Pattern"))).field("right", def2("Expression")).field("body", def2("Statement"));
          def2("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def2("Expression"), null)).field("delegate", Boolean, defaults2["false"]);
          def2("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def2("Expression")).field("blocks", [def2("ComprehensionBlock")]).field("filter", or(def2("Expression"), null));
          def2("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def2("Expression")).field("blocks", [def2("ComprehensionBlock")]).field("filter", or(def2("Expression"), null));
          def2("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def2("Pattern")).field("right", def2("Expression")).field("each", Boolean);
          def2("Property").field("key", or(def2("Literal"), def2("Identifier"), def2("Expression"))).field("value", or(def2("Expression"), def2("Pattern"))).field("method", Boolean, defaults2["false"]).field("shorthand", Boolean, defaults2["false"]).field("computed", Boolean, defaults2["false"]);
          def2("ObjectProperty").field("shorthand", Boolean, defaults2["false"]);
          def2("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def2("Literal"), def2("Identifier"), def2("Expression"))).field("pattern", def2("Pattern")).field("computed", Boolean, defaults2["false"]);
          def2("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def2("PropertyPattern"), def2("Property"))]);
          def2("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def2("Pattern"), null)]);
          def2("SpreadElement").bases("Node").build("argument").field("argument", def2("Expression"));
          def2("ArrayExpression").field("elements", [or(def2("Expression"), def2("SpreadElement"), def2("RestElement"), null)]);
          def2("NewExpression").field("arguments", [or(def2("Expression"), def2("SpreadElement"))]);
          def2("CallExpression").field("arguments", [or(def2("Expression"), def2("SpreadElement"))]);
          def2("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def2("Pattern")).field("right", def2("Expression"));
          def2("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def2("Expression")).field("value", def2("Function")).field("computed", Boolean, defaults2["false"]).field("static", Boolean, defaults2["false"]);
          var ClassBodyElement = or(def2("MethodDefinition"), def2("VariableDeclarator"), def2("ClassPropertyDefinition"), def2("ClassProperty"));
          def2("ClassProperty").bases("Declaration").build("key").field("key", or(def2("Literal"), def2("Identifier"), def2("Expression"))).field("computed", Boolean, defaults2["false"]);
          def2("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
          def2("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
          def2("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def2("Identifier"), null)).field("body", def2("ClassBody")).field("superClass", or(def2("Expression"), null), defaults2["null"]);
          def2("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def2("Identifier"), null), defaults2["null"]).field("body", def2("ClassBody")).field("superClass", or(def2("Expression"), null), defaults2["null"]);
          def2("Super").bases("Expression").build();
          def2("Specifier").bases("Node");
          def2("ModuleSpecifier").bases("Specifier").field("local", or(def2("Identifier"), null), defaults2["null"]).field("id", or(def2("Identifier"), null), defaults2["null"]).field("name", or(def2("Identifier"), null), defaults2["null"]);
          def2("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def2("Identifier"));
          def2("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
          def2("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
          def2("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def2("ImportSpecifier"), def2("ImportNamespaceSpecifier"), def2("ImportDefaultSpecifier"))], defaults2.emptyArray).field("source", def2("Literal")).field("importKind", or("value", "type"), function() {
            return "value";
          });
          def2("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def2("Declaration"), null)).field("specifiers", [def2("ExportSpecifier")], defaults2.emptyArray).field("source", or(def2("Literal"), null), defaults2["null"]);
          def2("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def2("Identifier"));
          def2("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def2("Declaration"), def2("Expression")));
          def2("ExportAllDeclaration").bases("Declaration").build("source").field("source", def2("Literal"));
          def2("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def2("Expression")).field("quasi", def2("TemplateLiteral"));
          def2("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def2("TemplateElement")]).field("expressions", [def2("Expression")]);
          def2("TemplateElement").bases("Node").build("value", "tail").field("value", { "cooked": String, "raw": String }).field("tail", Boolean);
          def2("MetaProperty").bases("Expression").build("meta", "property").field("meta", def2("Identifier")).field("property", def2("Identifier"));
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es6, es6.exports);
      var es2016 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var core_operators_1 = coreOperators;
        var es6_1 = tslib_12.__importDefault(es6.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        function default_1(fork2) {
          fork2.use(es6_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var BinaryOperator = or.apply(void 0, tslib_12.__spreadArrays(core_operators_1.BinaryOperators, ["**"]));
          def2("BinaryExpression").field("operator", BinaryOperator);
          var AssignmentOperator = or.apply(void 0, tslib_12.__spreadArrays(core_operators_1.AssignmentOperators, ["**="]));
          def2("AssignmentExpression").field("operator", AssignmentOperator);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es2016, es2016.exports);
      var es2017 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es2016_1 = tslib_12.__importDefault(es2016.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2016_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("Function").field("async", Boolean, defaults2["false"]);
          def2("AwaitExpression").bases("Expression").build("argument").field("argument", def2("Expression"));
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es2017, es2017.exports);
      var es2018 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es2017_1 = tslib_12.__importDefault(es2017.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2017_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("ForOfStatement").field("await", Boolean, defaults2["false"]);
          def2("SpreadProperty").bases("Node").build("argument").field("argument", def2("Expression"));
          def2("ObjectExpression").field("properties", [or(
            def2("Property"),
            def2("SpreadProperty"),
            // Legacy
            def2("SpreadElement")
          )]);
          def2("TemplateElement").field("value", { "cooked": or(String, null), "raw": String });
          def2("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def2("Pattern"));
          def2("ObjectPattern").field("properties", [or(def2("PropertyPattern"), def2("Property"), def2("RestElement"), def2("SpreadPropertyPattern"))]);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es2018, es2018.exports);
      var es2019 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es2018_1 = tslib_12.__importDefault(es2018.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2018_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("CatchClause").field("param", or(def2("Pattern"), null), defaults2["null"]);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es2019, es2019.exports);
      var es2020 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var core_operators_1 = coreOperators;
        var es2019_1 = tslib_12.__importDefault(es2019.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2019_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var shared2 = fork2.use(shared_1.default);
          var defaults2 = shared2.defaults;
          def2("ImportExpression").bases("Expression").build("source").field("source", def2("Expression"));
          def2("ExportAllDeclaration").build("source", "exported").field("source", def2("Literal")).field("exported", or(def2("Identifier"), null));
          def2("ChainElement").bases("Node").field("optional", Boolean, defaults2["false"]);
          def2("CallExpression").bases("Expression", "ChainElement");
          def2("MemberExpression").bases("Expression", "ChainElement");
          def2("ChainExpression").bases("Expression").build("expression").field("expression", def2("ChainElement"));
          def2("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults2["true"]);
          def2("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults2["true"]);
          var LogicalOperator = or.apply(void 0, tslib_12.__spreadArrays(core_operators_1.LogicalOperators, ["??"]));
          def2("LogicalExpression").field("operator", LogicalOperator);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(es2020, es2020.exports);
      var jsx$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es2020_1 = tslib_12.__importDefault(es2020.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2020_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("JSXAttribute").bases("Node").build("name", "value").field("name", or(def2("JSXIdentifier"), def2("JSXNamespacedName"))).field("value", or(
            def2("Literal"),
            // attr="value"
            def2("JSXExpressionContainer"),
            // attr={value}
            def2("JSXElement"),
            // attr=<div />
            def2("JSXFragment"),
            // attr=<></>
            null
            // attr= or just attr
          ), defaults2["null"]);
          def2("JSXIdentifier").bases("Identifier").build("name").field("name", String);
          def2("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def2("JSXIdentifier")).field("name", def2("JSXIdentifier"));
          def2("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def2("JSXIdentifier"), def2("JSXMemberExpression"))).field("property", def2("JSXIdentifier")).field("computed", Boolean, defaults2.false);
          var JSXElementName = or(def2("JSXIdentifier"), def2("JSXNamespacedName"), def2("JSXMemberExpression"));
          def2("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def2("Expression"));
          var JSXAttributes = [or(def2("JSXAttribute"), def2("JSXSpreadAttribute"))];
          def2("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def2("Expression"), def2("JSXEmptyExpression")));
          var JSXChildren = [or(
            def2("JSXText"),
            def2("JSXExpressionContainer"),
            def2("JSXSpreadChild"),
            def2("JSXElement"),
            def2("JSXFragment"),
            def2("Literal")
            // Legacy: Esprima should return JSXText instead.
          )];
          def2("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def2("JSXOpeningElement")).field("closingElement", or(def2("JSXClosingElement"), null), defaults2["null"]).field("children", JSXChildren, defaults2.emptyArray).field("name", JSXElementName, function() {
            return this.openingElement.name;
          }, true).field("selfClosing", Boolean, function() {
            return this.openingElement.selfClosing;
          }, true).field("attributes", JSXAttributes, function() {
            return this.openingElement.attributes;
          }, true);
          def2("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults2.emptyArray).field("selfClosing", Boolean, defaults2["false"]);
          def2("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
          def2("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def2("JSXOpeningFragment")).field("closingFragment", def2("JSXClosingFragment")).field("children", JSXChildren, defaults2.emptyArray);
          def2("JSXOpeningFragment").bases("Node").build();
          def2("JSXClosingFragment").bases("Node").build();
          def2("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
            return this.value;
          });
          def2("JSXEmptyExpression").bases("Node").build();
          def2("JSXSpreadChild").bases("Node").build("expression").field("expression", def2("Expression"));
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(jsx$1, jsx$1.exports);
      var flow$2 = { exports: {} };
      var esProposals = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        var es2020_1 = tslib_12.__importDefault(es2020.exports);
        function default_1(fork2) {
          fork2.use(es2020_1.default);
          var types2 = fork2.use(types_1.default);
          var Type = types2.Type;
          var def2 = types2.Type.def;
          var or = Type.or;
          var shared2 = fork2.use(shared_1.default);
          var defaults2 = shared2.defaults;
          def2("AwaitExpression").build("argument", "all").field("argument", or(def2("Expression"), null)).field("all", Boolean, defaults2["false"]);
          def2("Decorator").bases("Node").build("expression").field("expression", def2("Expression"));
          def2("Property").field("decorators", or([def2("Decorator")], null), defaults2["null"]);
          def2("MethodDefinition").field("decorators", or([def2("Decorator")], null), defaults2["null"]);
          def2("PrivateName").bases("Expression", "Pattern").build("id").field("id", def2("Identifier"));
          def2("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def2("PrivateName")).field("value", or(def2("Expression"), null), defaults2["null"]);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(esProposals, esProposals.exports);
      var typeAnnotations = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          var TypeAnnotation = or(def2("TypeAnnotation"), def2("TSTypeAnnotation"), null);
          var TypeParamDecl = or(def2("TypeParameterDeclaration"), def2("TSTypeParameterDeclaration"), null);
          def2("Identifier").field("typeAnnotation", TypeAnnotation, defaults2["null"]);
          def2("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults2["null"]);
          def2("Function").field("returnType", TypeAnnotation, defaults2["null"]).field("typeParameters", TypeParamDecl, defaults2["null"]);
          def2("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def2("Expression"), null)).field("static", Boolean, defaults2["false"]).field("typeAnnotation", TypeAnnotation, defaults2["null"]);
          [
            "ClassDeclaration",
            "ClassExpression"
          ].forEach(function(typeName) {
            def2(typeName).field("typeParameters", TypeParamDecl, defaults2["null"]).field("superTypeParameters", or(def2("TypeParameterInstantiation"), def2("TSTypeParameterInstantiation"), null), defaults2["null"]).field("implements", or([def2("ClassImplements")], [def2("TSExpressionWithTypeArguments")]), defaults2.emptyArray);
          });
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(typeAnnotations, typeAnnotations.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es_proposals_1 = tslib_12.__importDefault(esProposals.exports);
        var type_annotations_1 = tslib_12.__importDefault(typeAnnotations.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es_proposals_1.default);
          fork2.use(type_annotations_1.default);
          var types2 = fork2.use(types_1.default);
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          def2("Flow").bases("Node");
          def2("FlowType").bases("Flow");
          def2("AnyTypeAnnotation").bases("FlowType").build();
          def2("EmptyTypeAnnotation").bases("FlowType").build();
          def2("MixedTypeAnnotation").bases("FlowType").build();
          def2("VoidTypeAnnotation").bases("FlowType").build();
          def2("SymbolTypeAnnotation").bases("FlowType").build();
          def2("NumberTypeAnnotation").bases("FlowType").build();
          def2("BigIntTypeAnnotation").bases("FlowType").build();
          def2("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
          def2("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
          def2("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
          def2("StringTypeAnnotation").bases("FlowType").build();
          def2("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
          def2("BooleanTypeAnnotation").bases("FlowType").build();
          def2("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
          def2("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def2("FlowType"));
          def2("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def2("FlowType"));
          def2("NullLiteralTypeAnnotation").bases("FlowType").build();
          def2("NullTypeAnnotation").bases("FlowType").build();
          def2("ThisTypeAnnotation").bases("FlowType").build();
          def2("ExistsTypeAnnotation").bases("FlowType").build();
          def2("ExistentialTypeParam").bases("FlowType").build();
          def2("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def2("FunctionTypeParam")]).field("returnType", def2("FlowType")).field("rest", or(def2("FunctionTypeParam"), null)).field("typeParameters", or(def2("TypeParameterDeclaration"), null));
          def2("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def2("Identifier"), null)).field("typeAnnotation", def2("FlowType")).field("optional", Boolean);
          def2("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def2("FlowType"));
          def2("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
            or(def2("ObjectTypeProperty"), def2("ObjectTypeSpreadProperty"))
          ]).field("indexers", [def2("ObjectTypeIndexer")], defaults2.emptyArray).field("callProperties", [def2("ObjectTypeCallProperty")], defaults2.emptyArray).field("inexact", or(Boolean, void 0), defaults2["undefined"]).field("exact", Boolean, defaults2["false"]).field("internalSlots", [def2("ObjectTypeInternalSlot")], defaults2.emptyArray);
          def2("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
          var LegacyVariance = or(def2("Variance"), "plus", "minus", null);
          def2("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def2("Literal"), def2("Identifier"))).field("value", def2("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults2["null"]);
          def2("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def2("Identifier")).field("key", def2("FlowType")).field("value", def2("FlowType")).field("variance", LegacyVariance, defaults2["null"]).field("static", Boolean, defaults2["false"]);
          def2("ObjectTypeCallProperty").bases("Node").build("value").field("value", def2("FunctionTypeAnnotation")).field("static", Boolean, defaults2["false"]);
          def2("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def2("Identifier"), def2("QualifiedTypeIdentifier"))).field("id", def2("Identifier"));
          def2("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def2("Identifier"), def2("QualifiedTypeIdentifier"))).field("typeParameters", or(def2("TypeParameterInstantiation"), null));
          def2("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def2("Identifier")).field("property", or(def2("MemberTypeAnnotation"), def2("GenericTypeAnnotation")));
          def2("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def2("FlowType")]);
          def2("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def2("FlowType")]);
          def2("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def2("FlowType"));
          def2("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def2("FlowType"));
          def2("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def2("Identifier")).field("value", def2("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
          def2("TypeParameterDeclaration").bases("Node").build("params").field("params", [def2("TypeParameter")]);
          def2("TypeParameterInstantiation").bases("Node").build("params").field("params", [def2("FlowType")]);
          def2("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults2["null"]).field("bound", or(def2("TypeAnnotation"), null), defaults2["null"]).field("default", or(def2("FlowType"), null), defaults2["null"]);
          def2("ClassProperty").field("variance", LegacyVariance, defaults2["null"]);
          def2("ClassImplements").bases("Node").build("id").field("id", def2("Identifier")).field("superClass", or(def2("Expression"), null), defaults2["null"]).field("typeParameters", or(def2("TypeParameterInstantiation"), null), defaults2["null"]);
          def2("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def2("ObjectTypeAnnotation")).field("extends", or([def2("InterfaceExtends")], null), defaults2["null"]);
          def2("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def2("Identifier")).field("typeParameters", or(def2("TypeParameterDeclaration"), null), defaults2["null"]).field("body", def2("ObjectTypeAnnotation")).field("extends", [def2("InterfaceExtends")]);
          def2("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
          def2("InterfaceExtends").bases("Node").build("id").field("id", def2("Identifier")).field("typeParameters", or(def2("TypeParameterInstantiation"), null), defaults2["null"]);
          def2("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def2("Identifier")).field("typeParameters", or(def2("TypeParameterDeclaration"), null)).field("right", def2("FlowType"));
          def2("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
          def2("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def2("Identifier")).field("typeParameters", or(def2("TypeParameterDeclaration"), null)).field("impltype", def2("FlowType")).field("supertype", or(def2("FlowType"), null));
          def2("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def2("FlowType"), null));
          def2("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def2("Expression")).field("typeAnnotation", def2("TypeAnnotation"));
          def2("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def2("FlowType")]);
          def2("DeclareVariable").bases("Statement").build("id").field("id", def2("Identifier"));
          def2("DeclareFunction").bases("Statement").build("id").field("id", def2("Identifier")).field("predicate", or(def2("FlowPredicate"), null), defaults2["null"]);
          def2("DeclareClass").bases("InterfaceDeclaration").build("id");
          def2("DeclareModule").bases("Statement").build("id", "body").field("id", or(def2("Identifier"), def2("Literal"))).field("body", def2("BlockStatement"));
          def2("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def2("TypeAnnotation"));
          def2("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
            def2("DeclareVariable"),
            def2("DeclareFunction"),
            def2("DeclareClass"),
            def2("FlowType"),
            // Implies default.
            def2("TypeAlias"),
            // Implies named type
            def2("DeclareOpaqueType"),
            // Implies named opaque type
            def2("InterfaceDeclaration"),
            null
          )).field("specifiers", [or(def2("ExportSpecifier"), def2("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def2("Literal"), null), defaults2["null"]);
          def2("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def2("Literal"), null), defaults2["null"]);
          def2("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
            return "value";
          });
          def2("FlowPredicate").bases("Flow");
          def2("InferredPredicate").bases("FlowPredicate").build();
          def2("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def2("Expression"));
          def2("Function").field("predicate", or(def2("FlowPredicate"), null), defaults2["null"]);
          def2("CallExpression").field("typeArguments", or(null, def2("TypeParameterInstantiation")), defaults2["null"]);
          def2("NewExpression").field("typeArguments", or(null, def2("TypeParameterInstantiation")), defaults2["null"]);
          def2("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def2("Identifier")).field("body", or(def2("EnumBooleanBody"), def2("EnumNumberBody"), def2("EnumStringBody"), def2("EnumSymbolBody")));
          def2("EnumBooleanBody").build("members", "explicitType").field("members", [def2("EnumBooleanMember")]).field("explicitType", Boolean);
          def2("EnumNumberBody").build("members", "explicitType").field("members", [def2("EnumNumberMember")]).field("explicitType", Boolean);
          def2("EnumStringBody").build("members", "explicitType").field("members", or([def2("EnumStringMember")], [def2("EnumDefaultedMember")])).field("explicitType", Boolean);
          def2("EnumSymbolBody").build("members").field("members", [def2("EnumDefaultedMember")]);
          def2("EnumBooleanMember").build("id", "init").field("id", def2("Identifier")).field("init", or(def2("Literal"), Boolean));
          def2("EnumNumberMember").build("id", "init").field("id", def2("Identifier")).field("init", def2("Literal"));
          def2("EnumStringMember").build("id", "init").field("id", def2("Identifier")).field("init", def2("Literal"));
          def2("EnumDefaultedMember").build("id").field("id", def2("Identifier"));
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(flow$2, flow$2.exports);
      var esprima$2 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es2020_1 = tslib_12.__importDefault(es2020.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es2020_1.default);
          var types2 = fork2.use(types_1.default);
          var defaults2 = fork2.use(shared_1.default).defaults;
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          def2("VariableDeclaration").field("declarations", [or(
            def2("VariableDeclarator"),
            def2("Identifier")
            // Esprima deviation.
          )]);
          def2("Property").field("value", or(
            def2("Expression"),
            def2("Pattern")
            // Esprima deviation.
          ));
          def2("ArrayPattern").field("elements", [or(def2("Pattern"), def2("SpreadElement"), null)]);
          def2("ObjectPattern").field("properties", [or(
            def2("Property"),
            def2("PropertyPattern"),
            def2("SpreadPropertyPattern"),
            def2("SpreadProperty")
            // Used by Esprima.
          )]);
          def2("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
          def2("ExportBatchSpecifier").bases("Specifier").build();
          def2("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
            def2("Declaration"),
            def2("Expression"),
            // Implies default.
            null
          )).field("specifiers", [or(def2("ExportSpecifier"), def2("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def2("Literal"), null), defaults2["null"]);
          def2("Block").bases("Comment").build(
            "value",
            /*optional:*/
            "leading",
            "trailing"
          );
          def2("Line").bases("Comment").build(
            "value",
            /*optional:*/
            "leading",
            "trailing"
          );
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(esprima$2, esprima$2.exports);
      var babel = { exports: {} };
      var babelCore = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var es_proposals_1 = tslib_12.__importDefault(esProposals.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(es_proposals_1.default);
          var types2 = fork2.use(types_1.default);
          var defaults2 = fork2.use(shared_1.default).defaults;
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          def2("Noop").bases("Statement").build();
          def2("DoExpression").bases("Expression").build("body").field("body", [def2("Statement")]);
          def2("BindExpression").bases("Expression").build("object", "callee").field("object", or(def2("Expression"), null)).field("callee", def2("Expression"));
          def2("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def2("Expression"));
          def2("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def2("Identifier"));
          def2("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def2("Identifier"));
          def2("CommentBlock").bases("Comment").build(
            "value",
            /*optional:*/
            "leading",
            "trailing"
          );
          def2("CommentLine").bases("Comment").build(
            "value",
            /*optional:*/
            "leading",
            "trailing"
          );
          def2("Directive").bases("Node").build("value").field("value", def2("DirectiveLiteral"));
          def2("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults2["use strict"]);
          def2("InterpreterDirective").bases("Node").build("value").field("value", String);
          def2("BlockStatement").bases("Statement").build("body").field("body", [def2("Statement")]).field("directives", [def2("Directive")], defaults2.emptyArray);
          def2("Program").bases("Node").build("body").field("body", [def2("Statement")]).field("directives", [def2("Directive")], defaults2.emptyArray).field("interpreter", or(def2("InterpreterDirective"), null), defaults2["null"]);
          def2("StringLiteral").bases("Literal").build("value").field("value", String);
          def2("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults2["null"]).field("extra", {
            rawValue: Number,
            raw: String
          }, function getDefault() {
            return {
              rawValue: this.value,
              raw: this.value + ""
            };
          });
          def2("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number)).field("extra", {
            rawValue: String,
            raw: String
          }, function getDefault() {
            return {
              rawValue: String(this.value),
              raw: this.value + "n"
            };
          });
          def2("NullLiteral").bases("Literal").build().field("value", null, defaults2["null"]);
          def2("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
          def2("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
            return new RegExp(this.pattern, this.flags);
          });
          var ObjectExpressionProperty = or(def2("Property"), def2("ObjectMethod"), def2("ObjectProperty"), def2("SpreadProperty"), def2("SpreadElement"));
          def2("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
          def2("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def2("Literal"), def2("Identifier"), def2("Expression"))).field("params", [def2("Pattern")]).field("body", def2("BlockStatement")).field("computed", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]).field(
            "accessibility",
            // TypeScript
            or(def2("Literal"), null),
            defaults2["null"]
          ).field("decorators", or([def2("Decorator")], null), defaults2["null"]);
          def2("ObjectProperty").bases("Node").build("key", "value").field("key", or(def2("Literal"), def2("Identifier"), def2("Expression"))).field("value", or(def2("Expression"), def2("Pattern"))).field(
            "accessibility",
            // TypeScript
            or(def2("Literal"), null),
            defaults2["null"]
          ).field("computed", Boolean, defaults2["false"]);
          var ClassBodyElement = or(def2("MethodDefinition"), def2("VariableDeclarator"), def2("ClassPropertyDefinition"), def2("ClassProperty"), def2("ClassPrivateProperty"), def2("ClassMethod"), def2("ClassPrivateMethod"));
          def2("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
          def2("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def2("Literal"), def2("Identifier"), def2("Expression")));
          def2("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def2("PrivateName"));
          [
            "ClassMethod",
            "ClassPrivateMethod"
          ].forEach(function(typeName) {
            def2(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
              return "method";
            }).field("body", def2("BlockStatement")).field("computed", Boolean, defaults2["false"]).field("static", or(Boolean, null), defaults2["null"]).field("abstract", or(Boolean, null), defaults2["null"]).field("access", or("public", "private", "protected", null), defaults2["null"]).field("accessibility", or("public", "private", "protected", null), defaults2["null"]).field("decorators", or([def2("Decorator")], null), defaults2["null"]).field("optional", or(Boolean, null), defaults2["null"]);
          });
          var ObjectPatternProperty = or(
            def2("Property"),
            def2("PropertyPattern"),
            def2("SpreadPropertyPattern"),
            def2("SpreadProperty"),
            // Used by Esprima
            def2("ObjectProperty"),
            // Babel 6
            def2("RestProperty")
            // Babel 6
          );
          def2("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def2("Decorator")], null), defaults2["null"]);
          def2("SpreadProperty").bases("Node").build("argument").field("argument", def2("Expression"));
          def2("RestProperty").bases("Node").build("argument").field("argument", def2("Expression"));
          def2("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def2("VariableDeclaration"), def2("Expression"))).field("right", def2("Expression")).field("body", def2("Statement"));
          def2("Import").bases("Expression").build();
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(babelCore, babelCore.exports);
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var babel_core_1 = tslib_12.__importDefault(babelCore.exports);
        var flow_1 = tslib_12.__importDefault(flow$2.exports);
        function default_1(fork2) {
          fork2.use(babel_core_1.default);
          fork2.use(flow_1.default);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(babel, babel.exports);
      var typescript$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib_12 = require$$0$5;
        var babel_core_1 = tslib_12.__importDefault(babelCore.exports);
        var type_annotations_1 = tslib_12.__importDefault(typeAnnotations.exports);
        var types_1 = tslib_12.__importDefault(types$b);
        var shared_1 = tslib_12.__importDefault(shared$2.exports);
        function default_1(fork2) {
          fork2.use(babel_core_1.default);
          fork2.use(type_annotations_1.default);
          var types2 = fork2.use(types_1.default);
          var n2 = types2.namedTypes;
          var def2 = types2.Type.def;
          var or = types2.Type.or;
          var defaults2 = fork2.use(shared_1.default).defaults;
          var StringLiteral = types2.Type.from(function(value, deep) {
            if (n2.StringLiteral && n2.StringLiteral.check(value, deep)) {
              return true;
            }
            if (n2.Literal && n2.Literal.check(value, deep) && typeof value.value === "string") {
              return true;
            }
            return false;
          }, "StringLiteral");
          def2("TSType").bases("Node");
          var TSEntityName = or(def2("Identifier"), def2("TSQualifiedName"));
          def2("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
          def2("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def2("TSTypeParameterInstantiation"), null), defaults2["null"]);
          def2("TSHasOptionalTypeParameters").field("typeParameters", or(def2("TSTypeParameterDeclaration"), null, void 0), defaults2["null"]);
          def2("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def2("TSTypeAnnotation"), null), defaults2["null"]);
          def2("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
          def2("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def2("Expression")).field("typeAnnotation", def2("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults2["null"]);
          def2("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def2("Expression"));
          [
            "TSAnyKeyword",
            "TSBigIntKeyword",
            "TSBooleanKeyword",
            "TSNeverKeyword",
            "TSNullKeyword",
            "TSNumberKeyword",
            "TSObjectKeyword",
            "TSStringKeyword",
            "TSSymbolKeyword",
            "TSUndefinedKeyword",
            "TSUnknownKeyword",
            "TSVoidKeyword",
            "TSThisType"
          ].forEach(function(keywordType) {
            def2(keywordType).bases("TSType").build();
          });
          def2("TSArrayType").bases("TSType").build("elementType").field("elementType", def2("TSType"));
          def2("TSLiteralType").bases("TSType").build("literal").field("literal", or(def2("NumericLiteral"), def2("StringLiteral"), def2("BooleanLiteral"), def2("TemplateLiteral"), def2("UnaryExpression")));
          [
            "TSUnionType",
            "TSIntersectionType"
          ].forEach(function(typeName) {
            def2(typeName).bases("TSType").build("types").field("types", [def2("TSType")]);
          });
          def2("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def2("TSType")).field("extendsType", def2("TSType")).field("trueType", def2("TSType")).field("falseType", def2("TSType"));
          def2("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def2("TSTypeParameter"));
          def2("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def2("TSType"));
          var ParametersType = [or(def2("Identifier"), def2("RestElement"), def2("ArrayPattern"), def2("ObjectPattern"))];
          [
            "TSFunctionType",
            "TSConstructorType"
          ].forEach(function(typeName) {
            def2(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
          });
          def2("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("id", or(def2("Identifier"), null), defaults2["null"]).field("params", [def2("Pattern")]).field("returnType", or(
            def2("TSTypeAnnotation"),
            def2("Noop"),
            // Still used?
            null
          ), defaults2["null"]);
          def2("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("params", [def2("Pattern")]).field("abstract", Boolean, defaults2["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults2["undefined"]).field("static", Boolean, defaults2["false"]).field("computed", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("key", or(
            def2("Identifier"),
            def2("StringLiteral"),
            def2("NumericLiteral"),
            // Only allowed if .computed is true.
            def2("Expression")
          )).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
            return "method";
          }).field(
            "access",
            // Not "accessibility"?
            or("public", "private", "protected", void 0),
            defaults2["undefined"]
          ).field("decorators", or([def2("Decorator")], null), defaults2["null"]).field("returnType", or(
            def2("TSTypeAnnotation"),
            def2("Noop"),
            // Still used?
            null
          ), defaults2["null"]);
          def2("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults2["false"]).field("typeParameter", def2("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults2["false"]).field("typeAnnotation", or(def2("TSType"), null), defaults2["null"]);
          def2("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def2("TSType"), def2("TSNamedTupleMember"))]);
          def2("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def2("Identifier")).field("optional", Boolean, defaults2["false"]).field("elementType", def2("TSType"));
          def2("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def2("TSType"));
          def2("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def2("TSType"));
          def2("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def2("TSType")).field("indexType", def2("TSType"));
          def2("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def2("TSType"));
          def2("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def2("TSType"), def2("TSTypeAnnotation")));
          def2("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def2("Identifier")]).field("readonly", Boolean, defaults2["false"]);
          def2("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def2("Expression")).field("computed", Boolean, defaults2["false"]).field("readonly", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("initializer", or(def2("Expression"), null), defaults2["null"]);
          def2("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def2("Expression")).field("computed", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("parameters", ParametersType);
          def2("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def2("Identifier"), def2("TSThisType"))).field("typeAnnotation", or(def2("TSTypeAnnotation"), null), defaults2["null"]).field("asserts", Boolean, defaults2["false"]);
          [
            "TSCallSignatureDeclaration",
            "TSConstructSignatureDeclaration"
          ].forEach(function(typeName) {
            def2(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
          });
          def2("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def2("Identifier"), StringLiteral)).field("initializer", or(def2("Expression"), null), defaults2["null"]);
          def2("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def2("TSImportType")));
          var TSTypeMember = or(def2("TSCallSignatureDeclaration"), def2("TSConstructSignatureDeclaration"), def2("TSIndexSignature"), def2("TSMethodSignature"), def2("TSPropertySignature"));
          def2("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
          def2("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or(def2("TSType"), void 0), defaults2["undefined"]).field("default", or(def2("TSType"), void 0), defaults2["undefined"]);
          def2("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def2("TSType")).field("expression", def2("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults2["null"]);
          def2("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def2("TSTypeParameter")]);
          def2("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def2("TSType")]);
          def2("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def2("Identifier")).field("const", Boolean, defaults2["false"]).field("declare", Boolean, defaults2["false"]).field("members", [def2("TSEnumMember")]).field("initializer", or(def2("Expression"), null), defaults2["null"]);
          def2("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def2("Identifier")).field("declare", Boolean, defaults2["false"]).field("typeAnnotation", def2("TSType"));
          def2("TSModuleBlock").bases("Node").build("body").field("body", [def2("Statement")]);
          def2("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults2["false"]).field("global", Boolean, defaults2["false"]).field("body", or(def2("TSModuleBlock"), def2("TSModuleDeclaration"), null), defaults2["null"]);
          def2("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults2["undefined"]);
          def2("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def2("Identifier")).field("isExport", Boolean, defaults2["false"]).field("moduleReference", or(TSEntityName, def2("TSExternalModuleReference")));
          def2("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
          def2("TSExportAssignment").bases("Statement").build("expression").field("expression", def2("Expression"));
          def2("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def2("Identifier"));
          def2("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
          def2("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
          def2("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults2["false"]).field("extends", or([def2("TSExpressionWithTypeArguments")], null), defaults2["null"]).field("body", def2("TSInterfaceBody"));
          def2("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults2["undefined"]).field("readonly", Boolean, defaults2["false"]).field("parameter", or(def2("Identifier"), def2("AssignmentPattern")));
          def2("ClassProperty").field(
            "access",
            // Not "accessibility"?
            or("public", "private", "protected", void 0),
            defaults2["undefined"]
          );
          def2("ClassBody").field("body", [or(
            def2("MethodDefinition"),
            def2("VariableDeclarator"),
            def2("ClassPropertyDefinition"),
            def2("ClassProperty"),
            def2("ClassPrivateProperty"),
            def2("ClassMethod"),
            def2("ClassPrivateMethod"),
            // Just need to add these types:
            def2("TSDeclareMethod"),
            TSTypeMember
          )]);
        }
        exports2.default = default_1;
        module2.exports = exports2["default"];
      })(typescript$1, typescript$1.exports);
      var namedTypes$1 = {};
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.namedTypes = void 0;
        /* @__PURE__ */ (function(namedTypes2) {
        })(exports2.namedTypes || (exports2.namedTypes = {}));
      })(namedTypes$1);
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.visit = exports2.use = exports2.Type = exports2.someField = exports2.PathVisitor = exports2.Path = exports2.NodePath = exports2.namedTypes = exports2.getSupertypeNames = exports2.getFieldValue = exports2.getFieldNames = exports2.getBuilderName = exports2.finalize = exports2.eachField = exports2.defineMethod = exports2.builtInTypes = exports2.builders = exports2.astNodesAreEquivalent = void 0;
        var tslib_12 = require$$0$5;
        var fork_1 = tslib_12.__importDefault(fork.exports);
        var core_12 = tslib_12.__importDefault(core$4.exports);
        var es6_1 = tslib_12.__importDefault(es6.exports);
        var es2016_1 = tslib_12.__importDefault(es2016.exports);
        var es2017_1 = tslib_12.__importDefault(es2017.exports);
        var es2018_1 = tslib_12.__importDefault(es2018.exports);
        var es2019_1 = tslib_12.__importDefault(es2019.exports);
        var es2020_1 = tslib_12.__importDefault(es2020.exports);
        var jsx_1 = tslib_12.__importDefault(jsx$1.exports);
        var flow_1 = tslib_12.__importDefault(flow$2.exports);
        var esprima_1 = tslib_12.__importDefault(esprima$2.exports);
        var babel_1 = tslib_12.__importDefault(babel.exports);
        var typescript_1 = tslib_12.__importDefault(typescript$1.exports);
        var es_proposals_1 = tslib_12.__importDefault(esProposals.exports);
        var namedTypes_1 = namedTypes$1;
        Object.defineProperty(exports2, "namedTypes", { enumerable: true, get: function() {
          return namedTypes_1.namedTypes;
        } });
        var _a = fork_1.default([
          // This core module of AST types captures ES5 as it is parsed today by
          // git://github.com/ariya/esprima.git#master.
          core_12.default,
          // Feel free to add to or remove from this list of extension modules to
          // configure the precise type hierarchy that you need.
          es6_1.default,
          es2016_1.default,
          es2017_1.default,
          es2018_1.default,
          es2019_1.default,
          es2020_1.default,
          jsx_1.default,
          flow_1.default,
          esprima_1.default,
          babel_1.default,
          typescript_1.default,
          es_proposals_1.default
        ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n2 = _a.namedTypes, NodePath2 = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit2 = _a.visit;
        exports2.astNodesAreEquivalent = astNodesAreEquivalent;
        exports2.builders = builders;
        exports2.builtInTypes = builtInTypes;
        exports2.defineMethod = defineMethod;
        exports2.eachField = eachField;
        exports2.finalize = finalize;
        exports2.getBuilderName = getBuilderName;
        exports2.getFieldNames = getFieldNames;
        exports2.getFieldValue = getFieldValue;
        exports2.getSupertypeNames = getSupertypeNames;
        exports2.NodePath = NodePath2;
        exports2.Path = Path;
        exports2.PathVisitor = PathVisitor;
        exports2.someField = someField;
        exports2.Type = Type;
        exports2.use = use;
        exports2.visit = visit2;
        Object.assign(namedTypes_1.namedTypes, n2);
      })(main$2);
      var parser$5 = {};
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var inited = false;
      function init() {
        inited = true;
        var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i2 = 0, len = code2.length; i2 < len; ++i2) {
          lookup[i2] = code2[i2];
          revLookup[code2.charCodeAt(i2)] = i2;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
      }
      function toByteArray(b64) {
        if (!inited) {
          init();
        }
        var i2, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[L++] = tmp >> 16 & 255;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        if (!inited) {
          init();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output += lookup[tmp >> 2];
          output += lookup[tmp << 4 & 63];
          output += "==";
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          output += lookup[tmp >> 10];
          output += lookup[tmp >> 4 & 63];
          output += lookup[tmp << 2 & 63];
          output += "=";
        }
        parts.push(output);
        return parts.join("");
      }
      function read(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i2 = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i2];
        i2 += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      }
      function write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i2 = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i2 - d] |= s * 128;
      }
      var toString$3 = {}.toString;
      var isArray$7 = Array.isArray || function(arr) {
        return toString$3.call(arr) == "[object Array]";
      };
      var INSPECT_MAX_BYTES = 50;
      Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
      var _kMaxLength = kMaxLength();
      function kMaxLength() {
        return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function createBuffer(that, length) {
        if (kMaxLength() < length) {
          throw new RangeError("Invalid typed array length");
        }
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length);
          that.__proto__ = Buffer$1.prototype;
        } else {
          if (that === null) {
            that = new Buffer$1(length);
          }
          that.length = length;
        }
        return that;
      }
      function Buffer$1(arg, encodingOrOffset, length) {
        if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
          return new Buffer$1(arg, encodingOrOffset, length);
        }
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new Error(
              "If encoding is specified then the first argument must be a string"
            );
          }
          return allocUnsafe(this, arg);
        }
        return from(this, arg, encodingOrOffset, length);
      }
      Buffer$1.poolSize = 8192;
      Buffer$1._augment = function(arr) {
        arr.__proto__ = Buffer$1.prototype;
        return arr;
      };
      function from(that, value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length);
        }
        if (typeof value === "string") {
          return fromString$1(that, value, encodingOrOffset);
        }
        return fromObject(that, value);
      }
      Buffer$1.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        Buffer$1.prototype.__proto__ = Uint8Array.prototype;
        Buffer$1.__proto__ = Uint8Array;
      }
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      function alloc(that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
        }
        return createBuffer(that, size);
      }
      Buffer$1.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
          for (var i2 = 0; i2 < size; ++i2) {
            that[i2] = 0;
          }
        }
        return that;
      }
      Buffer$1.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer$1.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString$1(that, string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer$1.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var length = byteLength(string2, encoding) | 0;
        that = createBuffer(that, length);
        var actual = that.write(string2, encoding);
        if (actual !== length) {
          that = that.slice(0, actual);
        }
        return that;
      }
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        that = createBuffer(that, length);
        for (var i2 = 0; i2 < length; i2 += 1) {
          that[i2] = array[i2] & 255;
        }
        return that;
      }
      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength;
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        if (byteOffset === void 0 && length === void 0) {
          array = new Uint8Array(array);
        } else if (length === void 0) {
          array = new Uint8Array(array, byteOffset);
        } else {
          array = new Uint8Array(array, byteOffset, length);
        }
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          that = array;
          that.__proto__ = Buffer$1.prototype;
        } else {
          that = fromArrayLike(that, array);
        }
        return that;
      }
      function fromObject(that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);
          if (that.length === 0) {
            return that;
          }
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && isArray$7(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer$1.alloc(+length);
      }
      Buffer$1.isBuffer = isBuffer;
      function internalIsBuffer(b2) {
        return !!(b2 != null && b2._isBuffer);
      }
      Buffer$1.compare = function compare2(a, b2) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b2)
          return 0;
        var x = a.length;
        var y = b2.length;
        for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
          if (a[i2] !== b2[i2]) {
            x = a[i2];
            y = b2[i2];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer$1.isEncoding = function isEncoding2(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer$1.concat = function concat2(list2, length) {
        if (!isArray$7(list2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list2.length === 0) {
          return Buffer$1.alloc(0);
        }
        var i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list2.length; ++i2) {
            length += list2[i2].length;
          }
        }
        var buffer = Buffer$1.allocUnsafe(length);
        var pos = 0;
        for (i2 = 0; i2 < list2.length; ++i2) {
          var buf = list2[i2];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (internalIsBuffer(string2)) {
          return string2.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          string2 = "" + string2;
        }
        var len = string2.length;
        if (len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
            case void 0:
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase)
                return utf8ToBytes(string2).length;
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer$1.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer$1.prototype._isBuffer = true;
      function swap$1(b2, n2, m) {
        var i2 = b2[n2];
        b2[n2] = b2[m];
        b2[m] = i2;
      }
      Buffer$1.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap$1(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer$1.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap$1(this, i2, i2 + 3);
          swap$1(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer$1.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap$1(this, i2, i2 + 7);
          swap$1(this, i2 + 1, i2 + 6);
          swap$1(this, i2 + 2, i2 + 5);
          swap$1(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer$1.prototype.toString = function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer$1.prototype.equals = function equals2(b2) {
        if (!internalIsBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer$1.compare(this, b2) === 0;
      };
      Buffer$1.prototype.inspect = function inspect2() {
        var str2 = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str2 += " ... ";
        }
        return "<Buffer " + str2 + ">";
      };
      Buffer$1.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x = thisCopy[i2];
            y = targetCopy[i2];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer$1.from(val, encoding);
        }
        if (internalIsBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        var i2;
        if (dir) {
          var foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read2(arr, i2 + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i2;
          }
        }
        return -1;
      }
      Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer$1.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string2.length;
        if (strLen % 2 !== 0)
          throw new TypeError("Invalid hex string");
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i2 = 0; i2 < length; ++i2) {
          var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
          if (isNaN(parsed))
            return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string2, offset, length) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string2, offset, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset, length);
      }
      function latin1Write(buf, string2, offset, length) {
        return asciiWrite(buf, string2, offset, length);
      }
      function base64Write(buf, string2, offset, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset, length);
      }
      function ucs2Write(buf, string2, offset, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
      }
      Buffer$1.prototype.write = function write2(string2, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length);
            case "ascii":
              return asciiWrite(this, string2, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string2, offset, length);
            case "base64":
              return base64Write(this, string2, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer$1.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf);
        } else {
          return fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i2 = start;
        while (i2 < end) {
          var firstByte = buf[i2];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i2 = 0;
        while (i2 < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i2 = start; i2 < end; ++i2) {
          out += toHex(buf[i2]);
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i2 = 0; i2 < bytes.length; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer$1.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer$1.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer$1(sliceLen, void 0);
          for (var i2 = 0; i2 < sliceLen; ++i2) {
            newBuf[i2] = this[i2 + start];
          }
        }
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i2 = byteLength2;
        var mul = 1;
        var val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!internalIsBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 65535 + value + 1;
        for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
          buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
        }
      }
      Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 4294967295 + value + 1;
        for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
          buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
        }
      }
      Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer$1.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer$1.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i2;
        if (this === target && start < targetStart && targetStart < end) {
          for (i2 = len - 1; i2 >= 0; --i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
          for (i2 = 0; i2 < len; ++i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code2 = val.charCodeAt(0);
            if (code2 < 256) {
              val = code2;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
          var len = bytes.length;
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str2) {
        str2 = stringtrim(str2).replace(INVALID_BASE64_RE, "");
        if (str2.length < 2)
          return "";
        while (str2.length % 4 !== 0) {
          str2 = str2 + "=";
        }
        return str2;
      }
      function stringtrim(str2) {
        if (str2.trim)
          return str2.trim();
        return str2.replace(/^\s+|\s+$/g, "");
      }
      function toHex(n2) {
        if (n2 < 16)
          return "0" + n2.toString(16);
        return n2.toString(16);
      }
      function utf8ToBytes(string2, units) {
        units = units || Infinity;
        var codePoint;
        var length = string2.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i2 = 0; i2 < length; ++i2) {
          codePoint = string2.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str2) {
        var byteArray = [];
        for (var i2 = 0; i2 < str2.length; ++i2) {
          byteArray.push(str2.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str2, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i2 = 0; i2 < str2.length; ++i2) {
          if ((units -= 2) < 0)
            break;
          c = str2.charCodeAt(i2);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str2) {
        return toByteArray(base64clean(str2));
      }
      function blitBuffer(src2, dst, offset, length) {
        for (var i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src2.length)
            break;
          dst[i2 + offset] = src2[i2];
        }
        return i2;
      }
      function isnan(val) {
        return val !== val;
      }
      function isBuffer(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
      }
      function isFastBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
      }
      var _polyfillNode_buffer = Object.freeze({
        __proto__: null,
        Buffer: Buffer$1,
        INSPECT_MAX_BYTES,
        SlowBuffer,
        isBuffer,
        kMaxLength: _kMaxLength
      });
      var inherits;
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      var inherits$1 = inherits;
      var formatRegExp = /%[sdj%]/g;
      function format$1(f) {
        if (!isString$5(f)) {
          var objects = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            objects.push(inspect$1(arguments[i2]));
          }
          return objects.join(" ");
        }
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        var str2 = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i2 >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i2]; i2 < len; x = args[++i2]) {
          if (isNull(x) || !isObject$c(x)) {
            str2 += " " + x;
          } else {
            str2 += " " + inspect$1(x);
          }
        }
        return str2;
      }
      function deprecate$2(fn, msg) {
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate$2(fn, msg).apply(this, arguments);
          };
        }
        if (browser$1$1.noDeprecation === true) {
          return fn;
        }
        var warned2 = false;
        function deprecated() {
          if (!warned2) {
            if (browser$1$1.throwDeprecation) {
              throw new Error(msg);
            } else if (browser$1$1.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned2 = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      var debugs = {};
      var debugEnviron;
      function debuglog(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = browser$1$1.env.NODE_DEBUG || "";
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
            var pid = 0;
            debugs[set] = function() {
              var msg = format$1.apply(null, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      }
      function inspect$1(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          _extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      inspect$1.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect$1.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str2, styleType) {
        var style = inspect$1.styles[styleType];
        if (style) {
          return "\x1B[" + inspect$1.colors[style][0] + "m" + str2 + "\x1B[" + inspect$1.colors[style][1] + "m";
        } else {
          return str2;
        }
      }
      function stylizeNoColor(str2, styleType) {
        return str2;
      }
      function arrayToHash(array) {
        var hash2 = {};
        array.forEach(function(val, idx) {
          hash2[val] = true;
        });
        return hash2;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction$2(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString$5(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys2 = Object.keys(value);
        var visibleKeys = arrayToHash(keys2);
        if (ctx.showHidden) {
          keys2 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys2.length === 0) {
          if (isFunction$2(value)) {
            var name2 = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name2 + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate$1(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base2 = "", array = false, braces = ["{", "}"];
        if (isArray$6(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction$2(value)) {
          var n2 = value.name ? ": " + value.name : "";
          base2 = " [Function" + n2 + "]";
        }
        if (isRegExp(value)) {
          base2 = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate$1(value)) {
          base2 = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base2 = " " + formatError(value);
        }
        if (keys2.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base2 + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
        } else {
          output = keys2.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base2, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString$5(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber$1(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
        var output = [];
        for (var i2 = 0, l = value.length; i2 < l; ++i2) {
          if (hasOwnProperty$4(value, String(i2))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i2),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys2.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name2, str2, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str2 = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str2 = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str2 = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty$4(visibleKeys, key)) {
          name2 = "[" + key + "]";
        }
        if (!str2) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str2 = formatValue(ctx, desc.value, null);
            } else {
              str2 = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str2.indexOf("\n") > -1) {
              if (array) {
                str2 = str2.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str2 = "\n" + str2.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str2 = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name2)) {
          if (array && key.match(/^\d+$/)) {
            return str2;
          }
          name2 = JSON.stringify("" + key);
          if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name2 = name2.substr(1, name2.length - 2);
            name2 = ctx.stylize(name2, "name");
          } else {
            name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name2 = ctx.stylize(name2, "string");
          }
        }
        return name2 + ": " + str2;
      }
      function reduceToSingleString(output, base2, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
      }
      function isArray$6(ar) {
        return Array.isArray(ar);
      }
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      function isNull(arg) {
        return arg === null;
      }
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      function isNumber$1(arg) {
        return typeof arg === "number";
      }
      function isString$5(arg) {
        return typeof arg === "string";
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
      function isRegExp(re) {
        return isObject$c(re) && objectToString$2(re) === "[object RegExp]";
      }
      function isObject$c(arg) {
        return typeof arg === "object" && arg !== null;
      }
      function isDate$1(d) {
        return isObject$c(d) && objectToString$2(d) === "[object Date]";
      }
      function isError(e) {
        return isObject$c(e) && (objectToString$2(e) === "[object Error]" || e instanceof Error);
      }
      function isFunction$2(arg) {
        return typeof arg === "function";
      }
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      function objectToString$2(o) {
        return Object.prototype.toString.call(o);
      }
      function _extend(origin, add) {
        if (!add || !isObject$c(add))
          return origin;
        var keys2 = Object.keys(add);
        var i2 = keys2.length;
        while (i2--) {
          origin[keys2[i2]] = add[keys2[i2]];
        }
        return origin;
      }
      function hasOwnProperty$4(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function compare(a, b2) {
        if (a === b2) {
          return 0;
        }
        var x = a.length;
        var y = b2.length;
        for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
          if (a[i2] !== b2[i2]) {
            x = a[i2];
            y = b2[i2];
            break;
          }
        }
        if (x < y) {
          return -1;
        }
        if (y < x) {
          return 1;
        }
        return 0;
      }
      var hasOwn$8 = Object.prototype.hasOwnProperty;
      var objectKeys$1 = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          if (hasOwn$8.call(obj, key))
            keys2.push(key);
        }
        return keys2;
      };
      var pSlice = Array.prototype.slice;
      var _functionsHaveNames;
      function functionsHaveNames() {
        if (typeof _functionsHaveNames !== "undefined") {
          return _functionsHaveNames;
        }
        return _functionsHaveNames = function() {
          return (function foo() {
          }).name === "foo";
        }();
      }
      function pToString(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isView(arrbuf) {
        if (isBuffer(arrbuf)) {
          return false;
        }
        if (typeof global$1.ArrayBuffer !== "function") {
          return false;
        }
        if (typeof ArrayBuffer.isView === "function") {
          return ArrayBuffer.isView(arrbuf);
        }
        if (!arrbuf) {
          return false;
        }
        if (arrbuf instanceof DataView) {
          return true;
        }
        if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
          return true;
        }
        return false;
      }
      function assert$2(value, message) {
        if (!value)
          fail(value, true, message, "==", ok);
      }
      var regex = /\s*function\s+([^\(\s]*)\s*/;
      function getName(func) {
        if (!isFunction$2(func)) {
          return;
        }
        if (functionsHaveNames()) {
          return func.name;
        }
        var str2 = func.toString();
        var match = str2.match(regex);
        return match && match[1];
      }
      assert$2.AssertionError = AssertionError;
      function AssertionError(options2) {
        this.name = "AssertionError";
        this.actual = options2.actual;
        this.expected = options2.expected;
        this.operator = options2.operator;
        if (options2.message) {
          this.message = options2.message;
          this.generatedMessage = false;
        } else {
          this.message = getMessage(this);
          this.generatedMessage = true;
        }
        var stackStartFunction = options2.stackStartFunction || fail;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, stackStartFunction);
        } else {
          var err = new Error();
          if (err.stack) {
            var out = err.stack;
            var fn_name = getName(stackStartFunction);
            var idx = out.indexOf("\n" + fn_name);
            if (idx >= 0) {
              var next_line = out.indexOf("\n", idx + 1);
              out = out.substring(next_line + 1);
            }
            this.stack = out;
          }
        }
      }
      inherits$1(AssertionError, Error);
      function truncate(s, n2) {
        if (typeof s === "string") {
          return s.length < n2 ? s : s.slice(0, n2);
        } else {
          return s;
        }
      }
      function inspect(something) {
        if (functionsHaveNames() || !isFunction$2(something)) {
          return inspect$1(something);
        }
        var rawname = getName(something);
        var name2 = rawname ? ": " + rawname : "";
        return "[Function" + name2 + "]";
      }
      function getMessage(self2) {
        return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
      }
      function fail(actual, expected, message, operator, stackStartFunction) {
        throw new AssertionError({
          message,
          actual,
          expected,
          operator,
          stackStartFunction
        });
      }
      assert$2.fail = fail;
      function ok(value, message) {
        if (!value)
          fail(value, true, message, "==", ok);
      }
      assert$2.ok = ok;
      assert$2.equal = equal$1;
      function equal$1(actual, expected, message) {
        if (actual != expected)
          fail(actual, expected, message, "==", equal$1);
      }
      assert$2.notEqual = notEqual;
      function notEqual(actual, expected, message) {
        if (actual == expected) {
          fail(actual, expected, message, "!=", notEqual);
        }
      }
      assert$2.deepEqual = deepEqual;
      function deepEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected, false)) {
          fail(actual, expected, message, "deepEqual", deepEqual);
        }
      }
      assert$2.deepStrictEqual = deepStrictEqual;
      function deepStrictEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected, true)) {
          fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
        }
      }
      function _deepEqual(actual, expected, strict, memos) {
        if (actual === expected) {
          return true;
        } else if (isBuffer(actual) && isBuffer(expected)) {
          return compare(actual, expected) === 0;
        } else if (isDate$1(actual) && isDate$1(expected)) {
          return actual.getTime() === expected.getTime();
        } else if (isRegExp(actual) && isRegExp(expected)) {
          return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
        } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
          return strict ? actual === expected : actual == expected;
        } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
          return compare(
            new Uint8Array(actual.buffer),
            new Uint8Array(expected.buffer)
          ) === 0;
        } else if (isBuffer(actual) !== isBuffer(expected)) {
          return false;
        } else {
          memos = memos || { actual: [], expected: [] };
          var actualIndex = memos.actual.indexOf(actual);
          if (actualIndex !== -1) {
            if (actualIndex === memos.expected.indexOf(expected)) {
              return true;
            }
          }
          memos.actual.push(actual);
          memos.expected.push(expected);
          return objEquiv(actual, expected, strict, memos);
        }
      }
      function isArguments(object2) {
        return Object.prototype.toString.call(object2) == "[object Arguments]";
      }
      function objEquiv(a, b2, strict, actualVisitedObjects) {
        if (a === null || a === void 0 || b2 === null || b2 === void 0)
          return false;
        if (isPrimitive(a) || isPrimitive(b2))
          return a === b2;
        if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b2))
          return false;
        var aIsArgs = isArguments(a);
        var bIsArgs = isArguments(b2);
        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
          return false;
        if (aIsArgs) {
          a = pSlice.call(a);
          b2 = pSlice.call(b2);
          return _deepEqual(a, b2, strict);
        }
        var ka = objectKeys$1(a);
        var kb = objectKeys$1(b2);
        var key, i2;
        if (ka.length !== kb.length)
          return false;
        ka.sort();
        kb.sort();
        for (i2 = ka.length - 1; i2 >= 0; i2--) {
          if (ka[i2] !== kb[i2])
            return false;
        }
        for (i2 = ka.length - 1; i2 >= 0; i2--) {
          key = ka[i2];
          if (!_deepEqual(a[key], b2[key], strict, actualVisitedObjects))
            return false;
        }
        return true;
      }
      assert$2.notDeepEqual = notDeepEqual;
      function notDeepEqual(actual, expected, message) {
        if (_deepEqual(actual, expected, false)) {
          fail(actual, expected, message, "notDeepEqual", notDeepEqual);
        }
      }
      assert$2.notDeepStrictEqual = notDeepStrictEqual;
      function notDeepStrictEqual(actual, expected, message) {
        if (_deepEqual(actual, expected, true)) {
          fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
        }
      }
      assert$2.strictEqual = strictEqual;
      function strictEqual(actual, expected, message) {
        if (actual !== expected) {
          fail(actual, expected, message, "===", strictEqual);
        }
      }
      assert$2.notStrictEqual = notStrictEqual;
      function notStrictEqual(actual, expected, message) {
        if (actual === expected) {
          fail(actual, expected, message, "!==", notStrictEqual);
        }
      }
      function expectedException(actual, expected) {
        if (!actual || !expected) {
          return false;
        }
        if (Object.prototype.toString.call(expected) == "[object RegExp]") {
          return expected.test(actual);
        }
        try {
          if (actual instanceof expected) {
            return true;
          }
        } catch (e) {
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function _tryBlock(block) {
        var error2;
        try {
          block();
        } catch (e) {
          error2 = e;
        }
        return error2;
      }
      function _throws(shouldThrow, block, expected, message) {
        var actual;
        if (typeof block !== "function") {
          throw new TypeError('"block" argument must be a function');
        }
        if (typeof expected === "string") {
          message = expected;
          expected = null;
        }
        actual = _tryBlock(block);
        message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
        if (shouldThrow && !actual) {
          fail(actual, expected, "Missing expected exception" + message);
        }
        var userProvidedMessage = typeof message === "string";
        var isUnwantedException = !shouldThrow && isError(actual);
        var isUnexpectedException = !shouldThrow && actual && !expected;
        if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
          fail(actual, expected, "Got unwanted exception" + message);
        }
        if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
          throw actual;
        }
      }
      assert$2.throws = throws;
      function throws(block, error2, message) {
        _throws(true, block, error2, message);
      }
      assert$2.doesNotThrow = doesNotThrow;
      function doesNotThrow(block, error2, message) {
        _throws(false, block, error2, message);
      }
      assert$2.ifError = ifError;
      function ifError(err) {
        if (err)
          throw err;
      }
      var _polyfillNode_assert = Object.freeze({
        __proto__: null,
        "default": assert$2,
        AssertionError,
        fail,
        ok,
        assert: ok,
        equal: equal$1,
        notEqual,
        deepEqual,
        deepStrictEqual,
        notDeepEqual,
        notDeepStrictEqual,
        strictEqual,
        notStrictEqual,
        throws,
        doesNotThrow,
        ifError
      });
      var require$$0$4 = getAugmentedNamespace(_polyfillNode_assert);
      var options = {};
      var esprima$1 = {};
      var util$c = {};
      var sourceMap$2 = {};
      var sourceMapGenerator = {};
      var base64Vlq = {};
      var base64$1 = {};
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      base64$1.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      base64$1.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus2 = 43;
        var slash2 = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus2) {
          return 62;
        }
        if (charCode == slash2) {
          return 63;
        }
        return -1;
      };
      var base64 = base64$1;
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      base64Vlq.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result2 = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result2 = result2 + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result2);
        aOutParam.rest = aIndex;
      };
      var util$b = {};
      (function(exports2) {
        function getArg(aArgs, aName, aDefaultValue) {
          if (aName in aArgs) {
            return aArgs[aName];
          } else if (arguments.length === 3) {
            return aDefaultValue;
          } else {
            throw new Error('"' + aName + '" is a required argument.');
          }
        }
        exports2.getArg = getArg;
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse2(aUrl) {
          var match = aUrl.match(urlRegexp);
          if (!match) {
            return null;
          }
          return {
            scheme: match[1],
            auth: match[2],
            host: match[3],
            port: match[4],
            path: match[5]
          };
        }
        exports2.urlParse = urlParse2;
        function urlGenerate(aParsedUrl) {
          var url2 = "";
          if (aParsedUrl.scheme) {
            url2 += aParsedUrl.scheme + ":";
          }
          url2 += "//";
          if (aParsedUrl.auth) {
            url2 += aParsedUrl.auth + "@";
          }
          if (aParsedUrl.host) {
            url2 += aParsedUrl.host;
          }
          if (aParsedUrl.port) {
            url2 += ":" + aParsedUrl.port;
          }
          if (aParsedUrl.path) {
            url2 += aParsedUrl.path;
          }
          return url2;
        }
        exports2.urlGenerate = urlGenerate;
        function normalize2(aPath) {
          var path2 = aPath;
          var url2 = urlParse2(aPath);
          if (url2) {
            if (!url2.path) {
              return aPath;
            }
            path2 = url2.path;
          }
          var isAbsolute2 = exports2.isAbsolute(path2);
          var parts = path2.split(/\/+/);
          for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
            part = parts[i2];
            if (part === ".") {
              parts.splice(i2, 1);
            } else if (part === "..") {
              up++;
            } else if (up > 0) {
              if (part === "") {
                parts.splice(i2 + 1, up);
                up = 0;
              } else {
                parts.splice(i2, 2);
                up--;
              }
            }
          }
          path2 = parts.join("/");
          if (path2 === "") {
            path2 = isAbsolute2 ? "/" : ".";
          }
          if (url2) {
            url2.path = path2;
            return urlGenerate(url2);
          }
          return path2;
        }
        exports2.normalize = normalize2;
        function join2(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          if (aPath === "") {
            aPath = ".";
          }
          var aPathUrl = urlParse2(aPath);
          var aRootUrl = urlParse2(aRoot);
          if (aRootUrl) {
            aRoot = aRootUrl.path || "/";
          }
          if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
              aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
          }
          if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
          }
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
          }
          var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
          if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
          }
          return joined;
        }
        exports2.join = join2;
        exports2.isAbsolute = function(aPath) {
          return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
        };
        function relative2(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          aRoot = aRoot.replace(/\/$/, "");
          var level = 0;
          while (aPath.indexOf(aRoot + "/") !== 0) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0) {
              return aPath;
            }
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
              return aPath;
            }
            ++level;
          }
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports2.relative = relative2;
        var supportsNullProto = function() {
          var obj = /* @__PURE__ */ Object.create(null);
          return !("__proto__" in obj);
        }();
        function identity(s) {
          return s;
        }
        function toSetString(aStr) {
          if (isProtoString(aStr)) {
            return "$" + aStr;
          }
          return aStr;
        }
        exports2.toSetString = supportsNullProto ? identity : toSetString;
        function fromSetString(aStr) {
          if (isProtoString(aStr)) {
            return aStr.slice(1);
          }
          return aStr;
        }
        exports2.fromSetString = supportsNullProto ? identity : fromSetString;
        function isProtoString(s) {
          if (!s) {
            return false;
          }
          var length = s.length;
          if (length < 9) {
            return false;
          }
          if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
            return false;
          }
          for (var i2 = length - 10; i2 >= 0; i2--) {
            if (s.charCodeAt(i2) !== 36) {
              return false;
            }
          }
          return true;
        }
        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
          var cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports2.compareByOriginalPositions = compareByOriginalPositions;
        function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
          }
          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
        function strcmp(aStr1, aStr2) {
          if (aStr1 === aStr2) {
            return 0;
          }
          if (aStr1 === null) {
            return 1;
          }
          if (aStr2 === null) {
            return -1;
          }
          if (aStr1 > aStr2) {
            return 1;
          }
          return -1;
        }
        function compareByGeneratedPositionsInflated(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
        function parseSourceMapInput(str2) {
          return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
        }
        exports2.parseSourceMapInput = parseSourceMapInput;
        function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
          sourceURL = sourceURL || "";
          if (sourceRoot) {
            if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
              sourceRoot += "/";
            }
            sourceURL = sourceRoot + sourceURL;
          }
          if (sourceMapURL) {
            var parsed = urlParse2(sourceMapURL);
            if (!parsed) {
              throw new Error("sourceMapURL could not be parsed");
            }
            if (parsed.path) {
              var index = parsed.path.lastIndexOf("/");
              if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
              }
            }
            sourceURL = join2(urlGenerate(parsed), sourceURL);
          }
          return normalize2(sourceURL);
        }
        exports2.computeSourceURL = computeSourceURL;
      })(util$b);
      var arraySet = {};
      var util$a = util$b;
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet$2() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet$2();
        for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
          set.add(aArray[i2], aAllowDuplicates);
        }
        return set;
      };
      ArraySet$2.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util$a.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet$2.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util$a.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util$a.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet$2.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      arraySet.ArraySet = ArraySet$2;
      var mappingList = {};
      var util$9 = util$b;
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util$9.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList$1() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList$1.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList$1.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util$9.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      mappingList.MappingList = MappingList$1;
      var base64VLQ$1 = base64Vlq;
      var util$8 = util$b;
      var ArraySet$1 = arraySet.ArraySet;
      var MappingList = mappingList.MappingList;
      function SourceMapGenerator$3(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util$8.getArg(aArgs, "file", null);
        this._sourceRoot = util$8.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util$8.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet$1();
        this._names = new ArraySet$1();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator$3.prototype._version = 3;
      SourceMapGenerator$3.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator$3({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping2) {
          var newMapping = {
            generated: {
              line: mapping2.generatedLine,
              column: mapping2.generatedColumn
            }
          };
          if (mapping2.source != null) {
            newMapping.source = mapping2.source;
            if (sourceRoot != null) {
              newMapping.source = util$8.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping2.originalLine,
              column: mapping2.originalColumn
            };
            if (mapping2.name != null) {
              newMapping.name = mapping2.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util$8.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator$3.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util$8.getArg(aArgs, "generated");
        var original = util$8.getArg(aArgs, "original", null);
        var source = util$8.getArg(aArgs, "source", null);
        var name2 = util$8.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name2);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name2 != null) {
          name2 = String(name2);
          if (!this._names.has(name2)) {
            this._names.add(name2);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name: name2
        });
      };
      SourceMapGenerator$3.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util$8.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util$8.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util$8.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator$3.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util$8.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet$1();
        var newNames = new ArraySet$1();
        this._mappings.unsortedForEach(function(mapping2) {
          if (mapping2.source === sourceFile && mapping2.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping2.originalLine,
              column: mapping2.originalColumn
            });
            if (original.source != null) {
              mapping2.source = original.source;
              if (aSourceMapPath != null) {
                mapping2.source = util$8.join(aSourceMapPath, mapping2.source);
              }
              if (sourceRoot != null) {
                mapping2.source = util$8.relative(sourceRoot, mapping2.source);
              }
              mapping2.originalLine = original.line;
              mapping2.originalColumn = original.column;
              if (original.name != null) {
                mapping2.name = original.name;
              }
            }
          }
          var source = mapping2.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name2 = mapping2.name;
          if (name2 != null && !newNames.has(name2)) {
            newNames.add(name2);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util$8.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util$8.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator$3.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator$3.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result2 = "";
        var next;
        var mapping2;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
          mapping2 = mappings[i2];
          next = "";
          if (mapping2.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping2.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i2 > 0) {
              if (!util$8.compareByGeneratedPositionsInflated(mapping2, mappings[i2 - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ$1.encode(mapping2.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping2.generatedColumn;
          if (mapping2.source != null) {
            sourceIdx = this._sources.indexOf(mapping2.source);
            next += base64VLQ$1.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ$1.encode(mapping2.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping2.originalLine - 1;
            next += base64VLQ$1.encode(mapping2.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping2.originalColumn;
            if (mapping2.name != null) {
              nameIdx = this._names.indexOf(mapping2.name);
              next += base64VLQ$1.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result2 += next;
        }
        return result2;
      };
      SourceMapGenerator$3.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util$8.relative(aSourceRoot, source);
          }
          var key = util$8.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator$3.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map2 = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map2.file = this._file;
        }
        if (this._sourceRoot != null) {
          map2.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
        }
        return map2;
      };
      SourceMapGenerator$3.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$3;
      var sourceMapConsumer = {};
      var binarySearch$1 = {};
      (function(exports2) {
        exports2.GREATEST_LOWER_BOUND = 1;
        exports2.LEAST_UPPER_BOUND = 2;
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
          var mid = Math.floor((aHigh - aLow) / 2) + aLow;
          var cmp = aCompare(aNeedle, aHaystack[mid], true);
          if (cmp === 0) {
            return mid;
          } else if (cmp > 0) {
            if (aHigh - mid > 1) {
              return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
            }
            if (aBias == exports2.LEAST_UPPER_BOUND) {
              return aHigh < aHaystack.length ? aHigh : -1;
            } else {
              return mid;
            }
          } else {
            if (mid - aLow > 1) {
              return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
            }
            if (aBias == exports2.LEAST_UPPER_BOUND) {
              return mid;
            } else {
              return aLow < 0 ? -1 : aLow;
            }
          }
        }
        exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
          if (aHaystack.length === 0) {
            return -1;
          }
          var index = recursiveSearch(
            -1,
            aHaystack.length,
            aNeedle,
            aHaystack,
            aCompare,
            aBias || exports2.GREATEST_LOWER_BOUND
          );
          if (index < 0) {
            return -1;
          }
          while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
              break;
            }
            --index;
          }
          return index;
        };
      })(binarySearch$1);
      var quickSort$1 = {};
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i2 = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i2 += 1;
              swap(ary, i2, j);
            }
          }
          swap(ary, i2 + 1, j);
          var q = i2 + 1;
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      quickSort$1.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
      var util$7 = util$b;
      var binarySearch = binarySearch$1;
      var ArraySet = arraySet.ArraySet;
      var base64VLQ = base64Vlq;
      var quickSort = quickSort$1.quickSort;
      function SourceMapConsumer$2(aSourceMap, aSourceMapURL) {
        var sourceMap2 = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap2 = util$7.parseSourceMapInput(aSourceMap);
        }
        return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
      }
      SourceMapConsumer$2.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer$2.prototype._version = 3;
      SourceMapConsumer$2.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer$2.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer$2.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer$2.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer$2.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer$2.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer$2.GENERATED_ORDER = 1;
      SourceMapConsumer$2.ORIGINAL_ORDER = 2;
      SourceMapConsumer$2.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer$2.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer$2.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer$2.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer$2.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer$2.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping2) {
          var source = mapping2.source === null ? null : this._sources.at(mapping2.source);
          source = util$7.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping2.generatedLine,
            generatedColumn: mapping2.generatedColumn,
            originalLine: mapping2.originalLine,
            originalColumn: mapping2.originalColumn,
            name: mapping2.name === null ? null : this._names.at(mapping2.name)
          };
        }, this).forEach(aCallback, context);
      };
      SourceMapConsumer$2.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util$7.getArg(aArgs, "line");
        var needle = {
          source: util$7.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util$7.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util$7.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping2 = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping2.originalLine;
            while (mapping2 && mapping2.originalLine === originalLine) {
              mappings.push({
                line: util$7.getArg(mapping2, "generatedLine", null),
                column: util$7.getArg(mapping2, "generatedColumn", null),
                lastColumn: util$7.getArg(mapping2, "lastGeneratedColumn", null)
              });
              mapping2 = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping2.originalColumn;
            while (mapping2 && mapping2.originalLine === line && mapping2.originalColumn == originalColumn) {
              mappings.push({
                line: util$7.getArg(mapping2, "generatedLine", null),
                column: util$7.getArg(mapping2, "generatedColumn", null),
                lastColumn: util$7.getArg(mapping2, "lastGeneratedColumn", null)
              });
              mapping2 = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      sourceMapConsumer.SourceMapConsumer = SourceMapConsumer$2;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap2 = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap2 = util$7.parseSourceMapInput(aSourceMap);
        }
        var version2 = util$7.getArg(sourceMap2, "version");
        var sources = util$7.getArg(sourceMap2, "sources");
        var names = util$7.getArg(sourceMap2, "names", []);
        var sourceRoot = util$7.getArg(sourceMap2, "sourceRoot", null);
        var sourcesContent = util$7.getArg(sourceMap2, "sourcesContent", null);
        var mappings = util$7.getArg(sourceMap2, "mappings");
        var file = util$7.getArg(sourceMap2, "file", null);
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        if (sourceRoot) {
          sourceRoot = util$7.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util$7.normalize).map(function(source) {
          return sourceRoot && util$7.isAbsolute(sourceRoot) && util$7.isAbsolute(source) ? util$7.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util$7.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$2.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$2;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util$7.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i2;
        for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
          if (this._absoluteSources[i2] == aSource) {
            return i2;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util$7.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
          var srcMapping = generatedMappings[i2];
          var destMapping = new Mapping$1();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util$7.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping$1() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping2, str2, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping2 = new Mapping$1();
            mapping2.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str2 = aStr.slice(index, end);
            segment = cachedSegments[str2];
            if (segment) {
              index += str2.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str2] = segment;
            }
            mapping2.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping2.generatedColumn;
            if (segment.length > 1) {
              mapping2.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping2.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping2.originalLine;
              mapping2.originalLine += 1;
              mapping2.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping2.originalColumn;
              if (segment.length > 4) {
                mapping2.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping2);
            if (typeof mapping2.originalLine === "number") {
              originalMappings.push(mapping2);
            }
          }
        }
        quickSort(generatedMappings, util$7.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util$7.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping2 = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping2.generatedLine === nextMapping.generatedLine) {
              mapping2.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping2.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util$7.getArg(aArgs, "line"),
          generatedColumn: util$7.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util$7.compareByGeneratedPositionsDeflated,
          util$7.getArg(aArgs, "bias", SourceMapConsumer$2.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping2 = this._generatedMappings[index];
          if (mapping2.generatedLine === needle.generatedLine) {
            var source = util$7.getArg(mapping2, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util$7.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name2 = util$7.getArg(mapping2, "name", null);
            if (name2 !== null) {
              name2 = this._names.at(name2);
            }
            return {
              source,
              line: util$7.getArg(mapping2, "originalLine", null),
              column: util$7.getArg(mapping2, "originalColumn", null),
              name: name2
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util$7.relative(this.sourceRoot, relativeSource);
        }
        var url2;
        if (this.sourceRoot != null && (url2 = util$7.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util$7.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util$7.getArg(aArgs, "line"),
          originalColumn: util$7.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util$7.compareByOriginalPositions,
          util$7.getArg(aArgs, "bias", SourceMapConsumer$2.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping2 = this._originalMappings[index];
          if (mapping2.source === needle.source) {
            return {
              line: util$7.getArg(mapping2, "generatedLine", null),
              column: util$7.getArg(mapping2, "generatedColumn", null),
              lastColumn: util$7.getArg(mapping2, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap2 = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap2 = util$7.parseSourceMapInput(aSourceMap);
        }
        var version2 = util$7.getArg(sourceMap2, "version");
        var sections = util$7.getArg(sourceMap2, "sections");
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util$7.getArg(s, "offset");
          var offsetLine = util$7.getArg(offset, "line");
          var offsetColumn = util$7.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer$2(util$7.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$2.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$2;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i2 = 0; i2 < this._sections.length; i2++) {
            for (var j = 0; j < this._sections[i2].consumer.sources.length; j++) {
              sources.push(this._sections[i2].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util$7.getArg(aArgs, "line"),
          generatedColumn: util$7.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          if (section.consumer._findSourceIndex(util$7.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping2 = sectionMappings[j];
            var source = section.consumer._sources.at(mapping2.source);
            source = util$7.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name2 = null;
            if (mapping2.name) {
              name2 = section.consumer._names.at(mapping2.name);
              this._names.add(name2);
              name2 = this._names.indexOf(name2);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping2.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping2.generatedColumn + (section.generatedOffset.generatedLine === mapping2.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping2.originalLine,
              originalColumn: mapping2.originalColumn,
              name: name2
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util$7.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util$7.compareByOriginalPositions);
      };
      sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
      var sourceNode = {};
      var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
      var util$6 = util$b;
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node2 = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping2) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping2.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code2 = nextLine.substr(0, mapping2.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping2.generatedColumn;
              addMappingWithCode(lastMapping, code2);
              lastMapping = mapping2;
              return;
            }
          }
          while (lastGeneratedLine < mapping2.generatedLine) {
            node2.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping2.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node2.add(nextLine.substr(0, mapping2.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn);
            lastGeneratedColumn = mapping2.generatedColumn;
          }
          lastMapping = mapping2;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node2.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util$6.join(aRelativePath, sourceFile);
            }
            node2.setSourceContent(sourceFile, content);
          }
        });
        return node2;
        function addMappingWithCode(mapping2, code2) {
          if (mapping2 === null || mapping2.source === void 0) {
            node2.add(code2);
          } else {
            var source = aRelativePath ? util$6.join(aRelativePath, mapping2.source) : mapping2.source;
            node2.add(new SourceNode(
              mapping2.originalLine,
              mapping2.originalColumn,
              source,
              code2,
              mapping2.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
            this.prepend(aChunk[i2]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
          chunk = this.children[i2];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i2;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i2 = 0; i2 < len - 1; i2++) {
            newChildren.push(this.children[i2]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i2]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util$6.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
          if (this.children[i2][isSourceNode]) {
            this.children[i2].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i2 = 0, len = sources.length; i2 < len; i2++) {
          aFn(util$6.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str2 = "";
        this.walk(function(chunk) {
          str2 += chunk;
        });
        return str2;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map2 = new SourceMapGenerator$2(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map2.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map2.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map2.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map: map2 };
      };
      sourceNode.SourceNode = SourceNode;
      sourceMap$2.SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
      sourceMap$2.SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
      sourceMap$2.SourceNode = sourceNode.SourceNode;
      var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(util$c, "__esModule", { value: true });
      var assert_1$7 = __importDefault$8(require$$0$4);
      var types$a = __importStar$6(main$2);
      var n$3 = types$a.namedTypes;
      var source_map_1$1 = __importDefault$8(sourceMap$2);
      var SourceMapConsumer$1 = source_map_1$1.default.SourceMapConsumer;
      var SourceMapGenerator$1 = source_map_1$1.default.SourceMapGenerator;
      var hasOwn$7 = Object.prototype.hasOwnProperty;
      function getOption(options2, key, defaultValue) {
        if (options2 && hasOwn$7.call(options2, key)) {
          return options2[key];
        }
        return defaultValue;
      }
      util$c.getOption = getOption;
      function getUnionOfKeys() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var result2 = {};
        var argc = args.length;
        for (var i2 = 0; i2 < argc; ++i2) {
          var keys2 = Object.keys(args[i2]);
          var keyCount = keys2.length;
          for (var j = 0; j < keyCount; ++j) {
            result2[keys2[j]] = true;
          }
        }
        return result2;
      }
      util$c.getUnionOfKeys = getUnionOfKeys;
      function comparePos(pos1, pos2) {
        return pos1.line - pos2.line || pos1.column - pos2.column;
      }
      util$c.comparePos = comparePos;
      function copyPos(pos) {
        return {
          line: pos.line,
          column: pos.column
        };
      }
      util$c.copyPos = copyPos;
      function composeSourceMaps(formerMap, latterMap) {
        if (formerMap) {
          if (!latterMap) {
            return formerMap;
          }
        } else {
          return latterMap || null;
        }
        var smcFormer = new SourceMapConsumer$1(formerMap);
        var smcLatter = new SourceMapConsumer$1(latterMap);
        var smg = new SourceMapGenerator$1({
          file: latterMap.file,
          sourceRoot: latterMap.sourceRoot
        });
        var sourcesToContents = {};
        smcLatter.eachMapping(function(mapping2) {
          var origPos = smcFormer.originalPositionFor({
            line: mapping2.originalLine,
            column: mapping2.originalColumn
          });
          var sourceName = origPos.source;
          if (sourceName === null) {
            return;
          }
          smg.addMapping({
            source: sourceName,
            original: copyPos(origPos),
            generated: {
              line: mapping2.generatedLine,
              column: mapping2.generatedColumn
            },
            name: mapping2.name
          });
          var sourceContent = smcFormer.sourceContentFor(sourceName);
          if (sourceContent && !hasOwn$7.call(sourcesToContents, sourceName)) {
            sourcesToContents[sourceName] = sourceContent;
            smg.setSourceContent(sourceName, sourceContent);
          }
        });
        return smg.toJSON();
      }
      util$c.composeSourceMaps = composeSourceMaps;
      function getTrueLoc(node2, lines2) {
        if (!node2.loc) {
          return null;
        }
        var result2 = {
          start: node2.loc.start,
          end: node2.loc.end
        };
        function include(node3) {
          expandLoc(result2, node3.loc);
        }
        if (node2.declaration && node2.declaration.decorators && isExportDeclaration(node2)) {
          node2.declaration.decorators.forEach(include);
        }
        if (comparePos(result2.start, result2.end) < 0) {
          result2.start = copyPos(result2.start);
          lines2.skipSpaces(result2.start, false, true);
          if (comparePos(result2.start, result2.end) < 0) {
            result2.end = copyPos(result2.end);
            lines2.skipSpaces(result2.end, true, true);
          }
        }
        if (node2.comments) {
          node2.comments.forEach(include);
        }
        return result2;
      }
      util$c.getTrueLoc = getTrueLoc;
      function expandLoc(parentLoc, childLoc) {
        if (parentLoc && childLoc) {
          if (comparePos(childLoc.start, parentLoc.start) < 0) {
            parentLoc.start = childLoc.start;
          }
          if (comparePos(parentLoc.end, childLoc.end) < 0) {
            parentLoc.end = childLoc.end;
          }
        }
      }
      function fixFaultyLocations(node2, lines2) {
        var loc = node2.loc;
        if (loc) {
          if (loc.start.line < 1) {
            loc.start.line = 1;
          }
          if (loc.end.line < 1) {
            loc.end.line = 1;
          }
        }
        if (node2.type === "File") {
          loc.start = lines2.firstPos();
          loc.end = lines2.lastPos();
        }
        fixForLoopHead(node2, lines2);
        fixTemplateLiteral(node2, lines2);
        if (loc && node2.decorators) {
          node2.decorators.forEach(function(decorator) {
            expandLoc(loc, decorator.loc);
          });
        } else if (node2.declaration && isExportDeclaration(node2)) {
          node2.declaration.loc = null;
          var decorators = node2.declaration.decorators;
          if (decorators) {
            decorators.forEach(function(decorator) {
              expandLoc(loc, decorator.loc);
            });
          }
        } else if (n$3.MethodDefinition && n$3.MethodDefinition.check(node2) || n$3.Property.check(node2) && (node2.method || node2.shorthand)) {
          node2.value.loc = null;
          if (n$3.FunctionExpression.check(node2.value)) {
            node2.value.id = null;
          }
        } else if (node2.type === "ObjectTypeProperty") {
          var loc = node2.loc;
          var end = loc && loc.end;
          if (end) {
            end = copyPos(end);
            if (lines2.prevPos(end) && lines2.charAt(end) === ",") {
              if (end = lines2.skipSpaces(end, true, true)) {
                loc.end = end;
              }
            }
          }
        }
      }
      util$c.fixFaultyLocations = fixFaultyLocations;
      function fixForLoopHead(node2, lines2) {
        if (node2.type !== "ForStatement") {
          return;
        }
        function fix(child) {
          var loc = child && child.loc;
          var start = loc && loc.start;
          var end = loc && copyPos(loc.end);
          while (start && end && comparePos(start, end) < 0) {
            lines2.prevPos(end);
            if (lines2.charAt(end) === ";") {
              loc.end.line = end.line;
              loc.end.column = end.column;
            } else {
              break;
            }
          }
        }
        fix(node2.init);
        fix(node2.test);
        fix(node2.update);
      }
      function fixTemplateLiteral(node2, lines2) {
        if (node2.type !== "TemplateLiteral") {
          return;
        }
        if (node2.quasis.length === 0) {
          return;
        }
        if (node2.loc) {
          var afterLeftBackTickPos = copyPos(node2.loc.start);
          assert_1$7.default.strictEqual(lines2.charAt(afterLeftBackTickPos), "`");
          assert_1$7.default.ok(lines2.nextPos(afterLeftBackTickPos));
          var firstQuasi = node2.quasis[0];
          if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
            firstQuasi.loc.start = afterLeftBackTickPos;
          }
          var rightBackTickPos = copyPos(node2.loc.end);
          assert_1$7.default.ok(lines2.prevPos(rightBackTickPos));
          assert_1$7.default.strictEqual(lines2.charAt(rightBackTickPos), "`");
          var lastQuasi = node2.quasis[node2.quasis.length - 1];
          if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
            lastQuasi.loc.end = rightBackTickPos;
          }
        }
        node2.expressions.forEach(function(expr, i2) {
          var dollarCurlyPos = lines2.skipSpaces(expr.loc.start, true, false);
          if (lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "{" && lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "$") {
            var quasiBefore = node2.quasis[i2];
            if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
              quasiBefore.loc.end = dollarCurlyPos;
            }
          }
          var rightCurlyPos = lines2.skipSpaces(expr.loc.end, false, false);
          if (lines2.charAt(rightCurlyPos) === "}") {
            assert_1$7.default.ok(lines2.nextPos(rightCurlyPos));
            var quasiAfter = node2.quasis[i2 + 1];
            if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
              quasiAfter.loc.start = rightCurlyPos;
            }
          }
        });
      }
      function isExportDeclaration(node2) {
        if (node2)
          switch (node2.type) {
            case "ExportDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportDefaultSpecifier":
            case "DeclareExportDeclaration":
            case "ExportNamedDeclaration":
            case "ExportAllDeclaration":
              return true;
          }
        return false;
      }
      util$c.isExportDeclaration = isExportDeclaration;
      function getParentExportDeclaration(path2) {
        var parentNode = path2.getParentNode();
        if (path2.getName() === "declaration" && isExportDeclaration(parentNode)) {
          return parentNode;
        }
        return null;
      }
      util$c.getParentExportDeclaration = getParentExportDeclaration;
      function isTrailingCommaEnabled(options2, context) {
        var trailingComma = options2.trailingComma;
        if (typeof trailingComma === "object") {
          return !!trailingComma[context];
        }
        return !!trailingComma;
      }
      util$c.isTrailingCommaEnabled = isTrailingCommaEnabled;
      var esprima = { exports: {} };
      (function(module2, exports2) {
        (function webpackUniversalModuleDefinition(root2, factory2) {
          module2.exports = factory2();
        })(commonjsGlobal, function() {
          return (
            /******/
            function(modules) {
              var installedModules = {};
              function __webpack_require__(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module3 = installedModules[moduleId] = {
                  /******/
                  exports: {},
                  /******/
                  id: moduleId,
                  /******/
                  loaded: false
                  /******/
                };
                modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
                module3.loaded = true;
                return module3.exports;
              }
              __webpack_require__.m = modules;
              __webpack_require__.c = installedModules;
              __webpack_require__.p = "";
              return __webpack_require__(0);
            }([
              /* 0 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var comment_handler_1 = __webpack_require__(1);
                var jsx_parser_1 = __webpack_require__(3);
                var parser_12 = __webpack_require__(8);
                var tokenizer_1 = __webpack_require__(15);
                function parse2(code2, options2, delegate) {
                  var commentHandler = null;
                  var proxyDelegate = function(node2, metadata) {
                    if (delegate) {
                      delegate(node2, metadata);
                    }
                    if (commentHandler) {
                      commentHandler.visit(node2, metadata);
                    }
                  };
                  var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
                  var collectComment = false;
                  if (options2) {
                    collectComment = typeof options2.comment === "boolean" && options2.comment;
                    var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
                    if (collectComment || attachComment) {
                      commentHandler = new comment_handler_1.CommentHandler();
                      commentHandler.attach = attachComment;
                      options2.comment = true;
                      parserDelegate = proxyDelegate;
                    }
                  }
                  var isModule = false;
                  if (options2 && typeof options2.sourceType === "string") {
                    isModule = options2.sourceType === "module";
                  }
                  var parser2;
                  if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
                    parser2 = new jsx_parser_1.JSXParser(code2, options2, parserDelegate);
                  } else {
                    parser2 = new parser_12.Parser(code2, options2, parserDelegate);
                  }
                  var program = isModule ? parser2.parseModule() : parser2.parseScript();
                  var ast = program;
                  if (collectComment && commentHandler) {
                    ast.comments = commentHandler.comments;
                  }
                  if (parser2.config.tokens) {
                    ast.tokens = parser2.tokens;
                  }
                  if (parser2.config.tolerant) {
                    ast.errors = parser2.errorHandler.errors;
                  }
                  return ast;
                }
                exports3.parse = parse2;
                function parseModule(code2, options2, delegate) {
                  var parsingOptions = options2 || {};
                  parsingOptions.sourceType = "module";
                  return parse2(code2, parsingOptions, delegate);
                }
                exports3.parseModule = parseModule;
                function parseScript(code2, options2, delegate) {
                  var parsingOptions = options2 || {};
                  parsingOptions.sourceType = "script";
                  return parse2(code2, parsingOptions, delegate);
                }
                exports3.parseScript = parseScript;
                function tokenize2(code2, options2, delegate) {
                  var tokenizer2 = new tokenizer_1.Tokenizer(code2, options2);
                  var tokens;
                  tokens = [];
                  try {
                    while (true) {
                      var token = tokenizer2.getNextToken();
                      if (!token) {
                        break;
                      }
                      if (delegate) {
                        token = delegate(token);
                      }
                      tokens.push(token);
                    }
                  } catch (e) {
                    tokenizer2.errorHandler.tolerate(e);
                  }
                  if (tokenizer2.errorHandler.tolerant) {
                    tokens.errors = tokenizer2.errors();
                  }
                  return tokens;
                }
                exports3.tokenize = tokenize2;
                var syntax_1 = __webpack_require__(2);
                exports3.Syntax = syntax_1.Syntax;
                exports3.version = "4.0.1";
              },
              /* 1 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var syntax_1 = __webpack_require__(2);
                var CommentHandler = function() {
                  function CommentHandler2() {
                    this.attach = false;
                    this.comments = [];
                    this.stack = [];
                    this.leading = [];
                    this.trailing = [];
                  }
                  CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
                    if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                      var innerComments = [];
                      for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                        var entry = this.leading[i2];
                        if (metadata.end.offset >= entry.start) {
                          innerComments.unshift(entry.comment);
                          this.leading.splice(i2, 1);
                          this.trailing.splice(i2, 1);
                        }
                      }
                      if (innerComments.length) {
                        node2.innerComments = innerComments;
                      }
                    }
                  };
                  CommentHandler2.prototype.findTrailingComments = function(metadata) {
                    var trailingComments = [];
                    if (this.trailing.length > 0) {
                      for (var i2 = this.trailing.length - 1; i2 >= 0; --i2) {
                        var entry_1 = this.trailing[i2];
                        if (entry_1.start >= metadata.end.offset) {
                          trailingComments.unshift(entry_1.comment);
                        }
                      }
                      this.trailing.length = 0;
                      return trailingComments;
                    }
                    var entry = this.stack[this.stack.length - 1];
                    if (entry && entry.node.trailingComments) {
                      var firstComment = entry.node.trailingComments[0];
                      if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                        trailingComments = entry.node.trailingComments;
                        delete entry.node.trailingComments;
                      }
                    }
                    return trailingComments;
                  };
                  CommentHandler2.prototype.findLeadingComments = function(metadata) {
                    var leadingComments = [];
                    var target;
                    while (this.stack.length > 0) {
                      var entry = this.stack[this.stack.length - 1];
                      if (entry && entry.start >= metadata.start.offset) {
                        target = entry.node;
                        this.stack.pop();
                      } else {
                        break;
                      }
                    }
                    if (target) {
                      var count = target.leadingComments ? target.leadingComments.length : 0;
                      for (var i2 = count - 1; i2 >= 0; --i2) {
                        var comment2 = target.leadingComments[i2];
                        if (comment2.range[1] <= metadata.start.offset) {
                          leadingComments.unshift(comment2);
                          target.leadingComments.splice(i2, 1);
                        }
                      }
                      if (target.leadingComments && target.leadingComments.length === 0) {
                        delete target.leadingComments;
                      }
                      return leadingComments;
                    }
                    for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                      var entry = this.leading[i2];
                      if (entry.start <= metadata.start.offset) {
                        leadingComments.unshift(entry.comment);
                        this.leading.splice(i2, 1);
                      }
                    }
                    return leadingComments;
                  };
                  CommentHandler2.prototype.visitNode = function(node2, metadata) {
                    if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
                      return;
                    }
                    this.insertInnerComments(node2, metadata);
                    var trailingComments = this.findTrailingComments(metadata);
                    var leadingComments = this.findLeadingComments(metadata);
                    if (leadingComments.length > 0) {
                      node2.leadingComments = leadingComments;
                    }
                    if (trailingComments.length > 0) {
                      node2.trailingComments = trailingComments;
                    }
                    this.stack.push({
                      node: node2,
                      start: metadata.start.offset
                    });
                  };
                  CommentHandler2.prototype.visitComment = function(node2, metadata) {
                    var type2 = node2.type[0] === "L" ? "Line" : "Block";
                    var comment2 = {
                      type: type2,
                      value: node2.value
                    };
                    if (node2.range) {
                      comment2.range = node2.range;
                    }
                    if (node2.loc) {
                      comment2.loc = node2.loc;
                    }
                    this.comments.push(comment2);
                    if (this.attach) {
                      var entry = {
                        comment: {
                          type: type2,
                          value: node2.value,
                          range: [metadata.start.offset, metadata.end.offset]
                        },
                        start: metadata.start.offset
                      };
                      if (node2.loc) {
                        entry.comment.loc = node2.loc;
                      }
                      node2.type = type2;
                      this.leading.push(entry);
                      this.trailing.push(entry);
                    }
                  };
                  CommentHandler2.prototype.visit = function(node2, metadata) {
                    if (node2.type === "LineComment") {
                      this.visitComment(node2, metadata);
                    } else if (node2.type === "BlockComment") {
                      this.visitComment(node2, metadata);
                    } else if (this.attach) {
                      this.visitNode(node2, metadata);
                    }
                  };
                  return CommentHandler2;
                }();
                exports3.CommentHandler = CommentHandler;
              },
              /* 2 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                exports3.Syntax = {
                  AssignmentExpression: "AssignmentExpression",
                  AssignmentPattern: "AssignmentPattern",
                  ArrayExpression: "ArrayExpression",
                  ArrayPattern: "ArrayPattern",
                  ArrowFunctionExpression: "ArrowFunctionExpression",
                  AwaitExpression: "AwaitExpression",
                  BlockStatement: "BlockStatement",
                  BinaryExpression: "BinaryExpression",
                  BreakStatement: "BreakStatement",
                  CallExpression: "CallExpression",
                  CatchClause: "CatchClause",
                  ClassBody: "ClassBody",
                  ClassDeclaration: "ClassDeclaration",
                  ClassExpression: "ClassExpression",
                  ConditionalExpression: "ConditionalExpression",
                  ContinueStatement: "ContinueStatement",
                  DoWhileStatement: "DoWhileStatement",
                  DebuggerStatement: "DebuggerStatement",
                  EmptyStatement: "EmptyStatement",
                  ExportAllDeclaration: "ExportAllDeclaration",
                  ExportDefaultDeclaration: "ExportDefaultDeclaration",
                  ExportNamedDeclaration: "ExportNamedDeclaration",
                  ExportSpecifier: "ExportSpecifier",
                  ExpressionStatement: "ExpressionStatement",
                  ForStatement: "ForStatement",
                  ForOfStatement: "ForOfStatement",
                  ForInStatement: "ForInStatement",
                  FunctionDeclaration: "FunctionDeclaration",
                  FunctionExpression: "FunctionExpression",
                  Identifier: "Identifier",
                  IfStatement: "IfStatement",
                  ImportDeclaration: "ImportDeclaration",
                  ImportDefaultSpecifier: "ImportDefaultSpecifier",
                  ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                  ImportSpecifier: "ImportSpecifier",
                  Literal: "Literal",
                  LabeledStatement: "LabeledStatement",
                  LogicalExpression: "LogicalExpression",
                  MemberExpression: "MemberExpression",
                  MetaProperty: "MetaProperty",
                  MethodDefinition: "MethodDefinition",
                  NewExpression: "NewExpression",
                  ObjectExpression: "ObjectExpression",
                  ObjectPattern: "ObjectPattern",
                  Program: "Program",
                  Property: "Property",
                  RestElement: "RestElement",
                  ReturnStatement: "ReturnStatement",
                  SequenceExpression: "SequenceExpression",
                  SpreadElement: "SpreadElement",
                  Super: "Super",
                  SwitchCase: "SwitchCase",
                  SwitchStatement: "SwitchStatement",
                  TaggedTemplateExpression: "TaggedTemplateExpression",
                  TemplateElement: "TemplateElement",
                  TemplateLiteral: "TemplateLiteral",
                  ThisExpression: "ThisExpression",
                  ThrowStatement: "ThrowStatement",
                  TryStatement: "TryStatement",
                  UnaryExpression: "UnaryExpression",
                  UpdateExpression: "UpdateExpression",
                  VariableDeclaration: "VariableDeclaration",
                  VariableDeclarator: "VariableDeclarator",
                  WhileStatement: "WhileStatement",
                  WithStatement: "WithStatement",
                  YieldExpression: "YieldExpression"
                };
              },
              /* 3 */
              /***/
              function(module3, exports3, __webpack_require__) {
                var __extends2 = this && this.__extends || function() {
                  var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b2) {
                    d.__proto__ = b2;
                  } || function(d, b2) {
                    for (var p in b2)
                      if (b2.hasOwnProperty(p))
                        d[p] = b2[p];
                  };
                  return function(d, b2) {
                    extendStatics2(d, b2);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                  };
                }();
                Object.defineProperty(exports3, "__esModule", { value: true });
                var character_1 = __webpack_require__(4);
                var JSXNode = __webpack_require__(5);
                var jsx_syntax_1 = __webpack_require__(6);
                var Node2 = __webpack_require__(7);
                var parser_12 = __webpack_require__(8);
                var token_1 = __webpack_require__(13);
                var xhtml_entities_1 = __webpack_require__(14);
                token_1.TokenName[
                  100
                  /* Identifier */
                ] = "JSXIdentifier";
                token_1.TokenName[
                  101
                  /* Text */
                ] = "JSXText";
                function getQualifiedElementName(elementName) {
                  var qualifiedName;
                  switch (elementName.type) {
                    case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                      var id2 = elementName;
                      qualifiedName = id2.name;
                      break;
                    case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                      var ns = elementName;
                      qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                      break;
                    case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                      var expr = elementName;
                      qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                      break;
                  }
                  return qualifiedName;
                }
                var JSXParser = function(_super) {
                  __extends2(JSXParser2, _super);
                  function JSXParser2(code2, options2, delegate) {
                    return _super.call(this, code2, options2, delegate) || this;
                  }
                  JSXParser2.prototype.parsePrimaryExpression = function() {
                    return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
                  };
                  JSXParser2.prototype.startJSX = function() {
                    this.scanner.index = this.startMarker.index;
                    this.scanner.lineNumber = this.startMarker.line;
                    this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                  };
                  JSXParser2.prototype.finishJSX = function() {
                    this.nextToken();
                  };
                  JSXParser2.prototype.reenterJSX = function() {
                    this.startJSX();
                    this.expectJSX("}");
                    if (this.config.tokens) {
                      this.tokens.pop();
                    }
                  };
                  JSXParser2.prototype.createJSXNode = function() {
                    this.collectComments();
                    return {
                      index: this.scanner.index,
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                  };
                  JSXParser2.prototype.createJSXChildNode = function() {
                    return {
                      index: this.scanner.index,
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                  };
                  JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                    var result2 = "&";
                    var valid = true;
                    var terminated = false;
                    var numeric = false;
                    var hex2 = false;
                    while (!this.scanner.eof() && valid && !terminated) {
                      var ch = this.scanner.source[this.scanner.index];
                      if (ch === quote) {
                        break;
                      }
                      terminated = ch === ";";
                      result2 += ch;
                      ++this.scanner.index;
                      if (!terminated) {
                        switch (result2.length) {
                          case 2:
                            numeric = ch === "#";
                            break;
                          case 3:
                            if (numeric) {
                              hex2 = ch === "x";
                              valid = hex2 || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                              numeric = numeric && !hex2;
                            }
                            break;
                          default:
                            valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                            valid = valid && !(hex2 && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                            break;
                        }
                      }
                    }
                    if (valid && terminated && result2.length > 2) {
                      var str2 = result2.substr(1, result2.length - 2);
                      if (numeric && str2.length > 1) {
                        result2 = String.fromCharCode(parseInt(str2.substr(1), 10));
                      } else if (hex2 && str2.length > 2) {
                        result2 = String.fromCharCode(parseInt("0" + str2.substr(1), 16));
                      } else if (!numeric && !hex2 && xhtml_entities_1.XHTMLEntities[str2]) {
                        result2 = xhtml_entities_1.XHTMLEntities[str2];
                      }
                    }
                    return result2;
                  };
                  JSXParser2.prototype.lexJSX = function() {
                    var cp = this.scanner.source.charCodeAt(this.scanner.index);
                    if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                      var value = this.scanner.source[this.scanner.index++];
                      return {
                        type: 7,
                        value,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start: this.scanner.index - 1,
                        end: this.scanner.index
                      };
                    }
                    if (cp === 34 || cp === 39) {
                      var start = this.scanner.index;
                      var quote = this.scanner.source[this.scanner.index++];
                      var str2 = "";
                      while (!this.scanner.eof()) {
                        var ch = this.scanner.source[this.scanner.index++];
                        if (ch === quote) {
                          break;
                        } else if (ch === "&") {
                          str2 += this.scanXHTMLEntity(quote);
                        } else {
                          str2 += ch;
                        }
                      }
                      return {
                        type: 8,
                        value: str2,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start,
                        end: this.scanner.index
                      };
                    }
                    if (cp === 46) {
                      var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                      var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                      var value = n1 === 46 && n2 === 46 ? "..." : ".";
                      var start = this.scanner.index;
                      this.scanner.index += value.length;
                      return {
                        type: 7,
                        value,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start,
                        end: this.scanner.index
                      };
                    }
                    if (cp === 96) {
                      return {
                        type: 10,
                        value: "",
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start: this.scanner.index,
                        end: this.scanner.index
                      };
                    }
                    if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                      var start = this.scanner.index;
                      ++this.scanner.index;
                      while (!this.scanner.eof()) {
                        var ch = this.scanner.source.charCodeAt(this.scanner.index);
                        if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                          ++this.scanner.index;
                        } else if (ch === 45) {
                          ++this.scanner.index;
                        } else {
                          break;
                        }
                      }
                      var id2 = this.scanner.source.slice(start, this.scanner.index);
                      return {
                        type: 100,
                        value: id2,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start,
                        end: this.scanner.index
                      };
                    }
                    return this.scanner.lex();
                  };
                  JSXParser2.prototype.nextJSXToken = function() {
                    this.collectComments();
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = this.lexJSX();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    if (this.config.tokens) {
                      this.tokens.push(this.convertToken(token));
                    }
                    return token;
                  };
                  JSXParser2.prototype.nextJSXText = function() {
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var start = this.scanner.index;
                    var text = "";
                    while (!this.scanner.eof()) {
                      var ch = this.scanner.source[this.scanner.index];
                      if (ch === "{" || ch === "<") {
                        break;
                      }
                      ++this.scanner.index;
                      text += ch;
                      if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        ++this.scanner.lineNumber;
                        if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                          ++this.scanner.index;
                        }
                        this.scanner.lineStart = this.scanner.index;
                      }
                    }
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = {
                      type: 101,
                      value: text,
                      lineNumber: this.scanner.lineNumber,
                      lineStart: this.scanner.lineStart,
                      start,
                      end: this.scanner.index
                    };
                    if (text.length > 0 && this.config.tokens) {
                      this.tokens.push(this.convertToken(token));
                    }
                    return token;
                  };
                  JSXParser2.prototype.peekJSXToken = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.lexJSX();
                    this.scanner.restoreState(state);
                    return next;
                  };
                  JSXParser2.prototype.expectJSX = function(value) {
                    var token = this.nextJSXToken();
                    if (token.type !== 7 || token.value !== value) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  JSXParser2.prototype.matchJSX = function(value) {
                    var next = this.peekJSXToken();
                    return next.type === 7 && next.value === value;
                  };
                  JSXParser2.prototype.parseJSXIdentifier = function() {
                    var node2 = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 100) {
                      this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
                  };
                  JSXParser2.prototype.parseJSXElementName = function() {
                    var node2 = this.createJSXNode();
                    var elementName = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                      var namespace2 = elementName;
                      this.expectJSX(":");
                      var name_1 = this.parseJSXIdentifier();
                      elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace2, name_1));
                    } else if (this.matchJSX(".")) {
                      while (this.matchJSX(".")) {
                        var object2 = elementName;
                        this.expectJSX(".");
                        var property = this.parseJSXIdentifier();
                        elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object2, property));
                      }
                    }
                    return elementName;
                  };
                  JSXParser2.prototype.parseJSXAttributeName = function() {
                    var node2 = this.createJSXNode();
                    var attributeName;
                    var identifier = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                      var namespace2 = identifier;
                      this.expectJSX(":");
                      var name_2 = this.parseJSXIdentifier();
                      attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace2, name_2));
                    } else {
                      attributeName = identifier;
                    }
                    return attributeName;
                  };
                  JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                    var node2 = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 8) {
                      this.throwUnexpectedToken(token);
                    }
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node2, new Node2.Literal(token.value, raw));
                  };
                  JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    this.finishJSX();
                    if (this.match("}")) {
                      this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                    }
                    var expression = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                  };
                  JSXParser2.prototype.parseJSXAttributeValue = function() {
                    return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                  };
                  JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                    var node2 = this.createJSXNode();
                    var name2 = this.parseJSXAttributeName();
                    var value = null;
                    if (this.matchJSX("=")) {
                      this.expectJSX("=");
                      value = this.parseJSXAttributeValue();
                    }
                    return this.finalize(node2, new JSXNode.JSXAttribute(name2, value));
                  };
                  JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    this.expectJSX("...");
                    this.finishJSX();
                    var argument = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
                  };
                  JSXParser2.prototype.parseJSXAttributes = function() {
                    var attributes2 = [];
                    while (!this.matchJSX("/") && !this.matchJSX(">")) {
                      var attribute2 = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                      attributes2.push(attribute2);
                    }
                    return attributes2;
                  };
                  JSXParser2.prototype.parseJSXOpeningElement = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("<");
                    var name2 = this.parseJSXElementName();
                    var attributes2 = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                      this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes2));
                  };
                  JSXParser2.prototype.parseJSXBoundaryElement = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("<");
                    if (this.matchJSX("/")) {
                      this.expectJSX("/");
                      var name_3 = this.parseJSXElementName();
                      this.expectJSX(">");
                      return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
                    }
                    var name2 = this.parseJSXElementName();
                    var attributes2 = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                      this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes2));
                  };
                  JSXParser2.prototype.parseJSXEmptyExpression = function() {
                    var node2 = this.createJSXChildNode();
                    this.collectComments();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    return this.finalize(node2, new JSXNode.JSXEmptyExpression());
                  };
                  JSXParser2.prototype.parseJSXExpressionContainer = function() {
                    var node2 = this.createJSXNode();
                    this.expectJSX("{");
                    var expression;
                    if (this.matchJSX("}")) {
                      expression = this.parseJSXEmptyExpression();
                      this.expectJSX("}");
                    } else {
                      this.finishJSX();
                      expression = this.parseAssignmentExpression();
                      this.reenterJSX();
                    }
                    return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
                  };
                  JSXParser2.prototype.parseJSXChildren = function() {
                    var children = [];
                    while (!this.scanner.eof()) {
                      var node2 = this.createJSXChildNode();
                      var token = this.nextJSXText();
                      if (token.start < token.end) {
                        var raw = this.getTokenRaw(token);
                        var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                        children.push(child);
                      }
                      if (this.scanner.source[this.scanner.index] === "{") {
                        var container2 = this.parseJSXExpressionContainer();
                        children.push(container2);
                      } else {
                        break;
                      }
                    }
                    return children;
                  };
                  JSXParser2.prototype.parseComplexJSXElement = function(el) {
                    var stack = [];
                    while (!this.scanner.eof()) {
                      el.children = el.children.concat(this.parseJSXChildren());
                      var node2 = this.createJSXChildNode();
                      var element = this.parseJSXBoundaryElement();
                      if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                        var opening = element;
                        if (opening.selfClosing) {
                          var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                          el.children.push(child);
                        } else {
                          stack.push(el);
                          el = { node: node2, opening, closing: null, children: [] };
                        }
                      }
                      if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                        el.closing = element;
                        var open_1 = getQualifiedElementName(el.opening.name);
                        var close_1 = getQualifiedElementName(el.closing.name);
                        if (open_1 !== close_1) {
                          this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                        }
                        if (stack.length > 0) {
                          var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                          el = stack[stack.length - 1];
                          el.children.push(child);
                          stack.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    return el;
                  };
                  JSXParser2.prototype.parseJSXElement = function() {
                    var node2 = this.createJSXNode();
                    var opening = this.parseJSXOpeningElement();
                    var children = [];
                    var closing = null;
                    if (!opening.selfClosing) {
                      var el = this.parseComplexJSXElement({ node: node2, opening, closing, children });
                      children = el.children;
                      closing = el.closing;
                    }
                    return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
                  };
                  JSXParser2.prototype.parseJSXRoot = function() {
                    if (this.config.tokens) {
                      this.tokens.pop();
                    }
                    this.startJSX();
                    var element = this.parseJSXElement();
                    this.finishJSX();
                    return element;
                  };
                  JSXParser2.prototype.isStartOfExpression = function() {
                    return _super.prototype.isStartOfExpression.call(this) || this.match("<");
                  };
                  return JSXParser2;
                }(parser_12.Parser);
                exports3.JSXParser = JSXParser;
              },
              /* 4 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var Regex = {
                  // Unicode v8.0.0 NonAsciiIdentifierStart:
                  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                  // Unicode v8.0.0 NonAsciiIdentifierPart:
                  NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
                };
                exports3.Character = {
                  /* tslint:disable:no-bitwise */
                  fromCodePoint: function(cp) {
                    return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
                  },
                  // https://tc39.github.io/ecma262/#sec-white-space
                  isWhiteSpace: function(cp) {
                    return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
                  },
                  // https://tc39.github.io/ecma262/#sec-line-terminators
                  isLineTerminator: function(cp) {
                    return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
                  },
                  // https://tc39.github.io/ecma262/#sec-names-and-keywords
                  isIdentifierStart: function(cp) {
                    return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
                  },
                  isIdentifierPart: function(cp) {
                    return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
                  },
                  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
                  isDecimalDigit: function(cp) {
                    return cp >= 48 && cp <= 57;
                  },
                  isHexDigit: function(cp) {
                    return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
                  },
                  isOctalDigit: function(cp) {
                    return cp >= 48 && cp <= 55;
                  }
                };
              },
              /* 5 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var jsx_syntax_1 = __webpack_require__(6);
                var JSXClosingElement = /* @__PURE__ */ function() {
                  function JSXClosingElement2(name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                    this.name = name2;
                  }
                  return JSXClosingElement2;
                }();
                exports3.JSXClosingElement = JSXClosingElement;
                var JSXElement = /* @__PURE__ */ function() {
                  function JSXElement2(openingElement, children, closingElement) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                    this.openingElement = openingElement;
                    this.children = children;
                    this.closingElement = closingElement;
                  }
                  return JSXElement2;
                }();
                exports3.JSXElement = JSXElement;
                var JSXEmptyExpression = /* @__PURE__ */ function() {
                  function JSXEmptyExpression2() {
                    this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
                  }
                  return JSXEmptyExpression2;
                }();
                exports3.JSXEmptyExpression = JSXEmptyExpression;
                var JSXExpressionContainer = /* @__PURE__ */ function() {
                  function JSXExpressionContainer2(expression) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                    this.expression = expression;
                  }
                  return JSXExpressionContainer2;
                }();
                exports3.JSXExpressionContainer = JSXExpressionContainer;
                var JSXIdentifier = /* @__PURE__ */ function() {
                  function JSXIdentifier2(name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                    this.name = name2;
                  }
                  return JSXIdentifier2;
                }();
                exports3.JSXIdentifier = JSXIdentifier;
                var JSXMemberExpression = /* @__PURE__ */ function() {
                  function JSXMemberExpression2(object2, property) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                    this.object = object2;
                    this.property = property;
                  }
                  return JSXMemberExpression2;
                }();
                exports3.JSXMemberExpression = JSXMemberExpression;
                var JSXAttribute = /* @__PURE__ */ function() {
                  function JSXAttribute2(name2, value) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                    this.name = name2;
                    this.value = value;
                  }
                  return JSXAttribute2;
                }();
                exports3.JSXAttribute = JSXAttribute;
                var JSXNamespacedName = /* @__PURE__ */ function() {
                  function JSXNamespacedName2(namespace2, name2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                    this.namespace = namespace2;
                    this.name = name2;
                  }
                  return JSXNamespacedName2;
                }();
                exports3.JSXNamespacedName = JSXNamespacedName;
                var JSXOpeningElement = /* @__PURE__ */ function() {
                  function JSXOpeningElement2(name2, selfClosing, attributes2) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                    this.name = name2;
                    this.selfClosing = selfClosing;
                    this.attributes = attributes2;
                  }
                  return JSXOpeningElement2;
                }();
                exports3.JSXOpeningElement = JSXOpeningElement;
                var JSXSpreadAttribute = /* @__PURE__ */ function() {
                  function JSXSpreadAttribute2(argument) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                    this.argument = argument;
                  }
                  return JSXSpreadAttribute2;
                }();
                exports3.JSXSpreadAttribute = JSXSpreadAttribute;
                var JSXText = /* @__PURE__ */ function() {
                  function JSXText2(value, raw) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXText;
                    this.value = value;
                    this.raw = raw;
                  }
                  return JSXText2;
                }();
                exports3.JSXText = JSXText;
              },
              /* 6 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                exports3.JSXSyntax = {
                  JSXAttribute: "JSXAttribute",
                  JSXClosingElement: "JSXClosingElement",
                  JSXElement: "JSXElement",
                  JSXEmptyExpression: "JSXEmptyExpression",
                  JSXExpressionContainer: "JSXExpressionContainer",
                  JSXIdentifier: "JSXIdentifier",
                  JSXMemberExpression: "JSXMemberExpression",
                  JSXNamespacedName: "JSXNamespacedName",
                  JSXOpeningElement: "JSXOpeningElement",
                  JSXSpreadAttribute: "JSXSpreadAttribute",
                  JSXText: "JSXText"
                };
              },
              /* 7 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var syntax_1 = __webpack_require__(2);
                var ArrayExpression = /* @__PURE__ */ function() {
                  function ArrayExpression2(elements) {
                    this.type = syntax_1.Syntax.ArrayExpression;
                    this.elements = elements;
                  }
                  return ArrayExpression2;
                }();
                exports3.ArrayExpression = ArrayExpression;
                var ArrayPattern = /* @__PURE__ */ function() {
                  function ArrayPattern2(elements) {
                    this.type = syntax_1.Syntax.ArrayPattern;
                    this.elements = elements;
                  }
                  return ArrayPattern2;
                }();
                exports3.ArrayPattern = ArrayPattern;
                var ArrowFunctionExpression = /* @__PURE__ */ function() {
                  function ArrowFunctionExpression2(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = false;
                  }
                  return ArrowFunctionExpression2;
                }();
                exports3.ArrowFunctionExpression = ArrowFunctionExpression;
                var AssignmentExpression = /* @__PURE__ */ function() {
                  function AssignmentExpression2(operator, left, right) {
                    this.type = syntax_1.Syntax.AssignmentExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                  }
                  return AssignmentExpression2;
                }();
                exports3.AssignmentExpression = AssignmentExpression;
                var AssignmentPattern = /* @__PURE__ */ function() {
                  function AssignmentPattern2(left, right) {
                    this.type = syntax_1.Syntax.AssignmentPattern;
                    this.left = left;
                    this.right = right;
                  }
                  return AssignmentPattern2;
                }();
                exports3.AssignmentPattern = AssignmentPattern;
                var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
                  function AsyncArrowFunctionExpression2(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = true;
                  }
                  return AsyncArrowFunctionExpression2;
                }();
                exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
                var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
                  function AsyncFunctionDeclaration2(id2, params, body) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id2;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                  }
                  return AsyncFunctionDeclaration2;
                }();
                exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
                var AsyncFunctionExpression = /* @__PURE__ */ function() {
                  function AsyncFunctionExpression2(id2, params, body) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id2;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                  }
                  return AsyncFunctionExpression2;
                }();
                exports3.AsyncFunctionExpression = AsyncFunctionExpression;
                var AwaitExpression = /* @__PURE__ */ function() {
                  function AwaitExpression2(argument) {
                    this.type = syntax_1.Syntax.AwaitExpression;
                    this.argument = argument;
                  }
                  return AwaitExpression2;
                }();
                exports3.AwaitExpression = AwaitExpression;
                var BinaryExpression = /* @__PURE__ */ function() {
                  function BinaryExpression2(operator, left, right) {
                    var logical = operator === "||" || operator === "&&";
                    this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                  }
                  return BinaryExpression2;
                }();
                exports3.BinaryExpression = BinaryExpression;
                var BlockStatement = /* @__PURE__ */ function() {
                  function BlockStatement2(body) {
                    this.type = syntax_1.Syntax.BlockStatement;
                    this.body = body;
                  }
                  return BlockStatement2;
                }();
                exports3.BlockStatement = BlockStatement;
                var BreakStatement = /* @__PURE__ */ function() {
                  function BreakStatement2(label) {
                    this.type = syntax_1.Syntax.BreakStatement;
                    this.label = label;
                  }
                  return BreakStatement2;
                }();
                exports3.BreakStatement = BreakStatement;
                var CallExpression = /* @__PURE__ */ function() {
                  function CallExpression2(callee, args) {
                    this.type = syntax_1.Syntax.CallExpression;
                    this.callee = callee;
                    this.arguments = args;
                  }
                  return CallExpression2;
                }();
                exports3.CallExpression = CallExpression;
                var CatchClause = /* @__PURE__ */ function() {
                  function CatchClause2(param, body) {
                    this.type = syntax_1.Syntax.CatchClause;
                    this.param = param;
                    this.body = body;
                  }
                  return CatchClause2;
                }();
                exports3.CatchClause = CatchClause;
                var ClassBody = /* @__PURE__ */ function() {
                  function ClassBody2(body) {
                    this.type = syntax_1.Syntax.ClassBody;
                    this.body = body;
                  }
                  return ClassBody2;
                }();
                exports3.ClassBody = ClassBody;
                var ClassDeclaration = /* @__PURE__ */ function() {
                  function ClassDeclaration2(id2, superClass, body) {
                    this.type = syntax_1.Syntax.ClassDeclaration;
                    this.id = id2;
                    this.superClass = superClass;
                    this.body = body;
                  }
                  return ClassDeclaration2;
                }();
                exports3.ClassDeclaration = ClassDeclaration;
                var ClassExpression = /* @__PURE__ */ function() {
                  function ClassExpression2(id2, superClass, body) {
                    this.type = syntax_1.Syntax.ClassExpression;
                    this.id = id2;
                    this.superClass = superClass;
                    this.body = body;
                  }
                  return ClassExpression2;
                }();
                exports3.ClassExpression = ClassExpression;
                var ComputedMemberExpression = /* @__PURE__ */ function() {
                  function ComputedMemberExpression2(object2, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = true;
                    this.object = object2;
                    this.property = property;
                  }
                  return ComputedMemberExpression2;
                }();
                exports3.ComputedMemberExpression = ComputedMemberExpression;
                var ConditionalExpression = /* @__PURE__ */ function() {
                  function ConditionalExpression2(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.ConditionalExpression;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                  }
                  return ConditionalExpression2;
                }();
                exports3.ConditionalExpression = ConditionalExpression;
                var ContinueStatement = /* @__PURE__ */ function() {
                  function ContinueStatement2(label) {
                    this.type = syntax_1.Syntax.ContinueStatement;
                    this.label = label;
                  }
                  return ContinueStatement2;
                }();
                exports3.ContinueStatement = ContinueStatement;
                var DebuggerStatement = /* @__PURE__ */ function() {
                  function DebuggerStatement2() {
                    this.type = syntax_1.Syntax.DebuggerStatement;
                  }
                  return DebuggerStatement2;
                }();
                exports3.DebuggerStatement = DebuggerStatement;
                var Directive = /* @__PURE__ */ function() {
                  function Directive2(expression, directive) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                    this.directive = directive;
                  }
                  return Directive2;
                }();
                exports3.Directive = Directive;
                var DoWhileStatement = /* @__PURE__ */ function() {
                  function DoWhileStatement2(body, test) {
                    this.type = syntax_1.Syntax.DoWhileStatement;
                    this.body = body;
                    this.test = test;
                  }
                  return DoWhileStatement2;
                }();
                exports3.DoWhileStatement = DoWhileStatement;
                var EmptyStatement = /* @__PURE__ */ function() {
                  function EmptyStatement2() {
                    this.type = syntax_1.Syntax.EmptyStatement;
                  }
                  return EmptyStatement2;
                }();
                exports3.EmptyStatement = EmptyStatement;
                var ExportAllDeclaration = /* @__PURE__ */ function() {
                  function ExportAllDeclaration2(source) {
                    this.type = syntax_1.Syntax.ExportAllDeclaration;
                    this.source = source;
                  }
                  return ExportAllDeclaration2;
                }();
                exports3.ExportAllDeclaration = ExportAllDeclaration;
                var ExportDefaultDeclaration = /* @__PURE__ */ function() {
                  function ExportDefaultDeclaration2(declaration2) {
                    this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                    this.declaration = declaration2;
                  }
                  return ExportDefaultDeclaration2;
                }();
                exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
                var ExportNamedDeclaration = /* @__PURE__ */ function() {
                  function ExportNamedDeclaration2(declaration2, specifiers, source) {
                    this.type = syntax_1.Syntax.ExportNamedDeclaration;
                    this.declaration = declaration2;
                    this.specifiers = specifiers;
                    this.source = source;
                  }
                  return ExportNamedDeclaration2;
                }();
                exports3.ExportNamedDeclaration = ExportNamedDeclaration;
                var ExportSpecifier = /* @__PURE__ */ function() {
                  function ExportSpecifier2(local, exported) {
                    this.type = syntax_1.Syntax.ExportSpecifier;
                    this.exported = exported;
                    this.local = local;
                  }
                  return ExportSpecifier2;
                }();
                exports3.ExportSpecifier = ExportSpecifier;
                var ExpressionStatement = /* @__PURE__ */ function() {
                  function ExpressionStatement2(expression) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                  }
                  return ExpressionStatement2;
                }();
                exports3.ExpressionStatement = ExpressionStatement;
                var ForInStatement = /* @__PURE__ */ function() {
                  function ForInStatement2(left, right, body) {
                    this.type = syntax_1.Syntax.ForInStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                    this.each = false;
                  }
                  return ForInStatement2;
                }();
                exports3.ForInStatement = ForInStatement;
                var ForOfStatement = /* @__PURE__ */ function() {
                  function ForOfStatement2(left, right, body) {
                    this.type = syntax_1.Syntax.ForOfStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                  }
                  return ForOfStatement2;
                }();
                exports3.ForOfStatement = ForOfStatement;
                var ForStatement = /* @__PURE__ */ function() {
                  function ForStatement2(init2, test, update, body) {
                    this.type = syntax_1.Syntax.ForStatement;
                    this.init = init2;
                    this.test = test;
                    this.update = update;
                    this.body = body;
                  }
                  return ForStatement2;
                }();
                exports3.ForStatement = ForStatement;
                var FunctionDeclaration = /* @__PURE__ */ function() {
                  function FunctionDeclaration2(id2, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id2;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                  }
                  return FunctionDeclaration2;
                }();
                exports3.FunctionDeclaration = FunctionDeclaration;
                var FunctionExpression = /* @__PURE__ */ function() {
                  function FunctionExpression2(id2, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id2;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                  }
                  return FunctionExpression2;
                }();
                exports3.FunctionExpression = FunctionExpression;
                var Identifier = /* @__PURE__ */ function() {
                  function Identifier2(name2) {
                    this.type = syntax_1.Syntax.Identifier;
                    this.name = name2;
                  }
                  return Identifier2;
                }();
                exports3.Identifier = Identifier;
                var IfStatement = /* @__PURE__ */ function() {
                  function IfStatement2(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.IfStatement;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                  }
                  return IfStatement2;
                }();
                exports3.IfStatement = IfStatement;
                var ImportDeclaration = /* @__PURE__ */ function() {
                  function ImportDeclaration2(specifiers, source) {
                    this.type = syntax_1.Syntax.ImportDeclaration;
                    this.specifiers = specifiers;
                    this.source = source;
                  }
                  return ImportDeclaration2;
                }();
                exports3.ImportDeclaration = ImportDeclaration;
                var ImportDefaultSpecifier = /* @__PURE__ */ function() {
                  function ImportDefaultSpecifier2(local) {
                    this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                    this.local = local;
                  }
                  return ImportDefaultSpecifier2;
                }();
                exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
                var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
                  function ImportNamespaceSpecifier2(local) {
                    this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                    this.local = local;
                  }
                  return ImportNamespaceSpecifier2;
                }();
                exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
                var ImportSpecifier = /* @__PURE__ */ function() {
                  function ImportSpecifier2(local, imported) {
                    this.type = syntax_1.Syntax.ImportSpecifier;
                    this.local = local;
                    this.imported = imported;
                  }
                  return ImportSpecifier2;
                }();
                exports3.ImportSpecifier = ImportSpecifier;
                var LabeledStatement = /* @__PURE__ */ function() {
                  function LabeledStatement2(label, body) {
                    this.type = syntax_1.Syntax.LabeledStatement;
                    this.label = label;
                    this.body = body;
                  }
                  return LabeledStatement2;
                }();
                exports3.LabeledStatement = LabeledStatement;
                var Literal = /* @__PURE__ */ function() {
                  function Literal2(value, raw) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                  }
                  return Literal2;
                }();
                exports3.Literal = Literal;
                var MetaProperty = /* @__PURE__ */ function() {
                  function MetaProperty2(meta, property) {
                    this.type = syntax_1.Syntax.MetaProperty;
                    this.meta = meta;
                    this.property = property;
                  }
                  return MetaProperty2;
                }();
                exports3.MetaProperty = MetaProperty;
                var MethodDefinition = /* @__PURE__ */ function() {
                  function MethodDefinition2(key, computed, value, kind, isStatic) {
                    this.type = syntax_1.Syntax.MethodDefinition;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.static = isStatic;
                  }
                  return MethodDefinition2;
                }();
                exports3.MethodDefinition = MethodDefinition;
                var Module = /* @__PURE__ */ function() {
                  function Module2(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "module";
                  }
                  return Module2;
                }();
                exports3.Module = Module;
                var NewExpression = /* @__PURE__ */ function() {
                  function NewExpression2(callee, args) {
                    this.type = syntax_1.Syntax.NewExpression;
                    this.callee = callee;
                    this.arguments = args;
                  }
                  return NewExpression2;
                }();
                exports3.NewExpression = NewExpression;
                var ObjectExpression = /* @__PURE__ */ function() {
                  function ObjectExpression2(properties) {
                    this.type = syntax_1.Syntax.ObjectExpression;
                    this.properties = properties;
                  }
                  return ObjectExpression2;
                }();
                exports3.ObjectExpression = ObjectExpression;
                var ObjectPattern = /* @__PURE__ */ function() {
                  function ObjectPattern2(properties) {
                    this.type = syntax_1.Syntax.ObjectPattern;
                    this.properties = properties;
                  }
                  return ObjectPattern2;
                }();
                exports3.ObjectPattern = ObjectPattern;
                var Property = /* @__PURE__ */ function() {
                  function Property2(kind, key, computed, value, method2, shorthand) {
                    this.type = syntax_1.Syntax.Property;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.method = method2;
                    this.shorthand = shorthand;
                  }
                  return Property2;
                }();
                exports3.Property = Property;
                var RegexLiteral = /* @__PURE__ */ function() {
                  function RegexLiteral2(value, raw, pattern, flags) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                    this.regex = { pattern, flags };
                  }
                  return RegexLiteral2;
                }();
                exports3.RegexLiteral = RegexLiteral;
                var RestElement = /* @__PURE__ */ function() {
                  function RestElement2(argument) {
                    this.type = syntax_1.Syntax.RestElement;
                    this.argument = argument;
                  }
                  return RestElement2;
                }();
                exports3.RestElement = RestElement;
                var ReturnStatement2 = /* @__PURE__ */ function() {
                  function ReturnStatement3(argument) {
                    this.type = syntax_1.Syntax.ReturnStatement;
                    this.argument = argument;
                  }
                  return ReturnStatement3;
                }();
                exports3.ReturnStatement = ReturnStatement2;
                var Script = /* @__PURE__ */ function() {
                  function Script2(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "script";
                  }
                  return Script2;
                }();
                exports3.Script = Script;
                var SequenceExpression = /* @__PURE__ */ function() {
                  function SequenceExpression2(expressions) {
                    this.type = syntax_1.Syntax.SequenceExpression;
                    this.expressions = expressions;
                  }
                  return SequenceExpression2;
                }();
                exports3.SequenceExpression = SequenceExpression;
                var SpreadElement = /* @__PURE__ */ function() {
                  function SpreadElement2(argument) {
                    this.type = syntax_1.Syntax.SpreadElement;
                    this.argument = argument;
                  }
                  return SpreadElement2;
                }();
                exports3.SpreadElement = SpreadElement;
                var StaticMemberExpression = /* @__PURE__ */ function() {
                  function StaticMemberExpression2(object2, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = false;
                    this.object = object2;
                    this.property = property;
                  }
                  return StaticMemberExpression2;
                }();
                exports3.StaticMemberExpression = StaticMemberExpression;
                var Super = /* @__PURE__ */ function() {
                  function Super2() {
                    this.type = syntax_1.Syntax.Super;
                  }
                  return Super2;
                }();
                exports3.Super = Super;
                var SwitchCase = /* @__PURE__ */ function() {
                  function SwitchCase2(test, consequent) {
                    this.type = syntax_1.Syntax.SwitchCase;
                    this.test = test;
                    this.consequent = consequent;
                  }
                  return SwitchCase2;
                }();
                exports3.SwitchCase = SwitchCase;
                var SwitchStatement = /* @__PURE__ */ function() {
                  function SwitchStatement2(discriminant, cases) {
                    this.type = syntax_1.Syntax.SwitchStatement;
                    this.discriminant = discriminant;
                    this.cases = cases;
                  }
                  return SwitchStatement2;
                }();
                exports3.SwitchStatement = SwitchStatement;
                var TaggedTemplateExpression = /* @__PURE__ */ function() {
                  function TaggedTemplateExpression2(tag2, quasi) {
                    this.type = syntax_1.Syntax.TaggedTemplateExpression;
                    this.tag = tag2;
                    this.quasi = quasi;
                  }
                  return TaggedTemplateExpression2;
                }();
                exports3.TaggedTemplateExpression = TaggedTemplateExpression;
                var TemplateElement = /* @__PURE__ */ function() {
                  function TemplateElement2(value, tail) {
                    this.type = syntax_1.Syntax.TemplateElement;
                    this.value = value;
                    this.tail = tail;
                  }
                  return TemplateElement2;
                }();
                exports3.TemplateElement = TemplateElement;
                var TemplateLiteral = /* @__PURE__ */ function() {
                  function TemplateLiteral2(quasis, expressions) {
                    this.type = syntax_1.Syntax.TemplateLiteral;
                    this.quasis = quasis;
                    this.expressions = expressions;
                  }
                  return TemplateLiteral2;
                }();
                exports3.TemplateLiteral = TemplateLiteral;
                var ThisExpression = /* @__PURE__ */ function() {
                  function ThisExpression2() {
                    this.type = syntax_1.Syntax.ThisExpression;
                  }
                  return ThisExpression2;
                }();
                exports3.ThisExpression = ThisExpression;
                var ThrowStatement = /* @__PURE__ */ function() {
                  function ThrowStatement2(argument) {
                    this.type = syntax_1.Syntax.ThrowStatement;
                    this.argument = argument;
                  }
                  return ThrowStatement2;
                }();
                exports3.ThrowStatement = ThrowStatement;
                var TryStatement = /* @__PURE__ */ function() {
                  function TryStatement2(block, handler, finalizer) {
                    this.type = syntax_1.Syntax.TryStatement;
                    this.block = block;
                    this.handler = handler;
                    this.finalizer = finalizer;
                  }
                  return TryStatement2;
                }();
                exports3.TryStatement = TryStatement;
                var UnaryExpression = /* @__PURE__ */ function() {
                  function UnaryExpression2(operator, argument) {
                    this.type = syntax_1.Syntax.UnaryExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = true;
                  }
                  return UnaryExpression2;
                }();
                exports3.UnaryExpression = UnaryExpression;
                var UpdateExpression = /* @__PURE__ */ function() {
                  function UpdateExpression2(operator, argument, prefix2) {
                    this.type = syntax_1.Syntax.UpdateExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = prefix2;
                  }
                  return UpdateExpression2;
                }();
                exports3.UpdateExpression = UpdateExpression;
                var VariableDeclaration = /* @__PURE__ */ function() {
                  function VariableDeclaration2(declarations, kind) {
                    this.type = syntax_1.Syntax.VariableDeclaration;
                    this.declarations = declarations;
                    this.kind = kind;
                  }
                  return VariableDeclaration2;
                }();
                exports3.VariableDeclaration = VariableDeclaration;
                var VariableDeclarator = /* @__PURE__ */ function() {
                  function VariableDeclarator2(id2, init2) {
                    this.type = syntax_1.Syntax.VariableDeclarator;
                    this.id = id2;
                    this.init = init2;
                  }
                  return VariableDeclarator2;
                }();
                exports3.VariableDeclarator = VariableDeclarator;
                var WhileStatement = /* @__PURE__ */ function() {
                  function WhileStatement2(test, body) {
                    this.type = syntax_1.Syntax.WhileStatement;
                    this.test = test;
                    this.body = body;
                  }
                  return WhileStatement2;
                }();
                exports3.WhileStatement = WhileStatement;
                var WithStatement = /* @__PURE__ */ function() {
                  function WithStatement2(object2, body) {
                    this.type = syntax_1.Syntax.WithStatement;
                    this.object = object2;
                    this.body = body;
                  }
                  return WithStatement2;
                }();
                exports3.WithStatement = WithStatement;
                var YieldExpression = /* @__PURE__ */ function() {
                  function YieldExpression2(argument, delegate) {
                    this.type = syntax_1.Syntax.YieldExpression;
                    this.argument = argument;
                    this.delegate = delegate;
                  }
                  return YieldExpression2;
                }();
                exports3.YieldExpression = YieldExpression;
              },
              /* 8 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var assert_12 = __webpack_require__(9);
                var error_handler_1 = __webpack_require__(10);
                var messages_1 = __webpack_require__(11);
                var Node2 = __webpack_require__(7);
                var scanner_1 = __webpack_require__(12);
                var syntax_1 = __webpack_require__(2);
                var token_1 = __webpack_require__(13);
                var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
                var Parser2 = function() {
                  function Parser3(code2, options2, delegate) {
                    if (options2 === void 0) {
                      options2 = {};
                    }
                    this.config = {
                      range: typeof options2.range === "boolean" && options2.range,
                      loc: typeof options2.loc === "boolean" && options2.loc,
                      source: null,
                      tokens: typeof options2.tokens === "boolean" && options2.tokens,
                      comment: typeof options2.comment === "boolean" && options2.comment,
                      tolerant: typeof options2.tolerant === "boolean" && options2.tolerant
                    };
                    if (this.config.loc && options2.source && options2.source !== null) {
                      this.config.source = String(options2.source);
                    }
                    this.delegate = delegate;
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = this.config.tolerant;
                    this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
                    this.scanner.trackComment = this.config.comment;
                    this.operatorPrecedence = {
                      ")": 0,
                      ";": 0,
                      ",": 0,
                      "=": 0,
                      "]": 0,
                      "||": 1,
                      "&&": 2,
                      "|": 3,
                      "^": 4,
                      "&": 5,
                      "==": 6,
                      "!=": 6,
                      "===": 6,
                      "!==": 6,
                      "<": 7,
                      ">": 7,
                      "<=": 7,
                      ">=": 7,
                      "<<": 8,
                      ">>": 8,
                      ">>>": 8,
                      "+": 9,
                      "-": 9,
                      "*": 11,
                      "/": 11,
                      "%": 11
                    };
                    this.lookahead = {
                      type: 2,
                      value: "",
                      lineNumber: this.scanner.lineNumber,
                      lineStart: 0,
                      start: 0,
                      end: 0
                    };
                    this.hasLineTerminator = false;
                    this.context = {
                      isModule: false,
                      await: false,
                      allowIn: true,
                      allowStrictDirective: true,
                      allowYield: true,
                      firstCoverInitializedNameError: null,
                      isAssignmentTarget: false,
                      isBindingElement: false,
                      inFunctionBody: false,
                      inIteration: false,
                      inSwitch: false,
                      labelSet: {},
                      strict: false
                    };
                    this.tokens = [];
                    this.startMarker = {
                      index: 0,
                      line: this.scanner.lineNumber,
                      column: 0
                    };
                    this.lastMarker = {
                      index: 0,
                      line: this.scanner.lineNumber,
                      column: 0
                    };
                    this.nextToken();
                    this.lastMarker = {
                      index: this.scanner.index,
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                  }
                  Parser3.prototype.throwError = function(messageFormat) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                      assert_12.assert(idx < args.length, "Message reference must be in range");
                      return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.lastMarker.line;
                    var column = this.lastMarker.column + 1;
                    throw this.errorHandler.createError(index, line, column, msg);
                  };
                  Parser3.prototype.tolerateError = function(messageFormat) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                      assert_12.assert(idx < args.length, "Message reference must be in range");
                      return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.scanner.lineNumber;
                    var column = this.lastMarker.column + 1;
                    this.errorHandler.tolerateError(index, line, column, msg);
                  };
                  Parser3.prototype.unexpectedTokenError = function(token, message) {
                    var msg = message || messages_1.Messages.UnexpectedToken;
                    var value;
                    if (token) {
                      if (!message) {
                        msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                        if (token.type === 4) {
                          if (this.scanner.isFutureReservedWord(token.value)) {
                            msg = messages_1.Messages.UnexpectedReserved;
                          } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                            msg = messages_1.Messages.StrictReservedWord;
                          }
                        }
                      }
                      value = token.value;
                    } else {
                      value = "ILLEGAL";
                    }
                    msg = msg.replace("%0", value);
                    if (token && typeof token.lineNumber === "number") {
                      var index = token.start;
                      var line = token.lineNumber;
                      var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                      var column = token.start - lastMarkerLineStart + 1;
                      return this.errorHandler.createError(index, line, column, msg);
                    } else {
                      var index = this.lastMarker.index;
                      var line = this.lastMarker.line;
                      var column = this.lastMarker.column + 1;
                      return this.errorHandler.createError(index, line, column, msg);
                    }
                  };
                  Parser3.prototype.throwUnexpectedToken = function(token, message) {
                    throw this.unexpectedTokenError(token, message);
                  };
                  Parser3.prototype.tolerateUnexpectedToken = function(token, message) {
                    this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
                  };
                  Parser3.prototype.collectComments = function() {
                    if (!this.config.comment) {
                      this.scanner.scanComments();
                    } else {
                      var comments2 = this.scanner.scanComments();
                      if (comments2.length > 0 && this.delegate) {
                        for (var i2 = 0; i2 < comments2.length; ++i2) {
                          var e = comments2[i2];
                          var node2 = void 0;
                          node2 = {
                            type: e.multiLine ? "BlockComment" : "LineComment",
                            value: this.scanner.source.slice(e.slice[0], e.slice[1])
                          };
                          if (this.config.range) {
                            node2.range = e.range;
                          }
                          if (this.config.loc) {
                            node2.loc = e.loc;
                          }
                          var metadata = {
                            start: {
                              line: e.loc.start.line,
                              column: e.loc.start.column,
                              offset: e.range[0]
                            },
                            end: {
                              line: e.loc.end.line,
                              column: e.loc.end.column,
                              offset: e.range[1]
                            }
                          };
                          this.delegate(node2, metadata);
                        }
                      }
                    }
                  };
                  Parser3.prototype.getTokenRaw = function(token) {
                    return this.scanner.source.slice(token.start, token.end);
                  };
                  Parser3.prototype.convertToken = function(token) {
                    var t2 = {
                      type: token_1.TokenName[token.type],
                      value: this.getTokenRaw(token)
                    };
                    if (this.config.range) {
                      t2.range = [token.start, token.end];
                    }
                    if (this.config.loc) {
                      t2.loc = {
                        start: {
                          line: this.startMarker.line,
                          column: this.startMarker.column
                        },
                        end: {
                          line: this.scanner.lineNumber,
                          column: this.scanner.index - this.scanner.lineStart
                        }
                      };
                    }
                    if (token.type === 9) {
                      var pattern = token.pattern;
                      var flags = token.flags;
                      t2.regex = { pattern, flags };
                    }
                    return t2;
                  };
                  Parser3.prototype.nextToken = function() {
                    var token = this.lookahead;
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    this.collectComments();
                    if (this.scanner.index !== this.startMarker.index) {
                      this.startMarker.index = this.scanner.index;
                      this.startMarker.line = this.scanner.lineNumber;
                      this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    }
                    var next = this.scanner.lex();
                    this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                    if (next && this.context.strict && next.type === 3) {
                      if (this.scanner.isStrictModeReservedWord(next.value)) {
                        next.type = 4;
                      }
                    }
                    this.lookahead = next;
                    if (this.config.tokens && next.type !== 2) {
                      this.tokens.push(this.convertToken(next));
                    }
                    return token;
                  };
                  Parser3.prototype.nextRegexToken = function() {
                    this.collectComments();
                    var token = this.scanner.scanRegExp();
                    if (this.config.tokens) {
                      this.tokens.pop();
                      this.tokens.push(this.convertToken(token));
                    }
                    this.lookahead = token;
                    this.nextToken();
                    return token;
                  };
                  Parser3.prototype.createNode = function() {
                    return {
                      index: this.startMarker.index,
                      line: this.startMarker.line,
                      column: this.startMarker.column
                    };
                  };
                  Parser3.prototype.startNode = function(token, lastLineStart) {
                    if (lastLineStart === void 0) {
                      lastLineStart = 0;
                    }
                    var column = token.start - token.lineStart;
                    var line = token.lineNumber;
                    if (column < 0) {
                      column += lastLineStart;
                      line--;
                    }
                    return {
                      index: token.start,
                      line,
                      column
                    };
                  };
                  Parser3.prototype.finalize = function(marker, node2) {
                    if (this.config.range) {
                      node2.range = [marker.index, this.lastMarker.index];
                    }
                    if (this.config.loc) {
                      node2.loc = {
                        start: {
                          line: marker.line,
                          column: marker.column
                        },
                        end: {
                          line: this.lastMarker.line,
                          column: this.lastMarker.column
                        }
                      };
                      if (this.config.source) {
                        node2.loc.source = this.config.source;
                      }
                    }
                    if (this.delegate) {
                      var metadata = {
                        start: {
                          line: marker.line,
                          column: marker.column,
                          offset: marker.index
                        },
                        end: {
                          line: this.lastMarker.line,
                          column: this.lastMarker.column,
                          offset: this.lastMarker.index
                        }
                      };
                      this.delegate(node2, metadata);
                    }
                    return node2;
                  };
                  Parser3.prototype.expect = function(value) {
                    var token = this.nextToken();
                    if (token.type !== 7 || token.value !== value) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  Parser3.prototype.expectCommaSeparator = function() {
                    if (this.config.tolerant) {
                      var token = this.lookahead;
                      if (token.type === 7 && token.value === ",") {
                        this.nextToken();
                      } else if (token.type === 7 && token.value === ";") {
                        this.nextToken();
                        this.tolerateUnexpectedToken(token);
                      } else {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                      }
                    } else {
                      this.expect(",");
                    }
                  };
                  Parser3.prototype.expectKeyword = function(keyword) {
                    var token = this.nextToken();
                    if (token.type !== 4 || token.value !== keyword) {
                      this.throwUnexpectedToken(token);
                    }
                  };
                  Parser3.prototype.match = function(value) {
                    return this.lookahead.type === 7 && this.lookahead.value === value;
                  };
                  Parser3.prototype.matchKeyword = function(keyword) {
                    return this.lookahead.type === 4 && this.lookahead.value === keyword;
                  };
                  Parser3.prototype.matchContextualKeyword = function(keyword) {
                    return this.lookahead.type === 3 && this.lookahead.value === keyword;
                  };
                  Parser3.prototype.matchAssign = function() {
                    if (this.lookahead.type !== 7) {
                      return false;
                    }
                    var op = this.lookahead.value;
                    return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
                  };
                  Parser3.prototype.isolateCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result2 = parseFunction.call(this);
                    if (this.context.firstCoverInitializedNameError !== null) {
                      this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                    }
                    this.context.isBindingElement = previousIsBindingElement;
                    this.context.isAssignmentTarget = previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                    return result2;
                  };
                  Parser3.prototype.inheritCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result2 = parseFunction.call(this);
                    this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                    this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                    return result2;
                  };
                  Parser3.prototype.consumeSemicolon = function() {
                    if (this.match(";")) {
                      this.nextToken();
                    } else if (!this.hasLineTerminator) {
                      if (this.lookahead.type !== 2 && !this.match("}")) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      this.lastMarker.index = this.startMarker.index;
                      this.lastMarker.line = this.startMarker.line;
                      this.lastMarker.column = this.startMarker.column;
                    }
                  };
                  Parser3.prototype.parsePrimaryExpression = function() {
                    var node2 = this.createNode();
                    var expr;
                    var token, raw;
                    switch (this.lookahead.type) {
                      case 3:
                        if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                          this.tolerateUnexpectedToken(this.lookahead);
                        }
                        expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node2.Identifier(this.nextToken().value));
                        break;
                      case 6:
                      case 8:
                        if (this.context.strict && this.lookahead.octal) {
                          this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                        }
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node2, new Node2.Literal(token.value, raw));
                        break;
                      case 1:
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node2, new Node2.Literal(token.value === "true", raw));
                        break;
                      case 5:
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        token = this.nextToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node2, new Node2.Literal(null, raw));
                        break;
                      case 10:
                        expr = this.parseTemplateLiteral();
                        break;
                      case 7:
                        switch (this.lookahead.value) {
                          case "(":
                            this.context.isBindingElement = false;
                            expr = this.inheritCoverGrammar(this.parseGroupExpression);
                            break;
                          case "[":
                            expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                            break;
                          case "{":
                            expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                            break;
                          case "/":
                          case "/=":
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            this.scanner.index = this.startMarker.index;
                            token = this.nextRegexToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node2, new Node2.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                            break;
                          default:
                            expr = this.throwUnexpectedToken(this.nextToken());
                        }
                        break;
                      case 4:
                        if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                          expr = this.parseIdentifierName();
                        } else if (!this.context.strict && this.matchKeyword("let")) {
                          expr = this.finalize(node2, new Node2.Identifier(this.nextToken().value));
                        } else {
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          if (this.matchKeyword("function")) {
                            expr = this.parseFunctionExpression();
                          } else if (this.matchKeyword("this")) {
                            this.nextToken();
                            expr = this.finalize(node2, new Node2.ThisExpression());
                          } else if (this.matchKeyword("class")) {
                            expr = this.parseClassExpression();
                          } else {
                            expr = this.throwUnexpectedToken(this.nextToken());
                          }
                        }
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    return expr;
                  };
                  Parser3.prototype.parseSpreadElement = function() {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    return this.finalize(node2, new Node2.SpreadElement(arg));
                  };
                  Parser3.prototype.parseArrayInitializer = function() {
                    var node2 = this.createNode();
                    var elements = [];
                    this.expect("[");
                    while (!this.match("]")) {
                      if (this.match(",")) {
                        this.nextToken();
                        elements.push(null);
                      } else if (this.match("...")) {
                        var element = this.parseSpreadElement();
                        if (!this.match("]")) {
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          this.expect(",");
                        }
                        elements.push(element);
                      } else {
                        elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (!this.match("]")) {
                          this.expect(",");
                        }
                      }
                    }
                    this.expect("]");
                    return this.finalize(node2, new Node2.ArrayExpression(elements));
                  };
                  Parser3.prototype.parsePropertyMethod = function(params) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = params.simple;
                    var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                    if (this.context.strict && params.firstRestricted) {
                      this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                    }
                    if (this.context.strict && params.stricted) {
                      this.tolerateUnexpectedToken(params.stricted, params.message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    return body;
                  };
                  Parser3.prototype.parsePropertyMethodFunction = function() {
                    var isGenerator = false;
                    var node2 = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    var method2 = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node2.FunctionExpression(null, params.params, method2, isGenerator));
                  };
                  Parser3.prototype.parsePropertyMethodAsyncFunction = function() {
                    var node2 = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = false;
                    this.context.await = true;
                    var params = this.parseFormalParameters();
                    var method2 = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                    return this.finalize(node2, new Node2.AsyncFunctionExpression(null, params.params, method2));
                  };
                  Parser3.prototype.parseObjectPropertyKey = function() {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var key;
                    switch (token.type) {
                      case 8:
                      case 6:
                        if (this.context.strict && token.octal) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                        }
                        var raw = this.getTokenRaw(token);
                        key = this.finalize(node2, new Node2.Literal(token.value, raw));
                        break;
                      case 3:
                      case 1:
                      case 5:
                      case 4:
                        key = this.finalize(node2, new Node2.Identifier(token.value));
                        break;
                      case 7:
                        if (token.value === "[") {
                          key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          this.expect("]");
                        } else {
                          key = this.throwUnexpectedToken(token);
                        }
                        break;
                      default:
                        key = this.throwUnexpectedToken(token);
                    }
                    return key;
                  };
                  Parser3.prototype.isPropertyKey = function(key, value) {
                    return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
                  };
                  Parser3.prototype.parseObjectProperty = function(hasProto) {
                    var node2 = this.createNode();
                    var token = this.lookahead;
                    var kind;
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method2 = false;
                    var shorthand = false;
                    var isAsync = false;
                    if (token.type === 3) {
                      var id2 = token.value;
                      this.nextToken();
                      computed = this.match("[");
                      isAsync = !this.hasLineTerminator && id2 === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                      key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node2.Identifier(id2));
                    } else if (this.match("*")) {
                      this.nextToken();
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                      kind = "get";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      this.context.allowYield = false;
                      value = this.parseGetterMethod();
                    } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                      kind = "set";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseSetterMethod();
                    } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                      kind = "init";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseGeneratorMethod();
                      method2 = true;
                    } else {
                      if (!key) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      kind = "init";
                      if (this.match(":") && !isAsync) {
                        if (!computed && this.isPropertyKey(key, "__proto__")) {
                          if (hasProto.value) {
                            this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                          }
                          hasProto.value = true;
                        }
                        this.nextToken();
                        value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                      } else if (this.match("(")) {
                        value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                        method2 = true;
                      } else if (token.type === 3) {
                        var id2 = this.finalize(node2, new Node2.Identifier(token.value));
                        if (this.match("=")) {
                          this.context.firstCoverInitializedNameError = this.lookahead;
                          this.nextToken();
                          shorthand = true;
                          var init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          value = this.finalize(node2, new Node2.AssignmentPattern(id2, init2));
                        } else {
                          shorthand = true;
                          value = id2;
                        }
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    return this.finalize(node2, new Node2.Property(kind, key, computed, value, method2, shorthand));
                  };
                  Parser3.prototype.parseObjectInitializer = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var properties = [];
                    var hasProto = { value: false };
                    while (!this.match("}")) {
                      properties.push(this.parseObjectProperty(hasProto));
                      if (!this.match("}")) {
                        this.expectCommaSeparator();
                      }
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node2.ObjectExpression(properties));
                  };
                  Parser3.prototype.parseTemplateHead = function() {
                    assert_12.assert(this.lookahead.head, "Template literal must start with a template head");
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token.tail));
                  };
                  Parser3.prototype.parseTemplateElement = function() {
                    if (this.lookahead.type !== 10) {
                      this.throwUnexpectedToken();
                    }
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token.tail));
                  };
                  Parser3.prototype.parseTemplateLiteral = function() {
                    var node2 = this.createNode();
                    var expressions = [];
                    var quasis = [];
                    var quasi = this.parseTemplateHead();
                    quasis.push(quasi);
                    while (!quasi.tail) {
                      expressions.push(this.parseExpression());
                      quasi = this.parseTemplateElement();
                      quasis.push(quasi);
                    }
                    return this.finalize(node2, new Node2.TemplateLiteral(quasis, expressions));
                  };
                  Parser3.prototype.reinterpretExpressionAsPattern = function(expr) {
                    switch (expr.type) {
                      case syntax_1.Syntax.Identifier:
                      case syntax_1.Syntax.MemberExpression:
                      case syntax_1.Syntax.RestElement:
                      case syntax_1.Syntax.AssignmentPattern:
                        break;
                      case syntax_1.Syntax.SpreadElement:
                        expr.type = syntax_1.Syntax.RestElement;
                        this.reinterpretExpressionAsPattern(expr.argument);
                        break;
                      case syntax_1.Syntax.ArrayExpression:
                        expr.type = syntax_1.Syntax.ArrayPattern;
                        for (var i2 = 0; i2 < expr.elements.length; i2++) {
                          if (expr.elements[i2] !== null) {
                            this.reinterpretExpressionAsPattern(expr.elements[i2]);
                          }
                        }
                        break;
                      case syntax_1.Syntax.ObjectExpression:
                        expr.type = syntax_1.Syntax.ObjectPattern;
                        for (var i2 = 0; i2 < expr.properties.length; i2++) {
                          this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                        }
                        break;
                      case syntax_1.Syntax.AssignmentExpression:
                        expr.type = syntax_1.Syntax.AssignmentPattern;
                        delete expr.operator;
                        this.reinterpretExpressionAsPattern(expr.left);
                        break;
                    }
                  };
                  Parser3.prototype.parseGroupExpression = function() {
                    var expr;
                    this.expect("(");
                    if (this.match(")")) {
                      this.nextToken();
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [],
                        async: false
                      };
                    } else {
                      var startToken = this.lookahead;
                      var params = [];
                      if (this.match("...")) {
                        expr = this.parseRestElement(params);
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      } else {
                        var arrow = false;
                        this.context.isBindingElement = true;
                        expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        if (this.match(",")) {
                          var expressions = [];
                          this.context.isAssignmentTarget = false;
                          expressions.push(expr);
                          while (this.lookahead.type !== 2) {
                            if (!this.match(",")) {
                              break;
                            }
                            this.nextToken();
                            if (this.match(")")) {
                              this.nextToken();
                              for (var i2 = 0; i2 < expressions.length; i2++) {
                                this.reinterpretExpressionAsPattern(expressions[i2]);
                              }
                              arrow = true;
                              expr = {
                                type: ArrowParameterPlaceHolder,
                                params: expressions,
                                async: false
                              };
                            } else if (this.match("...")) {
                              if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                              }
                              expressions.push(this.parseRestElement(params));
                              this.expect(")");
                              if (!this.match("=>")) {
                                this.expect("=>");
                              }
                              this.context.isBindingElement = false;
                              for (var i2 = 0; i2 < expressions.length; i2++) {
                                this.reinterpretExpressionAsPattern(expressions[i2]);
                              }
                              arrow = true;
                              expr = {
                                type: ArrowParameterPlaceHolder,
                                params: expressions,
                                async: false
                              };
                            } else {
                              expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                            }
                            if (arrow) {
                              break;
                            }
                          }
                          if (!arrow) {
                            expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions));
                          }
                        }
                        if (!arrow) {
                          this.expect(")");
                          if (this.match("=>")) {
                            if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                              arrow = true;
                              expr = {
                                type: ArrowParameterPlaceHolder,
                                params: [expr],
                                async: false
                              };
                            }
                            if (!arrow) {
                              if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                              }
                              if (expr.type === syntax_1.Syntax.SequenceExpression) {
                                for (var i2 = 0; i2 < expr.expressions.length; i2++) {
                                  this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                                }
                              } else {
                                this.reinterpretExpressionAsPattern(expr);
                              }
                              var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                              expr = {
                                type: ArrowParameterPlaceHolder,
                                params: parameters,
                                async: false
                              };
                            }
                          }
                          this.context.isBindingElement = false;
                        }
                      }
                    }
                    return expr;
                  };
                  Parser3.prototype.parseArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                      while (true) {
                        var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                        args.push(expr);
                        if (this.match(")")) {
                          break;
                        }
                        this.expectCommaSeparator();
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return args;
                  };
                  Parser3.prototype.isIdentifierName = function(token) {
                    return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
                  };
                  Parser3.prototype.parseIdentifierName = function() {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    if (!this.isIdentifierName(token)) {
                      this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node2, new Node2.Identifier(token.value));
                  };
                  Parser3.prototype.parseNewExpression = function() {
                    var node2 = this.createNode();
                    var id2 = this.parseIdentifierName();
                    assert_12.assert(id2.name === "new", "New expression must start with `new`");
                    var expr;
                    if (this.match(".")) {
                      this.nextToken();
                      if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                        var property = this.parseIdentifierName();
                        expr = new Node2.MetaProperty(id2, property);
                      } else {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    } else {
                      var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                      var args = this.match("(") ? this.parseArguments() : [];
                      expr = new Node2.NewExpression(callee, args);
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    }
                    return this.finalize(node2, expr);
                  };
                  Parser3.prototype.parseAsyncArgument = function() {
                    var arg = this.parseAssignmentExpression();
                    this.context.firstCoverInitializedNameError = null;
                    return arg;
                  };
                  Parser3.prototype.parseAsyncArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                      while (true) {
                        var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                        args.push(expr);
                        if (this.match(")")) {
                          break;
                        }
                        this.expectCommaSeparator();
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return args;
                  };
                  Parser3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                    var startToken = this.lookahead;
                    var maybeAsync = this.matchContextualKeyword("async");
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    var expr;
                    if (this.matchKeyword("super") && this.context.inFunctionBody) {
                      expr = this.createNode();
                      this.nextToken();
                      expr = this.finalize(expr, new Node2.Super());
                      if (!this.match("(") && !this.match(".") && !this.match("[")) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    } else {
                      expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    }
                    while (true) {
                      if (this.match(".")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect(".");
                        var property = this.parseIdentifierName();
                        expr = this.finalize(this.startNode(startToken), new Node2.StaticMemberExpression(expr, property));
                      } else if (this.match("(")) {
                        var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = false;
                        var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                        expr = this.finalize(this.startNode(startToken), new Node2.CallExpression(expr, args));
                        if (asyncArrow && this.match("=>")) {
                          for (var i2 = 0; i2 < args.length; ++i2) {
                            this.reinterpretExpressionAsPattern(args[i2]);
                          }
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: args,
                            async: true
                          };
                        }
                      } else if (this.match("[")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect("[");
                        var property = this.isolateCoverGrammar(this.parseExpression);
                        this.expect("]");
                        expr = this.finalize(this.startNode(startToken), new Node2.ComputedMemberExpression(expr, property));
                      } else if (this.lookahead.type === 10 && this.lookahead.head) {
                        var quasi = this.parseTemplateLiteral();
                        expr = this.finalize(this.startNode(startToken), new Node2.TaggedTemplateExpression(expr, quasi));
                      } else {
                        break;
                      }
                    }
                    this.context.allowIn = previousAllowIn;
                    return expr;
                  };
                  Parser3.prototype.parseSuper = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("super");
                    if (!this.match("[") && !this.match(".")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    return this.finalize(node2, new Node2.Super());
                  };
                  Parser3.prototype.parseLeftHandSideExpression = function() {
                    assert_12.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                    var node2 = this.startNode(this.lookahead);
                    var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    while (true) {
                      if (this.match("[")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect("[");
                        var property = this.isolateCoverGrammar(this.parseExpression);
                        this.expect("]");
                        expr = this.finalize(node2, new Node2.ComputedMemberExpression(expr, property));
                      } else if (this.match(".")) {
                        this.context.isBindingElement = false;
                        this.context.isAssignmentTarget = true;
                        this.expect(".");
                        var property = this.parseIdentifierName();
                        expr = this.finalize(node2, new Node2.StaticMemberExpression(expr, property));
                      } else if (this.lookahead.type === 10 && this.lookahead.head) {
                        var quasi = this.parseTemplateLiteral();
                        expr = this.finalize(node2, new Node2.TaggedTemplateExpression(expr, quasi));
                      } else {
                        break;
                      }
                    }
                    return expr;
                  };
                  Parser3.prototype.parseUpdateExpression = function() {
                    var expr;
                    var startToken = this.lookahead;
                    if (this.match("++") || this.match("--")) {
                      var node2 = this.startNode(startToken);
                      var token = this.nextToken();
                      expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                      }
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      var prefix2 = true;
                      expr = this.finalize(node2, new Node2.UpdateExpression(token.value, expr, prefix2));
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                      if (!this.hasLineTerminator && this.lookahead.type === 7) {
                        if (this.match("++") || this.match("--")) {
                          if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                            this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                          }
                          if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                          }
                          this.context.isAssignmentTarget = false;
                          this.context.isBindingElement = false;
                          var operator = this.nextToken().value;
                          var prefix2 = false;
                          expr = this.finalize(this.startNode(startToken), new Node2.UpdateExpression(operator, expr, prefix2));
                        }
                      }
                    }
                    return expr;
                  };
                  Parser3.prototype.parseAwaitExpression = function() {
                    var node2 = this.createNode();
                    this.nextToken();
                    var argument = this.parseUnaryExpression();
                    return this.finalize(node2, new Node2.AwaitExpression(argument));
                  };
                  Parser3.prototype.parseUnaryExpression = function() {
                    var expr;
                    if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                      var node2 = this.startNode(this.lookahead);
                      var token = this.nextToken();
                      expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                      expr = this.finalize(node2, new Node2.UnaryExpression(token.value, expr));
                      if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                        this.tolerateError(messages_1.Messages.StrictDelete);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else if (this.context.await && this.matchContextualKeyword("await")) {
                      expr = this.parseAwaitExpression();
                    } else {
                      expr = this.parseUpdateExpression();
                    }
                    return expr;
                  };
                  Parser3.prototype.parseExponentiationExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                    if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                      this.nextToken();
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var left = expr;
                      var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                      expr = this.finalize(this.startNode(startToken), new Node2.BinaryExpression("**", left, right));
                    }
                    return expr;
                  };
                  Parser3.prototype.binaryPrecedence = function(token) {
                    var op = token.value;
                    var precedence;
                    if (token.type === 7) {
                      precedence = this.operatorPrecedence[op] || 0;
                    } else if (token.type === 4) {
                      precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                    } else {
                      precedence = 0;
                    }
                    return precedence;
                  };
                  Parser3.prototype.parseBinaryExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                    var token = this.lookahead;
                    var prec = this.binaryPrecedence(token);
                    if (prec > 0) {
                      this.nextToken();
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var markers = [startToken, this.lookahead];
                      var left = expr;
                      var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                      var stack = [left, token.value, right];
                      var precedences = [prec];
                      while (true) {
                        prec = this.binaryPrecedence(this.lookahead);
                        if (prec <= 0) {
                          break;
                        }
                        while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                          right = stack.pop();
                          var operator = stack.pop();
                          precedences.pop();
                          left = stack.pop();
                          markers.pop();
                          var node2 = this.startNode(markers[markers.length - 1]);
                          stack.push(this.finalize(node2, new Node2.BinaryExpression(operator, left, right)));
                        }
                        stack.push(this.nextToken().value);
                        precedences.push(prec);
                        markers.push(this.lookahead);
                        stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                      }
                      var i2 = stack.length - 1;
                      expr = stack[i2];
                      var lastMarker = markers.pop();
                      while (i2 > 1) {
                        var marker = markers.pop();
                        var lastLineStart = lastMarker && lastMarker.lineStart;
                        var node2 = this.startNode(marker, lastLineStart);
                        var operator = stack[i2 - 1];
                        expr = this.finalize(node2, new Node2.BinaryExpression(operator, stack[i2 - 2], expr));
                        i2 -= 2;
                        lastMarker = marker;
                      }
                    }
                    return expr;
                  };
                  Parser3.prototype.parseConditionalExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                    if (this.match("?")) {
                      this.nextToken();
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.context.allowIn = previousAllowIn;
                      this.expect(":");
                      var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      expr = this.finalize(this.startNode(startToken), new Node2.ConditionalExpression(expr, consequent, alternate));
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    }
                    return expr;
                  };
                  Parser3.prototype.checkPatternParam = function(options2, param) {
                    switch (param.type) {
                      case syntax_1.Syntax.Identifier:
                        this.validateParam(options2, param, param.name);
                        break;
                      case syntax_1.Syntax.RestElement:
                        this.checkPatternParam(options2, param.argument);
                        break;
                      case syntax_1.Syntax.AssignmentPattern:
                        this.checkPatternParam(options2, param.left);
                        break;
                      case syntax_1.Syntax.ArrayPattern:
                        for (var i2 = 0; i2 < param.elements.length; i2++) {
                          if (param.elements[i2] !== null) {
                            this.checkPatternParam(options2, param.elements[i2]);
                          }
                        }
                        break;
                      case syntax_1.Syntax.ObjectPattern:
                        for (var i2 = 0; i2 < param.properties.length; i2++) {
                          this.checkPatternParam(options2, param.properties[i2].value);
                        }
                        break;
                    }
                    options2.simple = options2.simple && param instanceof Node2.Identifier;
                  };
                  Parser3.prototype.reinterpretAsCoverFormalsList = function(expr) {
                    var params = [expr];
                    var options2;
                    var asyncArrow = false;
                    switch (expr.type) {
                      case syntax_1.Syntax.Identifier:
                        break;
                      case ArrowParameterPlaceHolder:
                        params = expr.params;
                        asyncArrow = expr.async;
                        break;
                      default:
                        return null;
                    }
                    options2 = {
                      simple: true,
                      paramSet: {}
                    };
                    for (var i2 = 0; i2 < params.length; ++i2) {
                      var param = params[i2];
                      if (param.type === syntax_1.Syntax.AssignmentPattern) {
                        if (param.right.type === syntax_1.Syntax.YieldExpression) {
                          if (param.right.argument) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          param.right.type = syntax_1.Syntax.Identifier;
                          param.right.name = "yield";
                          delete param.right.argument;
                          delete param.right.delegate;
                        }
                      } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      this.checkPatternParam(options2, param);
                      params[i2] = param;
                    }
                    if (this.context.strict || !this.context.allowYield) {
                      for (var i2 = 0; i2 < params.length; ++i2) {
                        var param = params[i2];
                        if (param.type === syntax_1.Syntax.YieldExpression) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                      }
                    }
                    if (options2.message === messages_1.Messages.StrictParamDupe) {
                      var token = this.context.strict ? options2.stricted : options2.firstRestricted;
                      this.throwUnexpectedToken(token, options2.message);
                    }
                    return {
                      simple: options2.simple,
                      params,
                      stricted: options2.stricted,
                      firstRestricted: options2.firstRestricted,
                      message: options2.message
                    };
                  };
                  Parser3.prototype.parseAssignmentExpression = function() {
                    var expr;
                    if (!this.context.allowYield && this.matchKeyword("yield")) {
                      expr = this.parseYieldExpression();
                    } else {
                      var startToken = this.lookahead;
                      var token = startToken;
                      expr = this.parseConditionalExpression();
                      if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                        if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                          var arg = this.parsePrimaryExpression();
                          this.reinterpretExpressionAsPattern(arg);
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [arg],
                            async: true
                          };
                        }
                      }
                      if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var isAsync = expr.async;
                        var list2 = this.reinterpretAsCoverFormalsList(expr);
                        if (list2) {
                          if (this.hasLineTerminator) {
                            this.tolerateUnexpectedToken(this.lookahead);
                          }
                          this.context.firstCoverInitializedNameError = null;
                          var previousStrict = this.context.strict;
                          var previousAllowStrictDirective = this.context.allowStrictDirective;
                          this.context.allowStrictDirective = list2.simple;
                          var previousAllowYield = this.context.allowYield;
                          var previousAwait = this.context.await;
                          this.context.allowYield = true;
                          this.context.await = isAsync;
                          var node2 = this.startNode(startToken);
                          this.expect("=>");
                          var body = void 0;
                          if (this.match("{")) {
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = true;
                            body = this.parseFunctionSourceElements();
                            this.context.allowIn = previousAllowIn;
                          } else {
                            body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          }
                          var expression = body.type !== syntax_1.Syntax.BlockStatement;
                          if (this.context.strict && list2.firstRestricted) {
                            this.throwUnexpectedToken(list2.firstRestricted, list2.message);
                          }
                          if (this.context.strict && list2.stricted) {
                            this.tolerateUnexpectedToken(list2.stricted, list2.message);
                          }
                          expr = isAsync ? this.finalize(node2, new Node2.AsyncArrowFunctionExpression(list2.params, body, expression)) : this.finalize(node2, new Node2.ArrowFunctionExpression(list2.params, body, expression));
                          this.context.strict = previousStrict;
                          this.context.allowStrictDirective = previousAllowStrictDirective;
                          this.context.allowYield = previousAllowYield;
                          this.context.await = previousAwait;
                        }
                      } else {
                        if (this.matchAssign()) {
                          if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                          }
                          if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                            var id2 = expr;
                            if (this.scanner.isRestrictedWord(id2.name)) {
                              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                            }
                            if (this.scanner.isStrictModeReservedWord(id2.name)) {
                              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                            }
                          }
                          if (!this.match("=")) {
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                          } else {
                            this.reinterpretExpressionAsPattern(expr);
                          }
                          token = this.nextToken();
                          var operator = token.value;
                          var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                          expr = this.finalize(this.startNode(startToken), new Node2.AssignmentExpression(operator, expr, right));
                          this.context.firstCoverInitializedNameError = null;
                        }
                      }
                    }
                    return expr;
                  };
                  Parser3.prototype.parseExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                      var expressions = [];
                      expressions.push(expr);
                      while (this.lookahead.type !== 2) {
                        if (!this.match(",")) {
                          break;
                        }
                        this.nextToken();
                        expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions));
                    }
                    return expr;
                  };
                  Parser3.prototype.parseStatementListItem = function() {
                    var statement;
                    this.context.isAssignmentTarget = true;
                    this.context.isBindingElement = true;
                    if (this.lookahead.type === 4) {
                      switch (this.lookahead.value) {
                        case "export":
                          if (!this.context.isModule) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                          }
                          statement = this.parseExportDeclaration();
                          break;
                        case "import":
                          if (!this.context.isModule) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                          }
                          statement = this.parseImportDeclaration();
                          break;
                        case "const":
                          statement = this.parseLexicalDeclaration({ inFor: false });
                          break;
                        case "function":
                          statement = this.parseFunctionDeclaration();
                          break;
                        case "class":
                          statement = this.parseClassDeclaration();
                          break;
                        case "let":
                          statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                          break;
                        default:
                          statement = this.parseStatement();
                          break;
                      }
                    } else {
                      statement = this.parseStatement();
                    }
                    return statement;
                  };
                  Parser3.prototype.parseBlock = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var block = [];
                    while (true) {
                      if (this.match("}")) {
                        break;
                      }
                      block.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node2.BlockStatement(block));
                  };
                  Parser3.prototype.parseLexicalBinding = function(kind, options2) {
                    var node2 = this.createNode();
                    var params = [];
                    var id2 = this.parsePattern(params, kind);
                    if (this.context.strict && id2.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(id2.name)) {
                        this.tolerateError(messages_1.Messages.StrictVarName);
                      }
                    }
                    var init2 = null;
                    if (kind === "const") {
                      if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                        if (this.match("=")) {
                          this.nextToken();
                          init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        } else {
                          this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                        }
                      }
                    } else if (!options2.inFor && id2.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                      this.expect("=");
                      init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    return this.finalize(node2, new Node2.VariableDeclarator(id2, init2));
                  };
                  Parser3.prototype.parseBindingList = function(kind, options2) {
                    var list2 = [this.parseLexicalBinding(kind, options2)];
                    while (this.match(",")) {
                      this.nextToken();
                      list2.push(this.parseLexicalBinding(kind, options2));
                    }
                    return list2;
                  };
                  Parser3.prototype.isLexicalDeclaration = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.scanner.lex();
                    this.scanner.restoreState(state);
                    return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
                  };
                  Parser3.prototype.parseLexicalDeclaration = function(options2) {
                    var node2 = this.createNode();
                    var kind = this.nextToken().value;
                    assert_12.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                    var declarations = this.parseBindingList(kind, options2);
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.VariableDeclaration(declarations, kind));
                  };
                  Parser3.prototype.parseBindingRestElement = function(params, kind) {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params, kind);
                    return this.finalize(node2, new Node2.RestElement(arg));
                  };
                  Parser3.prototype.parseArrayPattern = function(params, kind) {
                    var node2 = this.createNode();
                    this.expect("[");
                    var elements = [];
                    while (!this.match("]")) {
                      if (this.match(",")) {
                        this.nextToken();
                        elements.push(null);
                      } else {
                        if (this.match("...")) {
                          elements.push(this.parseBindingRestElement(params, kind));
                          break;
                        } else {
                          elements.push(this.parsePatternWithDefault(params, kind));
                        }
                        if (!this.match("]")) {
                          this.expect(",");
                        }
                      }
                    }
                    this.expect("]");
                    return this.finalize(node2, new Node2.ArrayPattern(elements));
                  };
                  Parser3.prototype.parsePropertyPattern = function(params, kind) {
                    var node2 = this.createNode();
                    var computed = false;
                    var shorthand = false;
                    var method2 = false;
                    var key;
                    var value;
                    if (this.lookahead.type === 3) {
                      var keyToken = this.lookahead;
                      key = this.parseVariableIdentifier();
                      var init2 = this.finalize(node2, new Node2.Identifier(keyToken.value));
                      if (this.match("=")) {
                        params.push(keyToken);
                        shorthand = true;
                        this.nextToken();
                        var expr = this.parseAssignmentExpression();
                        value = this.finalize(this.startNode(keyToken), new Node2.AssignmentPattern(init2, expr));
                      } else if (!this.match(":")) {
                        params.push(keyToken);
                        shorthand = true;
                        value = init2;
                      } else {
                        this.expect(":");
                        value = this.parsePatternWithDefault(params, kind);
                      }
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      this.expect(":");
                      value = this.parsePatternWithDefault(params, kind);
                    }
                    return this.finalize(node2, new Node2.Property("init", key, computed, value, method2, shorthand));
                  };
                  Parser3.prototype.parseObjectPattern = function(params, kind) {
                    var node2 = this.createNode();
                    var properties = [];
                    this.expect("{");
                    while (!this.match("}")) {
                      properties.push(this.parsePropertyPattern(params, kind));
                      if (!this.match("}")) {
                        this.expect(",");
                      }
                    }
                    this.expect("}");
                    return this.finalize(node2, new Node2.ObjectPattern(properties));
                  };
                  Parser3.prototype.parsePattern = function(params, kind) {
                    var pattern;
                    if (this.match("[")) {
                      pattern = this.parseArrayPattern(params, kind);
                    } else if (this.match("{")) {
                      pattern = this.parseObjectPattern(params, kind);
                    } else {
                      if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                      }
                      params.push(this.lookahead);
                      pattern = this.parseVariableIdentifier(kind);
                    }
                    return pattern;
                  };
                  Parser3.prototype.parsePatternWithDefault = function(params, kind) {
                    var startToken = this.lookahead;
                    var pattern = this.parsePattern(params, kind);
                    if (this.match("=")) {
                      this.nextToken();
                      var previousAllowYield = this.context.allowYield;
                      this.context.allowYield = true;
                      var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.context.allowYield = previousAllowYield;
                      pattern = this.finalize(this.startNode(startToken), new Node2.AssignmentPattern(pattern, right));
                    }
                    return pattern;
                  };
                  Parser3.prototype.parseVariableIdentifier = function(kind) {
                    var node2 = this.createNode();
                    var token = this.nextToken();
                    if (token.type === 4 && token.value === "yield") {
                      if (this.context.strict) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      } else if (!this.context.allowYield) {
                        this.throwUnexpectedToken(token);
                      }
                    } else if (token.type !== 3) {
                      if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      } else {
                        if (this.context.strict || token.value !== "let" || kind !== "var") {
                          this.throwUnexpectedToken(token);
                        }
                      }
                    } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                      this.tolerateUnexpectedToken(token);
                    }
                    return this.finalize(node2, new Node2.Identifier(token.value));
                  };
                  Parser3.prototype.parseVariableDeclaration = function(options2) {
                    var node2 = this.createNode();
                    var params = [];
                    var id2 = this.parsePattern(params, "var");
                    if (this.context.strict && id2.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(id2.name)) {
                        this.tolerateError(messages_1.Messages.StrictVarName);
                      }
                    }
                    var init2 = null;
                    if (this.match("=")) {
                      this.nextToken();
                      init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else if (id2.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
                      this.expect("=");
                    }
                    return this.finalize(node2, new Node2.VariableDeclarator(id2, init2));
                  };
                  Parser3.prototype.parseVariableDeclarationList = function(options2) {
                    var opt = { inFor: options2.inFor };
                    var list2 = [];
                    list2.push(this.parseVariableDeclaration(opt));
                    while (this.match(",")) {
                      this.nextToken();
                      list2.push(this.parseVariableDeclaration(opt));
                    }
                    return list2;
                  };
                  Parser3.prototype.parseVariableStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("var");
                    var declarations = this.parseVariableDeclarationList({ inFor: false });
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.VariableDeclaration(declarations, "var"));
                  };
                  Parser3.prototype.parseEmptyStatement = function() {
                    var node2 = this.createNode();
                    this.expect(";");
                    return this.finalize(node2, new Node2.EmptyStatement());
                  };
                  Parser3.prototype.parseExpressionStatement = function() {
                    var node2 = this.createNode();
                    var expr = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.ExpressionStatement(expr));
                  };
                  Parser3.prototype.parseIfClause = function() {
                    if (this.context.strict && this.matchKeyword("function")) {
                      this.tolerateError(messages_1.Messages.StrictFunction);
                    }
                    return this.parseStatement();
                  };
                  Parser3.prototype.parseIfStatement = function() {
                    var node2 = this.createNode();
                    var consequent;
                    var alternate = null;
                    this.expectKeyword("if");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      consequent = this.finalize(this.createNode(), new Node2.EmptyStatement());
                    } else {
                      this.expect(")");
                      consequent = this.parseIfClause();
                      if (this.matchKeyword("else")) {
                        this.nextToken();
                        alternate = this.parseIfClause();
                      }
                    }
                    return this.finalize(node2, new Node2.IfStatement(test, consequent, alternate));
                  };
                  Parser3.prototype.parseDoWhileStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("do");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    var body = this.parseStatement();
                    this.context.inIteration = previousInIteration;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                    } else {
                      this.expect(")");
                      if (this.match(";")) {
                        this.nextToken();
                      }
                    }
                    return this.finalize(node2, new Node2.DoWhileStatement(body, test));
                  };
                  Parser3.prototype.parseWhileStatement = function() {
                    var node2 = this.createNode();
                    var body;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node2.EmptyStatement());
                    } else {
                      this.expect(")");
                      var previousInIteration = this.context.inIteration;
                      this.context.inIteration = true;
                      body = this.parseStatement();
                      this.context.inIteration = previousInIteration;
                    }
                    return this.finalize(node2, new Node2.WhileStatement(test, body));
                  };
                  Parser3.prototype.parseForStatement = function() {
                    var init2 = null;
                    var test = null;
                    var update = null;
                    var forIn = true;
                    var left, right;
                    var node2 = this.createNode();
                    this.expectKeyword("for");
                    this.expect("(");
                    if (this.match(";")) {
                      this.nextToken();
                    } else {
                      if (this.matchKeyword("var")) {
                        init2 = this.createNode();
                        this.nextToken();
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = false;
                        var declarations = this.parseVariableDeclarationList({ inFor: true });
                        this.context.allowIn = previousAllowIn;
                        if (declarations.length === 1 && this.matchKeyword("in")) {
                          var decl = declarations[0];
                          if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                            this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                          }
                          init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, "var"));
                          this.nextToken();
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                          init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, "var"));
                          this.nextToken();
                          left = init2;
                          right = this.parseAssignmentExpression();
                          init2 = null;
                          forIn = false;
                        } else {
                          init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, "var"));
                          this.expect(";");
                        }
                      } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                        init2 = this.createNode();
                        var kind = this.nextToken().value;
                        if (!this.context.strict && this.lookahead.value === "in") {
                          init2 = this.finalize(init2, new Node2.Identifier(kind));
                          this.nextToken();
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else {
                          var previousAllowIn = this.context.allowIn;
                          this.context.allowIn = false;
                          var declarations = this.parseBindingList(kind, { inFor: true });
                          this.context.allowIn = previousAllowIn;
                          if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                            init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, kind));
                            this.nextToken();
                            left = init2;
                            right = this.parseExpression();
                            init2 = null;
                          } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                            init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, kind));
                            this.nextToken();
                            left = init2;
                            right = this.parseAssignmentExpression();
                            init2 = null;
                            forIn = false;
                          } else {
                            this.consumeSemicolon();
                            init2 = this.finalize(init2, new Node2.VariableDeclaration(declarations, kind));
                          }
                        }
                      } else {
                        var initStartToken = this.lookahead;
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = false;
                        init2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowIn = previousAllowIn;
                        if (this.matchKeyword("in")) {
                          if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                          }
                          this.nextToken();
                          this.reinterpretExpressionAsPattern(init2);
                          left = init2;
                          right = this.parseExpression();
                          init2 = null;
                        } else if (this.matchContextualKeyword("of")) {
                          if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                          }
                          this.nextToken();
                          this.reinterpretExpressionAsPattern(init2);
                          left = init2;
                          right = this.parseAssignmentExpression();
                          init2 = null;
                          forIn = false;
                        } else {
                          if (this.match(",")) {
                            var initSeq = [init2];
                            while (this.match(",")) {
                              this.nextToken();
                              initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                            }
                            init2 = this.finalize(this.startNode(initStartToken), new Node2.SequenceExpression(initSeq));
                          }
                          this.expect(";");
                        }
                      }
                    }
                    if (typeof left === "undefined") {
                      if (!this.match(";")) {
                        test = this.parseExpression();
                      }
                      this.expect(";");
                      if (!this.match(")")) {
                        update = this.parseExpression();
                      }
                    }
                    var body;
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node2.EmptyStatement());
                    } else {
                      this.expect(")");
                      var previousInIteration = this.context.inIteration;
                      this.context.inIteration = true;
                      body = this.isolateCoverGrammar(this.parseStatement);
                      this.context.inIteration = previousInIteration;
                    }
                    return typeof left === "undefined" ? this.finalize(node2, new Node2.ForStatement(init2, test, update, body)) : forIn ? this.finalize(node2, new Node2.ForInStatement(left, right, body)) : this.finalize(node2, new Node2.ForOfStatement(left, right, body));
                  };
                  Parser3.prototype.parseContinueStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("continue");
                    var label = null;
                    if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                      var id2 = this.parseVariableIdentifier();
                      label = id2;
                      var key = "$" + id2.name;
                      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.UnknownLabel, id2.name);
                      }
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration) {
                      this.throwError(messages_1.Messages.IllegalContinue);
                    }
                    return this.finalize(node2, new Node2.ContinueStatement(label));
                  };
                  Parser3.prototype.parseBreakStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("break");
                    var label = null;
                    if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                      var id2 = this.parseVariableIdentifier();
                      var key = "$" + id2.name;
                      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.UnknownLabel, id2.name);
                      }
                      label = id2;
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                      this.throwError(messages_1.Messages.IllegalBreak);
                    }
                    return this.finalize(node2, new Node2.BreakStatement(label));
                  };
                  Parser3.prototype.parseReturnStatement = function() {
                    if (!this.context.inFunctionBody) {
                      this.tolerateError(messages_1.Messages.IllegalReturn);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("return");
                    var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                    var argument = hasArgument ? this.parseExpression() : null;
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.ReturnStatement(argument));
                  };
                  Parser3.prototype.parseWithStatement = function() {
                    if (this.context.strict) {
                      this.tolerateError(messages_1.Messages.StrictModeWith);
                    }
                    var node2 = this.createNode();
                    var body;
                    this.expectKeyword("with");
                    this.expect("(");
                    var object2 = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                      this.tolerateUnexpectedToken(this.nextToken());
                      body = this.finalize(this.createNode(), new Node2.EmptyStatement());
                    } else {
                      this.expect(")");
                      body = this.parseStatement();
                    }
                    return this.finalize(node2, new Node2.WithStatement(object2, body));
                  };
                  Parser3.prototype.parseSwitchCase = function() {
                    var node2 = this.createNode();
                    var test;
                    if (this.matchKeyword("default")) {
                      this.nextToken();
                      test = null;
                    } else {
                      this.expectKeyword("case");
                      test = this.parseExpression();
                    }
                    this.expect(":");
                    var consequent = [];
                    while (true) {
                      if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                        break;
                      }
                      consequent.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node2.SwitchCase(test, consequent));
                  };
                  Parser3.prototype.parseSwitchStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("switch");
                    this.expect("(");
                    var discriminant = this.parseExpression();
                    this.expect(")");
                    var previousInSwitch = this.context.inSwitch;
                    this.context.inSwitch = true;
                    var cases = [];
                    var defaultFound = false;
                    this.expect("{");
                    while (true) {
                      if (this.match("}")) {
                        break;
                      }
                      var clause = this.parseSwitchCase();
                      if (clause.test === null) {
                        if (defaultFound) {
                          this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                        }
                        defaultFound = true;
                      }
                      cases.push(clause);
                    }
                    this.expect("}");
                    this.context.inSwitch = previousInSwitch;
                    return this.finalize(node2, new Node2.SwitchStatement(discriminant, cases));
                  };
                  Parser3.prototype.parseLabelledStatement = function() {
                    var node2 = this.createNode();
                    var expr = this.parseExpression();
                    var statement;
                    if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                      this.nextToken();
                      var id2 = expr;
                      var key = "$" + id2.name;
                      if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                        this.throwError(messages_1.Messages.Redeclaration, "Label", id2.name);
                      }
                      this.context.labelSet[key] = true;
                      var body = void 0;
                      if (this.matchKeyword("class")) {
                        this.tolerateUnexpectedToken(this.lookahead);
                        body = this.parseClassDeclaration();
                      } else if (this.matchKeyword("function")) {
                        var token = this.lookahead;
                        var declaration2 = this.parseFunctionDeclaration();
                        if (this.context.strict) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                        } else if (declaration2.generator) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                        }
                        body = declaration2;
                      } else {
                        body = this.parseStatement();
                      }
                      delete this.context.labelSet[key];
                      statement = new Node2.LabeledStatement(id2, body);
                    } else {
                      this.consumeSemicolon();
                      statement = new Node2.ExpressionStatement(expr);
                    }
                    return this.finalize(node2, statement);
                  };
                  Parser3.prototype.parseThrowStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("throw");
                    if (this.hasLineTerminator) {
                      this.throwError(messages_1.Messages.NewlineAfterThrow);
                    }
                    var argument = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.ThrowStatement(argument));
                  };
                  Parser3.prototype.parseCatchClause = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("catch");
                    this.expect("(");
                    if (this.match(")")) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    var params = [];
                    var param = this.parsePattern(params);
                    var paramMap = {};
                    for (var i2 = 0; i2 < params.length; i2++) {
                      var key = "$" + params[i2].value;
                      if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                        this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value);
                      }
                      paramMap[key] = true;
                    }
                    if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                      if (this.scanner.isRestrictedWord(param.name)) {
                        this.tolerateError(messages_1.Messages.StrictCatchVariable);
                      }
                    }
                    this.expect(")");
                    var body = this.parseBlock();
                    return this.finalize(node2, new Node2.CatchClause(param, body));
                  };
                  Parser3.prototype.parseFinallyClause = function() {
                    this.expectKeyword("finally");
                    return this.parseBlock();
                  };
                  Parser3.prototype.parseTryStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("try");
                    var block = this.parseBlock();
                    var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                    var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                    if (!handler && !finalizer) {
                      this.throwError(messages_1.Messages.NoCatchOrFinally);
                    }
                    return this.finalize(node2, new Node2.TryStatement(block, handler, finalizer));
                  };
                  Parser3.prototype.parseDebuggerStatement = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("debugger");
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.DebuggerStatement());
                  };
                  Parser3.prototype.parseStatement = function() {
                    var statement;
                    switch (this.lookahead.type) {
                      case 1:
                      case 5:
                      case 6:
                      case 8:
                      case 10:
                      case 9:
                        statement = this.parseExpressionStatement();
                        break;
                      case 7:
                        var value = this.lookahead.value;
                        if (value === "{") {
                          statement = this.parseBlock();
                        } else if (value === "(") {
                          statement = this.parseExpressionStatement();
                        } else if (value === ";") {
                          statement = this.parseEmptyStatement();
                        } else {
                          statement = this.parseExpressionStatement();
                        }
                        break;
                      case 3:
                        statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                        break;
                      case 4:
                        switch (this.lookahead.value) {
                          case "break":
                            statement = this.parseBreakStatement();
                            break;
                          case "continue":
                            statement = this.parseContinueStatement();
                            break;
                          case "debugger":
                            statement = this.parseDebuggerStatement();
                            break;
                          case "do":
                            statement = this.parseDoWhileStatement();
                            break;
                          case "for":
                            statement = this.parseForStatement();
                            break;
                          case "function":
                            statement = this.parseFunctionDeclaration();
                            break;
                          case "if":
                            statement = this.parseIfStatement();
                            break;
                          case "return":
                            statement = this.parseReturnStatement();
                            break;
                          case "switch":
                            statement = this.parseSwitchStatement();
                            break;
                          case "throw":
                            statement = this.parseThrowStatement();
                            break;
                          case "try":
                            statement = this.parseTryStatement();
                            break;
                          case "var":
                            statement = this.parseVariableStatement();
                            break;
                          case "while":
                            statement = this.parseWhileStatement();
                            break;
                          case "with":
                            statement = this.parseWithStatement();
                            break;
                          default:
                            statement = this.parseExpressionStatement();
                            break;
                        }
                        break;
                      default:
                        statement = this.throwUnexpectedToken(this.lookahead);
                    }
                    return statement;
                  };
                  Parser3.prototype.parseFunctionSourceElements = function() {
                    var node2 = this.createNode();
                    this.expect("{");
                    var body = this.parseDirectivePrologues();
                    var previousLabelSet = this.context.labelSet;
                    var previousInIteration = this.context.inIteration;
                    var previousInSwitch = this.context.inSwitch;
                    var previousInFunctionBody = this.context.inFunctionBody;
                    this.context.labelSet = {};
                    this.context.inIteration = false;
                    this.context.inSwitch = false;
                    this.context.inFunctionBody = true;
                    while (this.lookahead.type !== 2) {
                      if (this.match("}")) {
                        break;
                      }
                      body.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    this.context.labelSet = previousLabelSet;
                    this.context.inIteration = previousInIteration;
                    this.context.inSwitch = previousInSwitch;
                    this.context.inFunctionBody = previousInFunctionBody;
                    return this.finalize(node2, new Node2.BlockStatement(body));
                  };
                  Parser3.prototype.validateParam = function(options2, param, name2) {
                    var key = "$" + name2;
                    if (this.context.strict) {
                      if (this.scanner.isRestrictedWord(name2)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamName;
                      }
                      if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamDupe;
                      }
                    } else if (!options2.firstRestricted) {
                      if (this.scanner.isRestrictedWord(name2)) {
                        options2.firstRestricted = param;
                        options2.message = messages_1.Messages.StrictParamName;
                      } else if (this.scanner.isStrictModeReservedWord(name2)) {
                        options2.firstRestricted = param;
                        options2.message = messages_1.Messages.StrictReservedWord;
                      } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                        options2.stricted = param;
                        options2.message = messages_1.Messages.StrictParamDupe;
                      }
                    }
                    if (typeof Object.defineProperty === "function") {
                      Object.defineProperty(options2.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
                    } else {
                      options2.paramSet[key] = true;
                    }
                  };
                  Parser3.prototype.parseRestElement = function(params) {
                    var node2 = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params);
                    if (this.match("=")) {
                      this.throwError(messages_1.Messages.DefaultRestParameter);
                    }
                    if (!this.match(")")) {
                      this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                    }
                    return this.finalize(node2, new Node2.RestElement(arg));
                  };
                  Parser3.prototype.parseFormalParameter = function(options2) {
                    var params = [];
                    var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                    for (var i2 = 0; i2 < params.length; i2++) {
                      this.validateParam(options2, params[i2], params[i2].value);
                    }
                    options2.simple = options2.simple && param instanceof Node2.Identifier;
                    options2.params.push(param);
                  };
                  Parser3.prototype.parseFormalParameters = function(firstRestricted) {
                    var options2;
                    options2 = {
                      simple: true,
                      params: [],
                      firstRestricted
                    };
                    this.expect("(");
                    if (!this.match(")")) {
                      options2.paramSet = {};
                      while (this.lookahead.type !== 2) {
                        this.parseFormalParameter(options2);
                        if (this.match(")")) {
                          break;
                        }
                        this.expect(",");
                        if (this.match(")")) {
                          break;
                        }
                      }
                    }
                    this.expect(")");
                    return {
                      simple: options2.simple,
                      params: options2.params,
                      stricted: options2.stricted,
                      firstRestricted: options2.firstRestricted,
                      message: options2.message
                    };
                  };
                  Parser3.prototype.matchAsyncFunction = function() {
                    var match = this.matchContextualKeyword("async");
                    if (match) {
                      var state = this.scanner.saveState();
                      this.scanner.scanComments();
                      var next = this.scanner.lex();
                      this.scanner.restoreState(state);
                      match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                    }
                    return match;
                  };
                  Parser3.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                    var node2 = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                      this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                      this.nextToken();
                    }
                    var message;
                    var id2 = null;
                    var firstRestricted = null;
                    if (!identifierIsOptional || !this.match("(")) {
                      var token = this.lookahead;
                      id2 = this.parseVariableIdentifier();
                      if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                        }
                      } else {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictFunctionName;
                        } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictReservedWord;
                        }
                      }
                    }
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                      message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                      this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                      this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node2, new Node2.AsyncFunctionDeclaration(id2, params, body)) : this.finalize(node2, new Node2.FunctionDeclaration(id2, params, body, isGenerator));
                  };
                  Parser3.prototype.parseFunctionExpression = function() {
                    var node2 = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                      this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                      this.nextToken();
                    }
                    var message;
                    var id2 = null;
                    var firstRestricted;
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    if (!this.match("(")) {
                      var token = this.lookahead;
                      id2 = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                      if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                        }
                      } else {
                        if (this.scanner.isRestrictedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictFunctionName;
                        } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                          firstRestricted = token;
                          message = messages_1.Messages.StrictReservedWord;
                        }
                      }
                    }
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                      message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                      this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                      this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node2, new Node2.AsyncFunctionExpression(id2, params, body)) : this.finalize(node2, new Node2.FunctionExpression(id2, params, body, isGenerator));
                  };
                  Parser3.prototype.parseDirective = function() {
                    var token = this.lookahead;
                    var node2 = this.createNode();
                    var expr = this.parseExpression();
                    var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                    this.consumeSemicolon();
                    return this.finalize(node2, directive ? new Node2.Directive(expr, directive) : new Node2.ExpressionStatement(expr));
                  };
                  Parser3.prototype.parseDirectivePrologues = function() {
                    var firstRestricted = null;
                    var body = [];
                    while (true) {
                      var token = this.lookahead;
                      if (token.type !== 8) {
                        break;
                      }
                      var statement = this.parseDirective();
                      body.push(statement);
                      var directive = statement.directive;
                      if (typeof directive !== "string") {
                        break;
                      }
                      if (directive === "use strict") {
                        this.context.strict = true;
                        if (firstRestricted) {
                          this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                        }
                        if (!this.context.allowStrictDirective) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                        }
                      } else {
                        if (!firstRestricted && token.octal) {
                          firstRestricted = token;
                        }
                      }
                    }
                    return body;
                  };
                  Parser3.prototype.qualifiedPropertyName = function(token) {
                    switch (token.type) {
                      case 3:
                      case 8:
                      case 1:
                      case 5:
                      case 6:
                      case 4:
                        return true;
                      case 7:
                        return token.value === "[";
                    }
                    return false;
                  };
                  Parser3.prototype.parseGetterMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length > 0) {
                      this.tolerateError(messages_1.Messages.BadGetterArity);
                    }
                    var method2 = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method2, isGenerator));
                  };
                  Parser3.prototype.parseSetterMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length !== 1) {
                      this.tolerateError(messages_1.Messages.BadSetterArity);
                    } else if (formalParameters.params[0] instanceof Node2.RestElement) {
                      this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                    }
                    var method2 = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method2, isGenerator));
                  };
                  Parser3.prototype.parseGeneratorMethod = function() {
                    var node2 = this.createNode();
                    var isGenerator = true;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    this.context.allowYield = false;
                    var method2 = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node2, new Node2.FunctionExpression(null, params.params, method2, isGenerator));
                  };
                  Parser3.prototype.isStartOfExpression = function() {
                    var start = true;
                    var value = this.lookahead.value;
                    switch (this.lookahead.type) {
                      case 7:
                        start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                        break;
                      case 4:
                        start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                        break;
                    }
                    return start;
                  };
                  Parser3.prototype.parseYieldExpression = function() {
                    var node2 = this.createNode();
                    this.expectKeyword("yield");
                    var argument = null;
                    var delegate = false;
                    if (!this.hasLineTerminator) {
                      var previousAllowYield = this.context.allowYield;
                      this.context.allowYield = false;
                      delegate = this.match("*");
                      if (delegate) {
                        this.nextToken();
                        argument = this.parseAssignmentExpression();
                      } else if (this.isStartOfExpression()) {
                        argument = this.parseAssignmentExpression();
                      }
                      this.context.allowYield = previousAllowYield;
                    }
                    return this.finalize(node2, new Node2.YieldExpression(argument, delegate));
                  };
                  Parser3.prototype.parseClassElement = function(hasConstructor) {
                    var token = this.lookahead;
                    var node2 = this.createNode();
                    var kind = "";
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method2 = false;
                    var isStatic = false;
                    var isAsync = false;
                    if (this.match("*")) {
                      this.nextToken();
                    } else {
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      var id2 = key;
                      if (id2.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                        token = this.lookahead;
                        isStatic = true;
                        computed = this.match("[");
                        if (this.match("*")) {
                          this.nextToken();
                        } else {
                          key = this.parseObjectPropertyKey();
                        }
                      }
                      if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                        var punctuator = this.lookahead.value;
                        if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                          isAsync = true;
                          token = this.lookahead;
                          key = this.parseObjectPropertyKey();
                          if (token.type === 3 && token.value === "constructor") {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                          }
                        }
                      }
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3) {
                      if (token.value === "get" && lookaheadPropertyKey) {
                        kind = "get";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.context.allowYield = false;
                        value = this.parseGetterMethod();
                      } else if (token.value === "set" && lookaheadPropertyKey) {
                        kind = "set";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseSetterMethod();
                      }
                    } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                      kind = "init";
                      computed = this.match("[");
                      key = this.parseObjectPropertyKey();
                      value = this.parseGeneratorMethod();
                      method2 = true;
                    }
                    if (!kind && key && this.match("(")) {
                      kind = "init";
                      value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                      method2 = true;
                    }
                    if (!kind) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    if (kind === "init") {
                      kind = "method";
                    }
                    if (!computed) {
                      if (isStatic && this.isPropertyKey(key, "prototype")) {
                        this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                      }
                      if (!isStatic && this.isPropertyKey(key, "constructor")) {
                        if (kind !== "method" || !method2 || value && value.generator) {
                          this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                        }
                        if (hasConstructor.value) {
                          this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                        } else {
                          hasConstructor.value = true;
                        }
                        kind = "constructor";
                      }
                    }
                    return this.finalize(node2, new Node2.MethodDefinition(key, computed, value, kind, isStatic));
                  };
                  Parser3.prototype.parseClassElementList = function() {
                    var body = [];
                    var hasConstructor = { value: false };
                    this.expect("{");
                    while (!this.match("}")) {
                      if (this.match(";")) {
                        this.nextToken();
                      } else {
                        body.push(this.parseClassElement(hasConstructor));
                      }
                    }
                    this.expect("}");
                    return body;
                  };
                  Parser3.prototype.parseClassBody = function() {
                    var node2 = this.createNode();
                    var elementList = this.parseClassElementList();
                    return this.finalize(node2, new Node2.ClassBody(elementList));
                  };
                  Parser3.prototype.parseClassDeclaration = function(identifierIsOptional) {
                    var node2 = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id2 = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                      this.nextToken();
                      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node2, new Node2.ClassDeclaration(id2, superClass, classBody));
                  };
                  Parser3.prototype.parseClassExpression = function() {
                    var node2 = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id2 = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                      this.nextToken();
                      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node2, new Node2.ClassExpression(id2, superClass, classBody));
                  };
                  Parser3.prototype.parseModule = function() {
                    this.context.strict = true;
                    this.context.isModule = true;
                    this.scanner.isModule = true;
                    var node2 = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while (this.lookahead.type !== 2) {
                      body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node2.Module(body));
                  };
                  Parser3.prototype.parseScript = function() {
                    var node2 = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while (this.lookahead.type !== 2) {
                      body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node2, new Node2.Script(body));
                  };
                  Parser3.prototype.parseModuleSpecifier = function() {
                    var node2 = this.createNode();
                    if (this.lookahead.type !== 8) {
                      this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                    }
                    var token = this.nextToken();
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node2, new Node2.Literal(token.value, raw));
                  };
                  Parser3.prototype.parseImportSpecifier = function() {
                    var node2 = this.createNode();
                    var imported;
                    var local;
                    if (this.lookahead.type === 3) {
                      imported = this.parseVariableIdentifier();
                      local = imported;
                      if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        local = this.parseVariableIdentifier();
                      }
                    } else {
                      imported = this.parseIdentifierName();
                      local = imported;
                      if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        local = this.parseVariableIdentifier();
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    return this.finalize(node2, new Node2.ImportSpecifier(local, imported));
                  };
                  Parser3.prototype.parseNamedImports = function() {
                    this.expect("{");
                    var specifiers = [];
                    while (!this.match("}")) {
                      specifiers.push(this.parseImportSpecifier());
                      if (!this.match("}")) {
                        this.expect(",");
                      }
                    }
                    this.expect("}");
                    return specifiers;
                  };
                  Parser3.prototype.parseImportDefaultSpecifier = function() {
                    var node2 = this.createNode();
                    var local = this.parseIdentifierName();
                    return this.finalize(node2, new Node2.ImportDefaultSpecifier(local));
                  };
                  Parser3.prototype.parseImportNamespaceSpecifier = function() {
                    var node2 = this.createNode();
                    this.expect("*");
                    if (!this.matchContextualKeyword("as")) {
                      this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                    }
                    this.nextToken();
                    var local = this.parseIdentifierName();
                    return this.finalize(node2, new Node2.ImportNamespaceSpecifier(local));
                  };
                  Parser3.prototype.parseImportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                      this.throwError(messages_1.Messages.IllegalImportDeclaration);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("import");
                    var src2;
                    var specifiers = [];
                    if (this.lookahead.type === 8) {
                      src2 = this.parseModuleSpecifier();
                    } else {
                      if (this.match("{")) {
                        specifiers = specifiers.concat(this.parseNamedImports());
                      } else if (this.match("*")) {
                        specifiers.push(this.parseImportNamespaceSpecifier());
                      } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                        specifiers.push(this.parseImportDefaultSpecifier());
                        if (this.match(",")) {
                          this.nextToken();
                          if (this.match("*")) {
                            specifiers.push(this.parseImportNamespaceSpecifier());
                          } else if (this.match("{")) {
                            specifiers = specifiers.concat(this.parseNamedImports());
                          } else {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                        }
                      } else {
                        this.throwUnexpectedToken(this.nextToken());
                      }
                      if (!this.matchContextualKeyword("from")) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      }
                      this.nextToken();
                      src2 = this.parseModuleSpecifier();
                    }
                    this.consumeSemicolon();
                    return this.finalize(node2, new Node2.ImportDeclaration(specifiers, src2));
                  };
                  Parser3.prototype.parseExportSpecifier = function() {
                    var node2 = this.createNode();
                    var local = this.parseIdentifierName();
                    var exported = local;
                    if (this.matchContextualKeyword("as")) {
                      this.nextToken();
                      exported = this.parseIdentifierName();
                    }
                    return this.finalize(node2, new Node2.ExportSpecifier(local, exported));
                  };
                  Parser3.prototype.parseExportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                      this.throwError(messages_1.Messages.IllegalExportDeclaration);
                    }
                    var node2 = this.createNode();
                    this.expectKeyword("export");
                    var exportDeclaration;
                    if (this.matchKeyword("default")) {
                      this.nextToken();
                      if (this.matchKeyword("function")) {
                        var declaration2 = this.parseFunctionDeclaration(true);
                        exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration2));
                      } else if (this.matchKeyword("class")) {
                        var declaration2 = this.parseClassDeclaration(true);
                        exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration2));
                      } else if (this.matchContextualKeyword("async")) {
                        var declaration2 = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                        exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration2));
                      } else {
                        if (this.matchContextualKeyword("from")) {
                          this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                        }
                        var declaration2 = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                        this.consumeSemicolon();
                        exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration2));
                      }
                    } else if (this.match("*")) {
                      this.nextToken();
                      if (!this.matchContextualKeyword("from")) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      }
                      this.nextToken();
                      var src2 = this.parseModuleSpecifier();
                      this.consumeSemicolon();
                      exportDeclaration = this.finalize(node2, new Node2.ExportAllDeclaration(src2));
                    } else if (this.lookahead.type === 4) {
                      var declaration2 = void 0;
                      switch (this.lookahead.value) {
                        case "let":
                        case "const":
                          declaration2 = this.parseLexicalDeclaration({ inFor: false });
                          break;
                        case "var":
                        case "class":
                        case "function":
                          declaration2 = this.parseStatementListItem();
                          break;
                        default:
                          this.throwUnexpectedToken(this.lookahead);
                      }
                      exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration2, [], null));
                    } else if (this.matchAsyncFunction()) {
                      var declaration2 = this.parseFunctionDeclaration();
                      exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration2, [], null));
                    } else {
                      var specifiers = [];
                      var source = null;
                      var isExportFromIdentifier = false;
                      this.expect("{");
                      while (!this.match("}")) {
                        isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                        specifiers.push(this.parseExportSpecifier());
                        if (!this.match("}")) {
                          this.expect(",");
                        }
                      }
                      this.expect("}");
                      if (this.matchContextualKeyword("from")) {
                        this.nextToken();
                        source = this.parseModuleSpecifier();
                        this.consumeSemicolon();
                      } else if (isExportFromIdentifier) {
                        var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                        this.throwError(message, this.lookahead.value);
                      } else {
                        this.consumeSemicolon();
                      }
                      exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(null, specifiers, source));
                    }
                    return exportDeclaration;
                  };
                  return Parser3;
                }();
                exports3.Parser = Parser2;
              },
              /* 9 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                function assert2(condition, message) {
                  if (!condition) {
                    throw new Error("ASSERT: " + message);
                  }
                }
                exports3.assert = assert2;
              },
              /* 10 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var ErrorHandler = function() {
                  function ErrorHandler2() {
                    this.errors = [];
                    this.tolerant = false;
                  }
                  ErrorHandler2.prototype.recordError = function(error2) {
                    this.errors.push(error2);
                  };
                  ErrorHandler2.prototype.tolerate = function(error2) {
                    if (this.tolerant) {
                      this.recordError(error2);
                    } else {
                      throw error2;
                    }
                  };
                  ErrorHandler2.prototype.constructError = function(msg, column) {
                    var error2 = new Error(msg);
                    try {
                      throw error2;
                    } catch (base2) {
                      if (Object.create && Object.defineProperty) {
                        error2 = Object.create(base2);
                        Object.defineProperty(error2, "column", { value: column });
                      }
                    }
                    return error2;
                  };
                  ErrorHandler2.prototype.createError = function(index, line, col, description2) {
                    var msg = "Line " + line + ": " + description2;
                    var error2 = this.constructError(msg, col);
                    error2.index = index;
                    error2.lineNumber = line;
                    error2.description = description2;
                    return error2;
                  };
                  ErrorHandler2.prototype.throwError = function(index, line, col, description2) {
                    throw this.createError(index, line, col, description2);
                  };
                  ErrorHandler2.prototype.tolerateError = function(index, line, col, description2) {
                    var error2 = this.createError(index, line, col, description2);
                    if (this.tolerant) {
                      this.recordError(error2);
                    } else {
                      throw error2;
                    }
                  };
                  return ErrorHandler2;
                }();
                exports3.ErrorHandler = ErrorHandler;
              },
              /* 11 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                exports3.Messages = {
                  BadGetterArity: "Getter must not have any formal parameters",
                  BadSetterArity: "Setter must have exactly one formal parameter",
                  BadSetterRestParameter: "Setter function argument must not be a rest parameter",
                  ConstructorIsAsync: "Class constructor may not be an async method",
                  ConstructorSpecialMethod: "Class constructor may not be an accessor",
                  DeclarationMissingInitializer: "Missing initializer in %0 declaration",
                  DefaultRestParameter: "Unexpected token =",
                  DuplicateBinding: "Duplicate binding %0",
                  DuplicateConstructor: "A class may only have one constructor",
                  DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
                  ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
                  GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
                  IllegalBreak: "Illegal break statement",
                  IllegalContinue: "Illegal continue statement",
                  IllegalExportDeclaration: "Unexpected token",
                  IllegalImportDeclaration: "Unexpected token",
                  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
                  IllegalReturn: "Illegal return statement",
                  InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
                  InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
                  InvalidLHSInAssignment: "Invalid left-hand side in assignment",
                  InvalidLHSInForIn: "Invalid left-hand side in for-in",
                  InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
                  InvalidModuleSpecifier: "Unexpected token",
                  InvalidRegExp: "Invalid regular expression",
                  LetInLexicalBinding: "let is disallowed as a lexically bound name",
                  MissingFromClause: "Unexpected token",
                  MultipleDefaultsInSwitch: "More than one default clause in switch statement",
                  NewlineAfterThrow: "Illegal newline after throw",
                  NoAsAfterImportNamespace: "Unexpected token",
                  NoCatchOrFinally: "Missing catch or finally after try",
                  ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
                  Redeclaration: "%0 '%1' has already been declared",
                  StaticPrototype: "Classes may not have static property named prototype",
                  StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
                  StrictDelete: "Delete of an unqualified identifier in strict mode.",
                  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
                  StrictFunctionName: "Function name may not be eval or arguments in strict mode",
                  StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
                  StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
                  StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
                  StrictModeWith: "Strict mode code may not include a with statement",
                  StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
                  StrictParamDupe: "Strict mode function may not have duplicate parameter names",
                  StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
                  StrictReservedWord: "Use of future reserved word in strict mode",
                  StrictVarName: "Variable name may not be eval or arguments in strict mode",
                  TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
                  UnexpectedEOS: "Unexpected end of input",
                  UnexpectedIdentifier: "Unexpected identifier",
                  UnexpectedNumber: "Unexpected number",
                  UnexpectedReserved: "Unexpected reserved word",
                  UnexpectedString: "Unexpected string",
                  UnexpectedTemplate: "Unexpected quasi %0",
                  UnexpectedToken: "Unexpected token %0",
                  UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
                  UnknownLabel: "Undefined label '%0'",
                  UnterminatedRegExp: "Invalid regular expression: missing /"
                };
              },
              /* 12 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var assert_12 = __webpack_require__(9);
                var character_1 = __webpack_require__(4);
                var messages_1 = __webpack_require__(11);
                function hexValue(ch) {
                  return "0123456789abcdef".indexOf(ch.toLowerCase());
                }
                function octalValue(ch) {
                  return "01234567".indexOf(ch);
                }
                var Scanner = function() {
                  function Scanner2(code2, handler) {
                    this.source = code2;
                    this.errorHandler = handler;
                    this.trackComment = false;
                    this.isModule = false;
                    this.length = code2.length;
                    this.index = 0;
                    this.lineNumber = code2.length > 0 ? 1 : 0;
                    this.lineStart = 0;
                    this.curlyStack = [];
                  }
                  Scanner2.prototype.saveState = function() {
                    return {
                      index: this.index,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart
                    };
                  };
                  Scanner2.prototype.restoreState = function(state) {
                    this.index = state.index;
                    this.lineNumber = state.lineNumber;
                    this.lineStart = state.lineStart;
                  };
                  Scanner2.prototype.eof = function() {
                    return this.index >= this.length;
                  };
                  Scanner2.prototype.throwUnexpectedToken = function(message) {
                    if (message === void 0) {
                      message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                  };
                  Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                    if (message === void 0) {
                      message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                  };
                  Scanner2.prototype.skipSingleLineComment = function(offset) {
                    var comments2 = [];
                    var start, loc;
                    if (this.trackComment) {
                      comments2 = [];
                      start = this.index - offset;
                      loc = {
                        start: {
                          line: this.lineNumber,
                          column: this.index - this.lineStart - offset
                        },
                        end: {}
                      };
                    }
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      ++this.index;
                      if (character_1.Character.isLineTerminator(ch)) {
                        if (this.trackComment) {
                          loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart - 1
                          };
                          var entry = {
                            multiLine: false,
                            slice: [start + offset, this.index - 1],
                            range: [start, this.index - 1],
                            loc
                          };
                          comments2.push(entry);
                        }
                        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        this.lineStart = this.index;
                        return comments2;
                      }
                    }
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: false,
                        slice: [start + offset, this.index],
                        range: [start, this.index],
                        loc
                      };
                      comments2.push(entry);
                    }
                    return comments2;
                  };
                  Scanner2.prototype.skipMultiLineComment = function() {
                    var comments2 = [];
                    var start, loc;
                    if (this.trackComment) {
                      comments2 = [];
                      start = this.index - 2;
                      loc = {
                        start: {
                          line: this.lineNumber,
                          column: this.index - this.lineStart - 2
                        },
                        end: {}
                      };
                    }
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isLineTerminator(ch)) {
                        if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        ++this.index;
                        this.lineStart = this.index;
                      } else if (ch === 42) {
                        if (this.source.charCodeAt(this.index + 1) === 47) {
                          this.index += 2;
                          if (this.trackComment) {
                            loc.end = {
                              line: this.lineNumber,
                              column: this.index - this.lineStart
                            };
                            var entry = {
                              multiLine: true,
                              slice: [start + 2, this.index - 2],
                              range: [start, this.index],
                              loc
                            };
                            comments2.push(entry);
                          }
                          return comments2;
                        }
                        ++this.index;
                      } else {
                        ++this.index;
                      }
                    }
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index],
                        range: [start, this.index],
                        loc
                      };
                      comments2.push(entry);
                    }
                    this.tolerateUnexpectedToken();
                    return comments2;
                  };
                  Scanner2.prototype.scanComments = function() {
                    var comments2;
                    if (this.trackComment) {
                      comments2 = [];
                    }
                    var start = this.index === 0;
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isWhiteSpace(ch)) {
                        ++this.index;
                      } else if (character_1.Character.isLineTerminator(ch)) {
                        ++this.index;
                        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                          ++this.index;
                        }
                        ++this.lineNumber;
                        this.lineStart = this.index;
                        start = true;
                      } else if (ch === 47) {
                        ch = this.source.charCodeAt(this.index + 1);
                        if (ch === 47) {
                          this.index += 2;
                          var comment2 = this.skipSingleLineComment(2);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                          start = true;
                        } else if (ch === 42) {
                          this.index += 2;
                          var comment2 = this.skipMultiLineComment();
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else if (start && ch === 45) {
                        if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                          this.index += 3;
                          var comment2 = this.skipSingleLineComment(3);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else if (ch === 60 && !this.isModule) {
                        if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                          this.index += 4;
                          var comment2 = this.skipSingleLineComment(4);
                          if (this.trackComment) {
                            comments2 = comments2.concat(comment2);
                          }
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                    }
                    return comments2;
                  };
                  Scanner2.prototype.isFutureReservedWord = function(id2) {
                    switch (id2) {
                      case "enum":
                      case "export":
                      case "import":
                      case "super":
                        return true;
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.isStrictModeReservedWord = function(id2) {
                    switch (id2) {
                      case "implements":
                      case "interface":
                      case "package":
                      case "private":
                      case "protected":
                      case "public":
                      case "static":
                      case "yield":
                      case "let":
                        return true;
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.isRestrictedWord = function(id2) {
                    return id2 === "eval" || id2 === "arguments";
                  };
                  Scanner2.prototype.isKeyword = function(id2) {
                    switch (id2.length) {
                      case 2:
                        return id2 === "if" || id2 === "in" || id2 === "do";
                      case 3:
                        return id2 === "var" || id2 === "for" || id2 === "new" || id2 === "try" || id2 === "let";
                      case 4:
                        return id2 === "this" || id2 === "else" || id2 === "case" || id2 === "void" || id2 === "with" || id2 === "enum";
                      case 5:
                        return id2 === "while" || id2 === "break" || id2 === "catch" || id2 === "throw" || id2 === "const" || id2 === "yield" || id2 === "class" || id2 === "super";
                      case 6:
                        return id2 === "return" || id2 === "typeof" || id2 === "delete" || id2 === "switch" || id2 === "export" || id2 === "import";
                      case 7:
                        return id2 === "default" || id2 === "finally" || id2 === "extends";
                      case 8:
                        return id2 === "function" || id2 === "continue" || id2 === "debugger";
                      case 10:
                        return id2 === "instanceof";
                      default:
                        return false;
                    }
                  };
                  Scanner2.prototype.codePointAt = function(i2) {
                    var cp = this.source.charCodeAt(i2);
                    if (cp >= 55296 && cp <= 56319) {
                      var second = this.source.charCodeAt(i2 + 1);
                      if (second >= 56320 && second <= 57343) {
                        var first = cp;
                        cp = (first - 55296) * 1024 + second - 56320 + 65536;
                      }
                    }
                    return cp;
                  };
                  Scanner2.prototype.scanHexEscape = function(prefix2) {
                    var len = prefix2 === "u" ? 4 : 2;
                    var code2 = 0;
                    for (var i2 = 0; i2 < len; ++i2) {
                      if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                        code2 = code2 * 16 + hexValue(this.source[this.index++]);
                      } else {
                        return null;
                      }
                    }
                    return String.fromCharCode(code2);
                  };
                  Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                    var ch = this.source[this.index];
                    var code2 = 0;
                    if (ch === "}") {
                      this.throwUnexpectedToken();
                    }
                    while (!this.eof()) {
                      ch = this.source[this.index++];
                      if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                        break;
                      }
                      code2 = code2 * 16 + hexValue(ch);
                    }
                    if (code2 > 1114111 || ch !== "}") {
                      this.throwUnexpectedToken();
                    }
                    return character_1.Character.fromCodePoint(code2);
                  };
                  Scanner2.prototype.getIdentifier = function() {
                    var start = this.index++;
                    while (!this.eof()) {
                      var ch = this.source.charCodeAt(this.index);
                      if (ch === 92) {
                        this.index = start;
                        return this.getComplexIdentifier();
                      } else if (ch >= 55296 && ch < 57343) {
                        this.index = start;
                        return this.getComplexIdentifier();
                      }
                      if (character_1.Character.isIdentifierPart(ch)) {
                        ++this.index;
                      } else {
                        break;
                      }
                    }
                    return this.source.slice(start, this.index);
                  };
                  Scanner2.prototype.getComplexIdentifier = function() {
                    var cp = this.codePointAt(this.index);
                    var id2 = character_1.Character.fromCodePoint(cp);
                    this.index += id2.length;
                    var ch;
                    if (cp === 92) {
                      if (this.source.charCodeAt(this.index) !== 117) {
                        this.throwUnexpectedToken();
                      }
                      ++this.index;
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        ch = this.scanUnicodeCodePointEscape();
                      } else {
                        ch = this.scanHexEscape("u");
                        if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken();
                        }
                      }
                      id2 = ch;
                    }
                    while (!this.eof()) {
                      cp = this.codePointAt(this.index);
                      if (!character_1.Character.isIdentifierPart(cp)) {
                        break;
                      }
                      ch = character_1.Character.fromCodePoint(cp);
                      id2 += ch;
                      this.index += ch.length;
                      if (cp === 92) {
                        id2 = id2.substr(0, id2.length - 1);
                        if (this.source.charCodeAt(this.index) !== 117) {
                          this.throwUnexpectedToken();
                        }
                        ++this.index;
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          ch = this.scanUnicodeCodePointEscape();
                        } else {
                          ch = this.scanHexEscape("u");
                          if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken();
                          }
                        }
                        id2 += ch;
                      }
                    }
                    return id2;
                  };
                  Scanner2.prototype.octalToDecimal = function(ch) {
                    var octal = ch !== "0";
                    var code2 = octalValue(ch);
                    if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                      octal = true;
                      code2 = code2 * 8 + octalValue(this.source[this.index++]);
                      if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        code2 = code2 * 8 + octalValue(this.source[this.index++]);
                      }
                    }
                    return {
                      code: code2,
                      octal
                    };
                  };
                  Scanner2.prototype.scanIdentifier = function() {
                    var type2;
                    var start = this.index;
                    var id2 = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                    if (id2.length === 1) {
                      type2 = 3;
                    } else if (this.isKeyword(id2)) {
                      type2 = 4;
                    } else if (id2 === "null") {
                      type2 = 5;
                    } else if (id2 === "true" || id2 === "false") {
                      type2 = 1;
                    } else {
                      type2 = 3;
                    }
                    if (type2 !== 3 && start + id2.length !== this.index) {
                      var restore = this.index;
                      this.index = start;
                      this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                      this.index = restore;
                    }
                    return {
                      type: type2,
                      value: id2,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanPunctuator = function() {
                    var start = this.index;
                    var str2 = this.source[this.index];
                    switch (str2) {
                      case "(":
                      case "{":
                        if (str2 === "{") {
                          this.curlyStack.push("{");
                        }
                        ++this.index;
                        break;
                      case ".":
                        ++this.index;
                        if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                          this.index += 2;
                          str2 = "...";
                        }
                        break;
                      case "}":
                        ++this.index;
                        this.curlyStack.pop();
                        break;
                      case ")":
                      case ";":
                      case ",":
                      case "[":
                      case "]":
                      case ":":
                      case "?":
                      case "~":
                        ++this.index;
                        break;
                      default:
                        str2 = this.source.substr(this.index, 4);
                        if (str2 === ">>>=") {
                          this.index += 4;
                        } else {
                          str2 = str2.substr(0, 3);
                          if (str2 === "===" || str2 === "!==" || str2 === ">>>" || str2 === "<<=" || str2 === ">>=" || str2 === "**=") {
                            this.index += 3;
                          } else {
                            str2 = str2.substr(0, 2);
                            if (str2 === "&&" || str2 === "||" || str2 === "==" || str2 === "!=" || str2 === "+=" || str2 === "-=" || str2 === "*=" || str2 === "/=" || str2 === "++" || str2 === "--" || str2 === "<<" || str2 === ">>" || str2 === "&=" || str2 === "|=" || str2 === "^=" || str2 === "%=" || str2 === "<=" || str2 === ">=" || str2 === "=>" || str2 === "**") {
                              this.index += 2;
                            } else {
                              str2 = this.source[this.index];
                              if ("<>=!+-*%&|^/".indexOf(str2) >= 0) {
                                ++this.index;
                              }
                            }
                          }
                        }
                    }
                    if (this.index === start) {
                      this.throwUnexpectedToken();
                    }
                    return {
                      type: 7,
                      value: str2,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanHexLiteral = function(start) {
                    var num = "";
                    while (!this.eof()) {
                      if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {
                      type: 6,
                      value: parseInt("0x" + num, 16),
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanBinaryLiteral = function(start) {
                    var num = "";
                    var ch;
                    while (!this.eof()) {
                      ch = this.source[this.index];
                      if (ch !== "0" && ch !== "1") {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (!this.eof()) {
                      ch = this.source.charCodeAt(this.index);
                      if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                        this.throwUnexpectedToken();
                      }
                    }
                    return {
                      type: 6,
                      value: parseInt(num, 2),
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanOctalLiteral = function(prefix2, start) {
                    var num = "";
                    var octal = false;
                    if (character_1.Character.isOctalDigit(prefix2.charCodeAt(0))) {
                      octal = true;
                      num = "0" + this.source[this.index++];
                    } else {
                      ++this.index;
                    }
                    while (!this.eof()) {
                      if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        break;
                      }
                      num += this.source[this.index++];
                    }
                    if (!octal && num.length === 0) {
                      this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {
                      type: 6,
                      value: parseInt(num, 8),
                      octal,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.isImplicitOctalLiteral = function() {
                    for (var i2 = this.index + 1; i2 < this.length; ++i2) {
                      var ch = this.source[i2];
                      if (ch === "8" || ch === "9") {
                        return false;
                      }
                      if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        return true;
                      }
                    }
                    return true;
                  };
                  Scanner2.prototype.scanNumericLiteral = function() {
                    var start = this.index;
                    var ch = this.source[start];
                    assert_12.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                    var num = "";
                    if (ch !== ".") {
                      num = this.source[this.index++];
                      ch = this.source[this.index];
                      if (num === "0") {
                        if (ch === "x" || ch === "X") {
                          ++this.index;
                          return this.scanHexLiteral(start);
                        }
                        if (ch === "b" || ch === "B") {
                          ++this.index;
                          return this.scanBinaryLiteral(start);
                        }
                        if (ch === "o" || ch === "O") {
                          return this.scanOctalLiteral(ch, start);
                        }
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          if (this.isImplicitOctalLiteral()) {
                            return this.scanOctalLiteral(ch, start);
                          }
                        }
                      }
                      while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        num += this.source[this.index++];
                      }
                      ch = this.source[this.index];
                    }
                    if (ch === ".") {
                      num += this.source[this.index++];
                      while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        num += this.source[this.index++];
                      }
                      ch = this.source[this.index];
                    }
                    if (ch === "e" || ch === "E") {
                      num += this.source[this.index++];
                      ch = this.source[this.index];
                      if (ch === "+" || ch === "-") {
                        num += this.source[this.index++];
                      }
                      if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          num += this.source[this.index++];
                        }
                      } else {
                        this.throwUnexpectedToken();
                      }
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken();
                    }
                    return {
                      type: 6,
                      value: parseFloat(num),
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanStringLiteral = function() {
                    var start = this.index;
                    var quote = this.source[start];
                    assert_12.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                    ++this.index;
                    var octal = false;
                    var str2 = "";
                    while (!this.eof()) {
                      var ch = this.source[this.index++];
                      if (ch === quote) {
                        quote = "";
                        break;
                      } else if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          switch (ch) {
                            case "u":
                              if (this.source[this.index] === "{") {
                                ++this.index;
                                str2 += this.scanUnicodeCodePointEscape();
                              } else {
                                var unescaped_1 = this.scanHexEscape(ch);
                                if (unescaped_1 === null) {
                                  this.throwUnexpectedToken();
                                }
                                str2 += unescaped_1;
                              }
                              break;
                            case "x":
                              var unescaped = this.scanHexEscape(ch);
                              if (unescaped === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                              }
                              str2 += unescaped;
                              break;
                            case "n":
                              str2 += "\n";
                              break;
                            case "r":
                              str2 += "\r";
                              break;
                            case "t":
                              str2 += "	";
                              break;
                            case "b":
                              str2 += "\b";
                              break;
                            case "f":
                              str2 += "\f";
                              break;
                            case "v":
                              str2 += "\v";
                              break;
                            case "8":
                            case "9":
                              str2 += ch;
                              this.tolerateUnexpectedToken();
                              break;
                            default:
                              if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                var octToDec = this.octalToDecimal(ch);
                                octal = octToDec.octal || octal;
                                str2 += String.fromCharCode(octToDec.code);
                              } else {
                                str2 += ch;
                              }
                              break;
                          }
                        } else {
                          ++this.lineNumber;
                          if (ch === "\r" && this.source[this.index] === "\n") {
                            ++this.index;
                          }
                          this.lineStart = this.index;
                        }
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        break;
                      } else {
                        str2 += ch;
                      }
                    }
                    if (quote !== "") {
                      this.index = start;
                      this.throwUnexpectedToken();
                    }
                    return {
                      type: 8,
                      value: str2,
                      octal,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.scanTemplate = function() {
                    var cooked = "";
                    var terminated = false;
                    var start = this.index;
                    var head = this.source[start] === "`";
                    var tail = false;
                    var rawOffset = 2;
                    ++this.index;
                    while (!this.eof()) {
                      var ch = this.source[this.index++];
                      if (ch === "`") {
                        rawOffset = 1;
                        tail = true;
                        terminated = true;
                        break;
                      } else if (ch === "$") {
                        if (this.source[this.index] === "{") {
                          this.curlyStack.push("${");
                          ++this.index;
                          terminated = true;
                          break;
                        }
                        cooked += ch;
                      } else if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          switch (ch) {
                            case "n":
                              cooked += "\n";
                              break;
                            case "r":
                              cooked += "\r";
                              break;
                            case "t":
                              cooked += "	";
                              break;
                            case "u":
                              if (this.source[this.index] === "{") {
                                ++this.index;
                                cooked += this.scanUnicodeCodePointEscape();
                              } else {
                                var restore = this.index;
                                var unescaped_2 = this.scanHexEscape(ch);
                                if (unescaped_2 !== null) {
                                  cooked += unescaped_2;
                                } else {
                                  this.index = restore;
                                  cooked += ch;
                                }
                              }
                              break;
                            case "x":
                              var unescaped = this.scanHexEscape(ch);
                              if (unescaped === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                              }
                              cooked += unescaped;
                              break;
                            case "b":
                              cooked += "\b";
                              break;
                            case "f":
                              cooked += "\f";
                              break;
                            case "v":
                              cooked += "\v";
                              break;
                            default:
                              if (ch === "0") {
                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                  this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                }
                                cooked += "\0";
                              } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                              } else {
                                cooked += ch;
                              }
                              break;
                          }
                        } else {
                          ++this.lineNumber;
                          if (ch === "\r" && this.source[this.index] === "\n") {
                            ++this.index;
                          }
                          this.lineStart = this.index;
                        }
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        ++this.lineNumber;
                        if (ch === "\r" && this.source[this.index] === "\n") {
                          ++this.index;
                        }
                        this.lineStart = this.index;
                        cooked += "\n";
                      } else {
                        cooked += ch;
                      }
                    }
                    if (!terminated) {
                      this.throwUnexpectedToken();
                    }
                    if (!head) {
                      this.curlyStack.pop();
                    }
                    return {
                      type: 10,
                      value: this.source.slice(start + 1, this.index - rawOffset),
                      cooked,
                      head,
                      tail,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.testRegExp = function(pattern, flags) {
                    var astralSubstitute = "￿";
                    var tmp = pattern;
                    var self2 = this;
                    if (flags.indexOf("u") >= 0) {
                      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                        var codePoint = parseInt($1 || $2, 16);
                        if (codePoint > 1114111) {
                          self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                        }
                        if (codePoint <= 65535) {
                          return String.fromCharCode(codePoint);
                        }
                        return astralSubstitute;
                      }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                    }
                    try {
                      RegExp(tmp);
                    } catch (e) {
                      this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    try {
                      return new RegExp(pattern, flags);
                    } catch (exception) {
                      return null;
                    }
                  };
                  Scanner2.prototype.scanRegExpBody = function() {
                    var ch = this.source[this.index];
                    assert_12.assert(ch === "/", "Regular expression literal must start with a slash");
                    var str2 = this.source[this.index++];
                    var classMarker = false;
                    var terminated = false;
                    while (!this.eof()) {
                      ch = this.source[this.index++];
                      str2 += ch;
                      if (ch === "\\") {
                        ch = this.source[this.index++];
                        if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                        }
                        str2 += ch;
                      } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                      } else if (classMarker) {
                        if (ch === "]") {
                          classMarker = false;
                        }
                      } else {
                        if (ch === "/") {
                          terminated = true;
                          break;
                        } else if (ch === "[") {
                          classMarker = true;
                        }
                      }
                    }
                    if (!terminated) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    return str2.substr(1, str2.length - 2);
                  };
                  Scanner2.prototype.scanRegExpFlags = function() {
                    var str2 = "";
                    var flags = "";
                    while (!this.eof()) {
                      var ch = this.source[this.index];
                      if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        break;
                      }
                      ++this.index;
                      if (ch === "\\" && !this.eof()) {
                        ch = this.source[this.index];
                        if (ch === "u") {
                          ++this.index;
                          var restore = this.index;
                          var char = this.scanHexEscape("u");
                          if (char !== null) {
                            flags += char;
                            for (str2 += "\\u"; restore < this.index; ++restore) {
                              str2 += this.source[restore];
                            }
                          } else {
                            this.index = restore;
                            flags += "u";
                            str2 += "\\u";
                          }
                          this.tolerateUnexpectedToken();
                        } else {
                          str2 += "\\";
                          this.tolerateUnexpectedToken();
                        }
                      } else {
                        flags += ch;
                        str2 += ch;
                      }
                    }
                    return flags;
                  };
                  Scanner2.prototype.scanRegExp = function() {
                    var start = this.index;
                    var pattern = this.scanRegExpBody();
                    var flags = this.scanRegExpFlags();
                    var value = this.testRegExp(pattern, flags);
                    return {
                      type: 9,
                      value: "",
                      pattern,
                      flags,
                      regex: value,
                      lineNumber: this.lineNumber,
                      lineStart: this.lineStart,
                      start,
                      end: this.index
                    };
                  };
                  Scanner2.prototype.lex = function() {
                    if (this.eof()) {
                      return {
                        type: 2,
                        value: "",
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: this.index,
                        end: this.index
                      };
                    }
                    var cp = this.source.charCodeAt(this.index);
                    if (character_1.Character.isIdentifierStart(cp)) {
                      return this.scanIdentifier();
                    }
                    if (cp === 40 || cp === 41 || cp === 59) {
                      return this.scanPunctuator();
                    }
                    if (cp === 39 || cp === 34) {
                      return this.scanStringLiteral();
                    }
                    if (cp === 46) {
                      if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                        return this.scanNumericLiteral();
                      }
                      return this.scanPunctuator();
                    }
                    if (character_1.Character.isDecimalDigit(cp)) {
                      return this.scanNumericLiteral();
                    }
                    if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                      return this.scanTemplate();
                    }
                    if (cp >= 55296 && cp < 57343) {
                      if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                        return this.scanIdentifier();
                      }
                    }
                    return this.scanPunctuator();
                  };
                  return Scanner2;
                }();
                exports3.Scanner = Scanner;
              },
              /* 13 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                exports3.TokenName = {};
                exports3.TokenName[
                  1
                  /* BooleanLiteral */
                ] = "Boolean";
                exports3.TokenName[
                  2
                  /* EOF */
                ] = "<end>";
                exports3.TokenName[
                  3
                  /* Identifier */
                ] = "Identifier";
                exports3.TokenName[
                  4
                  /* Keyword */
                ] = "Keyword";
                exports3.TokenName[
                  5
                  /* NullLiteral */
                ] = "Null";
                exports3.TokenName[
                  6
                  /* NumericLiteral */
                ] = "Numeric";
                exports3.TokenName[
                  7
                  /* Punctuator */
                ] = "Punctuator";
                exports3.TokenName[
                  8
                  /* StringLiteral */
                ] = "String";
                exports3.TokenName[
                  9
                  /* RegularExpression */
                ] = "RegularExpression";
                exports3.TokenName[
                  10
                  /* Template */
                ] = "Template";
              },
              /* 14 */
              /***/
              function(module3, exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                exports3.XHTMLEntities = {
                  quot: '"',
                  amp: "&",
                  apos: "'",
                  gt: ">",
                  nbsp: " ",
                  iexcl: "¡",
                  cent: "¢",
                  pound: "£",
                  curren: "¤",
                  yen: "¥",
                  brvbar: "¦",
                  sect: "§",
                  uml: "¨",
                  copy: "©",
                  ordf: "ª",
                  laquo: "«",
                  not: "¬",
                  shy: "­",
                  reg: "®",
                  macr: "¯",
                  deg: "°",
                  plusmn: "±",
                  sup2: "²",
                  sup3: "³",
                  acute: "´",
                  micro: "µ",
                  para: "¶",
                  middot: "·",
                  cedil: "¸",
                  sup1: "¹",
                  ordm: "º",
                  raquo: "»",
                  frac14: "¼",
                  frac12: "½",
                  frac34: "¾",
                  iquest: "¿",
                  Agrave: "À",
                  Aacute: "Á",
                  Acirc: "Â",
                  Atilde: "Ã",
                  Auml: "Ä",
                  Aring: "Å",
                  AElig: "Æ",
                  Ccedil: "Ç",
                  Egrave: "È",
                  Eacute: "É",
                  Ecirc: "Ê",
                  Euml: "Ë",
                  Igrave: "Ì",
                  Iacute: "Í",
                  Icirc: "Î",
                  Iuml: "Ï",
                  ETH: "Ð",
                  Ntilde: "Ñ",
                  Ograve: "Ò",
                  Oacute: "Ó",
                  Ocirc: "Ô",
                  Otilde: "Õ",
                  Ouml: "Ö",
                  times: "×",
                  Oslash: "Ø",
                  Ugrave: "Ù",
                  Uacute: "Ú",
                  Ucirc: "Û",
                  Uuml: "Ü",
                  Yacute: "Ý",
                  THORN: "Þ",
                  szlig: "ß",
                  agrave: "à",
                  aacute: "á",
                  acirc: "â",
                  atilde: "ã",
                  auml: "ä",
                  aring: "å",
                  aelig: "æ",
                  ccedil: "ç",
                  egrave: "è",
                  eacute: "é",
                  ecirc: "ê",
                  euml: "ë",
                  igrave: "ì",
                  iacute: "í",
                  icirc: "î",
                  iuml: "ï",
                  eth: "ð",
                  ntilde: "ñ",
                  ograve: "ò",
                  oacute: "ó",
                  ocirc: "ô",
                  otilde: "õ",
                  ouml: "ö",
                  divide: "÷",
                  oslash: "ø",
                  ugrave: "ù",
                  uacute: "ú",
                  ucirc: "û",
                  uuml: "ü",
                  yacute: "ý",
                  thorn: "þ",
                  yuml: "ÿ",
                  OElig: "Œ",
                  oelig: "œ",
                  Scaron: "Š",
                  scaron: "š",
                  Yuml: "Ÿ",
                  fnof: "ƒ",
                  circ: "ˆ",
                  tilde: "˜",
                  Alpha: "Α",
                  Beta: "Β",
                  Gamma: "Γ",
                  Delta: "Δ",
                  Epsilon: "Ε",
                  Zeta: "Ζ",
                  Eta: "Η",
                  Theta: "Θ",
                  Iota: "Ι",
                  Kappa: "Κ",
                  Lambda: "Λ",
                  Mu: "Μ",
                  Nu: "Ν",
                  Xi: "Ξ",
                  Omicron: "Ο",
                  Pi: "Π",
                  Rho: "Ρ",
                  Sigma: "Σ",
                  Tau: "Τ",
                  Upsilon: "Υ",
                  Phi: "Φ",
                  Chi: "Χ",
                  Psi: "Ψ",
                  Omega: "Ω",
                  alpha: "α",
                  beta: "β",
                  gamma: "γ",
                  delta: "δ",
                  epsilon: "ε",
                  zeta: "ζ",
                  eta: "η",
                  theta: "θ",
                  iota: "ι",
                  kappa: "κ",
                  lambda: "λ",
                  mu: "μ",
                  nu: "ν",
                  xi: "ξ",
                  omicron: "ο",
                  pi: "π",
                  rho: "ρ",
                  sigmaf: "ς",
                  sigma: "σ",
                  tau: "τ",
                  upsilon: "υ",
                  phi: "φ",
                  chi: "χ",
                  psi: "ψ",
                  omega: "ω",
                  thetasym: "ϑ",
                  upsih: "ϒ",
                  piv: "ϖ",
                  ensp: " ",
                  emsp: " ",
                  thinsp: " ",
                  zwnj: "‌",
                  zwj: "‍",
                  lrm: "‎",
                  rlm: "‏",
                  ndash: "–",
                  mdash: "—",
                  lsquo: "‘",
                  rsquo: "’",
                  sbquo: "‚",
                  ldquo: "“",
                  rdquo: "”",
                  bdquo: "„",
                  dagger: "†",
                  Dagger: "‡",
                  bull: "•",
                  hellip: "…",
                  permil: "‰",
                  prime: "′",
                  Prime: "″",
                  lsaquo: "‹",
                  rsaquo: "›",
                  oline: "‾",
                  frasl: "⁄",
                  euro: "€",
                  image: "ℑ",
                  weierp: "℘",
                  real: "ℜ",
                  trade: "™",
                  alefsym: "ℵ",
                  larr: "←",
                  uarr: "↑",
                  rarr: "→",
                  darr: "↓",
                  harr: "↔",
                  crarr: "↵",
                  lArr: "⇐",
                  uArr: "⇑",
                  rArr: "⇒",
                  dArr: "⇓",
                  hArr: "⇔",
                  forall: "∀",
                  part: "∂",
                  exist: "∃",
                  empty: "∅",
                  nabla: "∇",
                  isin: "∈",
                  notin: "∉",
                  ni: "∋",
                  prod: "∏",
                  sum: "∑",
                  minus: "−",
                  lowast: "∗",
                  radic: "√",
                  prop: "∝",
                  infin: "∞",
                  ang: "∠",
                  and: "∧",
                  or: "∨",
                  cap: "∩",
                  cup: "∪",
                  int: "∫",
                  there4: "∴",
                  sim: "∼",
                  cong: "≅",
                  asymp: "≈",
                  ne: "≠",
                  equiv: "≡",
                  le: "≤",
                  ge: "≥",
                  sub: "⊂",
                  sup: "⊃",
                  nsub: "⊄",
                  sube: "⊆",
                  supe: "⊇",
                  oplus: "⊕",
                  otimes: "⊗",
                  perp: "⊥",
                  sdot: "⋅",
                  lceil: "⌈",
                  rceil: "⌉",
                  lfloor: "⌊",
                  rfloor: "⌋",
                  loz: "◊",
                  spades: "♠",
                  clubs: "♣",
                  hearts: "♥",
                  diams: "♦",
                  lang: "⟨",
                  rang: "⟩"
                };
              },
              /* 15 */
              /***/
              function(module3, exports3, __webpack_require__) {
                Object.defineProperty(exports3, "__esModule", { value: true });
                var error_handler_1 = __webpack_require__(10);
                var scanner_1 = __webpack_require__(12);
                var token_1 = __webpack_require__(13);
                var Reader = function() {
                  function Reader2() {
                    this.values = [];
                    this.curly = this.paren = -1;
                  }
                  Reader2.prototype.beforeFunctionExpression = function(t2) {
                    return [
                      "(",
                      "{",
                      "[",
                      "in",
                      "typeof",
                      "instanceof",
                      "new",
                      "return",
                      "case",
                      "delete",
                      "throw",
                      "void",
                      // assignment operators
                      "=",
                      "+=",
                      "-=",
                      "*=",
                      "**=",
                      "/=",
                      "%=",
                      "<<=",
                      ">>=",
                      ">>>=",
                      "&=",
                      "|=",
                      "^=",
                      ",",
                      // binary/unary operators
                      "+",
                      "-",
                      "*",
                      "**",
                      "/",
                      "%",
                      "++",
                      "--",
                      "<<",
                      ">>",
                      ">>>",
                      "&",
                      "|",
                      "^",
                      "!",
                      "~",
                      "&&",
                      "||",
                      "?",
                      ":",
                      "===",
                      "==",
                      ">=",
                      "<=",
                      "<",
                      ">",
                      "!=",
                      "!=="
                    ].indexOf(t2) >= 0;
                  };
                  Reader2.prototype.isRegexStart = function() {
                    var previous = this.values[this.values.length - 1];
                    var regex2 = previous !== null;
                    switch (previous) {
                      case "this":
                      case "]":
                        regex2 = false;
                        break;
                      case ")":
                        var keyword = this.values[this.paren - 1];
                        regex2 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                        break;
                      case "}":
                        regex2 = false;
                        if (this.values[this.curly - 3] === "function") {
                          var check = this.values[this.curly - 4];
                          regex2 = check ? !this.beforeFunctionExpression(check) : false;
                        } else if (this.values[this.curly - 4] === "function") {
                          var check = this.values[this.curly - 5];
                          regex2 = check ? !this.beforeFunctionExpression(check) : true;
                        }
                        break;
                    }
                    return regex2;
                  };
                  Reader2.prototype.push = function(token) {
                    if (token.type === 7 || token.type === 4) {
                      if (token.value === "{") {
                        this.curly = this.values.length;
                      } else if (token.value === "(") {
                        this.paren = this.values.length;
                      }
                      this.values.push(token.value);
                    } else {
                      this.values.push(null);
                    }
                  };
                  return Reader2;
                }();
                var Tokenizer2 = function() {
                  function Tokenizer3(code2, config2) {
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = config2 ? typeof config2.tolerant === "boolean" && config2.tolerant : false;
                    this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
                    this.scanner.trackComment = config2 ? typeof config2.comment === "boolean" && config2.comment : false;
                    this.trackRange = config2 ? typeof config2.range === "boolean" && config2.range : false;
                    this.trackLoc = config2 ? typeof config2.loc === "boolean" && config2.loc : false;
                    this.buffer = [];
                    this.reader = new Reader();
                  }
                  Tokenizer3.prototype.errors = function() {
                    return this.errorHandler.errors;
                  };
                  Tokenizer3.prototype.getNextToken = function() {
                    if (this.buffer.length === 0) {
                      var comments2 = this.scanner.scanComments();
                      if (this.scanner.trackComment) {
                        for (var i2 = 0; i2 < comments2.length; ++i2) {
                          var e = comments2[i2];
                          var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                          var comment2 = {
                            type: e.multiLine ? "BlockComment" : "LineComment",
                            value
                          };
                          if (this.trackRange) {
                            comment2.range = e.range;
                          }
                          if (this.trackLoc) {
                            comment2.loc = e.loc;
                          }
                          this.buffer.push(comment2);
                        }
                      }
                      if (!this.scanner.eof()) {
                        var loc = void 0;
                        if (this.trackLoc) {
                          loc = {
                            start: {
                              line: this.scanner.lineNumber,
                              column: this.scanner.index - this.scanner.lineStart
                            },
                            end: {}
                          };
                        }
                        var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                        var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                        this.reader.push(token);
                        var entry = {
                          type: token_1.TokenName[token.type],
                          value: this.scanner.source.slice(token.start, token.end)
                        };
                        if (this.trackRange) {
                          entry.range = [token.start, token.end];
                        }
                        if (this.trackLoc) {
                          loc.end = {
                            line: this.scanner.lineNumber,
                            column: this.scanner.index - this.scanner.lineStart
                          };
                          entry.loc = loc;
                        }
                        if (token.type === 9) {
                          var pattern = token.pattern;
                          var flags = token.flags;
                          entry.regex = { pattern, flags };
                        }
                        this.buffer.push(entry);
                      }
                    }
                    return this.buffer.shift();
                  };
                  return Tokenizer3;
                }();
                exports3.Tokenizer = Tokenizer2;
              }
              /******/
            ])
          );
        });
      })(esprima);
      Object.defineProperty(esprima$1, "__esModule", { value: true });
      var util_1$4 = util$c;
      function parse$l(source, options2) {
        var comments2 = [];
        var ast = esprima.exports.parse(source, {
          loc: true,
          locations: true,
          comment: true,
          onComment: comments2,
          range: util_1$4.getOption(options2, "range", false),
          tolerant: util_1$4.getOption(options2, "tolerant", true),
          tokens: true,
          jsx: util_1$4.getOption(options2, "jsx", false)
        });
        if (!Array.isArray(ast.comments)) {
          ast.comments = comments2;
        }
        return ast;
      }
      esprima$1.parse = parse$l;
      var _endianness;
      function endianness() {
        if (typeof _endianness === "undefined") {
          var a = new ArrayBuffer(2);
          var b2 = new Uint8Array(a);
          var c = new Uint16Array(a);
          b2[0] = 1;
          b2[1] = 2;
          if (c[0] === 258) {
            _endianness = "BE";
          } else if (c[0] === 513) {
            _endianness = "LE";
          } else {
            throw new Error("unable to figure out endianess");
          }
        }
        return _endianness;
      }
      function hostname() {
        if (typeof global$1.location !== "undefined") {
          return global$1.location.hostname;
        } else
          return "";
      }
      function loadavg() {
        return [];
      }
      function uptime() {
        return 0;
      }
      function freemem() {
        return Number.MAX_VALUE;
      }
      function totalmem() {
        return Number.MAX_VALUE;
      }
      function cpus() {
        return [];
      }
      function type() {
        return "Browser";
      }
      function release() {
        if (typeof global$1.navigator !== "undefined") {
          return global$1.navigator.appVersion;
        }
        return "";
      }
      function networkInterfaces() {
        return {};
      }
      function getNetworkInterfaces() {
        return {};
      }
      function arch() {
        return "javascript";
      }
      function platform() {
        return "browser";
      }
      function tmpDir() {
        return "/tmp";
      }
      var tmpdir = tmpDir;
      var EOL = "\n";
      var _polyfillNode_os = {
        EOL,
        arch,
        platform,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release,
        type,
        cpus,
        totalmem,
        freemem,
        uptime,
        loadavg,
        hostname,
        endianness
      };
      var _polyfillNode_os$1 = Object.freeze({
        __proto__: null,
        endianness,
        hostname,
        loadavg,
        uptime,
        freemem,
        totalmem,
        cpus,
        type,
        release,
        networkInterfaces,
        getNetworkInterfaces,
        arch,
        platform,
        tmpDir,
        tmpdir,
        EOL,
        "default": _polyfillNode_os
      });
      var require$$1$1 = getAugmentedNamespace(_polyfillNode_os$1);
      Object.defineProperty(options, "__esModule", { value: true });
      var defaults = {
        parser: esprima$1,
        tabWidth: 4,
        useTabs: false,
        reuseWhitespace: true,
        lineTerminator: require$$1$1.EOL || "\n",
        wrapColumn: 74,
        sourceFileName: null,
        sourceMapName: null,
        sourceRoot: null,
        inputSourceMap: null,
        range: false,
        tolerant: true,
        quote: null,
        trailingComma: false,
        arrayBracketSpacing: false,
        objectCurlySpacing: true,
        arrowParensAlways: false,
        flowObjectCommas: true,
        tokens: true
      };
      var hasOwn$6 = defaults.hasOwnProperty;
      function normalize$1(opts) {
        var options2 = opts || defaults;
        function get2(key) {
          return hasOwn$6.call(options2, key) ? options2[key] : defaults[key];
        }
        return {
          tabWidth: +get2("tabWidth"),
          useTabs: !!get2("useTabs"),
          reuseWhitespace: !!get2("reuseWhitespace"),
          lineTerminator: get2("lineTerminator"),
          wrapColumn: Math.max(get2("wrapColumn"), 0),
          sourceFileName: get2("sourceFileName"),
          sourceMapName: get2("sourceMapName"),
          sourceRoot: get2("sourceRoot"),
          inputSourceMap: get2("inputSourceMap"),
          parser: get2("esprima") || get2("parser"),
          range: get2("range"),
          tolerant: get2("tolerant"),
          quote: get2("quote"),
          trailingComma: get2("trailingComma"),
          arrayBracketSpacing: get2("arrayBracketSpacing"),
          objectCurlySpacing: get2("objectCurlySpacing"),
          arrowParensAlways: get2("arrowParensAlways"),
          flowObjectCommas: get2("flowObjectCommas"),
          tokens: !!get2("tokens")
        };
      }
      options.normalize = normalize$1;
      var lines = {};
      var mapping = {};
      var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(mapping, "__esModule", { value: true });
      var assert_1$6 = __importDefault$7(require$$0$4);
      var util_1$3 = util$c;
      var Mapping = (
        /** @class */
        function() {
          function Mapping2(sourceLines, sourceLoc, targetLoc) {
            if (targetLoc === void 0) {
              targetLoc = sourceLoc;
            }
            this.sourceLines = sourceLines;
            this.sourceLoc = sourceLoc;
            this.targetLoc = targetLoc;
          }
          Mapping2.prototype.slice = function(lines2, start, end) {
            if (end === void 0) {
              end = lines2.lastPos();
            }
            var sourceLines = this.sourceLines;
            var sourceLoc = this.sourceLoc;
            var targetLoc = this.targetLoc;
            function skip(name2) {
              var sourceFromPos = sourceLoc[name2];
              var targetFromPos = targetLoc[name2];
              var targetToPos = start;
              if (name2 === "end") {
                targetToPos = end;
              } else {
                assert_1$6.default.strictEqual(name2, "start");
              }
              return skipChars(sourceLines, sourceFromPos, lines2, targetFromPos, targetToPos);
            }
            if (util_1$3.comparePos(start, targetLoc.start) <= 0) {
              if (util_1$3.comparePos(targetLoc.end, end) <= 0) {
                targetLoc = {
                  start: subtractPos(targetLoc.start, start.line, start.column),
                  end: subtractPos(targetLoc.end, start.line, start.column)
                };
              } else if (util_1$3.comparePos(end, targetLoc.start) <= 0) {
                return null;
              } else {
                sourceLoc = {
                  start: sourceLoc.start,
                  end: skip("end")
                };
                targetLoc = {
                  start: subtractPos(targetLoc.start, start.line, start.column),
                  end: subtractPos(end, start.line, start.column)
                };
              }
            } else {
              if (util_1$3.comparePos(targetLoc.end, start) <= 0) {
                return null;
              }
              if (util_1$3.comparePos(targetLoc.end, end) <= 0) {
                sourceLoc = {
                  start: skip("start"),
                  end: sourceLoc.end
                };
                targetLoc = {
                  // Same as subtractPos(start, start.line, start.column):
                  start: { line: 1, column: 0 },
                  end: subtractPos(targetLoc.end, start.line, start.column)
                };
              } else {
                sourceLoc = {
                  start: skip("start"),
                  end: skip("end")
                };
                targetLoc = {
                  // Same as subtractPos(start, start.line, start.column):
                  start: { line: 1, column: 0 },
                  end: subtractPos(end, start.line, start.column)
                };
              }
            }
            return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
          };
          Mapping2.prototype.add = function(line, column) {
            return new Mapping2(this.sourceLines, this.sourceLoc, {
              start: addPos(this.targetLoc.start, line, column),
              end: addPos(this.targetLoc.end, line, column)
            });
          };
          Mapping2.prototype.subtract = function(line, column) {
            return new Mapping2(this.sourceLines, this.sourceLoc, {
              start: subtractPos(this.targetLoc.start, line, column),
              end: subtractPos(this.targetLoc.end, line, column)
            });
          };
          Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
            if (skipFirstLine === void 0) {
              skipFirstLine = false;
            }
            if (noNegativeColumns === void 0) {
              noNegativeColumns = false;
            }
            if (by === 0) {
              return this;
            }
            var targetLoc = this.targetLoc;
            var startLine = targetLoc.start.line;
            var endLine = targetLoc.end.line;
            if (skipFirstLine && startLine === 1 && endLine === 1) {
              return this;
            }
            targetLoc = {
              start: targetLoc.start,
              end: targetLoc.end
            };
            if (!skipFirstLine || startLine > 1) {
              var startColumn = targetLoc.start.column + by;
              targetLoc.start = {
                line: startLine,
                column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
              };
            }
            if (!skipFirstLine || endLine > 1) {
              var endColumn = targetLoc.end.column + by;
              targetLoc.end = {
                line: endLine,
                column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
              };
            }
            return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
          };
          return Mapping2;
        }()
      );
      mapping.default = Mapping;
      function addPos(toPos, line, column) {
        return {
          line: toPos.line + line - 1,
          column: toPos.line === 1 ? toPos.column + column : toPos.column
        };
      }
      function subtractPos(fromPos, line, column) {
        return {
          line: fromPos.line - line + 1,
          column: fromPos.line === line ? fromPos.column - column : fromPos.column
        };
      }
      function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
        var targetComparison = util_1$3.comparePos(targetFromPos, targetToPos);
        if (targetComparison === 0) {
          return sourceFromPos;
        }
        if (targetComparison < 0) {
          var sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
          var targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
          var lineDiff = targetToPos.line - targetCursor.line;
          sourceCursor.line += lineDiff;
          targetCursor.line += lineDiff;
          if (lineDiff > 0) {
            sourceCursor.column = 0;
            targetCursor.column = 0;
          } else {
            assert_1$6.default.strictEqual(lineDiff, 0);
          }
          while (util_1$3.comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
            assert_1$6.default.ok(sourceLines.nextPos(sourceCursor, true));
            assert_1$6.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
          }
        } else {
          var sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
          var targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
          var lineDiff = targetToPos.line - targetCursor.line;
          sourceCursor.line += lineDiff;
          targetCursor.line += lineDiff;
          if (lineDiff < 0) {
            sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
            targetCursor.column = targetLines.getLineLength(targetCursor.line);
          } else {
            assert_1$6.default.strictEqual(lineDiff, 0);
          }
          while (util_1$3.comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
            assert_1$6.default.ok(sourceLines.prevPos(sourceCursor, true));
            assert_1$6.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
          }
        }
        return sourceCursor;
      }
      var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
        __assign = Object.assign || function(t2) {
          for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s = arguments[i2];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t2[p] = s[p];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(lines, "__esModule", { value: true });
      var assert_1$5 = __importDefault$6(require$$0$4);
      var source_map_1 = __importDefault$6(sourceMap$2);
      var options_1$2 = options;
      var util_1$2 = util$c;
      var mapping_1 = __importDefault$6(mapping);
      var Lines = (
        /** @class */
        function() {
          function Lines2(infos, sourceFileName) {
            if (sourceFileName === void 0) {
              sourceFileName = null;
            }
            this.infos = infos;
            this.mappings = [];
            this.cachedSourceMap = null;
            this.cachedTabWidth = void 0;
            assert_1$5.default.ok(infos.length > 0);
            this.length = infos.length;
            this.name = sourceFileName || null;
            if (this.name) {
              this.mappings.push(new mapping_1.default(this, {
                start: this.firstPos(),
                end: this.lastPos()
              }));
            }
          }
          Lines2.prototype.toString = function(options2) {
            return this.sliceString(this.firstPos(), this.lastPos(), options2);
          };
          Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
            if (!sourceMapName) {
              return null;
            }
            var targetLines = this;
            function updateJSON(json) {
              json = json || {};
              json.file = sourceMapName;
              if (sourceRoot) {
                json.sourceRoot = sourceRoot;
              }
              return json;
            }
            if (targetLines.cachedSourceMap) {
              return updateJSON(targetLines.cachedSourceMap.toJSON());
            }
            var smg = new source_map_1.default.SourceMapGenerator(updateJSON());
            var sourcesToContents = {};
            targetLines.mappings.forEach(function(mapping2) {
              var sourceCursor = mapping2.sourceLines.skipSpaces(mapping2.sourceLoc.start) || mapping2.sourceLines.lastPos();
              var targetCursor = targetLines.skipSpaces(mapping2.targetLoc.start) || targetLines.lastPos();
              while (util_1$2.comparePos(sourceCursor, mapping2.sourceLoc.end) < 0 && util_1$2.comparePos(targetCursor, mapping2.targetLoc.end) < 0) {
                var sourceChar = mapping2.sourceLines.charAt(sourceCursor);
                var targetChar = targetLines.charAt(targetCursor);
                assert_1$5.default.strictEqual(sourceChar, targetChar);
                var sourceName = mapping2.sourceLines.name;
                smg.addMapping({
                  source: sourceName,
                  original: {
                    line: sourceCursor.line,
                    column: sourceCursor.column
                  },
                  generated: {
                    line: targetCursor.line,
                    column: targetCursor.column
                  }
                });
                if (!hasOwn$5.call(sourcesToContents, sourceName)) {
                  var sourceContent = mapping2.sourceLines.toString();
                  smg.setSourceContent(sourceName, sourceContent);
                  sourcesToContents[sourceName] = sourceContent;
                }
                targetLines.nextPos(targetCursor, true);
                mapping2.sourceLines.nextPos(sourceCursor, true);
              }
            });
            targetLines.cachedSourceMap = smg;
            return smg.toJSON();
          };
          Lines2.prototype.bootstrapCharAt = function(pos) {
            assert_1$5.default.strictEqual(typeof pos, "object");
            assert_1$5.default.strictEqual(typeof pos.line, "number");
            assert_1$5.default.strictEqual(typeof pos.column, "number");
            var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string2 = strings[line - 1];
            if (typeof string2 === "undefined")
              return "";
            if (column === string2.length && line < strings.length)
              return "\n";
            if (column >= string2.length)
              return "";
            return string2.charAt(column);
          };
          Lines2.prototype.charAt = function(pos) {
            assert_1$5.default.strictEqual(typeof pos, "object");
            assert_1$5.default.strictEqual(typeof pos.line, "number");
            assert_1$5.default.strictEqual(typeof pos.column, "number");
            var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;
            if (typeof info === "undefined" || c < 0)
              return "";
            var indent = this.getIndentAt(line);
            if (c < indent)
              return " ";
            c += info.sliceStart - indent;
            if (c === info.sliceEnd && line < this.length)
              return "\n";
            if (c >= info.sliceEnd)
              return "";
            return info.line.charAt(c);
          };
          Lines2.prototype.stripMargin = function(width, skipFirstLine) {
            if (width === 0)
              return this;
            assert_1$5.default.ok(width > 0, "negative margin: " + width);
            if (skipFirstLine && this.length === 1)
              return this;
            var lines2 = new Lines2(this.infos.map(function(info, i2) {
              if (info.line && (i2 > 0 || !skipFirstLine)) {
                info = __assign(__assign({}, info), { indent: Math.max(0, info.indent - width) });
              }
              return info;
            }));
            if (this.mappings.length > 0) {
              var newMappings_1 = lines2.mappings;
              assert_1$5.default.strictEqual(newMappings_1.length, 0);
              this.mappings.forEach(function(mapping2) {
                newMappings_1.push(mapping2.indent(width, skipFirstLine, true));
              });
            }
            return lines2;
          };
          Lines2.prototype.indent = function(by) {
            if (by === 0) {
              return this;
            }
            var lines2 = new Lines2(this.infos.map(function(info) {
              if (info.line && !info.locked) {
                info = __assign(__assign({}, info), { indent: info.indent + by });
              }
              return info;
            }));
            if (this.mappings.length > 0) {
              var newMappings_2 = lines2.mappings;
              assert_1$5.default.strictEqual(newMappings_2.length, 0);
              this.mappings.forEach(function(mapping2) {
                newMappings_2.push(mapping2.indent(by));
              });
            }
            return lines2;
          };
          Lines2.prototype.indentTail = function(by) {
            if (by === 0) {
              return this;
            }
            if (this.length < 2) {
              return this;
            }
            var lines2 = new Lines2(this.infos.map(function(info, i2) {
              if (i2 > 0 && info.line && !info.locked) {
                info = __assign(__assign({}, info), { indent: info.indent + by });
              }
              return info;
            }));
            if (this.mappings.length > 0) {
              var newMappings_3 = lines2.mappings;
              assert_1$5.default.strictEqual(newMappings_3.length, 0);
              this.mappings.forEach(function(mapping2) {
                newMappings_3.push(mapping2.indent(by, true));
              });
            }
            return lines2;
          };
          Lines2.prototype.lockIndentTail = function() {
            if (this.length < 2) {
              return this;
            }
            return new Lines2(this.infos.map(function(info, i2) {
              return __assign(__assign({}, info), { locked: i2 > 0 });
            }));
          };
          Lines2.prototype.getIndentAt = function(line) {
            assert_1$5.default.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
            return Math.max(this.infos[line - 1].indent, 0);
          };
          Lines2.prototype.guessTabWidth = function() {
            if (typeof this.cachedTabWidth === "number") {
              return this.cachedTabWidth;
            }
            var counts = [];
            var lastIndent = 0;
            for (var line = 1, last2 = this.length; line <= last2; ++line) {
              var info = this.infos[line - 1];
              var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
              if (isOnlyWhitespace(sliced)) {
                continue;
              }
              var diff = Math.abs(info.indent - lastIndent);
              counts[diff] = ~~counts[diff] + 1;
              lastIndent = info.indent;
            }
            var maxCount = -1;
            var result2 = 2;
            for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
              if (hasOwn$5.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
                maxCount = counts[tabWidth];
                result2 = tabWidth;
              }
            }
            return this.cachedTabWidth = result2;
          };
          Lines2.prototype.startsWithComment = function() {
            if (this.infos.length === 0) {
              return false;
            }
            var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
            return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
          };
          Lines2.prototype.isOnlyWhitespace = function() {
            return isOnlyWhitespace(this.toString());
          };
          Lines2.prototype.isPrecededOnlyByWhitespace = function(pos) {
            var info = this.infos[pos.line - 1];
            var indent = Math.max(info.indent, 0);
            var diff = pos.column - indent;
            if (diff <= 0) {
              return true;
            }
            var start = info.sliceStart;
            var end = Math.min(start + diff, info.sliceEnd);
            var prefix2 = info.line.slice(start, end);
            return isOnlyWhitespace(prefix2);
          };
          Lines2.prototype.getLineLength = function(line) {
            var info = this.infos[line - 1];
            return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
          };
          Lines2.prototype.nextPos = function(pos, skipSpaces) {
            if (skipSpaces === void 0) {
              skipSpaces = false;
            }
            var l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);
            if (c < this.getLineLength(l)) {
              pos.column += 1;
              return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
            }
            if (l < this.length) {
              pos.line += 1;
              pos.column = 0;
              return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
            }
            return false;
          };
          Lines2.prototype.prevPos = function(pos, skipSpaces) {
            if (skipSpaces === void 0) {
              skipSpaces = false;
            }
            var l = pos.line, c = pos.column;
            if (c < 1) {
              l -= 1;
              if (l < 1)
                return false;
              c = this.getLineLength(l);
            } else {
              c = Math.min(c - 1, this.getLineLength(l));
            }
            pos.line = l;
            pos.column = c;
            return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
          };
          Lines2.prototype.firstPos = function() {
            return { line: 1, column: 0 };
          };
          Lines2.prototype.lastPos = function() {
            return {
              line: this.length,
              column: this.getLineLength(this.length)
            };
          };
          Lines2.prototype.skipSpaces = function(pos, backward, modifyInPlace) {
            if (backward === void 0) {
              backward = false;
            }
            if (modifyInPlace === void 0) {
              modifyInPlace = false;
            }
            if (pos) {
              pos = modifyInPlace ? pos : {
                line: pos.line,
                column: pos.column
              };
            } else if (backward) {
              pos = this.lastPos();
            } else {
              pos = this.firstPos();
            }
            if (backward) {
              while (this.prevPos(pos)) {
                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
                  return pos;
                }
              }
              return null;
            } else {
              while (isOnlyWhitespace(this.charAt(pos))) {
                if (!this.nextPos(pos)) {
                  return null;
                }
              }
              return pos;
            }
          };
          Lines2.prototype.trimLeft = function() {
            var pos = this.skipSpaces(this.firstPos(), false, true);
            return pos ? this.slice(pos) : emptyLines;
          };
          Lines2.prototype.trimRight = function() {
            var pos = this.skipSpaces(this.lastPos(), true, true);
            return pos ? this.slice(this.firstPos(), pos) : emptyLines;
          };
          Lines2.prototype.trim = function() {
            var start = this.skipSpaces(this.firstPos(), false, true);
            if (start === null) {
              return emptyLines;
            }
            var end = this.skipSpaces(this.lastPos(), true, true);
            if (end === null) {
              return emptyLines;
            }
            return this.slice(start, end);
          };
          Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
            if (startPos === void 0) {
              startPos = this.firstPos();
            }
            if (skipSpaces === void 0) {
              skipSpaces = false;
            }
            var pos = this.firstPos();
            if (startPos) {
              pos.line = startPos.line, pos.column = startPos.column;
            }
            if (skipSpaces && !this.skipSpaces(pos, false, true)) {
              return;
            }
            do
              callback.call(this, pos);
            while (this.nextPos(pos, skipSpaces));
          };
          Lines2.prototype.bootstrapSlice = function(start, end) {
            var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
            if (strings.length > 0) {
              strings.push(strings.pop().slice(0, end.column));
              strings[0] = strings[0].slice(start.column);
            }
            return fromString(strings.join("\n"));
          };
          Lines2.prototype.slice = function(start, end) {
            if (!end) {
              if (!start) {
                return this;
              }
              end = this.lastPos();
            }
            if (!start) {
              throw new Error("cannot slice with end but not start");
            }
            var sliced = this.infos.slice(start.line - 1, end.line);
            if (start.line === end.line) {
              sliced[0] = sliceInfo(sliced[0], start.column, end.column);
            } else {
              assert_1$5.default.ok(start.line < end.line);
              sliced[0] = sliceInfo(sliced[0], start.column);
              sliced.push(sliceInfo(sliced.pop(), 0, end.column));
            }
            var lines2 = new Lines2(sliced);
            if (this.mappings.length > 0) {
              var newMappings_4 = lines2.mappings;
              assert_1$5.default.strictEqual(newMappings_4.length, 0);
              this.mappings.forEach(function(mapping2) {
                var sliced2 = mapping2.slice(this, start, end);
                if (sliced2) {
                  newMappings_4.push(sliced2);
                }
              }, this);
            }
            return lines2;
          };
          Lines2.prototype.bootstrapSliceString = function(start, end, options2) {
            return this.slice(start, end).toString(options2);
          };
          Lines2.prototype.sliceString = function(start, end, options2) {
            if (start === void 0) {
              start = this.firstPos();
            }
            if (end === void 0) {
              end = this.lastPos();
            }
            options2 = options_1$2.normalize(options2);
            var parts = [];
            var _a = options2.tabWidth, tabWidth = _a === void 0 ? 2 : _a;
            for (var line = start.line; line <= end.line; ++line) {
              var info = this.infos[line - 1];
              if (line === start.line) {
                if (line === end.line) {
                  info = sliceInfo(info, start.column, end.column);
                } else {
                  info = sliceInfo(info, start.column);
                }
              } else if (line === end.line) {
                info = sliceInfo(info, 0, end.column);
              }
              var indent = Math.max(info.indent, 0);
              var before_1 = info.line.slice(0, info.sliceStart);
              if (options2.reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, options2.tabWidth) === indent) {
                parts.push(info.line.slice(0, info.sliceEnd));
                continue;
              }
              var tabs = 0;
              var spaces = indent;
              if (options2.useTabs) {
                tabs = Math.floor(indent / tabWidth);
                spaces -= tabs * tabWidth;
              }
              var result2 = "";
              if (tabs > 0) {
                result2 += new Array(tabs + 1).join("	");
              }
              if (spaces > 0) {
                result2 += new Array(spaces + 1).join(" ");
              }
              result2 += info.line.slice(info.sliceStart, info.sliceEnd);
              parts.push(result2);
            }
            return parts.join(options2.lineTerminator);
          };
          Lines2.prototype.isEmpty = function() {
            return this.length < 2 && this.getLineLength(1) < 1;
          };
          Lines2.prototype.join = function(elements) {
            var separator = this;
            var infos = [];
            var mappings = [];
            var prevInfo;
            function appendLines(linesOrNull) {
              if (linesOrNull === null) {
                return;
              }
              if (prevInfo) {
                var info = linesOrNull.infos[0];
                var indent = new Array(info.indent + 1).join(" ");
                var prevLine_1 = infos.length;
                var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
                prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
                prevInfo.locked = prevInfo.locked || info.locked;
                prevInfo.sliceEnd = prevInfo.line.length;
                if (linesOrNull.mappings.length > 0) {
                  linesOrNull.mappings.forEach(function(mapping2) {
                    mappings.push(mapping2.add(prevLine_1, prevColumn_1));
                  });
                }
              } else if (linesOrNull.mappings.length > 0) {
                mappings.push.apply(mappings, linesOrNull.mappings);
              }
              linesOrNull.infos.forEach(function(info2, i2) {
                if (!prevInfo || i2 > 0) {
                  prevInfo = __assign({}, info2);
                  infos.push(prevInfo);
                }
              });
            }
            function appendWithSeparator(linesOrNull, i2) {
              if (i2 > 0)
                appendLines(separator);
              appendLines(linesOrNull);
            }
            elements.map(function(elem) {
              var lines3 = fromString(elem);
              if (lines3.isEmpty())
                return null;
              return lines3;
            }).forEach(function(linesOrNull, i2) {
              if (separator.isEmpty()) {
                appendLines(linesOrNull);
              } else {
                appendWithSeparator(linesOrNull, i2);
              }
            });
            if (infos.length < 1)
              return emptyLines;
            var lines2 = new Lines2(infos);
            lines2.mappings = mappings;
            return lines2;
          };
          Lines2.prototype.concat = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var list2 = [this];
            list2.push.apply(list2, args);
            assert_1$5.default.strictEqual(list2.length, args.length + 1);
            return emptyLines.join(list2);
          };
          return Lines2;
        }()
      );
      lines.Lines = Lines;
      var fromStringCache = {};
      var hasOwn$5 = fromStringCache.hasOwnProperty;
      var maxCacheKeyLen = 10;
      function countSpaces(spaces, tabWidth) {
        var count = 0;
        var len = spaces.length;
        for (var i2 = 0; i2 < len; ++i2) {
          switch (spaces.charCodeAt(i2)) {
            case 9:
              assert_1$5.default.strictEqual(typeof tabWidth, "number");
              assert_1$5.default.ok(tabWidth > 0);
              var next = Math.ceil(count / tabWidth) * tabWidth;
              if (next === count) {
                count += tabWidth;
              } else {
                count = next;
              }
              break;
            case 11:
            case 12:
            case 13:
            case 65279:
              break;
            case 32:
            default:
              count += 1;
              break;
          }
        }
        return count;
      }
      lines.countSpaces = countSpaces;
      var leadingSpaceExp = /^\s*/;
      var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
      function fromString(string2, options2) {
        if (string2 instanceof Lines)
          return string2;
        string2 += "";
        var tabWidth = options2 && options2.tabWidth;
        var tabless = string2.indexOf("	") < 0;
        var cacheable = !options2 && tabless && string2.length <= maxCacheKeyLen;
        assert_1$5.default.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string2);
        if (cacheable && hasOwn$5.call(fromStringCache, string2))
          return fromStringCache[string2];
        var lines2 = new Lines(string2.split(lineTerminatorSeqExp).map(function(line) {
          var spaces = leadingSpaceExp.exec(line)[0];
          return {
            line,
            indent: countSpaces(spaces, tabWidth),
            // Boolean indicating whether this line can be reindented.
            locked: false,
            sliceStart: spaces.length,
            sliceEnd: line.length
          };
        }), options_1$2.normalize(options2).sourceFileName);
        if (cacheable)
          fromStringCache[string2] = lines2;
        return lines2;
      }
      lines.fromString = fromString;
      function isOnlyWhitespace(string2) {
        return !/\S/.test(string2);
      }
      function sliceInfo(info, startCol, endCol) {
        var sliceStart = info.sliceStart;
        var sliceEnd = info.sliceEnd;
        var indent = Math.max(info.indent, 0);
        var lineLength = indent + sliceEnd - sliceStart;
        if (typeof endCol === "undefined") {
          endCol = lineLength;
        }
        startCol = Math.max(startCol, 0);
        endCol = Math.min(endCol, lineLength);
        endCol = Math.max(endCol, startCol);
        if (endCol < indent) {
          indent = endCol;
          sliceEnd = sliceStart;
        } else {
          sliceEnd -= lineLength - endCol;
        }
        lineLength = endCol;
        lineLength -= startCol;
        if (startCol < indent) {
          indent -= startCol;
        } else {
          startCol -= indent;
          indent = 0;
          sliceStart += startCol;
        }
        assert_1$5.default.ok(indent >= 0);
        assert_1$5.default.ok(sliceStart <= sliceEnd);
        assert_1$5.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);
        if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
          return info;
        }
        return {
          line: info.line,
          indent,
          // A destructive slice always unlocks indentation.
          locked: false,
          sliceStart,
          sliceEnd
        };
      }
      function concat(elements) {
        return emptyLines.join(elements);
      }
      lines.concat = concat;
      var emptyLines = fromString("");
      var comments = {};
      var _private = {};
      var originalObject = Object;
      var originalDefProp = Object.defineProperty;
      var originalCreate = Object.create;
      function defProp(obj, name2, value) {
        if (originalDefProp)
          try {
            originalDefProp.call(originalObject, obj, name2, { value });
          } catch (definePropertyIsBrokenInIE8) {
            obj[name2] = value;
          }
        else {
          obj[name2] = value;
        }
      }
      function makeSafeToCall(fun) {
        if (fun) {
          defProp(fun, "call", fun.call);
          defProp(fun, "apply", fun.apply);
        }
        return fun;
      }
      makeSafeToCall(originalDefProp);
      makeSafeToCall(originalCreate);
      var hasOwn$4 = makeSafeToCall(Object.prototype.hasOwnProperty);
      var numToStr = makeSafeToCall(Number.prototype.toString);
      var strSlice = makeSafeToCall(String.prototype.slice);
      var cloner = function() {
      };
      function create(prototype) {
        if (originalCreate) {
          return originalCreate.call(originalObject, prototype);
        }
        cloner.prototype = prototype || null;
        return new cloner();
      }
      var rand = Math.random;
      var uniqueKeys = create(null);
      function makeUniqueKey() {
        do
          var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
        while (hasOwn$4.call(uniqueKeys, uniqueKey));
        return uniqueKeys[uniqueKey] = uniqueKey;
      }
      function internString(str2) {
        var obj = {};
        obj[str2] = true;
        return Object.keys(obj)[0];
      }
      _private.makeUniqueKey = makeUniqueKey;
      var originalGetOPNs = Object.getOwnPropertyNames;
      Object.getOwnPropertyNames = function getOwnPropertyNames(object2) {
        for (var names = originalGetOPNs(object2), src2 = 0, dst = 0, len = names.length; src2 < len; ++src2) {
          if (!hasOwn$4.call(uniqueKeys, names[src2])) {
            if (src2 > dst) {
              names[dst] = names[src2];
            }
            ++dst;
          }
        }
        names.length = dst;
        return names;
      };
      function defaultCreatorFn(object2) {
        return create(null);
      }
      function makeAccessor(secretCreatorFn) {
        var brand = makeUniqueKey();
        var passkey = create(null);
        secretCreatorFn = secretCreatorFn || defaultCreatorFn;
        function register(object2) {
          var secret;
          function vault(key, forget) {
            if (key === passkey) {
              return forget ? secret = null : secret || (secret = secretCreatorFn(object2));
            }
          }
          defProp(object2, brand, vault);
        }
        function accessor(object2) {
          if (!hasOwn$4.call(object2, brand))
            register(object2);
          return object2[brand](passkey);
        }
        accessor.forget = function(object2) {
          if (hasOwn$4.call(object2, brand))
            object2[brand](passkey, true);
        };
        return accessor;
      }
      _private.makeAccessor = makeAccessor;
      var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(comments, "__esModule", { value: true });
      var assert_1$4 = __importDefault$5(require$$0$4);
      var types$9 = __importStar$5(main$2);
      var n$2 = types$9.namedTypes;
      var isArray$5 = types$9.builtInTypes.array;
      var isObject$b = types$9.builtInTypes.object;
      var lines_1$2 = lines;
      var util_1$1 = util$c;
      var private_1 = _private;
      var childNodesCacheKey = private_1.makeUniqueKey();
      function getSortedChildNodes(node2, lines2, resultArray) {
        if (!node2) {
          return;
        }
        util_1$1.fixFaultyLocations(node2, lines2);
        if (resultArray) {
          if (n$2.Node.check(node2) && n$2.SourceLocation.check(node2.loc)) {
            for (var i2 = resultArray.length - 1; i2 >= 0; --i2) {
              if (util_1$1.comparePos(resultArray[i2].loc.end, node2.loc.start) <= 0) {
                break;
              }
            }
            resultArray.splice(i2 + 1, 0, node2);
            return;
          }
        } else if (node2[childNodesCacheKey]) {
          return node2[childNodesCacheKey];
        }
        var names;
        if (isArray$5.check(node2)) {
          names = Object.keys(node2);
        } else if (isObject$b.check(node2)) {
          names = types$9.getFieldNames(node2);
        } else {
          return;
        }
        if (!resultArray) {
          Object.defineProperty(node2, childNodesCacheKey, {
            value: resultArray = [],
            enumerable: false
          });
        }
        for (var i2 = 0, nameCount = names.length; i2 < nameCount; ++i2) {
          getSortedChildNodes(node2[names[i2]], lines2, resultArray);
        }
        return resultArray;
      }
      function decorateComment(node2, comment2, lines2) {
        var childNodes = getSortedChildNodes(node2, lines2);
        var left = 0, right = childNodes.length;
        while (left < right) {
          var middle = left + right >> 1;
          var child = childNodes[middle];
          if (util_1$1.comparePos(child.loc.start, comment2.loc.start) <= 0 && util_1$1.comparePos(comment2.loc.end, child.loc.end) <= 0) {
            decorateComment(comment2.enclosingNode = child, comment2, lines2);
            return;
          }
          if (util_1$1.comparePos(child.loc.end, comment2.loc.start) <= 0) {
            var precedingNode = child;
            left = middle + 1;
            continue;
          }
          if (util_1$1.comparePos(comment2.loc.end, child.loc.start) <= 0) {
            var followingNode = child;
            right = middle;
            continue;
          }
          throw new Error("Comment location overlaps with node location");
        }
        if (precedingNode) {
          comment2.precedingNode = precedingNode;
        }
        if (followingNode) {
          comment2.followingNode = followingNode;
        }
      }
      function attach(comments2, ast, lines2) {
        if (!isArray$5.check(comments2)) {
          return;
        }
        var tiesToBreak = [];
        comments2.forEach(function(comment2) {
          comment2.loc.lines = lines2;
          decorateComment(ast, comment2, lines2);
          var pn = comment2.precedingNode;
          var en = comment2.enclosingNode;
          var fn = comment2.followingNode;
          if (pn && fn) {
            var tieCount = tiesToBreak.length;
            if (tieCount > 0) {
              var lastTie = tiesToBreak[tieCount - 1];
              assert_1$4.default.strictEqual(lastTie.precedingNode === comment2.precedingNode, lastTie.followingNode === comment2.followingNode);
              if (lastTie.followingNode !== comment2.followingNode) {
                breakTies(tiesToBreak, lines2);
              }
            }
            tiesToBreak.push(comment2);
          } else if (pn) {
            breakTies(tiesToBreak, lines2);
            addTrailingComment(pn, comment2);
          } else if (fn) {
            breakTies(tiesToBreak, lines2);
            addLeadingComment(fn, comment2);
          } else if (en) {
            breakTies(tiesToBreak, lines2);
            addDanglingComment(en, comment2);
          } else {
            throw new Error("AST contains no nodes at all?");
          }
        });
        breakTies(tiesToBreak, lines2);
        comments2.forEach(function(comment2) {
          delete comment2.precedingNode;
          delete comment2.enclosingNode;
          delete comment2.followingNode;
        });
      }
      comments.attach = attach;
      function breakTies(tiesToBreak, lines2) {
        var tieCount = tiesToBreak.length;
        if (tieCount === 0) {
          return;
        }
        var pn = tiesToBreak[0].precedingNode;
        var fn = tiesToBreak[0].followingNode;
        var gapEndPos = fn.loc.start;
        for (var indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
          var comment2 = tiesToBreak[indexOfFirstLeadingComment - 1];
          assert_1$4.default.strictEqual(comment2.precedingNode, pn);
          assert_1$4.default.strictEqual(comment2.followingNode, fn);
          var gap = lines2.sliceString(comment2.loc.end, gapEndPos);
          if (/\S/.test(gap)) {
            break;
          }
          gapEndPos = comment2.loc.start;
        }
        while (indexOfFirstLeadingComment <= tieCount && (comment2 = tiesToBreak[indexOfFirstLeadingComment]) && // If the comment is a //-style comment and indented more
        // deeply than the node itself, reconsider it as trailing.
        (comment2.type === "Line" || comment2.type === "CommentLine") && comment2.loc.start.column > fn.loc.start.column) {
          ++indexOfFirstLeadingComment;
        }
        tiesToBreak.forEach(function(comment3, i2) {
          if (i2 < indexOfFirstLeadingComment) {
            addTrailingComment(pn, comment3);
          } else {
            addLeadingComment(fn, comment3);
          }
        });
        tiesToBreak.length = 0;
      }
      function addCommentHelper(node2, comment2) {
        var comments2 = node2.comments || (node2.comments = []);
        comments2.push(comment2);
      }
      function addLeadingComment(node2, comment2) {
        comment2.leading = true;
        comment2.trailing = false;
        addCommentHelper(node2, comment2);
      }
      function addDanglingComment(node2, comment2) {
        comment2.leading = false;
        comment2.trailing = false;
        addCommentHelper(node2, comment2);
      }
      function addTrailingComment(node2, comment2) {
        comment2.leading = false;
        comment2.trailing = true;
        addCommentHelper(node2, comment2);
      }
      function printLeadingComment(commentPath, print2) {
        var comment2 = commentPath.getValue();
        n$2.Comment.assert(comment2);
        var loc = comment2.loc;
        var lines2 = loc && loc.lines;
        var parts = [print2(commentPath)];
        if (comment2.trailing) {
          parts.push("\n");
        } else if (lines2 instanceof lines_1$2.Lines) {
          var trailingSpace = lines2.slice(loc.end, lines2.skipSpaces(loc.end) || lines2.lastPos());
          if (trailingSpace.length === 1) {
            parts.push(trailingSpace);
          } else {
            parts.push(new Array(trailingSpace.length).join("\n"));
          }
        } else {
          parts.push("\n");
        }
        return lines_1$2.concat(parts);
      }
      function printTrailingComment(commentPath, print2) {
        var comment2 = commentPath.getValue(commentPath);
        n$2.Comment.assert(comment2);
        var loc = comment2.loc;
        var lines2 = loc && loc.lines;
        var parts = [];
        if (lines2 instanceof lines_1$2.Lines) {
          var fromPos = lines2.skipSpaces(loc.start, true) || lines2.firstPos();
          var leadingSpace = lines2.slice(fromPos, loc.start);
          if (leadingSpace.length === 1) {
            parts.push(leadingSpace);
          } else {
            parts.push(new Array(leadingSpace.length).join("\n"));
          }
        }
        parts.push(print2(commentPath));
        return lines_1$2.concat(parts);
      }
      function printComments(path2, print2) {
        var value = path2.getValue();
        var innerLines = print2(path2);
        var comments2 = n$2.Node.check(value) && types$9.getFieldValue(value, "comments");
        if (!comments2 || comments2.length === 0) {
          return innerLines;
        }
        var leadingParts = [];
        var trailingParts = [innerLines];
        path2.each(function(commentPath) {
          var comment2 = commentPath.getValue();
          var leading = types$9.getFieldValue(comment2, "leading");
          var trailing = types$9.getFieldValue(comment2, "trailing");
          if (leading || trailing && !(n$2.Statement.check(value) || comment2.type === "Block" || comment2.type === "CommentBlock")) {
            leadingParts.push(printLeadingComment(commentPath, print2));
          } else if (trailing) {
            trailingParts.push(printTrailingComment(commentPath, print2));
          }
        }, "comments");
        leadingParts.push.apply(leadingParts, trailingParts);
        return lines_1$2.concat(leadingParts);
      }
      comments.printComments = printComments;
      var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(parser$5, "__esModule", { value: true });
      var assert_1$3 = __importDefault$4(require$$0$4);
      var types$8 = __importStar$4(main$2);
      var b = types$8.builders;
      var isObject$a = types$8.builtInTypes.object;
      var isArray$4 = types$8.builtInTypes.array;
      var options_1$1 = options;
      var lines_1$1 = lines;
      var comments_1$1 = comments;
      var util$5 = __importStar$4(util$c);
      function parse$k(source, options2) {
        options2 = options_1$1.normalize(options2);
        var lines2 = lines_1$1.fromString(source, options2);
        var sourceWithoutTabs = lines2.toString({
          tabWidth: options2.tabWidth,
          reuseWhitespace: false,
          useTabs: false
        });
        var comments2 = [];
        var ast = options2.parser.parse(sourceWithoutTabs, {
          jsx: true,
          loc: true,
          locations: true,
          range: options2.range,
          comment: true,
          onComment: comments2,
          tolerant: util$5.getOption(options2, "tolerant", true),
          ecmaVersion: 6,
          sourceType: util$5.getOption(options2, "sourceType", "module")
        });
        var tokens = Array.isArray(ast.tokens) ? ast.tokens : esprima.exports.tokenize(sourceWithoutTabs, {
          loc: true
        });
        delete ast.tokens;
        tokens.forEach(function(token) {
          if (typeof token.value !== "string") {
            token.value = lines2.sliceString(token.loc.start, token.loc.end);
          }
        });
        if (Array.isArray(ast.comments)) {
          comments2 = ast.comments;
          delete ast.comments;
        }
        if (ast.loc) {
          util$5.fixFaultyLocations(ast, lines2);
        } else {
          ast.loc = {
            start: lines2.firstPos(),
            end: lines2.lastPos()
          };
        }
        ast.loc.lines = lines2;
        ast.loc.indent = 0;
        var file;
        var program;
        if (ast.type === "Program") {
          program = ast;
          file = b.file(ast, options2.sourceFileName || null);
          file.loc = {
            start: lines2.firstPos(),
            end: lines2.lastPos(),
            lines: lines2,
            indent: 0
          };
        } else if (ast.type === "File") {
          file = ast;
          program = file.program;
        }
        if (options2.tokens) {
          file.tokens = tokens;
        }
        var trueProgramLoc = util$5.getTrueLoc({
          type: program.type,
          loc: program.loc,
          body: [],
          comments: comments2
        }, lines2);
        program.loc.start = trueProgramLoc.start;
        program.loc.end = trueProgramLoc.end;
        comments_1$1.attach(comments2, program.body.length ? file.program : file, lines2);
        return new TreeCopier(lines2, tokens).copy(file);
      }
      parser$5.parse = parse$k;
      var TreeCopier = function TreeCopier2(lines2, tokens) {
        assert_1$3.default.ok(this instanceof TreeCopier2);
        this.lines = lines2;
        this.tokens = tokens;
        this.startTokenIndex = 0;
        this.endTokenIndex = tokens.length;
        this.indent = 0;
        this.seen = /* @__PURE__ */ new Map();
      };
      var TCp = TreeCopier.prototype;
      TCp.copy = function(node2) {
        if (this.seen.has(node2)) {
          return this.seen.get(node2);
        }
        if (isArray$4.check(node2)) {
          var copy = new Array(node2.length);
          this.seen.set(node2, copy);
          node2.forEach(function(item, i3) {
            copy[i3] = this.copy(item);
          }, this);
          return copy;
        }
        if (!isObject$a.check(node2)) {
          return node2;
        }
        util$5.fixFaultyLocations(node2, this.lines);
        var copy = Object.create(Object.getPrototypeOf(node2), {
          original: {
            value: node2,
            configurable: false,
            enumerable: false,
            writable: true
          }
        });
        this.seen.set(node2, copy);
        var loc = node2.loc;
        var oldIndent = this.indent;
        var newIndent = oldIndent;
        var oldStartTokenIndex = this.startTokenIndex;
        var oldEndTokenIndex = this.endTokenIndex;
        if (loc) {
          if (node2.type === "Block" || node2.type === "Line" || node2.type === "CommentBlock" || node2.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
            newIndent = this.indent = loc.start.column;
          }
          loc.lines = this.lines;
          loc.tokens = this.tokens;
          loc.indent = newIndent;
          this.findTokenRange(loc);
        }
        var keys2 = Object.keys(node2);
        var keyCount = keys2.length;
        for (var i2 = 0; i2 < keyCount; ++i2) {
          var key = keys2[i2];
          if (key === "loc") {
            copy[key] = node2[key];
          } else if (key === "tokens" && node2.type === "File") {
            copy[key] = node2[key];
          } else {
            copy[key] = this.copy(node2[key]);
          }
        }
        this.indent = oldIndent;
        this.startTokenIndex = oldStartTokenIndex;
        this.endTokenIndex = oldEndTokenIndex;
        return copy;
      };
      TCp.findTokenRange = function(loc) {
        while (this.startTokenIndex > 0) {
          var token = loc.tokens[this.startTokenIndex];
          if (util$5.comparePos(loc.start, token.loc.start) < 0) {
            --this.startTokenIndex;
          } else
            break;
        }
        while (this.endTokenIndex < loc.tokens.length) {
          var token = loc.tokens[this.endTokenIndex];
          if (util$5.comparePos(token.loc.end, loc.end) < 0) {
            ++this.endTokenIndex;
          } else
            break;
        }
        while (this.startTokenIndex < this.endTokenIndex) {
          var token = loc.tokens[this.startTokenIndex];
          if (util$5.comparePos(token.loc.start, loc.start) < 0) {
            ++this.startTokenIndex;
          } else
            break;
        }
        loc.start.token = this.startTokenIndex;
        while (this.endTokenIndex > this.startTokenIndex) {
          var token = loc.tokens[this.endTokenIndex - 1];
          if (util$5.comparePos(loc.end, token.loc.end) < 0) {
            --this.endTokenIndex;
          } else
            break;
        }
        loc.end.token = this.endTokenIndex;
      };
      var printer = {};
      var patcher = {};
      var fastPath = {};
      var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(fastPath, "__esModule", { value: true });
      var assert_1$2 = __importDefault$3(require$$0$4);
      var types$7 = __importStar$3(main$2);
      var n$1 = types$7.namedTypes;
      var isArray$3 = types$7.builtInTypes.array;
      var isNumber = types$7.builtInTypes.number;
      var util$4 = __importStar$3(util$c);
      var FastPath = function FastPath2(value) {
        assert_1$2.default.ok(this instanceof FastPath2);
        this.stack = [value];
      };
      var FPp = FastPath.prototype;
      FastPath.from = function(obj) {
        if (obj instanceof FastPath) {
          return obj.copy();
        }
        if (obj instanceof types$7.NodePath) {
          var copy = Object.create(FastPath.prototype);
          var stack = [obj.value];
          for (var pp; pp = obj.parentPath; obj = pp)
            stack.push(obj.name, pp.value);
          copy.stack = stack.reverse();
          return copy;
        }
        return new FastPath(obj);
      };
      FPp.copy = function copy() {
        var copy2 = Object.create(FastPath.prototype);
        copy2.stack = this.stack.slice(0);
        return copy2;
      };
      FPp.getName = function getName2() {
        var s = this.stack;
        var len = s.length;
        if (len > 1) {
          return s[len - 2];
        }
        return null;
      };
      FPp.getValue = function getValue() {
        var s = this.stack;
        return s[s.length - 1];
      };
      FPp.valueIsDuplicate = function() {
        var s = this.stack;
        var valueIndex = s.length - 1;
        return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
      };
      function getNodeHelper(path2, count) {
        var s = path2.stack;
        for (var i2 = s.length - 1; i2 >= 0; i2 -= 2) {
          var value = s[i2];
          if (n$1.Node.check(value) && --count < 0) {
            return value;
          }
        }
        return null;
      }
      FPp.getNode = function getNode(count) {
        if (count === void 0) {
          count = 0;
        }
        return getNodeHelper(this, ~~count);
      };
      FPp.getParentNode = function getParentNode(count) {
        if (count === void 0) {
          count = 0;
        }
        return getNodeHelper(this, ~~count + 1);
      };
      FPp.getRootValue = function getRootValue() {
        var s = this.stack;
        if (s.length % 2 === 0) {
          return s[1];
        }
        return s[0];
      };
      FPp.call = function call(callback) {
        var s = this.stack;
        var origLen = s.length;
        var value = s[origLen - 1];
        var argc = arguments.length;
        for (var i2 = 1; i2 < argc; ++i2) {
          var name2 = arguments[i2];
          value = value[name2];
          s.push(name2, value);
        }
        var result2 = callback(this);
        s.length = origLen;
        return result2;
      };
      FPp.each = function each(callback) {
        var s = this.stack;
        var origLen = s.length;
        var value = s[origLen - 1];
        var argc = arguments.length;
        for (var i2 = 1; i2 < argc; ++i2) {
          var name2 = arguments[i2];
          value = value[name2];
          s.push(name2, value);
        }
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (i2 in value) {
            s.push(i2, value[i2]);
            callback(this);
            s.length -= 2;
          }
        }
        s.length = origLen;
      };
      FPp.map = function map2(callback) {
        var s = this.stack;
        var origLen = s.length;
        var value = s[origLen - 1];
        var argc = arguments.length;
        for (var i2 = 1; i2 < argc; ++i2) {
          var name2 = arguments[i2];
          value = value[name2];
          s.push(name2, value);
        }
        var result2 = new Array(value.length);
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (i2 in value) {
            s.push(i2, value[i2]);
            result2[i2] = callback(this, i2);
            s.length -= 2;
          }
        }
        s.length = origLen;
        return result2;
      };
      FPp.hasParens = function() {
        var node2 = this.getNode();
        var prevToken = this.getPrevToken(node2);
        if (!prevToken) {
          return false;
        }
        var nextToken = this.getNextToken(node2);
        if (!nextToken) {
          return false;
        }
        if (prevToken.value === "(") {
          if (nextToken.value === ")") {
            return true;
          }
          var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);
          if (justNeedsOpeningParen) {
            return true;
          }
        }
        return false;
      };
      FPp.getPrevToken = function(node2) {
        node2 = node2 || this.getNode();
        var loc = node2 && node2.loc;
        var tokens = loc && loc.tokens;
        if (tokens && loc.start.token > 0) {
          var token = tokens[loc.start.token - 1];
          if (token) {
            var rootLoc = this.getRootValue().loc;
            if (util$4.comparePos(rootLoc.start, token.loc.start) <= 0) {
              return token;
            }
          }
        }
        return null;
      };
      FPp.getNextToken = function(node2) {
        node2 = node2 || this.getNode();
        var loc = node2 && node2.loc;
        var tokens = loc && loc.tokens;
        if (tokens && loc.end.token < tokens.length) {
          var token = tokens[loc.end.token];
          if (token) {
            var rootLoc = this.getRootValue().loc;
            if (util$4.comparePos(token.loc.end, rootLoc.end) <= 0) {
              return token;
            }
          }
        }
        return null;
      };
      FPp.needsParens = function(assumeExpressionContext) {
        var node2 = this.getNode();
        if (node2.type === "AssignmentExpression" && node2.left.type === "ObjectPattern") {
          return true;
        }
        var parent = this.getParentNode();
        if (!parent) {
          return false;
        }
        var name2 = this.getName();
        if (this.getValue() !== node2) {
          return false;
        }
        if (n$1.Statement.check(node2)) {
          return false;
        }
        if (node2.type === "Identifier") {
          return false;
        }
        if (parent.type === "ParenthesizedExpression") {
          return false;
        }
        switch (node2.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && name2 === "object" && parent.object === node2;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return name2 === "callee" && parent.callee === node2;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return true;
              case "MemberExpression":
                return name2 === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression":
                var po = parent.operator;
                var pp = PRECEDENCE[po];
                var no = node2.operator;
                var np = PRECEDENCE[no];
                if (pp > np) {
                  return true;
                }
                if (pp === np && name2 === "right") {
                  assert_1$2.default.strictEqual(parent.right, node2);
                  return true;
                }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ReturnStatement":
                return false;
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return name2 !== "expression";
              default:
                return true;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return true;
              default:
                return false;
            }
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return parent.type === "NullableTypeAnnotation";
          case "Literal":
            return parent.type === "MemberExpression" && isNumber.check(node2.value) && name2 === "object" && parent.object === node2;
          case "NumericLiteral":
            return parent.type === "MemberExpression" && name2 === "object" && parent.object === node2;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return true;
              case "CallExpression":
              case "NewExpression":
                return name2 === "callee" && parent.callee === node2;
              case "ConditionalExpression":
                return name2 === "test" && parent.test === node2;
              case "MemberExpression":
                return name2 === "object" && parent.object === node2;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            if (n$1.CallExpression.check(parent) && name2 === "callee") {
              return true;
            }
            if (n$1.MemberExpression.check(parent) && name2 === "object") {
              return true;
            }
            return isBinary(parent);
          case "ObjectExpression":
            if (parent.type === "ArrowFunctionExpression" && name2 === "body") {
              return true;
            }
            break;
          case "TSAsExpression":
            if (parent.type === "ArrowFunctionExpression" && name2 === "body" && node2.expression.type === "ObjectExpression") {
              return true;
            }
            break;
          case "CallExpression":
            if (name2 === "declaration" && n$1.ExportDefaultDeclaration.check(parent) && n$1.FunctionExpression.check(node2.callee)) {
              return true;
            }
        }
        if (parent.type === "NewExpression" && name2 === "callee" && parent.callee === node2) {
          return containsCallExpression(node2);
        }
        if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {
          return true;
        }
        return false;
      };
      function isBinary(node2) {
        return n$1.BinaryExpression.check(node2) || n$1.LogicalExpression.check(node2);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"],
        ["**"]
      ].forEach(function(tier, i2) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i2;
        });
      });
      function containsCallExpression(node2) {
        if (n$1.CallExpression.check(node2)) {
          return true;
        }
        if (isArray$3.check(node2)) {
          return node2.some(containsCallExpression);
        }
        if (n$1.Node.check(node2)) {
          return types$7.someField(node2, function(_name, child) {
            return containsCallExpression(child);
          });
        }
        return false;
      }
      FPp.canBeFirstInStatement = function() {
        var node2 = this.getNode();
        if (n$1.FunctionExpression.check(node2)) {
          return false;
        }
        if (n$1.ObjectExpression.check(node2)) {
          return false;
        }
        if (n$1.ClassExpression.check(node2)) {
          return false;
        }
        return true;
      };
      FPp.firstInStatement = function() {
        var s = this.stack;
        var parentName, parent;
        var childName, child;
        for (var i2 = s.length - 1; i2 >= 0; i2 -= 2) {
          if (n$1.Node.check(s[i2])) {
            childName = parentName;
            child = parent;
            parentName = s[i2 - 1];
            parent = s[i2];
          }
          if (!parent || !child) {
            continue;
          }
          if (n$1.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
            assert_1$2.default.strictEqual(parent.body[0], child);
            return true;
          }
          if (n$1.ExpressionStatement.check(parent) && childName === "expression") {
            assert_1$2.default.strictEqual(parent.expression, child);
            return true;
          }
          if (n$1.AssignmentExpression.check(parent) && childName === "left") {
            assert_1$2.default.strictEqual(parent.left, child);
            return true;
          }
          if (n$1.ArrowFunctionExpression.check(parent) && childName === "body") {
            assert_1$2.default.strictEqual(parent.body, child);
            return true;
          }
          if (n$1.SequenceExpression.check(parent) && parentName === "expressions" && childName === 0) {
            assert_1$2.default.strictEqual(parent.expressions[0], child);
            continue;
          }
          if (n$1.CallExpression.check(parent) && childName === "callee") {
            assert_1$2.default.strictEqual(parent.callee, child);
            continue;
          }
          if (n$1.MemberExpression.check(parent) && childName === "object") {
            assert_1$2.default.strictEqual(parent.object, child);
            continue;
          }
          if (n$1.ConditionalExpression.check(parent) && childName === "test") {
            assert_1$2.default.strictEqual(parent.test, child);
            continue;
          }
          if (isBinary(parent) && childName === "left") {
            assert_1$2.default.strictEqual(parent.left, child);
            continue;
          }
          if (n$1.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
            assert_1$2.default.strictEqual(parent.argument, child);
            continue;
          }
          return false;
        }
        return true;
      };
      fastPath.default = FastPath;
      var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(patcher, "__esModule", { value: true });
      var assert_1$1 = __importDefault$2(require$$0$4);
      var linesModule = __importStar$2(lines);
      var types$6 = __importStar$2(main$2);
      var Printable = types$6.namedTypes.Printable;
      var Expression = types$6.namedTypes.Expression;
      var ReturnStatement = types$6.namedTypes.ReturnStatement;
      var SourceLocation$1 = types$6.namedTypes.SourceLocation;
      var util_1 = util$c;
      var fast_path_1$1 = __importDefault$2(fastPath);
      var isObject$9 = types$6.builtInTypes.object;
      var isArray$2 = types$6.builtInTypes.array;
      var isString$4 = types$6.builtInTypes.string;
      var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
      var Patcher = function Patcher2(lines2) {
        assert_1$1.default.ok(this instanceof Patcher2);
        assert_1$1.default.ok(lines2 instanceof linesModule.Lines);
        var self2 = this, replacements = [];
        self2.replace = function(loc, lines3) {
          if (isString$4.check(lines3))
            lines3 = linesModule.fromString(lines3);
          replacements.push({
            lines: lines3,
            start: loc.start,
            end: loc.end
          });
        };
        self2.get = function(loc) {
          loc = loc || {
            start: { line: 1, column: 0 },
            end: {
              line: lines2.length,
              column: lines2.getLineLength(lines2.length)
            }
          };
          var sliceFrom = loc.start, toConcat = [];
          function pushSlice(from2, to) {
            assert_1$1.default.ok(util_1.comparePos(from2, to) <= 0);
            toConcat.push(lines2.slice(from2, to));
          }
          replacements.sort(function(a, b2) {
            return util_1.comparePos(a.start, b2.start);
          }).forEach(function(rep) {
            if (util_1.comparePos(sliceFrom, rep.start) > 0)
              ;
            else {
              pushSlice(sliceFrom, rep.start);
              toConcat.push(rep.lines);
              sliceFrom = rep.end;
            }
          });
          pushSlice(sliceFrom, loc.end);
          return linesModule.concat(toConcat);
        };
      };
      patcher.Patcher = Patcher;
      var Pp = Patcher.prototype;
      Pp.tryToReprintComments = function(newNode, oldNode, print2) {
        var patcher2 = this;
        if (!newNode.comments && !oldNode.comments) {
          return true;
        }
        var newPath = fast_path_1$1.default.from(newNode);
        var oldPath = fast_path_1$1.default.from(oldNode);
        newPath.stack.push("comments", getSurroundingComments(newNode));
        oldPath.stack.push("comments", getSurroundingComments(oldNode));
        var reprints = [];
        var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
        if (ableToReprintComments && reprints.length > 0) {
          reprints.forEach(function(reprint) {
            var oldComment = reprint.oldPath.getValue();
            assert_1$1.default.ok(oldComment.leading || oldComment.trailing);
            patcher2.replace(
              oldComment.loc,
              // Comments can't have .comments, so it doesn't matter whether we
              // print with comments or without.
              print2(reprint.newPath).indentTail(oldComment.loc.indent)
            );
          });
        }
        return ableToReprintComments;
      };
      function getSurroundingComments(node2) {
        var result2 = [];
        if (node2.comments && node2.comments.length > 0) {
          node2.comments.forEach(function(comment2) {
            if (comment2.leading || comment2.trailing) {
              result2.push(comment2);
            }
          });
        }
        return result2;
      }
      Pp.deleteComments = function(node2) {
        if (!node2.comments) {
          return;
        }
        var patcher2 = this;
        node2.comments.forEach(function(comment2) {
          if (comment2.leading) {
            patcher2.replace({
              start: comment2.loc.start,
              end: node2.loc.lines.skipSpaces(comment2.loc.end, false, false)
            }, "");
          } else if (comment2.trailing) {
            patcher2.replace({
              start: node2.loc.lines.skipSpaces(comment2.loc.start, true, false),
              end: comment2.loc.end
            }, "");
          }
        });
      };
      function getReprinter(path2) {
        assert_1$1.default.ok(path2 instanceof fast_path_1$1.default);
        var node2 = path2.getValue();
        if (!Printable.check(node2))
          return;
        var orig = node2.original;
        var origLoc = orig && orig.loc;
        var lines2 = origLoc && origLoc.lines;
        var reprints = [];
        if (!lines2 || !findReprints(path2, reprints))
          return;
        return function(print2) {
          var patcher2 = new Patcher(lines2);
          reprints.forEach(function(reprint) {
            var newNode = reprint.newPath.getValue();
            var oldNode = reprint.oldPath.getValue();
            SourceLocation$1.assert(oldNode.loc, true);
            var needToPrintNewPathWithComments = !patcher2.tryToReprintComments(newNode, oldNode, print2);
            if (needToPrintNewPathWithComments) {
              patcher2.deleteComments(oldNode);
            }
            var newLines = print2(reprint.newPath, {
              includeComments: needToPrintNewPathWithComments,
              // If the oldNode we're replacing already had parentheses, we may
              // not need to print the new node with any extra parentheses,
              // because the existing parentheses will suffice. However, if the
              // newNode has a different type than the oldNode, let the printer
              // decide if reprint.newPath needs parentheses, as usual.
              avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
            }).indentTail(oldNode.loc.indent);
            var nls = needsLeadingSpace(lines2, oldNode.loc, newLines);
            var nts = needsTrailingSpace(lines2, oldNode.loc, newLines);
            if (nls || nts) {
              var newParts = [];
              nls && newParts.push(" ");
              newParts.push(newLines);
              nts && newParts.push(" ");
              newLines = linesModule.concat(newParts);
            }
            patcher2.replace(oldNode.loc, newLines);
          });
          var patchedLines = patcher2.get(origLoc).indentTail(-orig.loc.indent);
          if (path2.needsParens()) {
            return linesModule.concat(["(", patchedLines, ")"]);
          }
          return patchedLines;
        };
      }
      patcher.getReprinter = getReprinter;
      function needsLeadingSpace(oldLines, oldLoc, newLines) {
        var posBeforeOldLoc = util_1.copyPos(oldLoc.start);
        var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
        var newFirstChar = newLines.charAt(newLines.firstPos());
        return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
      }
      function needsTrailingSpace(oldLines, oldLoc, newLines) {
        var charAfterOldLoc = oldLines.charAt(oldLoc.end);
        var newLastPos = newLines.lastPos();
        var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
        return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
      }
      function findReprints(newPath, reprints) {
        var newNode = newPath.getValue();
        Printable.assert(newNode);
        var oldNode = newNode.original;
        Printable.assert(oldNode);
        assert_1$1.default.deepEqual(reprints, []);
        if (newNode.type !== oldNode.type) {
          return false;
        }
        var oldPath = new fast_path_1$1.default(oldNode);
        var canReprint = findChildReprints(newPath, oldPath, reprints);
        if (!canReprint) {
          reprints.length = 0;
        }
        return canReprint;
      }
      function findAnyReprints(newPath, oldPath, reprints) {
        var newNode = newPath.getValue();
        var oldNode = oldPath.getValue();
        if (newNode === oldNode)
          return true;
        if (isArray$2.check(newNode))
          return findArrayReprints(newPath, oldPath, reprints);
        if (isObject$9.check(newNode))
          return findObjectReprints(newPath, oldPath, reprints);
        return false;
      }
      function findArrayReprints(newPath, oldPath, reprints) {
        var newNode = newPath.getValue();
        var oldNode = oldPath.getValue();
        if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
          return true;
        }
        isArray$2.assert(newNode);
        var len = newNode.length;
        if (!(isArray$2.check(oldNode) && oldNode.length === len))
          return false;
        for (var i2 = 0; i2 < len; ++i2) {
          newPath.stack.push(i2, newNode[i2]);
          oldPath.stack.push(i2, oldNode[i2]);
          var canReprint = findAnyReprints(newPath, oldPath, reprints);
          newPath.stack.length -= 2;
          oldPath.stack.length -= 2;
          if (!canReprint) {
            return false;
          }
        }
        return true;
      }
      function findObjectReprints(newPath, oldPath, reprints) {
        var newNode = newPath.getValue();
        isObject$9.assert(newNode);
        if (newNode.original === null) {
          return false;
        }
        var oldNode = oldPath.getValue();
        if (!isObject$9.check(oldNode))
          return false;
        if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
          return true;
        }
        if (Printable.check(newNode)) {
          if (!Printable.check(oldNode)) {
            return false;
          }
          var newParentNode = newPath.getParentNode();
          var oldParentNode = oldPath.getParentNode();
          if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
            var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
            var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
            if (!oldNeedsParens && newNeedParens) {
              return false;
            }
          }
          if (newNode.type === oldNode.type) {
            var childReprints = [];
            if (findChildReprints(newPath, oldPath, childReprints)) {
              reprints.push.apply(reprints, childReprints);
            } else if (oldNode.loc) {
              reprints.push({
                oldPath: oldPath.copy(),
                newPath: newPath.copy()
              });
            } else {
              return false;
            }
            return true;
          }
          if (Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be
          // able to reprint it.
          oldNode.loc) {
            reprints.push({
              oldPath: oldPath.copy(),
              newPath: newPath.copy()
            });
            return true;
          }
          return false;
        }
        return findChildReprints(newPath, oldPath, reprints);
      }
      function findChildReprints(newPath, oldPath, reprints) {
        var newNode = newPath.getValue();
        var oldNode = oldPath.getValue();
        isObject$9.assert(newNode);
        isObject$9.assert(oldNode);
        if (newNode.original === null) {
          return false;
        }
        if (newPath.needsParens() && !oldPath.hasParens()) {
          return false;
        }
        var keys2 = util_1.getUnionOfKeys(oldNode, newNode);
        if (oldNode.type === "File" || newNode.type === "File") {
          delete keys2.tokens;
        }
        delete keys2.loc;
        var originalReprintCount = reprints.length;
        for (var k in keys2) {
          if (k.charAt(0) === "_") {
            continue;
          }
          newPath.stack.push(k, types$6.getFieldValue(newNode, k));
          oldPath.stack.push(k, types$6.getFieldValue(oldNode, k));
          var canReprint = findAnyReprints(newPath, oldPath, reprints);
          newPath.stack.length -= 2;
          oldPath.stack.length -= 2;
          if (!canReprint) {
            return false;
          }
        }
        if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {
          return false;
        }
        return true;
      }
      var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(printer, "__esModule", { value: true });
      var assert_1 = __importDefault$1(require$$0$4);
      var comments_1 = comments;
      var lines_1 = lines;
      var options_1 = options;
      var patcher_1 = patcher;
      var types$5 = __importStar$1(main$2);
      var namedTypes = types$5.namedTypes;
      var isString$3 = types$5.builtInTypes.string;
      var isObject$8 = types$5.builtInTypes.object;
      var fast_path_1 = __importDefault$1(fastPath);
      var util$3 = __importStar$1(util$c);
      var PrintResult = function PrintResult2(code2, sourceMap2) {
        assert_1.default.ok(this instanceof PrintResult2);
        isString$3.assert(code2);
        this.code = code2;
        if (sourceMap2) {
          isObject$8.assert(sourceMap2);
          this.map = sourceMap2;
        }
      };
      var PRp = PrintResult.prototype;
      var warnedAboutToString = false;
      PRp.toString = function() {
        if (!warnedAboutToString) {
          console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.");
          warnedAboutToString = true;
        }
        return this.code;
      };
      var emptyPrintResult = new PrintResult("");
      var Printer = function Printer2(config2) {
        assert_1.default.ok(this instanceof Printer2);
        var explicitTabWidth = config2 && config2.tabWidth;
        config2 = options_1.normalize(config2);
        config2.sourceFileName = null;
        function makePrintFunctionWith(options2, overrides) {
          options2 = Object.assign({}, options2, overrides);
          return function(path2) {
            return print2(path2, options2);
          };
        }
        function print2(path2, options2) {
          assert_1.default.ok(path2 instanceof fast_path_1.default);
          options2 = options2 || {};
          if (options2.includeComments) {
            return comments_1.printComments(path2, makePrintFunctionWith(options2, {
              includeComments: false
            }));
          }
          var oldTabWidth = config2.tabWidth;
          if (!explicitTabWidth) {
            var loc = path2.getNode().loc;
            if (loc && loc.lines && loc.lines.guessTabWidth) {
              config2.tabWidth = loc.lines.guessTabWidth();
            }
          }
          var reprinter = patcher_1.getReprinter(path2);
          var lines2 = reprinter ? reprinter(print2) : genericPrint(path2, config2, options2, makePrintFunctionWith(options2, {
            includeComments: true,
            avoidRootParens: false
          }));
          config2.tabWidth = oldTabWidth;
          return lines2;
        }
        this.print = function(ast) {
          if (!ast) {
            return emptyPrintResult;
          }
          var lines2 = print2(fast_path_1.default.from(ast), {
            includeComments: true,
            avoidRootParens: false
          });
          return new PrintResult(lines2.toString(config2), util$3.composeSourceMaps(config2.inputSourceMap, lines2.getSourceMap(config2.sourceMapName, config2.sourceRoot)));
        };
        this.printGenerically = function(ast) {
          if (!ast) {
            return emptyPrintResult;
          }
          function printGenerically(path3) {
            return comments_1.printComments(path3, function(path4) {
              return genericPrint(path4, config2, {
                includeComments: true,
                avoidRootParens: false
              }, printGenerically);
            });
          }
          var path2 = fast_path_1.default.from(ast);
          var oldReuseWhitespace = config2.reuseWhitespace;
          config2.reuseWhitespace = false;
          var pr = new PrintResult(printGenerically(path2).toString(config2));
          config2.reuseWhitespace = oldReuseWhitespace;
          return pr;
        };
      };
      printer.Printer = Printer;
      function genericPrint(path2, config2, options2, printPath) {
        assert_1.default.ok(path2 instanceof fast_path_1.default);
        var node2 = path2.getValue();
        var parts = [];
        var linesWithoutParens = genericPrintNoParens(path2, config2, printPath);
        if (!node2 || linesWithoutParens.isEmpty()) {
          return linesWithoutParens;
        }
        var shouldAddParens = false;
        var decoratorsLines = printDecorators(path2, printPath);
        if (decoratorsLines.isEmpty()) {
          if (!options2.avoidRootParens) {
            shouldAddParens = path2.needsParens();
          }
        } else {
          parts.push(decoratorsLines);
        }
        if (shouldAddParens) {
          parts.unshift("(");
        }
        parts.push(linesWithoutParens);
        if (shouldAddParens) {
          parts.push(")");
        }
        return lines_1.concat(parts);
      }
      function genericPrintNoParens(path2, options2, print2) {
        var n2 = path2.getValue();
        if (!n2) {
          return lines_1.fromString("");
        }
        if (typeof n2 === "string") {
          return lines_1.fromString(n2, options2);
        }
        namedTypes.Printable.assert(n2);
        var parts = [];
        switch (n2.type) {
          case "File":
            return path2.call(print2, "program");
          case "Program":
            if (n2.directives) {
              path2.each(function(childPath) {
                parts.push(print2(childPath), ";\n");
              }, "directives");
            }
            if (n2.interpreter) {
              parts.push(path2.call(print2, "interpreter"));
            }
            parts.push(path2.call(function(bodyPath) {
              return printStatementSequence(bodyPath, options2, print2);
            }, "body"));
            return lines_1.concat(parts);
          case "Noop":
          case "EmptyStatement":
            return lines_1.fromString("");
          case "ExpressionStatement":
            return lines_1.concat([path2.call(print2, "expression"), ";"]);
          case "ParenthesizedExpression":
            return lines_1.concat(["(", path2.call(print2, "expression"), ")"]);
          case "BinaryExpression":
          case "LogicalExpression":
          case "AssignmentExpression":
            return lines_1.fromString(" ").join([
              path2.call(print2, "left"),
              n2.operator,
              path2.call(print2, "right")
            ]);
          case "AssignmentPattern":
            return lines_1.concat([
              path2.call(print2, "left"),
              " = ",
              path2.call(print2, "right")
            ]);
          case "MemberExpression":
          case "OptionalMemberExpression":
            parts.push(path2.call(print2, "object"));
            var property = path2.call(print2, "property");
            var optional = n2.type === "OptionalMemberExpression" && n2.optional;
            if (n2.computed) {
              parts.push(optional ? "?.[" : "[", property, "]");
            } else {
              parts.push(optional ? "?." : ".", property);
            }
            return lines_1.concat(parts);
          case "MetaProperty":
            return lines_1.concat([
              path2.call(print2, "meta"),
              ".",
              path2.call(print2, "property")
            ]);
          case "BindExpression":
            if (n2.object) {
              parts.push(path2.call(print2, "object"));
            }
            parts.push("::", path2.call(print2, "callee"));
            return lines_1.concat(parts);
          case "Path":
            return lines_1.fromString(".").join(n2.body);
          case "Identifier":
            return lines_1.concat([
              lines_1.fromString(n2.name, options2),
              n2.optional ? "?" : "",
              path2.call(print2, "typeAnnotation")
            ]);
          case "SpreadElement":
          case "SpreadElementPattern":
          case "RestProperty":
          case "SpreadProperty":
          case "SpreadPropertyPattern":
          case "ObjectTypeSpreadProperty":
          case "RestElement":
            return lines_1.concat([
              "...",
              path2.call(print2, "argument"),
              path2.call(print2, "typeAnnotation")
            ]);
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "TSDeclareFunction":
            if (n2.declare) {
              parts.push("declare ");
            }
            if (n2.async) {
              parts.push("async ");
            }
            parts.push("function");
            if (n2.generator)
              parts.push("*");
            if (n2.id) {
              parts.push(" ", path2.call(print2, "id"), path2.call(print2, "typeParameters"));
            } else {
              if (n2.typeParameters) {
                parts.push(path2.call(print2, "typeParameters"));
              }
            }
            parts.push("(", printFunctionParams(path2, options2, print2), ")", path2.call(print2, "returnType"));
            if (n2.body) {
              parts.push(" ", path2.call(print2, "body"));
            }
            return lines_1.concat(parts);
          case "ArrowFunctionExpression":
            if (n2.async) {
              parts.push("async ");
            }
            if (n2.typeParameters) {
              parts.push(path2.call(print2, "typeParameters"));
            }
            if (!options2.arrowParensAlways && n2.params.length === 1 && !n2.rest && n2.params[0].type === "Identifier" && !n2.params[0].typeAnnotation && !n2.returnType) {
              parts.push(path2.call(print2, "params", 0));
            } else {
              parts.push("(", printFunctionParams(path2, options2, print2), ")", path2.call(print2, "returnType"));
            }
            parts.push(" => ", path2.call(print2, "body"));
            return lines_1.concat(parts);
          case "MethodDefinition":
            return printMethod(path2, options2, print2);
          case "YieldExpression":
            parts.push("yield");
            if (n2.delegate)
              parts.push("*");
            if (n2.argument)
              parts.push(" ", path2.call(print2, "argument"));
            return lines_1.concat(parts);
          case "AwaitExpression":
            parts.push("await");
            if (n2.all)
              parts.push("*");
            if (n2.argument)
              parts.push(" ", path2.call(print2, "argument"));
            return lines_1.concat(parts);
          case "ModuleDeclaration":
            parts.push("module", path2.call(print2, "id"));
            if (n2.source) {
              assert_1.default.ok(!n2.body);
              parts.push("from", path2.call(print2, "source"));
            } else {
              parts.push(path2.call(print2, "body"));
            }
            return lines_1.fromString(" ").join(parts);
          case "ImportSpecifier":
            if (n2.importKind && n2.importKind !== "value") {
              parts.push(n2.importKind + " ");
            }
            if (n2.imported) {
              parts.push(path2.call(print2, "imported"));
              if (n2.local && n2.local.name !== n2.imported.name) {
                parts.push(" as ", path2.call(print2, "local"));
              }
            } else if (n2.id) {
              parts.push(path2.call(print2, "id"));
              if (n2.name) {
                parts.push(" as ", path2.call(print2, "name"));
              }
            }
            return lines_1.concat(parts);
          case "ExportSpecifier":
            if (n2.local) {
              parts.push(path2.call(print2, "local"));
              if (n2.exported && n2.exported.name !== n2.local.name) {
                parts.push(" as ", path2.call(print2, "exported"));
              }
            } else if (n2.id) {
              parts.push(path2.call(print2, "id"));
              if (n2.name) {
                parts.push(" as ", path2.call(print2, "name"));
              }
            }
            return lines_1.concat(parts);
          case "ExportBatchSpecifier":
            return lines_1.fromString("*");
          case "ImportNamespaceSpecifier":
            parts.push("* as ");
            if (n2.local) {
              parts.push(path2.call(print2, "local"));
            } else if (n2.id) {
              parts.push(path2.call(print2, "id"));
            }
            return lines_1.concat(parts);
          case "ImportDefaultSpecifier":
            if (n2.local) {
              return path2.call(print2, "local");
            }
            return path2.call(print2, "id");
          case "TSExportAssignment":
            return lines_1.concat(["export = ", path2.call(print2, "expression")]);
          case "ExportDeclaration":
          case "ExportDefaultDeclaration":
          case "ExportNamedDeclaration":
            return printExportDeclaration(path2, options2, print2);
          case "ExportAllDeclaration":
            parts.push("export *");
            if (n2.exported) {
              parts.push(" as ", path2.call(print2, "exported"));
            }
            parts.push(" from ", path2.call(print2, "source"), ";");
            return lines_1.concat(parts);
          case "TSNamespaceExportDeclaration":
            parts.push("export as namespace ", path2.call(print2, "id"));
            return maybeAddSemicolon(lines_1.concat(parts));
          case "ExportNamespaceSpecifier":
            return lines_1.concat(["* as ", path2.call(print2, "exported")]);
          case "ExportDefaultSpecifier":
            return path2.call(print2, "exported");
          case "Import":
            return lines_1.fromString("import", options2);
          case "ImportExpression":
            return lines_1.concat(["import(", path2.call(print2, "source"), ")"]);
          case "ImportDeclaration": {
            parts.push("import ");
            if (n2.importKind && n2.importKind !== "value") {
              parts.push(n2.importKind + " ");
            }
            if (n2.specifiers && n2.specifiers.length > 0) {
              var unbracedSpecifiers_1 = [];
              var bracedSpecifiers_1 = [];
              path2.each(function(specifierPath) {
                var spec = specifierPath.getValue();
                if (spec.type === "ImportSpecifier") {
                  bracedSpecifiers_1.push(print2(specifierPath));
                } else if (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") {
                  unbracedSpecifiers_1.push(print2(specifierPath));
                }
              }, "specifiers");
              unbracedSpecifiers_1.forEach(function(lines3, i3) {
                if (i3 > 0) {
                  parts.push(", ");
                }
                parts.push(lines3);
              });
              if (bracedSpecifiers_1.length > 0) {
                var lines_2 = lines_1.fromString(", ").join(bracedSpecifiers_1);
                if (lines_2.getLineLength(1) > options2.wrapColumn) {
                  lines_2 = lines_1.concat([
                    lines_1.fromString(",\n").join(bracedSpecifiers_1).indent(options2.tabWidth),
                    ","
                  ]);
                }
                if (unbracedSpecifiers_1.length > 0) {
                  parts.push(", ");
                }
                if (lines_2.length > 1) {
                  parts.push("{\n", lines_2, "\n}");
                } else if (options2.objectCurlySpacing) {
                  parts.push("{ ", lines_2, " }");
                } else {
                  parts.push("{", lines_2, "}");
                }
              }
              parts.push(" from ");
            }
            parts.push(path2.call(print2, "source"), ";");
            return lines_1.concat(parts);
          }
          case "BlockStatement":
            var naked = path2.call(function(bodyPath) {
              return printStatementSequence(bodyPath, options2, print2);
            }, "body");
            if (naked.isEmpty()) {
              if (!n2.directives || n2.directives.length === 0) {
                return lines_1.fromString("{}");
              }
            }
            parts.push("{\n");
            if (n2.directives) {
              path2.each(function(childPath) {
                parts.push(maybeAddSemicolon(print2(childPath).indent(options2.tabWidth)), n2.directives.length > 1 || !naked.isEmpty() ? "\n" : "");
              }, "directives");
            }
            parts.push(naked.indent(options2.tabWidth));
            parts.push("\n}");
            return lines_1.concat(parts);
          case "ReturnStatement":
            parts.push("return");
            if (n2.argument) {
              var argLines = path2.call(print2, "argument");
              if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n2.argument)) {
                parts.push(" (\n", argLines.indent(options2.tabWidth), "\n)");
              } else {
                parts.push(" ", argLines);
              }
            }
            parts.push(";");
            return lines_1.concat(parts);
          case "CallExpression":
          case "OptionalCallExpression":
            parts.push(path2.call(print2, "callee"));
            if (n2.typeParameters) {
              parts.push(path2.call(print2, "typeParameters"));
            }
            if (n2.typeArguments) {
              parts.push(path2.call(print2, "typeArguments"));
            }
            if (n2.type === "OptionalCallExpression" && n2.callee.type !== "OptionalMemberExpression") {
              parts.push("?.");
            }
            parts.push(printArgumentsList(path2, options2, print2));
            return lines_1.concat(parts);
          case "ObjectExpression":
          case "ObjectPattern":
          case "ObjectTypeAnnotation":
            var allowBreak = false;
            var isTypeAnnotation = n2.type === "ObjectTypeAnnotation";
            var separator = options2.flowObjectCommas ? "," : isTypeAnnotation ? ";" : ",";
            var fields = [];
            if (isTypeAnnotation) {
              fields.push("indexers", "callProperties");
              if (n2.internalSlots != null) {
                fields.push("internalSlots");
              }
            }
            fields.push("properties");
            var len = 0;
            fields.forEach(function(field) {
              len += n2[field].length;
            });
            var oneLine = isTypeAnnotation && len === 1 || len === 0;
            var leftBrace = n2.exact ? "{|" : "{";
            var rightBrace = n2.exact ? "|}" : "}";
            parts.push(oneLine ? leftBrace : leftBrace + "\n");
            var leftBraceIndex = parts.length - 1;
            var i2 = 0;
            fields.forEach(function(field) {
              path2.each(function(childPath) {
                var lines3 = print2(childPath);
                if (!oneLine) {
                  lines3 = lines3.indent(options2.tabWidth);
                }
                var multiLine = !isTypeAnnotation && lines3.length > 1;
                if (multiLine && allowBreak) {
                  parts.push("\n");
                }
                parts.push(lines3);
                if (i2 < len - 1) {
                  parts.push(separator + (multiLine ? "\n\n" : "\n"));
                  allowBreak = !multiLine;
                } else if (len !== 1 && isTypeAnnotation) {
                  parts.push(separator);
                } else if (!oneLine && util$3.isTrailingCommaEnabled(options2, "objects")) {
                  parts.push(separator);
                }
                i2++;
              }, field);
            });
            if (n2.inexact) {
              var line = lines_1.fromString("...", options2);
              if (oneLine) {
                if (len > 0) {
                  parts.push(separator, " ");
                }
                parts.push(line);
              } else {
                parts.push("\n", line.indent(options2.tabWidth));
              }
            }
            parts.push(oneLine ? rightBrace : "\n" + rightBrace);
            if (i2 !== 0 && oneLine && options2.objectCurlySpacing) {
              parts[leftBraceIndex] = leftBrace + " ";
              parts[parts.length - 1] = " " + rightBrace;
            }
            if (n2.typeAnnotation) {
              parts.push(path2.call(print2, "typeAnnotation"));
            }
            return lines_1.concat(parts);
          case "PropertyPattern":
            return lines_1.concat([
              path2.call(print2, "key"),
              ": ",
              path2.call(print2, "pattern")
            ]);
          case "ObjectProperty":
          case "Property":
            if (n2.method || n2.kind === "get" || n2.kind === "set") {
              return printMethod(path2, options2, print2);
            }
            if (n2.shorthand && n2.value.type === "AssignmentPattern") {
              return path2.call(print2, "value");
            }
            var key = path2.call(print2, "key");
            if (n2.computed) {
              parts.push("[", key, "]");
            } else {
              parts.push(key);
            }
            if (!n2.shorthand) {
              parts.push(": ", path2.call(print2, "value"));
            }
            return lines_1.concat(parts);
          case "ClassMethod":
          case "ObjectMethod":
          case "ClassPrivateMethod":
          case "TSDeclareMethod":
            return printMethod(path2, options2, print2);
          case "PrivateName":
            return lines_1.concat(["#", path2.call(print2, "id")]);
          case "Decorator":
            return lines_1.concat(["@", path2.call(print2, "expression")]);
          case "ArrayExpression":
          case "ArrayPattern":
            var elems = n2.elements, len = elems.length;
            var printed2 = path2.map(print2, "elements");
            var joined = lines_1.fromString(", ").join(printed2);
            var oneLine = joined.getLineLength(1) <= options2.wrapColumn;
            if (oneLine) {
              if (options2.arrayBracketSpacing) {
                parts.push("[ ");
              } else {
                parts.push("[");
              }
            } else {
              parts.push("[\n");
            }
            path2.each(function(elemPath) {
              var i3 = elemPath.getName();
              var elem = elemPath.getValue();
              if (!elem) {
                parts.push(",");
              } else {
                var lines_3 = printed2[i3];
                if (oneLine) {
                  if (i3 > 0)
                    parts.push(" ");
                } else {
                  lines_3 = lines_3.indent(options2.tabWidth);
                }
                parts.push(lines_3);
                if (i3 < len - 1 || !oneLine && util$3.isTrailingCommaEnabled(options2, "arrays"))
                  parts.push(",");
                if (!oneLine)
                  parts.push("\n");
              }
            }, "elements");
            if (oneLine && options2.arrayBracketSpacing) {
              parts.push(" ]");
            } else {
              parts.push("]");
            }
            if (n2.typeAnnotation) {
              parts.push(path2.call(print2, "typeAnnotation"));
            }
            return lines_1.concat(parts);
          case "SequenceExpression":
            return lines_1.fromString(", ").join(path2.map(print2, "expressions"));
          case "ThisExpression":
            return lines_1.fromString("this");
          case "Super":
            return lines_1.fromString("super");
          case "NullLiteral":
            return lines_1.fromString("null");
          case "RegExpLiteral":
            return lines_1.fromString(n2.extra.raw);
          case "BigIntLiteral":
            return lines_1.fromString(n2.value + "n");
          case "NumericLiteral":
            if (n2.extra && typeof n2.extra.raw === "string" && Number(n2.extra.raw) === n2.value) {
              return lines_1.fromString(n2.extra.raw, options2);
            }
            return lines_1.fromString(n2.value, options2);
          case "BooleanLiteral":
          case "StringLiteral":
          case "Literal":
            if (typeof n2.value === "number" && typeof n2.raw === "string" && Number(n2.raw) === n2.value) {
              return lines_1.fromString(n2.raw, options2);
            }
            if (typeof n2.value !== "string") {
              return lines_1.fromString(n2.value, options2);
            }
            return lines_1.fromString(nodeStr(n2.value, options2), options2);
          case "Directive":
            return path2.call(print2, "value");
          case "DirectiveLiteral":
            return lines_1.fromString(nodeStr(n2.value, options2));
          case "InterpreterDirective":
            return lines_1.fromString("#!" + n2.value + "\n", options2);
          case "ModuleSpecifier":
            if (n2.local) {
              throw new Error("The ESTree ModuleSpecifier type should be abstract");
            }
            return lines_1.fromString(nodeStr(n2.value, options2), options2);
          case "UnaryExpression":
            parts.push(n2.operator);
            if (/[a-z]$/.test(n2.operator))
              parts.push(" ");
            parts.push(path2.call(print2, "argument"));
            return lines_1.concat(parts);
          case "UpdateExpression":
            parts.push(path2.call(print2, "argument"), n2.operator);
            if (n2.prefix)
              parts.reverse();
            return lines_1.concat(parts);
          case "ConditionalExpression":
            return lines_1.concat([
              path2.call(print2, "test"),
              " ? ",
              path2.call(print2, "consequent"),
              " : ",
              path2.call(print2, "alternate")
            ]);
          case "NewExpression":
            parts.push("new ", path2.call(print2, "callee"));
            if (n2.typeParameters) {
              parts.push(path2.call(print2, "typeParameters"));
            }
            if (n2.typeArguments) {
              parts.push(path2.call(print2, "typeArguments"));
            }
            var args = n2.arguments;
            if (args) {
              parts.push(printArgumentsList(path2, options2, print2));
            }
            return lines_1.concat(parts);
          case "VariableDeclaration":
            if (n2.declare) {
              parts.push("declare ");
            }
            parts.push(n2.kind, " ");
            var maxLen = 0;
            var printed2 = path2.map(function(childPath) {
              var lines3 = print2(childPath);
              maxLen = Math.max(lines3.length, maxLen);
              return lines3;
            }, "declarations");
            if (maxLen === 1) {
              parts.push(lines_1.fromString(", ").join(printed2));
            } else if (printed2.length > 1) {
              parts.push(lines_1.fromString(",\n").join(printed2).indentTail(n2.kind.length + 1));
            } else {
              parts.push(printed2[0]);
            }
            var parentNode = path2.getParentNode();
            if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {
              parts.push(";");
            }
            return lines_1.concat(parts);
          case "VariableDeclarator":
            return n2.init ? lines_1.fromString(" = ").join([
              path2.call(print2, "id"),
              path2.call(print2, "init")
            ]) : path2.call(print2, "id");
          case "WithStatement":
            return lines_1.concat([
              "with (",
              path2.call(print2, "object"),
              ") ",
              path2.call(print2, "body")
            ]);
          case "IfStatement":
            var con = adjustClause(path2.call(print2, "consequent"), options2);
            parts.push("if (", path2.call(print2, "test"), ")", con);
            if (n2.alternate)
              parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path2.call(print2, "alternate"), options2));
            return lines_1.concat(parts);
          case "ForStatement":
            var init2 = path2.call(print2, "init"), sep2 = init2.length > 1 ? ";\n" : "; ", forParen = "for (", indented = lines_1.fromString(sep2).join([
              init2,
              path2.call(print2, "test"),
              path2.call(print2, "update")
            ]).indentTail(forParen.length), head = lines_1.concat([forParen, indented, ")"]), clause = adjustClause(path2.call(print2, "body"), options2);
            parts.push(head);
            if (head.length > 1) {
              parts.push("\n");
              clause = clause.trimLeft();
            }
            parts.push(clause);
            return lines_1.concat(parts);
          case "WhileStatement":
            return lines_1.concat([
              "while (",
              path2.call(print2, "test"),
              ")",
              adjustClause(path2.call(print2, "body"), options2)
            ]);
          case "ForInStatement":
            return lines_1.concat([
              n2.each ? "for each (" : "for (",
              path2.call(print2, "left"),
              " in ",
              path2.call(print2, "right"),
              ")",
              adjustClause(path2.call(print2, "body"), options2)
            ]);
          case "ForOfStatement":
          case "ForAwaitStatement":
            parts.push("for ");
            if (n2.await || n2.type === "ForAwaitStatement") {
              parts.push("await ");
            }
            parts.push("(", path2.call(print2, "left"), " of ", path2.call(print2, "right"), ")", adjustClause(path2.call(print2, "body"), options2));
            return lines_1.concat(parts);
          case "DoWhileStatement":
            var doBody = lines_1.concat([
              "do",
              adjustClause(path2.call(print2, "body"), options2)
            ]);
            parts.push(doBody);
            if (endsWithBrace(doBody))
              parts.push(" while");
            else
              parts.push("\nwhile");
            parts.push(" (", path2.call(print2, "test"), ");");
            return lines_1.concat(parts);
          case "DoExpression":
            var statements = path2.call(function(bodyPath) {
              return printStatementSequence(bodyPath, options2, print2);
            }, "body");
            return lines_1.concat([
              "do {\n",
              statements.indent(options2.tabWidth),
              "\n}"
            ]);
          case "BreakStatement":
            parts.push("break");
            if (n2.label)
              parts.push(" ", path2.call(print2, "label"));
            parts.push(";");
            return lines_1.concat(parts);
          case "ContinueStatement":
            parts.push("continue");
            if (n2.label)
              parts.push(" ", path2.call(print2, "label"));
            parts.push(";");
            return lines_1.concat(parts);
          case "LabeledStatement":
            return lines_1.concat([
              path2.call(print2, "label"),
              ":\n",
              path2.call(print2, "body")
            ]);
          case "TryStatement":
            parts.push("try ", path2.call(print2, "block"));
            if (n2.handler) {
              parts.push(" ", path2.call(print2, "handler"));
            } else if (n2.handlers) {
              path2.each(function(handlerPath) {
                parts.push(" ", print2(handlerPath));
              }, "handlers");
            }
            if (n2.finalizer) {
              parts.push(" finally ", path2.call(print2, "finalizer"));
            }
            return lines_1.concat(parts);
          case "CatchClause":
            parts.push("catch ");
            if (n2.param) {
              parts.push("(", path2.call(print2, "param"));
            }
            if (n2.guard) {
              parts.push(" if ", path2.call(print2, "guard"));
            }
            if (n2.param) {
              parts.push(") ");
            }
            parts.push(path2.call(print2, "body"));
            return lines_1.concat(parts);
          case "ThrowStatement":
            return lines_1.concat(["throw ", path2.call(print2, "argument"), ";"]);
          case "SwitchStatement":
            return lines_1.concat([
              "switch (",
              path2.call(print2, "discriminant"),
              ") {\n",
              lines_1.fromString("\n").join(path2.map(print2, "cases")),
              "\n}"
            ]);
          case "SwitchCase":
            if (n2.test)
              parts.push("case ", path2.call(print2, "test"), ":");
            else
              parts.push("default:");
            if (n2.consequent.length > 0) {
              parts.push("\n", path2.call(function(consequentPath) {
                return printStatementSequence(consequentPath, options2, print2);
              }, "consequent").indent(options2.tabWidth));
            }
            return lines_1.concat(parts);
          case "DebuggerStatement":
            return lines_1.fromString("debugger;");
          case "JSXAttribute":
            parts.push(path2.call(print2, "name"));
            if (n2.value)
              parts.push("=", path2.call(print2, "value"));
            return lines_1.concat(parts);
          case "JSXIdentifier":
            return lines_1.fromString(n2.name, options2);
          case "JSXNamespacedName":
            return lines_1.fromString(":").join([
              path2.call(print2, "namespace"),
              path2.call(print2, "name")
            ]);
          case "JSXMemberExpression":
            return lines_1.fromString(".").join([
              path2.call(print2, "object"),
              path2.call(print2, "property")
            ]);
          case "JSXSpreadAttribute":
            return lines_1.concat(["{...", path2.call(print2, "argument"), "}"]);
          case "JSXSpreadChild":
            return lines_1.concat(["{...", path2.call(print2, "expression"), "}"]);
          case "JSXExpressionContainer":
            return lines_1.concat(["{", path2.call(print2, "expression"), "}"]);
          case "JSXElement":
          case "JSXFragment":
            var openingPropName = "opening" + (n2.type === "JSXElement" ? "Element" : "Fragment");
            var closingPropName = "closing" + (n2.type === "JSXElement" ? "Element" : "Fragment");
            var openingLines = path2.call(print2, openingPropName);
            if (n2[openingPropName].selfClosing) {
              assert_1.default.ok(!n2[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n2.type);
              return openingLines;
            }
            var childLines = lines_1.concat(path2.map(function(childPath) {
              var child = childPath.getValue();
              if (namedTypes.Literal.check(child) && typeof child.value === "string") {
                if (/\S/.test(child.value)) {
                  return child.value.replace(/^\s+|\s+$/g, "");
                } else if (/\n/.test(child.value)) {
                  return "\n";
                }
              }
              return print2(childPath);
            }, "children")).indentTail(options2.tabWidth);
            var closingLines = path2.call(print2, closingPropName);
            return lines_1.concat([
              openingLines,
              childLines,
              closingLines
            ]);
          case "JSXOpeningElement":
            parts.push("<", path2.call(print2, "name"));
            var attrParts = [];
            path2.each(function(attrPath) {
              attrParts.push(" ", print2(attrPath));
            }, "attributes");
            var attrLines = lines_1.concat(attrParts);
            var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options2.wrapColumn;
            if (needLineWrap) {
              attrParts.forEach(function(part, i3) {
                if (part === " ") {
                  assert_1.default.strictEqual(i3 % 2, 0);
                  attrParts[i3] = "\n";
                }
              });
              attrLines = lines_1.concat(attrParts).indentTail(options2.tabWidth);
            }
            parts.push(attrLines, n2.selfClosing ? " />" : ">");
            return lines_1.concat(parts);
          case "JSXClosingElement":
            return lines_1.concat(["</", path2.call(print2, "name"), ">"]);
          case "JSXOpeningFragment":
            return lines_1.fromString("<>");
          case "JSXClosingFragment":
            return lines_1.fromString("</>");
          case "JSXText":
            return lines_1.fromString(n2.value, options2);
          case "JSXEmptyExpression":
            return lines_1.fromString("");
          case "TypeAnnotatedIdentifier":
            return lines_1.concat([
              path2.call(print2, "annotation"),
              " ",
              path2.call(print2, "identifier")
            ]);
          case "ClassBody":
            if (n2.body.length === 0) {
              return lines_1.fromString("{}");
            }
            return lines_1.concat([
              "{\n",
              path2.call(function(bodyPath) {
                return printStatementSequence(bodyPath, options2, print2);
              }, "body").indent(options2.tabWidth),
              "\n}"
            ]);
          case "ClassPropertyDefinition":
            parts.push("static ", path2.call(print2, "definition"));
            if (!namedTypes.MethodDefinition.check(n2.definition))
              parts.push(";");
            return lines_1.concat(parts);
          case "ClassProperty":
            if (n2.declare) {
              parts.push("declare ");
            }
            var access = n2.accessibility || n2.access;
            if (typeof access === "string") {
              parts.push(access, " ");
            }
            if (n2.static) {
              parts.push("static ");
            }
            if (n2.abstract) {
              parts.push("abstract ");
            }
            if (n2.readonly) {
              parts.push("readonly ");
            }
            var key = path2.call(print2, "key");
            if (n2.computed) {
              key = lines_1.concat(["[", key, "]"]);
            }
            if (n2.variance) {
              key = lines_1.concat([printVariance(path2, print2), key]);
            }
            parts.push(key);
            if (n2.optional) {
              parts.push("?");
            }
            if (n2.typeAnnotation) {
              parts.push(path2.call(print2, "typeAnnotation"));
            }
            if (n2.value) {
              parts.push(" = ", path2.call(print2, "value"));
            }
            parts.push(";");
            return lines_1.concat(parts);
          case "ClassPrivateProperty":
            if (n2.static) {
              parts.push("static ");
            }
            parts.push(path2.call(print2, "key"));
            if (n2.typeAnnotation) {
              parts.push(path2.call(print2, "typeAnnotation"));
            }
            if (n2.value) {
              parts.push(" = ", path2.call(print2, "value"));
            }
            parts.push(";");
            return lines_1.concat(parts);
          case "ClassDeclaration":
          case "ClassExpression":
            if (n2.declare) {
              parts.push("declare ");
            }
            if (n2.abstract) {
              parts.push("abstract ");
            }
            parts.push("class");
            if (n2.id) {
              parts.push(" ", path2.call(print2, "id"));
            }
            if (n2.typeParameters) {
              parts.push(path2.call(print2, "typeParameters"));
            }
            if (n2.superClass) {
              parts.push(" extends ", path2.call(print2, "superClass"), path2.call(print2, "superTypeParameters"));
            }
            if (n2["implements"] && n2["implements"].length > 0) {
              parts.push(" implements ", lines_1.fromString(", ").join(path2.map(print2, "implements")));
            }
            parts.push(" ", path2.call(print2, "body"));
            return lines_1.concat(parts);
          case "TemplateElement":
            return lines_1.fromString(n2.value.raw, options2).lockIndentTail();
          case "TemplateLiteral":
            var expressions = path2.map(print2, "expressions");
            parts.push("`");
            path2.each(function(childPath) {
              var i3 = childPath.getName();
              parts.push(print2(childPath));
              if (i3 < expressions.length) {
                parts.push("${", expressions[i3], "}");
              }
            }, "quasis");
            parts.push("`");
            return lines_1.concat(parts).lockIndentTail();
          case "TaggedTemplateExpression":
            return lines_1.concat([
              path2.call(print2, "tag"),
              path2.call(print2, "quasi")
            ]);
          case "Node":
          case "Printable":
          case "SourceLocation":
          case "Position":
          case "Statement":
          case "Function":
          case "Pattern":
          case "Expression":
          case "Declaration":
          case "Specifier":
          case "NamedSpecifier":
          case "Comment":
          case "Flow":
          case "FlowType":
          case "FlowPredicate":
          case "MemberTypeAnnotation":
          case "Type":
          case "TSHasOptionalTypeParameterInstantiation":
          case "TSHasOptionalTypeParameters":
          case "TSHasOptionalTypeAnnotation":
            throw new Error("unprintable type: " + JSON.stringify(n2.type));
          case "CommentBlock":
          case "Block":
            return lines_1.concat(["/*", lines_1.fromString(n2.value, options2), "*/"]);
          case "CommentLine":
          case "Line":
            return lines_1.concat(["//", lines_1.fromString(n2.value, options2)]);
          case "TypeAnnotation":
            if (n2.typeAnnotation) {
              if (n2.typeAnnotation.type !== "FunctionTypeAnnotation") {
                parts.push(": ");
              }
              parts.push(path2.call(print2, "typeAnnotation"));
              return lines_1.concat(parts);
            }
            return lines_1.fromString("");
          case "ExistentialTypeParam":
          case "ExistsTypeAnnotation":
            return lines_1.fromString("*", options2);
          case "EmptyTypeAnnotation":
            return lines_1.fromString("empty", options2);
          case "AnyTypeAnnotation":
            return lines_1.fromString("any", options2);
          case "MixedTypeAnnotation":
            return lines_1.fromString("mixed", options2);
          case "ArrayTypeAnnotation":
            return lines_1.concat([
              path2.call(print2, "elementType"),
              "[]"
            ]);
          case "TupleTypeAnnotation":
            var printed2 = path2.map(print2, "types");
            var joined = lines_1.fromString(", ").join(printed2);
            var oneLine = joined.getLineLength(1) <= options2.wrapColumn;
            if (oneLine) {
              if (options2.arrayBracketSpacing) {
                parts.push("[ ");
              } else {
                parts.push("[");
              }
            } else {
              parts.push("[\n");
            }
            path2.each(function(elemPath) {
              var i3 = elemPath.getName();
              var elem = elemPath.getValue();
              if (!elem) {
                parts.push(",");
              } else {
                var lines_4 = printed2[i3];
                if (oneLine) {
                  if (i3 > 0)
                    parts.push(" ");
                } else {
                  lines_4 = lines_4.indent(options2.tabWidth);
                }
                parts.push(lines_4);
                if (i3 < n2.types.length - 1 || !oneLine && util$3.isTrailingCommaEnabled(options2, "arrays"))
                  parts.push(",");
                if (!oneLine)
                  parts.push("\n");
              }
            }, "types");
            if (oneLine && options2.arrayBracketSpacing) {
              parts.push(" ]");
            } else {
              parts.push("]");
            }
            return lines_1.concat(parts);
          case "BooleanTypeAnnotation":
            return lines_1.fromString("boolean", options2);
          case "BooleanLiteralTypeAnnotation":
            assert_1.default.strictEqual(typeof n2.value, "boolean");
            return lines_1.fromString("" + n2.value, options2);
          case "InterfaceTypeAnnotation":
            parts.push("interface");
            if (n2.extends && n2.extends.length > 0) {
              parts.push(" extends ", lines_1.fromString(", ").join(path2.map(print2, "extends")));
            }
            parts.push(" ", path2.call(print2, "body"));
            return lines_1.concat(parts);
          case "DeclareClass":
            return printFlowDeclaration(path2, [
              "class ",
              path2.call(print2, "id"),
              " ",
              path2.call(print2, "body")
            ]);
          case "DeclareFunction":
            return printFlowDeclaration(path2, [
              "function ",
              path2.call(print2, "id"),
              ";"
            ]);
          case "DeclareModule":
            return printFlowDeclaration(path2, [
              "module ",
              path2.call(print2, "id"),
              " ",
              path2.call(print2, "body")
            ]);
          case "DeclareModuleExports":
            return printFlowDeclaration(path2, [
              "module.exports",
              path2.call(print2, "typeAnnotation")
            ]);
          case "DeclareVariable":
            return printFlowDeclaration(path2, [
              "var ",
              path2.call(print2, "id"),
              ";"
            ]);
          case "DeclareExportDeclaration":
          case "DeclareExportAllDeclaration":
            return lines_1.concat([
              "declare ",
              printExportDeclaration(path2, options2, print2)
            ]);
          case "InferredPredicate":
            return lines_1.fromString("%checks", options2);
          case "DeclaredPredicate":
            return lines_1.concat([
              "%checks(",
              path2.call(print2, "value"),
              ")"
            ]);
          case "FunctionTypeAnnotation":
            var parent = path2.getParentNode(0);
            var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes.DeclareFunction.check(path2.getParentNode(2)));
            var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent) && !namedTypes.TypeAlias.check(parent);
            if (needsColon) {
              parts.push(": ");
            }
            var needsParens = n2.params.length !== 1 || n2.params[0].name;
            parts.push(needsParens ? "(" : "", printFunctionParams(path2, options2, print2), needsParens ? ")" : "");
            if (n2.returnType) {
              parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path2.call(print2, "returnType"));
            }
            return lines_1.concat(parts);
          case "FunctionTypeParam":
            var name2 = path2.call(print2, "name");
            parts.push(name2);
            if (n2.optional) {
              parts.push("?");
            }
            if (name2.infos[0].line) {
              parts.push(": ");
            }
            parts.push(path2.call(print2, "typeAnnotation"));
            return lines_1.concat(parts);
          case "GenericTypeAnnotation":
            return lines_1.concat([
              path2.call(print2, "id"),
              path2.call(print2, "typeParameters")
            ]);
          case "DeclareInterface":
            parts.push("declare ");
          case "InterfaceDeclaration":
          case "TSInterfaceDeclaration":
            if (n2.declare) {
              parts.push("declare ");
            }
            parts.push("interface ", path2.call(print2, "id"), path2.call(print2, "typeParameters"), " ");
            if (n2["extends"] && n2["extends"].length > 0) {
              parts.push("extends ", lines_1.fromString(", ").join(path2.map(print2, "extends")), " ");
            }
            if (n2.body) {
              parts.push(path2.call(print2, "body"));
            }
            return lines_1.concat(parts);
          case "ClassImplements":
          case "InterfaceExtends":
            return lines_1.concat([
              path2.call(print2, "id"),
              path2.call(print2, "typeParameters")
            ]);
          case "IntersectionTypeAnnotation":
            return lines_1.fromString(" & ").join(path2.map(print2, "types"));
          case "NullableTypeAnnotation":
            return lines_1.concat([
              "?",
              path2.call(print2, "typeAnnotation")
            ]);
          case "NullLiteralTypeAnnotation":
            return lines_1.fromString("null", options2);
          case "ThisTypeAnnotation":
            return lines_1.fromString("this", options2);
          case "NumberTypeAnnotation":
            return lines_1.fromString("number", options2);
          case "ObjectTypeCallProperty":
            return path2.call(print2, "value");
          case "ObjectTypeIndexer":
            return lines_1.concat([
              printVariance(path2, print2),
              "[",
              path2.call(print2, "id"),
              ": ",
              path2.call(print2, "key"),
              "]: ",
              path2.call(print2, "value")
            ]);
          case "ObjectTypeProperty":
            return lines_1.concat([
              printVariance(path2, print2),
              path2.call(print2, "key"),
              n2.optional ? "?" : "",
              ": ",
              path2.call(print2, "value")
            ]);
          case "ObjectTypeInternalSlot":
            return lines_1.concat([
              n2.static ? "static " : "",
              "[[",
              path2.call(print2, "id"),
              "]]",
              n2.optional ? "?" : "",
              n2.value.type !== "FunctionTypeAnnotation" ? ": " : "",
              path2.call(print2, "value")
            ]);
          case "QualifiedTypeIdentifier":
            return lines_1.concat([
              path2.call(print2, "qualification"),
              ".",
              path2.call(print2, "id")
            ]);
          case "StringLiteralTypeAnnotation":
            return lines_1.fromString(nodeStr(n2.value, options2), options2);
          case "NumberLiteralTypeAnnotation":
          case "NumericLiteralTypeAnnotation":
            assert_1.default.strictEqual(typeof n2.value, "number");
            return lines_1.fromString(JSON.stringify(n2.value), options2);
          case "StringTypeAnnotation":
            return lines_1.fromString("string", options2);
          case "DeclareTypeAlias":
            parts.push("declare ");
          case "TypeAlias":
            return lines_1.concat([
              "type ",
              path2.call(print2, "id"),
              path2.call(print2, "typeParameters"),
              " = ",
              path2.call(print2, "right"),
              ";"
            ]);
          case "DeclareOpaqueType":
            parts.push("declare ");
          case "OpaqueType":
            parts.push("opaque type ", path2.call(print2, "id"), path2.call(print2, "typeParameters"));
            if (n2["supertype"]) {
              parts.push(": ", path2.call(print2, "supertype"));
            }
            if (n2["impltype"]) {
              parts.push(" = ", path2.call(print2, "impltype"));
            }
            parts.push(";");
            return lines_1.concat(parts);
          case "TypeCastExpression":
            return lines_1.concat([
              "(",
              path2.call(print2, "expression"),
              path2.call(print2, "typeAnnotation"),
              ")"
            ]);
          case "TypeParameterDeclaration":
          case "TypeParameterInstantiation":
            return lines_1.concat([
              "<",
              lines_1.fromString(", ").join(path2.map(print2, "params")),
              ">"
            ]);
          case "Variance":
            if (n2.kind === "plus") {
              return lines_1.fromString("+");
            }
            if (n2.kind === "minus") {
              return lines_1.fromString("-");
            }
            return lines_1.fromString("");
          case "TypeParameter":
            if (n2.variance) {
              parts.push(printVariance(path2, print2));
            }
            parts.push(path2.call(print2, "name"));
            if (n2.bound) {
              parts.push(path2.call(print2, "bound"));
            }
            if (n2["default"]) {
              parts.push("=", path2.call(print2, "default"));
            }
            return lines_1.concat(parts);
          case "TypeofTypeAnnotation":
            return lines_1.concat([
              lines_1.fromString("typeof ", options2),
              path2.call(print2, "argument")
            ]);
          case "UnionTypeAnnotation":
            return lines_1.fromString(" | ").join(path2.map(print2, "types"));
          case "VoidTypeAnnotation":
            return lines_1.fromString("void", options2);
          case "NullTypeAnnotation":
            return lines_1.fromString("null", options2);
          case "TSType":
            throw new Error("unprintable type: " + JSON.stringify(n2.type));
          case "TSNumberKeyword":
            return lines_1.fromString("number", options2);
          case "TSBigIntKeyword":
            return lines_1.fromString("bigint", options2);
          case "TSObjectKeyword":
            return lines_1.fromString("object", options2);
          case "TSBooleanKeyword":
            return lines_1.fromString("boolean", options2);
          case "TSStringKeyword":
            return lines_1.fromString("string", options2);
          case "TSSymbolKeyword":
            return lines_1.fromString("symbol", options2);
          case "TSAnyKeyword":
            return lines_1.fromString("any", options2);
          case "TSVoidKeyword":
            return lines_1.fromString("void", options2);
          case "TSThisType":
            return lines_1.fromString("this", options2);
          case "TSNullKeyword":
            return lines_1.fromString("null", options2);
          case "TSUndefinedKeyword":
            return lines_1.fromString("undefined", options2);
          case "TSUnknownKeyword":
            return lines_1.fromString("unknown", options2);
          case "TSNeverKeyword":
            return lines_1.fromString("never", options2);
          case "TSArrayType":
            return lines_1.concat([
              path2.call(print2, "elementType"),
              "[]"
            ]);
          case "TSLiteralType":
            return path2.call(print2, "literal");
          case "TSUnionType":
            return lines_1.fromString(" | ").join(path2.map(print2, "types"));
          case "TSIntersectionType":
            return lines_1.fromString(" & ").join(path2.map(print2, "types"));
          case "TSConditionalType":
            parts.push(path2.call(print2, "checkType"), " extends ", path2.call(print2, "extendsType"), " ? ", path2.call(print2, "trueType"), " : ", path2.call(print2, "falseType"));
            return lines_1.concat(parts);
          case "TSInferType":
            parts.push("infer ", path2.call(print2, "typeParameter"));
            return lines_1.concat(parts);
          case "TSParenthesizedType":
            return lines_1.concat([
              "(",
              path2.call(print2, "typeAnnotation"),
              ")"
            ]);
          case "TSFunctionType":
            return lines_1.concat([
              path2.call(print2, "typeParameters"),
              "(",
              printFunctionParams(path2, options2, print2),
              ")",
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSConstructorType":
            return lines_1.concat([
              "new ",
              path2.call(print2, "typeParameters"),
              "(",
              printFunctionParams(path2, options2, print2),
              ")",
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSMappedType": {
            parts.push(n2.readonly ? "readonly " : "", "[", path2.call(print2, "typeParameter"), "]", n2.optional ? "?" : "");
            if (n2.typeAnnotation) {
              parts.push(": ", path2.call(print2, "typeAnnotation"), ";");
            }
            return lines_1.concat([
              "{\n",
              lines_1.concat(parts).indent(options2.tabWidth),
              "\n}"
            ]);
          }
          case "TSTupleType":
            return lines_1.concat([
              "[",
              lines_1.fromString(", ").join(path2.map(print2, "elementTypes")),
              "]"
            ]);
          case "TSRestType":
            return lines_1.concat([
              "...",
              path2.call(print2, "typeAnnotation"),
              "[]"
            ]);
          case "TSOptionalType":
            return lines_1.concat([
              path2.call(print2, "typeAnnotation"),
              "?"
            ]);
          case "TSIndexedAccessType":
            return lines_1.concat([
              path2.call(print2, "objectType"),
              "[",
              path2.call(print2, "indexType"),
              "]"
            ]);
          case "TSTypeOperator":
            return lines_1.concat([
              path2.call(print2, "operator"),
              " ",
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSTypeLiteral": {
            var memberLines_1 = lines_1.fromString(",\n").join(path2.map(print2, "members"));
            if (memberLines_1.isEmpty()) {
              return lines_1.fromString("{}", options2);
            }
            parts.push("{\n", memberLines_1.indent(options2.tabWidth), "\n}");
            return lines_1.concat(parts);
          }
          case "TSEnumMember":
            parts.push(path2.call(print2, "id"));
            if (n2.initializer) {
              parts.push(" = ", path2.call(print2, "initializer"));
            }
            return lines_1.concat(parts);
          case "TSTypeQuery":
            return lines_1.concat([
              "typeof ",
              path2.call(print2, "exprName")
            ]);
          case "TSParameterProperty":
            if (n2.accessibility) {
              parts.push(n2.accessibility, " ");
            }
            if (n2.export) {
              parts.push("export ");
            }
            if (n2.static) {
              parts.push("static ");
            }
            if (n2.readonly) {
              parts.push("readonly ");
            }
            parts.push(path2.call(print2, "parameter"));
            return lines_1.concat(parts);
          case "TSTypeReference":
            return lines_1.concat([
              path2.call(print2, "typeName"),
              path2.call(print2, "typeParameters")
            ]);
          case "TSQualifiedName":
            return lines_1.concat([
              path2.call(print2, "left"),
              ".",
              path2.call(print2, "right")
            ]);
          case "TSAsExpression": {
            var withParens = n2.extra && n2.extra.parenthesized === true;
            if (withParens)
              parts.push("(");
            var expression = path2.call(print2, "expression");
            var expressionType = path2.getValue().expression.type;
            var needParens = expressionType === "ArrowFunctionExpression" || expressionType === "FunctionExpression";
            parts.push(needParens ? "(" + expression + ")" : expression, lines_1.fromString(" as "), path2.call(print2, "typeAnnotation"));
            if (withParens)
              parts.push(")");
            return lines_1.concat(parts);
          }
          case "TSNonNullExpression":
            return lines_1.concat([
              path2.call(print2, "expression"),
              "!"
            ]);
          case "TSTypeAnnotation": {
            var parent = path2.getParentNode(0);
            var prefix2 = ": ";
            if (namedTypes.TSFunctionType.check(parent) || namedTypes.TSConstructorType.check(parent)) {
              prefix2 = " => ";
            }
            if (namedTypes.TSTypePredicate.check(parent)) {
              prefix2 = " is ";
            }
            return lines_1.concat([
              prefix2,
              path2.call(print2, "typeAnnotation")
            ]);
          }
          case "TSIndexSignature":
            return lines_1.concat([
              n2.readonly ? "readonly " : "",
              "[",
              path2.map(print2, "parameters"),
              "]",
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSPropertySignature":
            parts.push(printVariance(path2, print2), n2.readonly ? "readonly " : "");
            if (n2.computed) {
              parts.push("[", path2.call(print2, "key"), "]");
            } else {
              parts.push(path2.call(print2, "key"));
            }
            parts.push(n2.optional ? "?" : "", path2.call(print2, "typeAnnotation"));
            return lines_1.concat(parts);
          case "TSMethodSignature":
            if (n2.computed) {
              parts.push("[", path2.call(print2, "key"), "]");
            } else {
              parts.push(path2.call(print2, "key"));
            }
            if (n2.optional) {
              parts.push("?");
            }
            parts.push(path2.call(print2, "typeParameters"), "(", printFunctionParams(path2, options2, print2), ")", path2.call(print2, "typeAnnotation"));
            return lines_1.concat(parts);
          case "TSTypePredicate":
            return lines_1.concat([
              path2.call(print2, "parameterName"),
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSCallSignatureDeclaration":
            return lines_1.concat([
              path2.call(print2, "typeParameters"),
              "(",
              printFunctionParams(path2, options2, print2),
              ")",
              path2.call(print2, "typeAnnotation")
            ]);
          case "TSConstructSignatureDeclaration":
            if (n2.typeParameters) {
              parts.push("new", path2.call(print2, "typeParameters"));
            } else {
              parts.push("new ");
            }
            parts.push("(", printFunctionParams(path2, options2, print2), ")", path2.call(print2, "typeAnnotation"));
            return lines_1.concat(parts);
          case "TSTypeAliasDeclaration":
            return lines_1.concat([
              n2.declare ? "declare " : "",
              "type ",
              path2.call(print2, "id"),
              path2.call(print2, "typeParameters"),
              " = ",
              path2.call(print2, "typeAnnotation"),
              ";"
            ]);
          case "TSTypeParameter":
            parts.push(path2.call(print2, "name"));
            var parent = path2.getParentNode(0);
            var isInMappedType = namedTypes.TSMappedType.check(parent);
            if (n2.constraint) {
              parts.push(isInMappedType ? " in " : " extends ", path2.call(print2, "constraint"));
            }
            if (n2["default"]) {
              parts.push(" = ", path2.call(print2, "default"));
            }
            return lines_1.concat(parts);
          case "TSTypeAssertion":
            var withParens = n2.extra && n2.extra.parenthesized === true;
            if (withParens) {
              parts.push("(");
            }
            parts.push("<", path2.call(print2, "typeAnnotation"), "> ", path2.call(print2, "expression"));
            if (withParens) {
              parts.push(")");
            }
            return lines_1.concat(parts);
          case "TSTypeParameterDeclaration":
          case "TSTypeParameterInstantiation":
            return lines_1.concat([
              "<",
              lines_1.fromString(", ").join(path2.map(print2, "params")),
              ">"
            ]);
          case "TSEnumDeclaration":
            parts.push(n2.declare ? "declare " : "", n2.const ? "const " : "", "enum ", path2.call(print2, "id"));
            var memberLines = lines_1.fromString(",\n").join(path2.map(print2, "members"));
            if (memberLines.isEmpty()) {
              parts.push(" {}");
            } else {
              parts.push(" {\n", memberLines.indent(options2.tabWidth), "\n}");
            }
            return lines_1.concat(parts);
          case "TSExpressionWithTypeArguments":
            return lines_1.concat([
              path2.call(print2, "expression"),
              path2.call(print2, "typeParameters")
            ]);
          case "TSInterfaceBody":
            var lines2 = lines_1.fromString(";\n").join(path2.map(print2, "body"));
            if (lines2.isEmpty()) {
              return lines_1.fromString("{}", options2);
            }
            return lines_1.concat([
              "{\n",
              lines2.indent(options2.tabWidth),
              ";",
              "\n}"
            ]);
          case "TSImportType":
            parts.push("import(", path2.call(print2, "argument"), ")");
            if (n2.qualifier) {
              parts.push(".", path2.call(print2, "qualifier"));
            }
            if (n2.typeParameters) {
              parts.push(path2.call(print2, "typeParameters"));
            }
            return lines_1.concat(parts);
          case "TSImportEqualsDeclaration":
            if (n2.isExport) {
              parts.push("export ");
            }
            parts.push("import ", path2.call(print2, "id"), " = ", path2.call(print2, "moduleReference"));
            return maybeAddSemicolon(lines_1.concat(parts));
          case "TSExternalModuleReference":
            return lines_1.concat(["require(", path2.call(print2, "expression"), ")"]);
          case "TSModuleDeclaration": {
            var parent_1 = path2.getParentNode();
            if (parent_1.type === "TSModuleDeclaration") {
              parts.push(".");
            } else {
              if (n2.declare) {
                parts.push("declare ");
              }
              if (!n2.global) {
                var isExternal = n2.id.type === "StringLiteral" || n2.id.type === "Literal" && typeof n2.id.value === "string";
                if (isExternal) {
                  parts.push("module ");
                } else if (n2.loc && n2.loc.lines && n2.id.loc) {
                  var prefix2 = n2.loc.lines.sliceString(n2.loc.start, n2.id.loc.start);
                  if (prefix2.indexOf("module") >= 0) {
                    parts.push("module ");
                  } else {
                    parts.push("namespace ");
                  }
                } else {
                  parts.push("namespace ");
                }
              }
            }
            parts.push(path2.call(print2, "id"));
            if (n2.body && n2.body.type === "TSModuleDeclaration") {
              parts.push(path2.call(print2, "body"));
            } else if (n2.body) {
              var bodyLines = path2.call(print2, "body");
              if (bodyLines.isEmpty()) {
                parts.push(" {}");
              } else {
                parts.push(" {\n", bodyLines.indent(options2.tabWidth), "\n}");
              }
            }
            return lines_1.concat(parts);
          }
          case "TSModuleBlock":
            return path2.call(function(bodyPath) {
              return printStatementSequence(bodyPath, options2, print2);
            }, "body");
          case "ClassHeritage":
          case "ComprehensionBlock":
          case "ComprehensionExpression":
          case "Glob":
          case "GeneratorExpression":
          case "LetStatement":
          case "LetExpression":
          case "GraphExpression":
          case "GraphIndexExpression":
          case "XMLDefaultDeclaration":
          case "XMLAnyName":
          case "XMLQualifiedIdentifier":
          case "XMLFunctionQualifiedIdentifier":
          case "XMLAttributeSelector":
          case "XMLFilterExpression":
          case "XML":
          case "XMLElement":
          case "XMLList":
          case "XMLEscape":
          case "XMLText":
          case "XMLStartTag":
          case "XMLEndTag":
          case "XMLPointTag":
          case "XMLName":
          case "XMLAttribute":
          case "XMLCdata":
          case "XMLComment":
          case "XMLProcessingInstruction":
          default:
            debugger;
            throw new Error("unknown type: " + JSON.stringify(n2.type));
        }
      }
      function printDecorators(path2, printPath) {
        var parts = [];
        var node2 = path2.getValue();
        if (node2.decorators && node2.decorators.length > 0 && // If the parent node is an export declaration, it will be
        // responsible for printing node.decorators.
        !util$3.getParentExportDeclaration(path2)) {
          path2.each(function(decoratorPath) {
            parts.push(printPath(decoratorPath), "\n");
          }, "decorators");
        } else if (util$3.isExportDeclaration(node2) && node2.declaration && node2.declaration.decorators) {
          path2.each(function(decoratorPath) {
            parts.push(printPath(decoratorPath), "\n");
          }, "declaration", "decorators");
        }
        return lines_1.concat(parts);
      }
      function printStatementSequence(path2, options2, print2) {
        var filtered = [];
        var sawComment = false;
        var sawStatement = false;
        path2.each(function(stmtPath) {
          var stmt = stmtPath.getValue();
          if (!stmt) {
            return;
          }
          if (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0)) {
            return;
          }
          if (namedTypes.Comment.check(stmt)) {
            sawComment = true;
          } else if (namedTypes.Statement.check(stmt)) {
            sawStatement = true;
          } else {
            isString$3.assert(stmt);
          }
          filtered.push({
            node: stmt,
            printed: print2(stmtPath)
          });
        });
        if (sawComment) {
          assert_1.default.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
        }
        var prevTrailingSpace = null;
        var len = filtered.length;
        var parts = [];
        filtered.forEach(function(info, i2) {
          var printed2 = info.printed;
          var stmt = info.node;
          var multiLine = printed2.length > 1;
          var notFirst = i2 > 0;
          var notLast = i2 < len - 1;
          var leadingSpace;
          var trailingSpace;
          var lines2 = stmt && stmt.loc && stmt.loc.lines;
          var trueLoc = lines2 && options2.reuseWhitespace && util$3.getTrueLoc(stmt, lines2);
          if (notFirst) {
            if (trueLoc) {
              var beforeStart = lines2.skipSpaces(trueLoc.start, true);
              var beforeStartLine = beforeStart ? beforeStart.line : 1;
              var leadingGap = trueLoc.start.line - beforeStartLine;
              leadingSpace = Array(leadingGap + 1).join("\n");
            } else {
              leadingSpace = multiLine ? "\n\n" : "\n";
            }
          } else {
            leadingSpace = "";
          }
          if (notLast) {
            if (trueLoc) {
              var afterEnd = lines2.skipSpaces(trueLoc.end);
              var afterEndLine = afterEnd ? afterEnd.line : lines2.length;
              var trailingGap = afterEndLine - trueLoc.end.line;
              trailingSpace = Array(trailingGap + 1).join("\n");
            } else {
              trailingSpace = multiLine ? "\n\n" : "\n";
            }
          } else {
            trailingSpace = "";
          }
          parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed2);
          if (notLast) {
            prevTrailingSpace = trailingSpace;
          } else if (trailingSpace) {
            parts.push(trailingSpace);
          }
        });
        return lines_1.concat(parts);
      }
      function maxSpace(s1, s2) {
        if (!s1 && !s2) {
          return lines_1.fromString("");
        }
        if (!s1) {
          return lines_1.fromString(s2);
        }
        if (!s2) {
          return lines_1.fromString(s1);
        }
        var spaceLines1 = lines_1.fromString(s1);
        var spaceLines2 = lines_1.fromString(s2);
        if (spaceLines2.length > spaceLines1.length) {
          return spaceLines2;
        }
        return spaceLines1;
      }
      function printMethod(path2, options2, print2) {
        var node2 = path2.getNode();
        var kind = node2.kind;
        var parts = [];
        var nodeValue = node2.value;
        if (!namedTypes.FunctionExpression.check(nodeValue)) {
          nodeValue = node2;
        }
        var access = node2.accessibility || node2.access;
        if (typeof access === "string") {
          parts.push(access, " ");
        }
        if (node2.static) {
          parts.push("static ");
        }
        if (node2.abstract) {
          parts.push("abstract ");
        }
        if (node2.readonly) {
          parts.push("readonly ");
        }
        if (nodeValue.async) {
          parts.push("async ");
        }
        if (nodeValue.generator) {
          parts.push("*");
        }
        if (kind === "get" || kind === "set") {
          parts.push(kind, " ");
        }
        var key = path2.call(print2, "key");
        if (node2.computed) {
          key = lines_1.concat(["[", key, "]"]);
        }
        parts.push(key);
        if (node2.optional) {
          parts.push("?");
        }
        if (node2 === nodeValue) {
          parts.push(path2.call(print2, "typeParameters"), "(", printFunctionParams(path2, options2, print2), ")", path2.call(print2, "returnType"));
          if (node2.body) {
            parts.push(" ", path2.call(print2, "body"));
          } else {
            parts.push(";");
          }
        } else {
          parts.push(path2.call(print2, "value", "typeParameters"), "(", path2.call(function(valuePath) {
            return printFunctionParams(valuePath, options2, print2);
          }, "value"), ")", path2.call(print2, "value", "returnType"));
          if (nodeValue.body) {
            parts.push(" ", path2.call(print2, "value", "body"));
          } else {
            parts.push(";");
          }
        }
        return lines_1.concat(parts);
      }
      function printArgumentsList(path2, options2, print2) {
        var printed2 = path2.map(print2, "arguments");
        var trailingComma = util$3.isTrailingCommaEnabled(options2, "parameters");
        var joined = lines_1.fromString(", ").join(printed2);
        if (joined.getLineLength(1) > options2.wrapColumn) {
          joined = lines_1.fromString(",\n").join(printed2);
          return lines_1.concat([
            "(\n",
            joined.indent(options2.tabWidth),
            trailingComma ? ",\n)" : "\n)"
          ]);
        }
        return lines_1.concat(["(", joined, ")"]);
      }
      function printFunctionParams(path2, options2, print2) {
        var fun = path2.getValue();
        if (fun.params) {
          var params = fun.params;
          var printed2 = path2.map(print2, "params");
        } else if (fun.parameters) {
          params = fun.parameters;
          printed2 = path2.map(print2, "parameters");
        }
        if (fun.defaults) {
          path2.each(function(defExprPath) {
            var i2 = defExprPath.getName();
            var p = printed2[i2];
            if (p && defExprPath.getValue()) {
              printed2[i2] = lines_1.concat([p, " = ", print2(defExprPath)]);
            }
          }, "defaults");
        }
        if (fun.rest) {
          printed2.push(lines_1.concat(["...", path2.call(print2, "rest")]));
        }
        var joined = lines_1.fromString(", ").join(printed2);
        if (joined.length > 1 || joined.getLineLength(1) > options2.wrapColumn) {
          joined = lines_1.fromString(",\n").join(printed2);
          if (util$3.isTrailingCommaEnabled(options2, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement") {
            joined = lines_1.concat([joined, ",\n"]);
          } else {
            joined = lines_1.concat([joined, "\n"]);
          }
          return lines_1.concat(["\n", joined.indent(options2.tabWidth)]);
        }
        return joined;
      }
      function printExportDeclaration(path2, options2, print2) {
        var decl = path2.getValue();
        var parts = ["export "];
        if (decl.exportKind && decl.exportKind === "type") {
          if (!decl.declaration) {
            parts.push("type ");
          }
        }
        var shouldPrintSpaces = options2.objectCurlySpacing;
        namedTypes.Declaration.assert(decl);
        if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
          parts.push("default ");
        }
        if (decl.declaration) {
          parts.push(path2.call(print2, "declaration"));
        } else if (decl.specifiers) {
          if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") {
            parts.push("*");
          } else if (decl.specifiers.length === 0) {
            parts.push("{}");
          } else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
            var unbracedSpecifiers_2 = [];
            var bracedSpecifiers_2 = [];
            path2.each(function(specifierPath) {
              var spec = specifierPath.getValue();
              if (spec.type === "ExportDefaultSpecifier") {
                unbracedSpecifiers_2.push(print2(specifierPath));
              } else {
                bracedSpecifiers_2.push(print2(specifierPath));
              }
            }, "specifiers");
            unbracedSpecifiers_2.forEach(function(lines3, i2) {
              if (i2 > 0) {
                parts.push(", ");
              }
              parts.push(lines3);
            });
            if (bracedSpecifiers_2.length > 0) {
              var lines_5 = lines_1.fromString(", ").join(bracedSpecifiers_2);
              if (lines_5.getLineLength(1) > options2.wrapColumn) {
                lines_5 = lines_1.concat([
                  lines_1.fromString(",\n").join(bracedSpecifiers_2).indent(options2.tabWidth),
                  ","
                ]);
              }
              if (unbracedSpecifiers_2.length > 0) {
                parts.push(", ");
              }
              if (lines_5.length > 1) {
                parts.push("{\n", lines_5, "\n}");
              } else if (options2.objectCurlySpacing) {
                parts.push("{ ", lines_5, " }");
              } else {
                parts.push("{", lines_5, "}");
              }
            }
          } else {
            parts.push(shouldPrintSpaces ? "{ " : "{", lines_1.fromString(", ").join(path2.map(print2, "specifiers")), shouldPrintSpaces ? " }" : "}");
          }
          if (decl.source) {
            parts.push(" from ", path2.call(print2, "source"));
          }
        }
        var lines2 = lines_1.concat(parts);
        if (lastNonSpaceCharacter(lines2) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration"))) {
          lines2 = lines_1.concat([lines2, ";"]);
        }
        return lines2;
      }
      function printFlowDeclaration(path2, parts) {
        var parentExportDecl = util$3.getParentExportDeclaration(path2);
        if (parentExportDecl) {
          assert_1.default.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
        } else {
          parts.unshift("declare ");
        }
        return lines_1.concat(parts);
      }
      function printVariance(path2, print2) {
        return path2.call(function(variancePath) {
          var value = variancePath.getValue();
          if (value) {
            if (value === "plus") {
              return lines_1.fromString("+");
            }
            if (value === "minus") {
              return lines_1.fromString("-");
            }
            return print2(variancePath);
          }
          return lines_1.fromString("");
        }, "variance");
      }
      function adjustClause(clause, options2) {
        if (clause.length > 1)
          return lines_1.concat([" ", clause]);
        return lines_1.concat([
          "\n",
          maybeAddSemicolon(clause).indent(options2.tabWidth)
        ]);
      }
      function lastNonSpaceCharacter(lines2) {
        var pos = lines2.lastPos();
        do {
          var ch = lines2.charAt(pos);
          if (/\S/.test(ch))
            return ch;
        } while (lines2.prevPos(pos));
      }
      function endsWithBrace(lines2) {
        return lastNonSpaceCharacter(lines2) === "}";
      }
      function swapQuotes(str2) {
        return str2.replace(/['"]/g, function(m) {
          return m === '"' ? "'" : '"';
        });
      }
      function nodeStr(str2, options2) {
        isString$3.assert(str2);
        switch (options2.quote) {
          case "auto":
            var double = JSON.stringify(str2);
            var single = swapQuotes(JSON.stringify(swapQuotes(str2)));
            return double.length > single.length ? single : double;
          case "single":
            return swapQuotes(JSON.stringify(swapQuotes(str2)));
          case "double":
          default:
            return JSON.stringify(str2);
        }
      }
      function maybeAddSemicolon(lines2) {
        var eoc = lastNonSpaceCharacter(lines2);
        if (!eoc || "\n};".indexOf(eoc) < 0)
          return lines_1.concat([lines2, ";"]);
        return lines2;
      }
      var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result2 = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result2[k] = mod[k];
        }
        result2["default"] = mod;
        return result2;
      };
      Object.defineProperty(main$3, "__esModule", { value: true });
      var fs_1 = __importDefault(require$$4$1);
      var types$4 = __importStar(main$2);
      main$3.types = types$4;
      var parser_1 = parser$5;
      main$3.parse = parser_1.parse;
      var printer_1 = printer;
      var ast_types_yx_1 = main$2;
      main$3.visit = ast_types_yx_1.visit;
      function print(node2, options2) {
        return new printer_1.Printer(options2).print(node2);
      }
      main$3.print = print;
      function prettyPrint(node2, options2) {
        return new printer_1.Printer(options2).printGenerically(node2);
      }
      main$3.prettyPrint = prettyPrint;
      function run(transformer, options2) {
        return runFile(browser$1$1.argv[2], transformer, options2);
      }
      main$3.run = run;
      function runFile(path2, transformer, options2) {
        fs_1.default.readFile(path2, "utf-8", function(err, code2) {
          if (err) {
            console.error(err);
            return;
          }
          runString(code2, transformer, options2);
        });
      }
      function defaultWriteback(output) {
        browser$1$1.stdout.write(output);
      }
      function runString(code2, transformer, options2) {
        var writeback = options2 && options2.writeback || defaultWriteback;
        transformer(parser_1.parse(code2, options2), function(node2) {
          writeback(print(node2, options2).code);
        });
      }
      var lib$3 = {};
      Object.defineProperty(lib$3, "__esModule", { value: true });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      class Position {
        constructor(line, col, index) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index;
        }
      }
      class SourceLocation {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      }
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index
        } = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      const ParseErrorCodes = Object.freeze({
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      });
      const reflect = (keys2, last2 = keys2.length - 1) => ({
        get() {
          return keys2.reduce((object2, key) => object2[key], this);
        },
        set(value) {
          keys2.reduce((item, key, i2) => i2 === last2 ? item[key] = value : item[key], this);
        }
      });
      const instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties));
      var ModuleErrors = (_) => ({
        ImportMetaOutsideModule: _(`import.meta may appear only with 'sourceType: "module"'`, {
          code: ParseErrorCodes.SourceTypeModuleError
        }),
        ImportOutsideModule: _(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
          code: ParseErrorCodes.SourceTypeModuleError
        })
      });
      const NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      const toNodeDescription = ({
        type: type2,
        prefix: prefix2
      }) => type2 === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type2];
      var StandardErrors = (_) => ({
        AccessorIsGenerator: _(({
          kind
        }) => `A ${kind}ter cannot be a generator.`),
        ArgumentsInClass: _("'arguments' is only allowed in functions and class methods."),
        AsyncFunctionInSingleStatementContext: _("Async functions can only be declared at the top level or inside a block."),
        AwaitBindingIdentifier: _("Can not use 'await' as identifier inside an async function."),
        AwaitBindingIdentifierInStaticBlock: _("Can not use 'await' as identifier inside a static block."),
        AwaitExpressionFormalParameter: _("'await' is not allowed in async function parameters."),
        AwaitNotInAsyncContext: _("'await' is only allowed within async functions and at the top levels of modules."),
        AwaitNotInAsyncFunction: _("'await' is only allowed within async functions."),
        BadGetterArity: _("A 'get' accesor must not have any formal parameters."),
        BadSetterArity: _("A 'set' accesor must have exactly one formal parameter."),
        BadSetterRestParameter: _("A 'set' accesor function argument must not be a rest parameter."),
        ConstructorClassField: _("Classes may not have a field named 'constructor'."),
        ConstructorClassPrivateField: _("Classes may not have a private field named '#constructor'."),
        ConstructorIsAccessor: _("Class constructor may not be an accessor."),
        ConstructorIsAsync: _("Constructor can't be an async function."),
        ConstructorIsGenerator: _("Constructor can't be a generator."),
        DeclarationMissingInitializer: _(({
          kind
        }) => `Missing initializer in ${kind} declaration.`),
        DecoratorBeforeExport: _("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
        DecoratorConstructor: _("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
        DecoratorExportClass: _("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
        DecoratorSemicolon: _("Decorators must not be followed by a semicolon."),
        DecoratorStaticBlock: _("Decorators can't be used with a static block."),
        DeletePrivateField: _("Deleting a private field is not allowed."),
        DestructureNamedImport: _("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
        DuplicateConstructor: _("Duplicate constructor in the same class."),
        DuplicateDefaultExport: _("Only one default export allowed per module."),
        DuplicateExport: _(({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`),
        DuplicateProto: _("Redefinition of __proto__ property."),
        DuplicateRegExpFlags: _("Duplicate regular expression flag."),
        ElementAfterRest: _("Rest element must be last element."),
        EscapedCharNotAnIdentifier: _("Invalid Unicode escape."),
        ExportBindingIsString: _(({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`),
        ExportDefaultFromAsIdentifier: _("'from' is not allowed as an identifier after 'export default'."),
        ForInOfLoopInitializer: _(({
          type: type2
        }) => `'${type2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`),
        ForOfAsync: _("The left-hand side of a for-of loop may not be 'async'."),
        ForOfLet: _("The left-hand side of a for-of loop may not start with 'let'."),
        GeneratorInSingleStatementContext: _("Generators can only be declared at the top level or inside a block."),
        IllegalBreakContinue: _(({
          type: type2
        }) => `Unsyntactic ${type2 === "BreakStatement" ? "break" : "continue"}.`),
        IllegalLanguageModeDirective: _("Illegal 'use strict' directive in function with non-simple parameter list."),
        IllegalReturn: _("'return' outside of function."),
        ImportBindingIsString: _(({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`),
        ImportCallArgumentTrailingComma: _("Trailing comma is disallowed inside import(...) arguments."),
        ImportCallArity: _(({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`),
        ImportCallNotNewExpression: _("Cannot use new with import(...)."),
        ImportCallSpreadArgument: _("`...` is not allowed in `import()`."),
        ImportJSONBindingNotDefault: _("A JSON module can only be imported with `default`."),
        IncompatibleRegExpUVFlags: _("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
        InvalidBigIntLiteral: _("Invalid BigIntLiteral."),
        InvalidCodePoint: _("Code point out of bounds."),
        InvalidCoverInitializedName: _("Invalid shorthand property initializer."),
        InvalidDecimal: _("Invalid decimal."),
        InvalidDigit: _(({
          radix
        }) => `Expected number in radix ${radix}.`),
        InvalidEscapeSequence: _("Bad character escape sequence."),
        InvalidEscapeSequenceTemplate: _("Invalid escape sequence in template."),
        InvalidEscapedReservedWord: _(({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`),
        InvalidIdentifier: _(({
          identifierName
        }) => `Invalid identifier ${identifierName}.`),
        InvalidLhs: _(({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`),
        InvalidLhsBinding: _(({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`),
        InvalidNumber: _("Invalid number."),
        InvalidOrMissingExponent: _("Floating-point numbers require a valid exponent after the 'e'."),
        InvalidOrUnexpectedToken: _(({
          unexpected
        }) => `Unexpected character '${unexpected}'.`),
        InvalidParenthesizedAssignment: _("Invalid parenthesized assignment pattern."),
        InvalidPrivateFieldResolution: _(({
          identifierName
        }) => `Private name #${identifierName} is not defined.`),
        InvalidPropertyBindingPattern: _("Binding member expression."),
        InvalidRecordProperty: _("Only properties and spread elements are allowed in record definitions."),
        InvalidRestAssignmentPattern: _("Invalid rest operator's argument."),
        LabelRedeclaration: _(({
          labelName
        }) => `Label '${labelName}' is already declared.`),
        LetInLexicalBinding: _("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
        LineTerminatorBeforeArrow: _("No line break is allowed before '=>'."),
        MalformedRegExpFlags: _("Invalid regular expression flag."),
        MissingClassName: _("A class name is required."),
        MissingEqInAssignment: _("Only '=' operator can be used for specifying default value."),
        MissingSemicolon: _("Missing semicolon."),
        MissingPlugin: _(({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`),
        MissingOneOfPlugins: _(({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`),
        MissingUnicodeEscape: _("Expecting Unicode escape sequence \\uXXXX."),
        MixingCoalesceWithLogical: _("Nullish coalescing operator(??) requires parens when mixing with logical operators."),
        ModuleAttributeDifferentFromType: _("The only accepted module attribute is `type`."),
        ModuleAttributeInvalidValue: _("Only string literals are allowed as module attribute values."),
        ModuleAttributesWithDuplicateKeys: _(({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`),
        ModuleExportNameHasLoneSurrogate: _(({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`),
        ModuleExportUndefined: _(({
          localName
        }) => `Export '${localName}' is not defined.`),
        MultipleDefaultsInSwitch: _("Multiple default clauses."),
        NewlineAfterThrow: _("Illegal newline after throw."),
        NoCatchOrFinally: _("Missing catch or finally clause."),
        NumberIdentifier: _("Identifier directly after number."),
        NumericSeparatorInEscapeSequence: _("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."),
        ObsoleteAwaitStar: _("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
        OptionalChainingNoNew: _("Constructors in/after an Optional Chain are not allowed."),
        OptionalChainingNoTemplate: _("Tagged Template Literals are not allowed in optionalChain."),
        OverrideOnConstructor: _("'override' modifier cannot appear on a constructor declaration."),
        ParamDupe: _("Argument name clash."),
        PatternHasAccessor: _("Object pattern can't contain getter or setter."),
        PatternHasMethod: _("Object pattern can't contain methods."),
        PrivateInExpectedIn: _(({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`),
        PrivateNameRedeclaration: _(({
          identifierName
        }) => `Duplicate private name #${identifierName}.`),
        RecordExpressionBarIncorrectEndSyntaxType: _("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        RecordExpressionBarIncorrectStartSyntaxType: _("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        RecordExpressionHashIncorrectStartSyntaxType: _("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
        RecordNoProto: _("'__proto__' is not allowed in Record expressions."),
        RestTrailingComma: _("Unexpected trailing comma after rest element."),
        SloppyFunction: _("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."),
        StaticPrototype: _("Classes may not have static property named prototype."),
        SuperNotAllowed: _("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"),
        SuperPrivateField: _("Private fields can't be accessed on super."),
        TrailingDecorator: _("Decorators must be attached to a class element."),
        TupleExpressionBarIncorrectEndSyntaxType: _("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        TupleExpressionBarIncorrectStartSyntaxType: _("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        TupleExpressionHashIncorrectStartSyntaxType: _("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
        UnexpectedArgumentPlaceholder: _("Unexpected argument placeholder."),
        UnexpectedAwaitAfterPipelineBody: _('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'),
        UnexpectedDigitAfterHash: _("Unexpected digit after hash token."),
        UnexpectedImportExport: _("'import' and 'export' may only appear at the top level."),
        UnexpectedKeyword: _(({
          keyword
        }) => `Unexpected keyword '${keyword}'.`),
        UnexpectedLeadingDecorator: _("Leading decorators must be attached to a class declaration."),
        UnexpectedLexicalDeclaration: _("Lexical declaration cannot appear in a single-statement context."),
        UnexpectedNewTarget: _("`new.target` can only be used in functions or class properties."),
        UnexpectedNumericSeparator: _("A numeric separator is only allowed between two digits."),
        UnexpectedPrivateField: _("Unexpected private name."),
        UnexpectedReservedWord: _(({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`),
        UnexpectedSuper: _("'super' is only allowed in object methods and classes."),
        UnexpectedToken: _(({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`),
        UnexpectedTokenUnaryExponentiation: _("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."),
        UnsupportedBind: _("Binding should be performed on object property."),
        UnsupportedDecoratorExport: _("A decorated export must export a class declaration."),
        UnsupportedDefaultExport: _("Only expressions, functions or classes are allowed as the `default` export."),
        UnsupportedImport: _("`import` can only be used in `import()` or `import.meta`."),
        UnsupportedMetaProperty: _(({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`),
        UnsupportedParameterDecorator: _("Decorators cannot be used to decorate parameters."),
        UnsupportedPropertyDecorator: _("Decorators cannot be used to decorate object literal properties."),
        UnsupportedSuper: _("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."),
        UnterminatedComment: _("Unterminated comment."),
        UnterminatedRegExp: _("Unterminated regular expression."),
        UnterminatedString: _("Unterminated string constant."),
        UnterminatedTemplate: _("Unterminated template."),
        VarRedeclaration: _(({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`),
        YieldBindingIdentifier: _("Can not use 'yield' as identifier inside a generator."),
        YieldInParameter: _("Yield expression is not allowed in formal parameters."),
        ZeroDigitNumericSeparator: _("Numeric separator can not be used after leading 0.")
      });
      var StrictModeErrors = (_) => ({
        StrictDelete: _("Deleting local variable in strict mode."),
        StrictEvalArguments: _(({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`),
        StrictEvalArgumentsBinding: _(({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`),
        StrictFunction: _("In strict mode code, functions can only be declared at top level or inside a block."),
        StrictNumericEscape: _("The only valid numeric escape in strict mode is '\\0'."),
        StrictOctalLiteral: _("Legacy octal literals are not allowed in strict mode."),
        StrictWith: _("'with' in strict mode.")
      });
      const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = (_) => ({
        PipeBodyIsTighter: _("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."),
        PipeTopicRequiresHackPipes: _('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'),
        PipeTopicUnbound: _("Topic reference is unbound; it must be inside a pipe body."),
        PipeTopicUnconfiguredToken: _(({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`),
        PipeTopicUnused: _("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."),
        PipeUnparenthesizedBody: _(({
          type: type2
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type: type2
        })}; please wrap it in parentheses.`),
        PipelineBodyNoArrow: _('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'),
        PipelineBodySequenceExpression: _("Pipeline body may not be a comma-separated sequence expression."),
        PipelineHeadSequenceExpression: _("Pipeline head should not be a comma-separated sequence expression."),
        PipelineTopicUnused: _("Pipeline is in topic style but does not use topic reference."),
        PrimaryTopicNotAllowed: _("Topic reference was used in a lexical context without topic binding."),
        PrimaryTopicRequiresSmartPipeline: _('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.')
      });
      const _excluded$1 = ["toMessage"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function toParseErrorCredentials(toMessageOrMessage, credentials) {
        return Object.assign({
          toMessage: typeof toMessageOrMessage === "string" ? () => toMessageOrMessage : toMessageOrMessage
        }, credentials);
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (toParseErrorCredentialsMap) => ParseErrorEnum(toParseErrorCredentialsMap, argument[0]);
        }
        const partialCredentials = argument(toParseErrorCredentials);
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(partialCredentials)) {
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCodes.SyntaxError,
            reasonCode
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, partialCredentials[reasonCode]));
        }
        return ParseErrorConstructors;
      }
      const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      const {
        defineProperty
      } = Object;
      const toUnenumerable = (object2, key) => defineProperty(object2, key, {
        enumerable: false,
        value: object2[key]
      });
      function toESTreeLocation(node2) {
        node2.loc.start && toUnenumerable(node2.loc.start, "index");
        node2.loc.end && toUnenumerable(node2.loc.end, "index");
        return node2;
      }
      var estree = (superClass) => class extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex2 = null;
          try {
            regex2 = new RegExp(pattern, flags);
          } catch (e) {
          }
          const node2 = this.estreeParseLiteral(regex2);
          node2.regex = {
            pattern,
            flags
          };
          return node2;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node2 = this.estreeParseLiteral(bigInt);
          node2.bigint = String(node2.value || value);
          return node2;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node2 = this.estreeParseLiteral(decimal);
          node2.decimal = String(node2.value || value);
          return node2;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const directiveLiteral = directive.value;
          const stmt = this.startNodeAt(directive.start, directive.loc.start);
          const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.extra.expressionValue;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
        }
        initFunction(node2, isAsync) {
          super.initFunction(node2, isAsync);
          node2.expression = false;
        }
        checkDeclaration(node2) {
          if (node2 != null && this.isObjectProperty(node2)) {
            this.checkDeclaration(node2.value);
          } else {
            super.checkDeclaration(node2);
          }
        }
        getObjectOrClassMethodParams(method2) {
          return method2.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node2, ...args) {
          super.parseBlockBody(node2, ...args);
          const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
          node2.body = directiveStatements.concat(node2.body);
          delete node2.directives;
        }
        pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method2, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method2.typeParameters) {
            method2.value.typeParameters = method2.typeParameters;
            delete method2.typeParameters;
          }
          classBody.body.push(method2);
        }
        parsePrivateName() {
          const node2 = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node2;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node2);
        }
        convertPrivateNameToPrivateIdentifier(node2) {
          const name2 = super.getPrivateNameSV(node2);
          node2 = node2;
          delete node2.id;
          node2.name = name2;
          node2.type = "PrivateIdentifier";
          return node2;
        }
        isPrivateName(node2) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node2);
            }
          }
          return node2.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node2) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node2);
            }
          }
          return node2.name;
        }
        parseLiteral(value, type2) {
          const node2 = super.parseLiteral(value, type2);
          node2.raw = node2.extra.raw;
          delete node2.extra;
          return node2;
        }
        parseFunctionBody(node2, allowExpression, isMethod = false) {
          super.parseFunctionBody(node2, allowExpression, isMethod);
          node2.expression = node2.body.type !== "BlockStatement";
        }
        parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node2.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node2.value = funcNode;
          if (type2 === "ClassPrivateMethod") {
            node2.computed = false;
          }
          type2 = "MethodDefinition";
          return this.finishNode(node2, type2);
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node2 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node2) {
            node2.type = "Property";
            if (node2.kind === "method")
              node2.kind = "init";
            node2.shorthand = false;
          }
          return node2;
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          const node2 = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (node2) {
            node2.kind = "init";
            node2.type = "Property";
          }
          return node2;
        }
        isValidLVal(type2, ...rest) {
          return type2 === "Property" ? "value" : super.isValidLVal(type2, ...rest);
        }
        isAssignable(node2, isBinding) {
          if (node2 != null && this.isObjectProperty(node2)) {
            return this.isAssignable(node2.value, isBinding);
          }
          return super.isAssignable(node2, isBinding);
        }
        toAssignable(node2, isLHS = false) {
          if (node2 != null && this.isObjectProperty(node2)) {
            const {
              key,
              value
            } = node2;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node2, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(...arguments);
          }
        }
        finishCallExpression(node2, optional) {
          super.finishCallExpression(node2, optional);
          if (node2.callee.type === "Import") {
            node2.type = "ImportExpression";
            node2.source = node2.arguments[0];
            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node2.attributes = (_node$arguments$ = node2.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node2.arguments;
            delete node2.callee;
          }
          return node2;
        }
        toReferencedArguments(node2) {
          if (node2.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node2);
        }
        parseExport(node2) {
          super.parseExport(node2);
          switch (node2.type) {
            case "ExportAllDeclaration":
              node2.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
                node2.type = "ExportAllDeclaration";
                node2.exported = node2.specifiers[0].exported;
                delete node2.specifiers;
              }
              break;
          }
          return node2;
        }
        parseSubscript(base2, startPos, startLoc, noCalls, state) {
          const node2 = super.parseSubscript(base2, startPos, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
              node2.type = node2.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node2);
              chain.expression = node2;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
            node2.optional = false;
          }
          return node2;
        }
        hasPropertyAsPrivateName(node2) {
          if (node2.type === "ChainExpression") {
            node2 = node2.expression;
          }
          return super.hasPropertyAsPrivateName(node2);
        }
        isOptionalChain(node2) {
          return node2.type === "ChainExpression";
        }
        isObjectProperty(node2) {
          return node2.type === "Property" && node2.kind === "init" && !node2.method;
        }
        isObjectMethod(node2) {
          return node2.method || node2.kind === "get" || node2.kind === "set";
        }
        finishNodeAt(node2, type2, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node2, type2, endLoc));
        }
        resetStartLocation(node2, start, startLoc) {
          super.resetStartLocation(node2, start, startLoc);
          toESTreeLocation(node2);
        }
        resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node2, endLoc);
          toESTreeLocation(node2);
        }
      };
      class TokContext {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      }
      const types$3 = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types$3.template = new TokContext("`", true);
      }
      const beforeExpr = true;
      const startsExpr = true;
      const isLoop = true;
      const isAssign = true;
      const prefix = true;
      const postfix = true;
      class ExportedTokenType {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      }
      const keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name2, options2 = {}) {
        options2.keyword = name2;
        const token = createToken(name2, options2);
        keywords$1.set(name2, token);
        return token;
      }
      function createBinop(name2, binop) {
        return createToken(name2, {
          beforeExpr,
          binop
        });
      }
      let tokenTypeCounter = -1;
      const tokenTypes$3 = [];
      const tokenLabels = [];
      const tokenBinops = [];
      const tokenBeforeExprs = [];
      const tokenStartsExprs = [];
      const tokenPrefixes = [];
      function createToken(name2, options2 = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name2);
        tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : false);
        tokenTypes$3.push(new ExportedTokenType(name2, options2));
        return tokenTypeCounter;
      }
      function createKeywordLike(name2, options2 = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name2, tokenTypeCounter);
        tokenLabels.push(name2);
        tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : false);
        tokenTypes$3.push(new ExportedTokenType("name", options2));
        return tokenTypeCounter;
      }
      const tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 128;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 128;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 132;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 125 && token <= 127;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 117 && token <= 119;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 120 && token <= 126;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes$3[token];
      }
      {
        tokenTypes$3[8].updateContext = (context) => {
          context.pop();
        };
        tokenTypes$3[5].updateContext = tokenTypes$3[7].updateContext = tokenTypes$3[23].updateContext = (context) => {
          context.push(types$3.brace);
        };
        tokenTypes$3[22].updateContext = (context) => {
          if (context[context.length - 1] === types$3.template) {
            context.pop();
          } else {
            context.push(types$3.template);
          }
        };
        tokenTypes$3[138].updateContext = (context) => {
          context.push(types$3.j_expr, types$3.j_oTag);
        };
      }
      let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      let nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
      const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code2, set) {
        let pos = 65536;
        for (let i2 = 0, length = set.length; i2 < length; i2 += 2) {
          pos += set[i2];
          if (pos > code2)
            return false;
          pos += set[i2 + 1];
          if (pos >= code2)
            return true;
        }
        return false;
      }
      function isIdentifierStart(code2) {
        if (code2 < 65)
          return code2 === 36;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code2) {
        if (code2 < 48)
          return code2 === 36;
        if (code2 < 58)
          return true;
        if (code2 < 65)
          return false;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
      }
      const reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      const keywords$2 = new Set(reservedWords.keyword);
      const reservedWordsStrictSet = new Set(reservedWords.strict);
      const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word2, inModule) {
        return inModule && word2 === "await" || word2 === "enum";
      }
      function isStrictReservedWord(word2, inModule) {
        return isReservedWord(word2, inModule) || reservedWordsStrictSet.has(word2);
      }
      function isStrictBindOnlyReservedWord(word2) {
        return reservedWordsStrictBindSet.has(word2);
      }
      function isStrictBindReservedWord(word2, inModule) {
        return isStrictReservedWord(word2, inModule) || isStrictBindOnlyReservedWord(word2);
      }
      function isKeyword(word2) {
        return keywords$2.has(word2);
      }
      function isIteratorStart(current, next, next2) {
        return current === 64 && next === 64 && isIdentifierStart(next2);
      }
      const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word2) {
        return reservedWordLikeSet.has(word2);
      }
      const SCOPE_OTHER = 0, SCOPE_PROGRAM = 1, SCOPE_FUNCTION = 2, SCOPE_ARROW = 4, SCOPE_SIMPLE_CATCH = 8, SCOPE_SUPER = 16, SCOPE_DIRECT_SUPER = 32, SCOPE_CLASS = 64, SCOPE_STATIC_BLOCK = 128, SCOPE_TS_MODULE = 256, SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
      const BIND_KIND_VALUE = 1, BIND_KIND_TYPE = 2, BIND_SCOPE_VAR = 4, BIND_SCOPE_LEXICAL = 8, BIND_SCOPE_FUNCTION = 16, BIND_FLAGS_NONE = 64, BIND_FLAGS_CLASS = 128, BIND_FLAGS_TS_ENUM = 256, BIND_FLAGS_TS_CONST_ENUM = 512, BIND_FLAGS_TS_EXPORT_ONLY = 1024, BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS, BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0, BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0, BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0, BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS, BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0, BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM, BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE, BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE, BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM, BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      const CLASS_ELEMENT_FLAG_STATIC = 4, CLASS_ELEMENT_KIND_GETTER = 2, CLASS_ELEMENT_KIND_SETTER = 1, CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER, CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER, CLASS_ELEMENT_OTHER = 0;
      class BaseParser {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin2, name2) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin2)) == null ? void 0 : _this$plugins$get[name2];
        }
      }
      function setTrailingComments(node2, comments2) {
        if (node2.trailingComments === void 0) {
          node2.trailingComments = comments2;
        } else {
          node2.trailingComments.unshift(...comments2);
        }
      }
      function setLeadingComments(node2, comments2) {
        if (node2.leadingComments === void 0) {
          node2.leadingComments = comments2;
        } else {
          node2.leadingComments.unshift(...comments2);
        }
      }
      function setInnerComments(node2, comments2) {
        if (node2.innerComments === void 0) {
          node2.innerComments = comments2;
        } else {
          node2.innerComments.unshift(...comments2);
        }
      }
      function adjustInnerComments(node2, elements, commentWS) {
        let lastElement = null;
        let i2 = elements.length;
        while (lastElement === null && i2 > 0) {
          lastElement = elements[--i2];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node2, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      class CommentsParser extends BaseParser {
        addComment(comment2) {
          if (this.filename)
            comment2.loc.filename = this.filename;
          this.state.comments.push(comment2);
        }
        processComment(node2) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i2 = commentStackLength - 1;
          const lastCommentWS = commentStack[i2];
          if (lastCommentWS.start === node2.end) {
            lastCommentWS.leadingNode = node2;
            i2--;
          }
          const {
            start: nodeStart
          } = node2;
          for (; i2 >= 0; i2--) {
            const commentWS = commentStack[i2];
            const commentEnd2 = commentWS.end;
            if (commentEnd2 > nodeStart) {
              commentWS.containingNode = node2;
              this.finalizeComment(commentWS);
              commentStack.splice(i2, 1);
            } else {
              if (commentEnd2 === nodeStart) {
                commentWS.trailingNode = node2;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments: comments2
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments2);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments2);
            }
          } else {
            const {
              containingNode: node2,
              start: commentStart2
            } = commentWS;
            if (this.input.charCodeAt(commentStart2 - 1) === 44) {
              switch (node2.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node2, node2.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node2, node2.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node2, node2.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node2, node2.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node2, node2.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node2, comments2);
                }
              }
            } else {
              setInnerComments(node2, comments2);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i2 = commentStack.length - 1; i2 >= 0; i2--) {
            this.finalizeComment(commentStack[i2]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node2) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node2) {
            commentWS.leadingNode = null;
          }
        }
        takeSurroundingComments(node2, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i2 = commentStackLength - 1;
          for (; i2 >= 0; i2--) {
            const commentWS = commentStack[i2];
            const commentEnd2 = commentWS.end;
            const commentStart2 = commentWS.start;
            if (commentStart2 === end) {
              commentWS.leadingNode = node2;
            } else if (commentEnd2 === start) {
              commentWS.trailingNode = node2;
            } else if (commentEnd2 < start) {
              break;
            }
          }
        }
      }
      const lineBreak = /\r\n?|[\n\u2028\u2029]/;
      const lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code2) {
        switch (code2) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
      const skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace$9(code2) {
        switch (code2) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      class State {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.decoratorStack = [[]];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 135;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types$3.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State();
          const keys2 = Object.keys(this);
          for (let i2 = 0, length = keys2.length; i2 < length; i2++) {
            const key = keys2[i2];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      }
      const _excluded = ["at"], _excluded2 = ["at"];
      var _isDigit = function isDigit(code2) {
        return code2 >= 48 && code2 <= 57;
      };
      const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      const forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      const isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      class Token {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      }
      class Tokenizer extends CommentsParser {
        constructor(options2, input2) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.state = new State();
          this.state.init(options2);
          this.input = input2;
          this.length = input2.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type2) {
          if (this.match(type2)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type2) {
          return this.state.type === type2;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at2]) => this.raise(toParseError, {
              at: at2
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(135);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf("*/", start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + 2;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead)
            return;
          const comment2 = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment2);
          return comment2;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead)
            return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment2 = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment2);
          return comment2;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments2 = [];
          loop:
            while (this.state.pos < this.length) {
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const comment2 = this.skipBlockComment();
                      if (comment2 !== void 0) {
                        this.addComment(comment2);
                        if (this.options.attachComment)
                          comments2.push(comment2);
                      }
                      break;
                    }
                    case 47: {
                      const comment2 = this.skipLineComment(2);
                      if (comment2 !== void 0) {
                        this.addComment(comment2);
                        if (this.options.attachComment)
                          comments2.push(comment2);
                      }
                      break;
                    }
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (isWhitespace$9(ch)) {
                    ++this.state.pos;
                  } else if (ch === 45 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                      const comment2 = this.skipLineComment(3);
                      if (comment2 !== void 0) {
                        this.addComment(comment2);
                        if (this.options.attachComment)
                          comments2.push(comment2);
                      }
                    } else {
                      break loop;
                    }
                  } else if (ch === 60 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                      const comment2 = this.skipLineComment(4);
                      if (comment2 !== void 0) {
                        this.addComment(comment2);
                        if (this.options.attachComment)
                          comments2.push(comment2);
                      }
                    } else {
                      break loop;
                    }
                  } else {
                    break loop;
                  }
              }
            }
          if (comments2.length > 0) {
            const end = this.state.pos;
            const CommentWhitespace = {
              start: spaceStart,
              end,
              comments: comments2,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(CommentWhitespace);
          }
        }
        finishToken(type2, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type2;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type2) {
          this.state.type = type2;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
              throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1(next));
          } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
          }
          if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2)
            return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33)
            return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code2) {
          let type2 = code2 === 42 ? 55 : 54;
          let width = 1;
          let next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type2 = 57;
          }
          if (next === 61 && !this.state.inType) {
            width++;
            type2 = code2 === 37 ? 33 : 30;
          }
          this.finishOp(type2, width);
        }
        readToken_pipe_amp(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code2) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code2 === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code2 === 124) {
            if (next === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code2 === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              throw this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code2) {
            this.finishOp(34, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code2 === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code2 === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          const next2 = this.input.charCodeAt(this.state.pos + 2);
          if (next === 63) {
            if (next2 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code2) {
          switch (code2) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code2);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code2);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code2);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code2);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code2);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(code2)) {
                this.readWord(code2);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code2)
          });
        }
        finishOp(type2, size) {
          const str2 = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type2, str2);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                this.expectPlugin("regexpUnicodeSets", nextPos());
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(133, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen, allowNumSeparator = true) {
          const start = this.state.pos;
          const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
          const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
          let invalid = false;
          let total = 0;
          for (let i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2) {
            const code2 = this.input.charCodeAt(this.state.pos);
            let val;
            if (code2 === 95 && allowNumSeparator !== "bail") {
              const prev = this.input.charCodeAt(this.state.pos - 1);
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (!allowNumSeparator) {
                this.raise(Errors.NumericSeparatorInEscapeSequence, {
                  at: this.state.curPosition()
                });
              } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                this.raise(Errors.UnexpectedNumericSeparator, {
                  at: this.state.curPosition()
                });
              }
              ++this.state.pos;
              continue;
            }
            if (code2 >= 97) {
              val = code2 - 97 + 10;
            } else if (code2 >= 65) {
              val = code2 - 65 + 10;
            } else if (_isDigit(code2)) {
              val = code2 - 48;
            } else {
              val = Infinity;
            }
            if (val >= radix) {
              if (this.options.errorRecovery && val <= 9) {
                val = 0;
                this.raise(Errors.InvalidDigit, {
                  at: this.state.curPosition(),
                  radix
                });
              } else if (forceLen) {
                val = 0;
                invalid = true;
              } else {
                break;
              }
            }
            ++this.state.pos;
            total = total * radix + val;
          }
          if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
            return null;
          }
          return total;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next = this.input.charCodeAt(this.state.pos);
          if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str2 = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(131, str2);
            return;
          }
          this.finishToken(130, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if (next === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str2 = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(131, str2);
            return;
          }
          if (isDecimal) {
            this.finishToken(132, str2);
            return;
          }
          const val = isOctal ? parseInt(str2, 8) : parseFloat(str2);
          this.finishToken(130, val);
        }
        readCodePoint(throwOnInvalid) {
          const ch = this.input.charCodeAt(this.state.pos);
          let code2;
          if (ch === 123) {
            ++this.state.pos;
            code2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
            ++this.state.pos;
            if (code2 !== null && code2 > 1114111) {
              if (throwOnInvalid) {
                this.raise(Errors.InvalidCodePoint, {
                  at: this.state.curPosition()
                });
              } else {
                return null;
              }
            }
          } else {
            code2 = this.readHexChar(4, false, throwOnInvalid);
          }
          return code2;
        }
        readString(quote) {
          let out = "", chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 92) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.readEscapedChar(false);
              chunkStart = this.state.pos;
            } else if (ch === 8232 || ch === 8233) {
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
            } else if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          this.finishToken(129, out);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          let out = "", chunkStart = this.state.pos, containsInvalid = false;
          ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: createPositionWithColumnOffset(this.state.startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === 96) {
              ++this.state.pos;
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(24, containsInvalid ? null : out);
              return;
            }
            if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
              this.state.pos += 2;
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(25, containsInvalid ? null : out);
              return;
            }
            if (ch === 92) {
              out += this.input.slice(chunkStart, this.state.pos);
              const escaped = this.readEscapedChar(true);
              if (escaped === null) {
                containsInvalid = true;
              } else {
                out += escaped;
              }
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              ++this.state.pos;
              switch (ch) {
                case 13:
                  if (this.input.charCodeAt(this.state.pos) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                  out += "\n";
                  break;
                default:
                  out += String.fromCharCode(ch);
                  break;
              }
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
        }
        recordStrictModeErrors(toParseError, {
          at: at2
        }) {
          const index = at2.index;
          if (this.state.strict && !this.state.strictErrors.has(index)) {
            this.raise(toParseError, {
              at: at2
            });
          } else {
            this.state.strictErrors.set(index, [toParseError, at2]);
          }
        }
        readEscapedChar(inTemplate) {
          const throwOnInvalid = !inTemplate;
          const ch = this.input.charCodeAt(++this.state.pos);
          ++this.state.pos;
          switch (ch) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120: {
              const code2 = this.readHexChar(2, false, throwOnInvalid);
              return code2 === null ? null : String.fromCharCode(code2);
            }
            case 117: {
              const code2 = this.readCodePoint(throwOnInvalid);
              return code2 === null ? null : String.fromCodePoint(code2);
            }
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }
            case 10:
              this.state.lineStart = this.state.pos;
              ++this.state.curLine;
            case 8232:
            case 8233:
              return "";
            case 56:
            case 57:
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                  at: createPositionWithColumnOffset(this.state.curPosition(), -1)
                });
              }
            default:
              if (ch >= 48 && ch <= 55) {
                const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);
                const match = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/);
                let octalStr = match[0];
                let octal = parseInt(octalStr, 8);
                if (octal > 255) {
                  octalStr = octalStr.slice(0, -1);
                  octal = parseInt(octalStr, 8);
                }
                this.state.pos += octalStr.length - 1;
                const next = this.input.charCodeAt(this.state.pos);
                if (octalStr !== "0" || next === 56 || next === 57) {
                  if (inTemplate) {
                    return null;
                  } else {
                    this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                      at: codePos
                    });
                  }
                }
                return String.fromCharCode(octal);
              }
              return String.fromCharCode(ch);
          }
        }
        readHexChar(len, forceLen, throwOnInvalid) {
          const codeLoc = this.state.curPosition();
          const n2 = this.readInt(16, len, forceLen, false);
          if (n2 === null) {
            if (throwOnInvalid) {
              this.raise(Errors.InvalidEscapeSequence, {
                at: codeLoc
              });
            } else {
              this.state.pos = codeLoc.index - 1;
            }
          }
          return n2;
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word2 = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word2 += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word2 += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word2 + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word2 = this.readWord1(firstCode);
          const type2 = keywords$1.get(word2);
          if (type2 !== void 0) {
            this.finishToken(type2, tokenLabelName(type2));
          } else {
            this.finishToken(128, word2);
          }
        }
        checkKeywordEscapes() {
          const {
            type: type2
          } = this.state;
          if (tokenIsKeyword(type2) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type2)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at: at2
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at2 instanceof Position ? at2 : at2.loc.start;
          const error2 = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery)
            throw error2;
          if (!this.isLookahead)
            this.state.errors.push(error2);
          return error2;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at: at2
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at2 instanceof Position ? at2 : at2.loc.start;
          const pos = loc.index;
          const errors2 = this.state.errors;
          for (let i2 = errors2.length - 1; i2 >= 0; i2--) {
            const error2 = errors2[i2];
            if (error2.loc.index === pos) {
              return errors2[i2] = toParseError({
                loc,
                details
              });
            }
            if (error2.loc.index < pos)
              break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type2) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type2 ? tokenLabelName(type2) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name2) => this.hasPlugin(name2))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
      }
      class Scope {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      }
      class ScopeHandler {
        constructor(parser2, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser2;
          this.inModule = inModule;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i2 = this.scopeStack.length - 1; ; i2--) {
            const {
              flags
            } = this.scopeStack[i2];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(scope2) {
          return !!(scope2.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope2.flags & SCOPE_PROGRAM);
        }
        declareName(name2, bindingType, loc) {
          let scope2 = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope2.functions.add(name2);
            } else {
              scope2.lexical.add(name2);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope2, name2);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
              scope2 = this.scopeStack[i2];
              this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
              scope2.var.add(name2);
              this.maybeExportDefined(scope2, name2);
              if (scope2.flags & SCOPE_VAR)
                break;
            }
          }
          if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name2);
          }
        }
        maybeExportDefined(scope2, name2) {
          if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name2);
          }
        }
        checkRedeclarationInScope(scope2, name2, bindingType, loc) {
          if (this.isRedeclaredInScope(scope2, name2, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name2
            });
          }
        }
        isRedeclaredInScope(scope2, name2, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE))
            return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope2.lexical.has(name2) || scope2.functions.has(name2) || scope2.var.has(name2);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope2.lexical.has(name2) || !this.treatFunctionsAsVarInScope(scope2) && scope2.var.has(name2);
          }
          return scope2.lexical.has(name2) && !(scope2.flags & SCOPE_SIMPLE_CATCH && scope2.lexical.values().next().value === name2) || !this.treatFunctionsAsVarInScope(scope2) && scope2.functions.has(name2);
        }
        checkLocalExport(id2) {
          const {
            name: name2
          } = id2;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name2) && !topLevelScope.var.has(name2) && !topLevelScope.functions.has(name2)) {
            this.undefinedExports.set(name2, id2.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i2 = this.scopeStack.length - 1; ; i2--) {
            const {
              flags
            } = this.scopeStack[i2];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i2 = this.scopeStack.length - 1; ; i2--) {
            const {
              flags
            } = this.scopeStack[i2];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      }
      class FlowScope extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      }
      class FlowScopeHandler extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name2, bindingType, loc) {
          const scope2 = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
            this.maybeExportDefined(scope2, name2);
            scope2.declareFunctions.add(name2);
            return;
          }
          super.declareName(...arguments);
        }
        isRedeclaredInScope(scope2, name2, bindingType) {
          if (super.isRedeclaredInScope(...arguments))
            return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope2.declareFunctions.has(name2) && (scope2.lexical.has(name2) || scope2.functions.has(name2));
          }
          return false;
        }
        checkLocalExport(id2) {
          if (!this.scopeStack[0].declareFunctions.has(id2.name)) {
            super.checkLocalExport(id2);
          }
        }
      }
      class ClassScope {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      }
      class ClassScopeHandler {
        constructor(parser2) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser2;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name2, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name2)) {
                current.undefinedPrivateNames.set(name2, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name2
              });
            }
          }
        }
        declarePrivateName(name2, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name2);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name2);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined)
                loneAccessors.delete(name2);
            } else if (!redefined) {
              loneAccessors.set(name2, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name2
            });
          }
          privateNames.add(name2);
          undefinedPrivateNames.delete(name2);
        }
        usePrivateName(name2, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name2))
              return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name2, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name2
            });
          }
        }
      }
      const kExpression = 0, kMaybeArrowParameterDeclaration = 1, kMaybeAsyncArrowParameterDeclaration = 2, kParameterDeclaration = 3;
      class ExpressionScope {
        constructor(type2 = kExpression) {
          this.type = void 0;
          this.type = type2;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      }
      class ArrowHeadParsingScope extends ExpressionScope {
        constructor(type2) {
          super(type2);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at: at2
        }) {
          const index = at2.index;
          this.declarationErrors.set(index, [ParsingErrorClass, at2]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      }
      class ExpressionScopeHandler {
        constructor(parser2) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser2;
        }
        enter(scope2) {
          this.stack.push(scope2);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node2
        }) {
          const origin = {
            at: node2.loc.start
          };
          const {
            stack
          } = this;
          let i2 = stack.length - 1;
          let scope2 = stack[i2];
          while (!scope2.isCertainlyParameterDeclaration()) {
            if (scope2.canBeArrowParameterDeclaration()) {
              scope2.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope2 = stack[--i2];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParemeterBindingError(error2, {
          at: node2
        }) {
          const {
            stack
          } = this;
          const scope2 = stack[stack.length - 1];
          const origin = {
            at: node2.loc.start
          };
          if (scope2.isCertainlyParameterDeclaration()) {
            this.parser.raise(error2, origin);
          } else if (scope2.canBeArrowParameterDeclaration()) {
            scope2.recordDeclarationError(error2, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at: at2
        }) {
          const {
            stack
          } = this;
          let i2 = stack.length - 1;
          let scope2 = stack[i2];
          while (scope2.canBeArrowParameterDeclaration()) {
            if (scope2.type === kMaybeAsyncArrowParameterDeclaration) {
              scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at: at2
              });
            }
            scope2 = stack[--i2];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration())
            return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i2 = stack.length - 2;
            let scope2 = stack[i2];
            while (scope2.canBeArrowParameterDeclaration()) {
              scope2.clearDeclarationError(loc.index);
              scope2 = stack[--i2];
            }
          });
        }
      }
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      const PARAM = 0, PARAM_YIELD = 1, PARAM_AWAIT = 2, PARAM_RETURN = 4, PARAM_IN = 8;
      class ProductionParameterHandler {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      }
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      class UtilParser extends Tokenizer {
        addExtra(node2, key, value, enumerable = true) {
          if (!node2)
            return;
          const extra = node2.extra = node2.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name2) {
          const nameEnd = nameStart + name2.length;
          if (this.input.slice(nameStart, nameEnd) === name2) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name2) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name2);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type2, loc) {
          this.eat(type2) || this.unexpected(loc, type2);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node2 = fn((node3 = null) => {
              abortSignal.node = node3;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node: node2,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node: node2,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error2) {
            const failState = this.state;
            this.state = oldState;
            if (error2 instanceof SyntaxError) {
              return {
                node: null,
                error: error2,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error2 === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error2;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors)
            return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node2) {
          return node2.type === "PrivateName";
        }
        getPrivateNameSV(node2) {
          return node2.id.name;
        }
        hasPropertyAsPrivateName(node2) {
          return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
        }
        isOptionalChain(node2) {
          return node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression";
        }
        isObjectProperty(node2) {
          return node2.type === "ObjectProperty";
        }
        isObjectMethod(node2) {
          return node2.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      }
      class ExpressionErrors {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      }
      class Node$6 {
        constructor(parser2, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser2 != null && parser2.options.ranges)
            this.range = [pos, 0];
          if (parser2 != null && parser2.filename)
            this.loc.filename = parser2.filename;
        }
      }
      const NodePrototype = Node$6.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node$6();
          const keys2 = Object.keys(this);
          for (let i2 = 0, length = keys2.length; i2 < length; i2++) {
            const key = keys2[i2];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node2) {
        return cloneIdentifier(node2);
      }
      function cloneIdentifier(node2) {
        const {
          type: type2,
          start,
          end,
          loc,
          range: range2,
          extra,
          name: name2
        } = node2;
        const cloned = Object.create(NodePrototype);
        cloned.type = type2;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range2;
        cloned.extra = extra;
        cloned.name = name2;
        if (type2 === "Placeholder") {
          cloned.expectedNode = node2.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node2) {
        const {
          type: type2,
          start,
          end,
          loc,
          range: range2,
          extra
        } = node2;
        if (type2 === "Placeholder") {
          return clonePlaceholder(node2);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type2;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range2;
        if (node2.raw !== void 0) {
          cloned.raw = node2.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node2.value;
        return cloned;
      }
      class NodeUtils extends UtilParser {
        startNode() {
          return new Node$6(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(pos, loc) {
          return new Node$6(this, pos, loc);
        }
        startNodeAtNode(type2) {
          return this.startNodeAt(type2.start, type2.loc.start);
        }
        finishNode(node2, type2) {
          return this.finishNodeAt(node2, type2, this.state.lastTokEndLoc);
        }
        finishNodeAt(node2, type2, endLoc) {
          node2.type = type2;
          node2.end = endLoc.index;
          node2.loc.end = endLoc;
          if (this.options.ranges)
            node2.range[1] = endLoc.index;
          if (this.options.attachComment)
            this.processComment(node2);
          return node2;
        }
        resetStartLocation(node2, start, startLoc) {
          node2.start = start;
          node2.loc.start = startLoc;
          if (this.options.ranges)
            node2.range[0] = start;
        }
        resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
          node2.end = endLoc.index;
          node2.loc.end = endLoc;
          if (this.options.ranges)
            node2.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node2, locationNode) {
          this.resetStartLocation(node2, locationNode.start, locationNode.loc.start);
        }
      }
      const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      const FlowErrors = ParseErrorEnum`flow`((_) => ({
        AmbiguousConditionalArrow: _("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
        AmbiguousDeclareModuleKind: _("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
        AssignReservedType: _(({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`),
        DeclareClassElement: _("The `declare` modifier can only appear on class fields."),
        DeclareClassFieldInitializer: _("Initializers are not allowed in fields with the `declare` modifier."),
        DuplicateDeclareModuleExports: _("Duplicate `declare module.exports` statement."),
        EnumBooleanMemberNotInitialized: _(({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`),
        EnumDuplicateMemberName: _(({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`),
        EnumInconsistentMemberValues: _(({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),
        EnumInvalidExplicitType: _(({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`),
        EnumInvalidExplicitTypeUnknownSupplied: _(({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`),
        EnumInvalidMemberInitializerPrimaryType: _(({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`),
        EnumInvalidMemberInitializerSymbolType: _(({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`),
        EnumInvalidMemberInitializerUnknownType: _(({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`),
        EnumInvalidMemberName: _(({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`),
        EnumNumberMemberNotInitialized: _(({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`),
        EnumStringMemberInconsistentlyInitailized: _(({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`),
        GetterMayNotHaveThisParam: _("A getter cannot have a `this` parameter."),
        ImportTypeShorthandOnlyInPureImport: _("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
        InexactInsideExact: _("Explicit inexact syntax cannot appear inside an explicit exact object type."),
        InexactInsideNonObject: _("Explicit inexact syntax cannot appear in class or interface definitions."),
        InexactVariance: _("Explicit inexact syntax cannot have variance."),
        InvalidNonTypeImportInDeclareModule: _("Imports within a `declare module` body must always be `import type` or `import typeof`."),
        MissingTypeParamDefault: _("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
        NestedDeclareModule: _("`declare module` cannot be used inside another `declare module`."),
        NestedFlowComment: _("Cannot have a flow comment inside another flow comment."),
        PatternIsOptional: _("A binding pattern parameter cannot be optional in an implementation signature.", {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: _("A setter cannot have a `this` parameter."),
        SpreadVariance: _("Spread properties cannot have variance."),
        ThisParamAnnotationRequired: _("A type annotation is required for the `this` parameter."),
        ThisParamBannedInConstructor: _("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."),
        ThisParamMayNotBeOptional: _("The `this` parameter cannot be optional."),
        ThisParamMustBeFirst: _("The `this` parameter must be the first function parameter."),
        ThisParamNoDefault: _("The `this` parameter may not have a default value."),
        TypeBeforeInitializer: _("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
        TypeCastInPattern: _("The type cast expression is expected to be wrapped with parenthesis."),
        UnexpectedExplicitInexactInObject: _("Explicit inexact syntax must appear at the end of an inexact object."),
        UnexpectedReservedType: _(({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`),
        UnexpectedReservedUnderscore: _("`_` is only allowed as a type argument to call or new."),
        UnexpectedSpaceBetweenModuloChecks: _("Spaces between `%` and `checks` are not allowed here."),
        UnexpectedSpreadType: _("Spread operator cannot appear in class or interface definitions."),
        UnexpectedSubtractionOperand: _('Unexpected token, expected "number" or "bigint".'),
        UnexpectedTokenAfterTypeParameter: _("Expected an arrow function after this type parameter declaration."),
        UnexpectedTypeParameterBeforeAsyncArrowFunction: _("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."),
        UnsupportedDeclareExportKind: _(({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`),
        UnsupportedStatementInDeclareModule: _("Only declares and type imports are allowed inside declare module."),
        UnterminatedFlowComment: _("Unterminated flow-comment.")
      }));
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node2) {
        return node2.importKind === "type" || node2.importKind === "typeof";
      }
      function isMaybeDefaultImport(type2) {
        return tokenIsKeywordOrIdentifier(type2) && type2 !== 97;
      }
      const exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list2, test) {
        const list1 = [];
        const list22 = [];
        for (let i2 = 0; i2 < list2.length; i2++) {
          (test(list2[i2], i2, list2) ? list1 : list22).push(list2[i2]);
        }
        return [list1, list22];
      }
      const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow$1 = (superClass) => class extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type2, val) {
          if (type2 !== 129 && type2 !== 13 && type2 !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          return super.finishToken(type2, val);
        }
        addComment(comment2) {
          if (this.flowPragma === void 0) {
            const matches = FLOW_PRAGMA_REGEX.exec(comment2.value);
            if (!matches)
              ;
            else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          return super.addComment(comment2);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type2 = this.flowParseType();
          this.state.inType = oldInType;
          return type2;
        }
        flowParsePredicate() {
          const node2 = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(107);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node2.value = this.parseExpression();
            this.expect(11);
            return this.finishNode(node2, "DeclaredPredicate");
          } else {
            return this.finishNode(node2, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type2 = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type2 = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type2, predicate];
        }
        flowParseDeclareClass(node2) {
          this.next();
          this.flowParseInterfaceish(node2, true);
          return this.finishNode(node2, "DeclareClass");
        }
        flowParseDeclareFunction(node2) {
          this.next();
          const id2 = node2.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id2.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id2);
          this.semicolon();
          this.scope.declareName(node2.id.name, BIND_FLOW_DECLARE_FN, node2.id.loc.start);
          return this.finishNode(node2, "DeclareFunction");
        }
        flowParseDeclare(node2, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node2);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node2);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node2);
          } else if (this.eatContextual(123)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node2);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node2);
            }
          } else if (this.isContextual(126)) {
            return this.flowParseDeclareTypeAlias(node2);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareOpaqueType(node2);
          } else if (this.isContextual(125)) {
            return this.flowParseDeclareInterface(node2);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node2, insideModule);
          } else {
            throw this.unexpected();
          }
        }
        flowParseDeclareVariable(node2) {
          this.next();
          node2.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node2.id.name, BIND_VAR, node2.id.loc.start);
          this.semicolon();
          return this.finishNode(node2, "DeclareVariable");
        }
        flowParseDeclareModule(node2) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(129)) {
            node2.id = this.parseExprAtom();
          } else {
            node2.id = this.parseIdentifier();
          }
          const bodyNode = node2.body = this.startNode();
          const body = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(126) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              this.parseImport(bodyNode2);
            } else {
              this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node2.kind = kind || "CommonJS";
          return this.finishNode(node2, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node2, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node2.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node2.declaration = this.flowParseType();
              this.semicolon();
            }
            node2.default = true;
            return this.finishNode(node2, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
              node2.declaration = this.flowParseDeclare(this.startNode());
              node2.default = false;
              return this.finishNode(node2, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
              node2 = this.parseExport(node2);
              if (node2.type === "ExportNamedDeclaration") {
                node2.type = "ExportDeclaration";
                node2.default = false;
                delete node2.exportKind;
              }
              node2.type = "Declare" + node2.type;
              return node2;
            }
          }
          throw this.unexpected();
        }
        flowParseDeclareModuleExports(node2) {
          this.next();
          this.expectContextual(108);
          node2.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node2, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node2) {
          this.next();
          this.flowParseTypeAlias(node2);
          node2.type = "DeclareTypeAlias";
          return node2;
        }
        flowParseDeclareOpaqueType(node2) {
          this.next();
          this.flowParseOpaqueType(node2, true);
          node2.type = "DeclareOpaqueType";
          return node2;
        }
        flowParseDeclareInterface(node2) {
          this.next();
          this.flowParseInterfaceish(node2);
          return this.finishNode(node2, "DeclareInterface");
        }
        flowParseInterfaceish(node2, isClass = false) {
          node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node2.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node2.id.loc.start);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node2.typeParameters = null;
          }
          node2.extends = [];
          node2.implements = [];
          node2.mixins = [];
          if (this.eat(81)) {
            do {
              node2.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (this.isContextual(114)) {
            this.next();
            do {
              node2.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.isContextual(110)) {
            this.next();
            do {
              node2.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node2.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node2 = this.startNode();
          node2.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node2.typeParameters = null;
          }
          return this.finishNode(node2, "InterfaceExtends");
        }
        flowParseInterface(node2) {
          this.flowParseInterfaceish(node2);
          return this.finishNode(node2, "InterfaceDeclaration");
        }
        checkNotUnderscore(word2) {
          if (word2 === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word2, startLoc, declaration2) {
          if (!reservedTypes.has(word2))
            return;
          this.raise(declaration2 ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word2
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration2) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration2);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node2) {
          node2.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.loc.start);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node2.typeParameters = null;
          }
          node2.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node2, "TypeAlias");
        }
        flowParseOpaqueType(node2, declare) {
          this.expectContextual(126);
          node2.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.loc.start);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node2.typeParameters = null;
          }
          node2.supertype = null;
          if (this.match(14)) {
            node2.supertype = this.flowParseTypeInitialiser(14);
          }
          node2.impltype = null;
          if (!declare) {
            node2.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node2, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node2 = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node2.name = ident.name;
          node2.variance = variance;
          node2.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node2.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node2, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node2 = this.startNode();
          node2.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node2.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node2, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node2 = this.startNode();
          const oldInType = this.state.inType;
          node2.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node2.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node2, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node2 = this.startNode();
          const oldInType = this.state.inType;
          node2.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node2.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node2, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node2 = this.startNode();
          this.expectContextual(125);
          node2.extends = [];
          if (this.eat(81)) {
            do {
              node2.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node2.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node2, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node2, isStatic, variance) {
          node2.static = isStatic;
          if (this.lookahead().type === 14) {
            node2.id = this.flowParseObjectPropertyKey();
            node2.key = this.flowParseTypeInitialiser();
          } else {
            node2.id = null;
            node2.key = this.flowParseType();
          }
          this.expect(3);
          node2.value = this.flowParseTypeInitialiser();
          node2.variance = variance;
          return this.finishNode(node2, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node2, isStatic) {
          node2.static = isStatic;
          node2.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node2.method = true;
            node2.optional = false;
            node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
          } else {
            node2.method = false;
            if (this.eat(17)) {
              node2.optional = true;
            }
            node2.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node2, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node2) {
          node2.params = [];
          node2.rest = null;
          node2.typeParameters = null;
          node2.this = null;
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node2.this = this.flowParseFunctionTypeParam(true);
            node2.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node2.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node2.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node2.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node2, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node2, isStatic) {
          const valueNode = this.startNode();
          node2.static = isStatic;
          node2.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node2, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node2 = this.startNode();
            if (allowProto && this.isContextual(115)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node2.argument = this.flowParseType();
            return this.finishNode(node2, "ObjectTypeSpreadProperty");
          } else {
            node2.key = this.flowParseObjectPropertyKey();
            node2.static = isStatic;
            node2.proto = protoStartLoc != null;
            node2.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node2.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node2);
              }
              if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node2.value.this
                });
              }
            } else {
              if (kind !== "init")
                this.unexpected();
              node2.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node2.value = this.flowParseTypeInitialiser();
              node2.variance = variance;
            }
            node2.optional = optional;
            return this.finishNode(node2, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property) {
          const paramCount = property.kind === "get" ? 0 : 1;
          const length = property.value.params.length + (property.value.rest ? 1 : 0);
          if (property.value.this) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }
          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startPos, startLoc, id2) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          let node2 = id2 || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node22 = this.startNodeAt(startPos, startLoc);
            node22.qualification = node2;
            node22.id = this.flowParseRestrictedIdentifier(true);
            node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
          }
          return node2;
        }
        flowParseGenericType(startPos, startLoc, id2) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.typeParameters = null;
          node2.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id2);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node2, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node2 = this.startNode();
          this.expect(87);
          node2.argument = this.flowParsePrimaryType();
          return this.finishNode(node2, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node2 = this.startNode();
          node2.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node2.types.push(this.flowParseType());
            if (this.match(3))
              break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node2, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name2 = null;
          let optional = false;
          let typeAnnotation = null;
          const node2 = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node2
              });
            }
            name2 = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node2
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node2.name = name2;
          node2.optional = optional;
          node2.typeAnnotation = typeAnnotation;
          return this.finishNode(node2, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type2) {
          const node2 = this.startNodeAt(type2.start, type2.loc.start);
          node2.name = null;
          node2.optional = false;
          node2.typeAnnotation = type2;
          return this.finishNode(node2, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startPos, startLoc, node2, id2) {
          switch (id2.name) {
            case "any":
              return this.finishNode(node2, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node2, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node2, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node2, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node2, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node2, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node2, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id2.name);
              return this.flowParseGenericType(startPos, startLoc, id2);
          }
        }
        flowParsePrimaryType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node2 = this.startNode();
          let tmp;
          let type2;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type2 = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type2;
            case 47:
              node2.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node2.params = tmp.params;
              node2.rest = tmp.rest;
              node2.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node2.returnType = this.flowParseType();
              return this.finishNode(node2, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type2 = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type2;
                } else {
                  this.eat(12);
                }
              }
              if (type2) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type2)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node2.params = tmp.params;
              node2.rest = tmp.rest;
              node2.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node2.returnType = this.flowParseType();
              node2.typeParameters = null;
              return this.finishNode(node2, "FunctionTypeAnnotation");
            case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node2.value = this.match(85);
              this.next();
              return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(130)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
                }
                if (this.match(131)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();
            case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node2, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node2, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node2, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node2, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node2, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(125)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node2, this.parseIdentifier());
              }
          }
          throw this.unexpected();
        }
        flowParsePostfixType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let type2 = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startPos, startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node2.elementType = type2;
              this.next();
              type2 = this.finishNode(node2, "ArrayTypeAnnotation");
            } else {
              node2.objectType = type2;
              node2.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node2.optional = optional;
                type2 = this.finishNode(node2, "OptionalIndexedAccessType");
              } else {
                type2 = this.finishNode(node2, "IndexedAccessType");
              }
            }
          }
          return type2;
        }
        flowParsePrefixType() {
          const node2 = this.startNode();
          if (this.eat(17)) {
            node2.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node2, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node2 = this.startNodeAt(param.start, param.loc.start);
            node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node2.rest = null;
            node2.this = null;
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node2 = this.startNode();
          this.eat(45);
          const type2 = this.flowParseAnonFunctionWithoutParens();
          node2.types = [type2];
          while (this.eat(45)) {
            node2.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node2.types.length === 1 ? type2 : this.finishNode(node2, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node2 = this.startNode();
          this.eat(43);
          const type2 = this.flowParseIntersectionType();
          node2.types = [type2];
          while (this.eat(43)) {
            node2.types.push(this.flowParseIntersectionType());
          }
          return node2.types.length === 1 ? type2 : this.finishNode(node2, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type2 = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type2;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 128 && this.state.value === "_") {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node2 = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node2);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node2 = this.startNode();
          node2.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node2, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node2) {
          node2.expression.typeAnnotation = node2.typeAnnotation;
          this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
          return node2.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node2, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
          }
          return super.parseFunctionBody(node2, false, isMethod);
        }
        parseFunctionBodyAndFinish(node2, type2, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          super.parseFunctionBodyAndFinish(node2, type2, isMethod);
        }
        parseStatement(context, topLevel) {
          if (this.state.strict && this.isContextual(125)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node2 = this.startNode();
              this.next();
              return this.flowParseInterface(node2);
            }
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            const node2 = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node2);
          }
          const stmt = super.parseStatement(context, topLevel);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node2, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node2);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node2);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node2);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node2, false);
              }
            }
          }
          return super.parseExpressionStatement(node2, expr);
        }
        shouldParseExportDeclaration() {
          const {
            type: type2
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type2) || this.shouldParseEnums() && type2 === 122) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type: type2
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type2) || this.shouldParseEnums() && type2 === 122) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(122)) {
            const node2 = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node2);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.match(17))
            return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node2 = this.startNodeAt(startPos, startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i2 = 0; i2 < invalid.length; i2++) {
                noArrowAt.push(invalid[i2].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node2.test = expr;
          node2.consequent = consequent;
          node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node2, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node2, disallowInvalid) {
          const stack = [node2];
          const arrows = [];
          while (stack.length !== 0) {
            const node3 = stack.pop();
            if (node3.type === "ArrowFunctionExpression") {
              if (node3.typeParameters || !node3.returnType) {
                this.finishArrowValidation(node3);
              } else {
                arrows.push(node3);
              }
              stack.push(node3.body);
            } else if (node3.type === "ConditionalExpression") {
              stack.push(node3.consequent);
              stack.push(node3.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node3) => this.finishArrowValidation(node3));
            return [arrows, []];
          }
          return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node2) {
          var _node$extra;
          this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node2, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node2, parse2) {
          let result2;
          if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result2 = parse2();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result2 = parse2();
          }
          return result2;
        }
        parseParenItem(node2, startPos, startLoc) {
          node2 = super.parseParenItem(node2, startPos, startLoc);
          if (this.eat(17)) {
            node2.optional = true;
            this.resetEndLocation(node2);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node2;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node2;
        }
        assertModuleNodeAllowed(node2) {
          if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node2);
        }
        parseExport(node2) {
          const decl = super.parseExport(node2);
          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }
          return decl;
        }
        parseExportDeclaration(node2) {
          if (this.isContextual(126)) {
            node2.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node2.specifiers = this.parseExportSpecifiers(true);
              this.parseExportFrom(node2);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(127)) {
            node2.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(125)) {
            node2.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            node2.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node2);
          }
        }
        eatExportStar(node2) {
          if (super.eatExportStar(...arguments))
            return true;
          if (this.isContextual(126) && this.lookahead().type === 55) {
            node2.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node2) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
          if (hasNamespace && node2.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node2, isStatement, optionalId) {
          super.parseClassId(node2, isStatement, optionalId);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(121)) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word2) {
          return word2 === "iterator" || word2 === "asyncIterator";
        }
        readIterator() {
          const word2 = super.readWord1();
          const fullWord = "@@" + word2;
          if (!this.isIterator(word2) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(128, fullWord);
        }
        getTokenFromCode(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 123 && next === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
            return this.finishOp(code2 === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code2 === 63) {
            if (next === 46) {
              return this.finishOp(18, 2);
            }
            return this.finishOp(17, 1);
          } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return super.getTokenFromCode(code2);
          }
        }
        isAssignable(node2, isBinding) {
          if (node2.type === "TypeCastExpression") {
            return this.isAssignable(node2.expression, isBinding);
          } else {
            return super.isAssignable(node2, isBinding);
          }
        }
        toAssignable(node2, isLHS = false) {
          if (!isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression") {
            node2.left = this.typeCastToParameter(node2.left);
          }
          super.toAssignable(...arguments);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i2 = 0; i2 < exprList.length; i2++) {
            const expr = exprList[i2];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i2] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i2 = 0; i2 < exprList.length; i2++) {
            var _expr$extra;
            const expr = exprList[i2];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node2.elements);
          }
          return node2;
        }
        isValidLVal(type2, ...rest) {
          return type2 === "TypeCastExpression" || super.isValidLVal(type2, ...rest);
        }
        parseClassProperty(node2) {
          if (this.match(14)) {
            node2.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node2);
        }
        parseClassPrivateProperty(node2) {
          if (this.match(14)) {
            node2.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node2);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method2) {
          return !this.match(14) && super.isNonstaticConstructor(method2);
        }
        pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method2.variance) {
            this.unexpected(method2.variance.loc.start);
          }
          delete method2.variance;
          if (this.match(47)) {
            method2.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method2.params && isConstructor) {
            const params = method2.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method2
              });
            }
          } else if (method2.type === "MethodDefinition" && isConstructor && method2.value.params) {
            const params = method2.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method2
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method2, isGenerator, isAsync) {
          if (method2.variance) {
            this.unexpected(method2.variance.loc.start);
          }
          delete method2.variance;
          if (this.match(47)) {
            method2.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method2, isGenerator, isAsync);
        }
        parseClassSuper(node2) {
          super.parseClassSuper(node2);
          if (node2.superClass && this.match(47)) {
            node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(110)) {
            this.next();
            const implemented = node2.implements = [];
            do {
              const node3 = this.startNode();
              node3.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node3.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node3.typeParameters = null;
              }
              implemented.push(this.finishNode(node3, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method2) {
          super.checkGetterSetterParams(method2);
          const params = this.getObjectOrClassMethodParams(method2);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method2.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node2) {
          node2.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10))
              this.unexpected();
          }
          super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (prop.value || prop).typeParameters = typeParameters;
          }
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node2 = super.parseMaybeDefault(startPos, startLoc, left);
          if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node2.typeAnnotation
            });
          }
          return node2;
        }
        shouldParseDefaultImport(node2) {
          if (!hasTypeImportKind(node2)) {
            return super.shouldParseDefaultImport(node2);
          }
          return isMaybeDefaultImport(this.state.type);
        }
        parseImportSpecifierLocal(node2, specifier, type2) {
          specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node2.specifiers.push(this.finishImportSpecifier(specifier, type2));
        }
        maybeParseDefaultImportSpecifier(node2) {
          node2.importKind = "value";
          let kind = null;
          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(126)) {
            kind = "type";
          }
          if (kind) {
            const lh = this.lookahead();
            const {
              type: type2
            } = lh;
            if (kind === "type" && type2 === 55) {
              this.unexpected(null, lh.type);
            }
            if (isMaybeDefaultImport(type2) || type2 === 5 || type2 === 55) {
              this.next();
              node2.importKind = kind;
            }
          }
          return super.maybeParseDefaultImportSpecifier(node2);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node2, allowModifiers) {
          const kind = node2.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node2, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node2, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node2.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node2, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types$3.j_oTag || currentContext === types$3.j_expr) {
              context.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result2 = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result2, typeParameters);
                return result2;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
                abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression")
                abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node2) {
          if (this.match(14)) {
            const result2 = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(19))
                this.unexpected();
              return typeNode;
            });
            if (result2.thrown)
              return null;
            if (result2.error)
              this.state = result2.failState;
            node2.returnType = result2.node.typeAnnotation ? this.finishNode(result2.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node2);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node2, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
            node2.params = params;
          } else {
            super.setArrowFunctionParameters(node2, params);
          }
        }
        checkParams(node2, allowDuplicates, isArrowFunction) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
            return;
          }
          for (let i2 = 0; i2 < node2.params.length; i2++) {
            if (this.isThisParam(node2.params[i2]) && i2 > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node2.params[i2]
              });
            }
          }
          return super.checkParams(...arguments);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base2, startPos, startLoc, noCalls) {
          if (base2.type === "Identifier" && base2.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.callee = base2;
            node2.arguments = this.parseCallExpressionArguments(11, false);
            base2 = this.finishNode(node2, "CallExpression");
          } else if (base2.type === "Identifier" && base2.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            const result2 = this.tryParse(() => super.parseSubscripts(base2, startPos, startLoc, noCalls), state);
            if (result2.node && !result2.error)
              return result2.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result2.node) {
              this.state = result2.failState;
              return result2.node;
            }
            throw arrow.error || result2.error;
          }
          return super.parseSubscripts(base2, startPos, startLoc, noCalls);
        }
        parseSubscript(base2, startPos, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base2;
            }
            this.next();
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.callee = base2;
            node2.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node2.arguments = this.parseCallExpressionArguments(11, false);
            node2.optional = true;
            return this.finishCallExpression(node2, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.callee = base2;
            const result2 = this.tryParse(() => {
              node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node2.arguments = this.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember)
                node2.optional = false;
              return this.finishCallExpression(node2, subscriptState.optionalChainMember);
            });
            if (result2.node) {
              if (result2.error)
                this.state = result2.failState;
              return result2.node;
            }
          }
          return super.parseSubscript(base2, startPos, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node2) {
          super.parseNewCallee(node2);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node2.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          const node2 = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node2);
          if (!this.parseArrow(node2))
            return;
          return this.parseArrowExpression(node2, void 0, true);
        }
        readToken_mult_modulo(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code2);
        }
        readToken_pipe_amp(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code2);
        }
        parseTopLevel(file, program) {
          const fileNode = super.parseTopLevel(file, program);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            this.state.pos += this.skipFlowComment();
            this.state.hasFlowComment = true;
            return;
          }
          if (this.state.hasFlowComment) {
            const end = this.input.indexOf("*-/", this.state.pos + 2);
            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }
            this.state.pos = end + 2 + 3;
            return;
          }
          return super.skipBlockComment();
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node2, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node2,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 130: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 129: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id2 = this.parseIdentifier(true);
          const init2 = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id: id2,
            init: init2
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          const {
            explicitType
          } = context;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id: id2,
              init: init2
            } = this.flowEnumMemberRaw();
            const memberName = id2.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id2,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id2,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id2;
            switch (init2.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "boolean");
                memberNode.init = init2.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "number");
                memberNode.init = init2.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "string");
                memberNode.init = init2.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init2.loc, context);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init2.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init2.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101))
            return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node2, id2) {
          const enumName = id2.name;
          const nameLoc = id2.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node2.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node2.explicitType = true;
              node2.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node2, "EnumBooleanBody");
            case "number":
              node2.explicitType = true;
              node2.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node2, "EnumNumberBody");
            case "string":
              node2.explicitType = true;
              node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node2, "EnumStringBody");
            case "symbol":
              node2.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node2, "EnumSymbolBody");
            default: {
              const empty = () => {
                node2.members = [];
                this.expect(8);
                return this.finishNode(node2, "EnumStringBody");
              };
              node2.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node2, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node2.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node2, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node2.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node2, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node2) {
          const id2 = this.parseIdentifier();
          node2.id = id2;
          node2.body = this.flowEnumBody(this.startNode(), id2);
          return this.finishNode(node2, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next = this.nextTokenStart();
          if (this.input.charCodeAt(next) === 60) {
            const afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node2) {
          return node2.type === "TypeCastExpression" ? node2.expression : node2;
        }
      };
      const entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: " ",
        iexcl: "¡",
        cent: "¢",
        pound: "£",
        curren: "¤",
        yen: "¥",
        brvbar: "¦",
        sect: "§",
        uml: "¨",
        copy: "©",
        ordf: "ª",
        laquo: "«",
        not: "¬",
        shy: "­",
        reg: "®",
        macr: "¯",
        deg: "°",
        plusmn: "±",
        sup2: "²",
        sup3: "³",
        acute: "´",
        micro: "µ",
        para: "¶",
        middot: "·",
        cedil: "¸",
        sup1: "¹",
        ordm: "º",
        raquo: "»",
        frac14: "¼",
        frac12: "½",
        frac34: "¾",
        iquest: "¿",
        Agrave: "À",
        Aacute: "Á",
        Acirc: "Â",
        Atilde: "Ã",
        Auml: "Ä",
        Aring: "Å",
        AElig: "Æ",
        Ccedil: "Ç",
        Egrave: "È",
        Eacute: "É",
        Ecirc: "Ê",
        Euml: "Ë",
        Igrave: "Ì",
        Iacute: "Í",
        Icirc: "Î",
        Iuml: "Ï",
        ETH: "Ð",
        Ntilde: "Ñ",
        Ograve: "Ò",
        Oacute: "Ó",
        Ocirc: "Ô",
        Otilde: "Õ",
        Ouml: "Ö",
        times: "×",
        Oslash: "Ø",
        Ugrave: "Ù",
        Uacute: "Ú",
        Ucirc: "Û",
        Uuml: "Ü",
        Yacute: "Ý",
        THORN: "Þ",
        szlig: "ß",
        agrave: "à",
        aacute: "á",
        acirc: "â",
        atilde: "ã",
        auml: "ä",
        aring: "å",
        aelig: "æ",
        ccedil: "ç",
        egrave: "è",
        eacute: "é",
        ecirc: "ê",
        euml: "ë",
        igrave: "ì",
        iacute: "í",
        icirc: "î",
        iuml: "ï",
        eth: "ð",
        ntilde: "ñ",
        ograve: "ò",
        oacute: "ó",
        ocirc: "ô",
        otilde: "õ",
        ouml: "ö",
        divide: "÷",
        oslash: "ø",
        ugrave: "ù",
        uacute: "ú",
        ucirc: "û",
        uuml: "ü",
        yacute: "ý",
        thorn: "þ",
        yuml: "ÿ",
        OElig: "Œ",
        oelig: "œ",
        Scaron: "Š",
        scaron: "š",
        Yuml: "Ÿ",
        fnof: "ƒ",
        circ: "ˆ",
        tilde: "˜",
        Alpha: "Α",
        Beta: "Β",
        Gamma: "Γ",
        Delta: "Δ",
        Epsilon: "Ε",
        Zeta: "Ζ",
        Eta: "Η",
        Theta: "Θ",
        Iota: "Ι",
        Kappa: "Κ",
        Lambda: "Λ",
        Mu: "Μ",
        Nu: "Ν",
        Xi: "Ξ",
        Omicron: "Ο",
        Pi: "Π",
        Rho: "Ρ",
        Sigma: "Σ",
        Tau: "Τ",
        Upsilon: "Υ",
        Phi: "Φ",
        Chi: "Χ",
        Psi: "Ψ",
        Omega: "Ω",
        alpha: "α",
        beta: "β",
        gamma: "γ",
        delta: "δ",
        epsilon: "ε",
        zeta: "ζ",
        eta: "η",
        theta: "θ",
        iota: "ι",
        kappa: "κ",
        lambda: "λ",
        mu: "μ",
        nu: "ν",
        xi: "ξ",
        omicron: "ο",
        pi: "π",
        rho: "ρ",
        sigmaf: "ς",
        sigma: "σ",
        tau: "τ",
        upsilon: "υ",
        phi: "φ",
        chi: "χ",
        psi: "ψ",
        omega: "ω",
        thetasym: "ϑ",
        upsih: "ϒ",
        piv: "ϖ",
        ensp: " ",
        emsp: " ",
        thinsp: " ",
        zwnj: "‌",
        zwj: "‍",
        lrm: "‎",
        rlm: "‏",
        ndash: "–",
        mdash: "—",
        lsquo: "‘",
        rsquo: "’",
        sbquo: "‚",
        ldquo: "“",
        rdquo: "”",
        bdquo: "„",
        dagger: "†",
        Dagger: "‡",
        bull: "•",
        hellip: "…",
        permil: "‰",
        prime: "′",
        Prime: "″",
        lsaquo: "‹",
        rsaquo: "›",
        oline: "‾",
        frasl: "⁄",
        euro: "€",
        image: "ℑ",
        weierp: "℘",
        real: "ℜ",
        trade: "™",
        alefsym: "ℵ",
        larr: "←",
        uarr: "↑",
        rarr: "→",
        darr: "↓",
        harr: "↔",
        crarr: "↵",
        lArr: "⇐",
        uArr: "⇑",
        rArr: "⇒",
        dArr: "⇓",
        hArr: "⇔",
        forall: "∀",
        part: "∂",
        exist: "∃",
        empty: "∅",
        nabla: "∇",
        isin: "∈",
        notin: "∉",
        ni: "∋",
        prod: "∏",
        sum: "∑",
        minus: "−",
        lowast: "∗",
        radic: "√",
        prop: "∝",
        infin: "∞",
        ang: "∠",
        and: "∧",
        or: "∨",
        cap: "∩",
        cup: "∪",
        int: "∫",
        there4: "∴",
        sim: "∼",
        cong: "≅",
        asymp: "≈",
        ne: "≠",
        equiv: "≡",
        le: "≤",
        ge: "≥",
        sub: "⊂",
        sup: "⊃",
        nsub: "⊄",
        sube: "⊆",
        supe: "⊇",
        oplus: "⊕",
        otimes: "⊗",
        perp: "⊥",
        sdot: "⋅",
        lceil: "⌈",
        rceil: "⌉",
        lfloor: "⌊",
        rfloor: "⌋",
        lang: "〈",
        rang: "〉",
        loz: "◊",
        spades: "♠",
        clubs: "♣",
        hearts: "♥",
        diams: "♦"
      };
      const JsxErrors = ParseErrorEnum`jsx`((_) => ({
        AttributeIsEmpty: _("JSX attributes must only be assigned a non-empty expression."),
        MissingClosingTagElement: _(({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`),
        MissingClosingTagFragment: _("Expected corresponding JSX closing tag for <>."),
        UnexpectedSequenceExpression: _("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"),
        UnexpectedToken: _(({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`),
        UnsupportedJsxValue: _("JSX value should be either an expression or a quoted JSX text."),
        UnterminatedJsxContent: _("Unterminated JSX contents."),
        UnwrappedAdjacentJSXElements: _("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?")
      }));
      function isFragment(object2) {
        return object2 ? object2.type === "JSXOpeningFragment" || object2.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object2) {
        if (object2.type === "JSXIdentifier") {
          return object2.name;
        }
        if (object2.type === "JSXNamespacedName") {
          return object2.namespace.name + ":" + object2.name.name;
        }
        if (object2.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
        }
        throw new Error("Node had unexpected type: " + object2.type);
      }
      var jsx = (superClass) => class extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(138);
                  }
                  return super.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(137, out);
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(129, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(136, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node2 = this.startNode();
          if (this.match(136)) {
            node2.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node2.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node2, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const name2 = this.jsxParseIdentifier();
          if (!this.eat(14))
            return name2;
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.namespace = name2;
          node2.name = this.jsxParseIdentifier();
          return this.finishNode(node2, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let node2 = this.jsxParseNamespacedName();
          if (node2.type === "JSXNamespacedName") {
            return node2;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node2;
            newNode.property = this.jsxParseIdentifier();
            node2 = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node2;
        }
        jsxParseAttributeValue() {
          let node2;
          switch (this.state.type) {
            case 5:
              node2 = this.startNode();
              this.setContext(types$3.brace);
              this.next();
              node2 = this.jsxParseExpressionContainer(node2, types$3.j_oTag);
              if (node2.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node2
                });
              }
              return node2;
            case 138:
            case 129:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node2 = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
          return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node2) {
          this.next();
          node2.expression = this.parseExpression();
          this.setContext(types$3.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node2, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node2, previousContext) {
          if (this.match(8)) {
            node2.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node2.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node2, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node2 = this.startNode();
          if (this.match(5)) {
            this.setContext(types$3.brace);
            this.next();
            this.expect(21);
            node2.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types$3.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node2, "JSXSpreadAttribute");
          }
          node2.name = this.jsxParseNamespacedName();
          node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node2, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startPos, startLoc) {
          const node2 = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node2, "JSXOpeningFragment");
          }
          node2.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node2);
        }
        jsxParseOpeningElementAfterName(node2) {
          const attributes2 = [];
          while (!this.match(56) && !this.match(139)) {
            attributes2.push(this.jsxParseAttribute());
          }
          node2.attributes = attributes2;
          node2.selfClosing = this.eat(56);
          this.expect(139);
          return this.finishNode(node2, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startPos, startLoc) {
          const node2 = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node2, "JSXClosingFragment");
          }
          node2.name = this.jsxParseElementName();
          this.expect(139);
          return this.finishNode(node2, "JSXClosingElement");
        }
        jsxParseElementAt(startPos, startLoc) {
          const node2 = this.startNodeAt(startPos, startLoc);
          const children = [];
          const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.state.type) {
                  case 138:
                    startPos = this.state.start;
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsxParseElementAt(startPos, startLoc));
                    break;
                  case 137:
                    children.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const node3 = this.startNode();
                    this.setContext(types$3.brace);
                    this.next();
                    if (this.match(21)) {
                      children.push(this.jsxParseSpreadChild(node3));
                    } else {
                      children.push(this.jsxParseExpressionContainer(node3, types$3.j_expr));
                    }
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node2.openingFragment = openingElement;
            node2.closingFragment = closingElement;
          } else {
            node2.openingElement = openingElement;
            node2.closingElement = closingElement;
          }
          node2.children = children;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
        }
        jsxParseElement() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
        setContext(newContext) {
          const {
            context
          } = this.state;
          context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(137)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(138)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace)
            super.skipSpace();
        }
        getTokenFromCode(code2) {
          const context = this.curContext();
          if (context === types$3.j_expr) {
            return this.jsxReadToken();
          }
          if (context === types$3.j_oTag || context === types$3.j_cTag) {
            if (isIdentifierStart(code2)) {
              return this.jsxReadWord();
            }
            if (code2 === 62) {
              ++this.state.pos;
              return this.finishToken(139);
            }
            if ((code2 === 34 || code2 === 39) && context === types$3.j_oTag) {
              return this.jsxReadString(code2);
            }
          }
          if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(138);
          }
          return super.getTokenFromCode(code2);
        }
        updateContext(prevType) {
          const {
            context,
            type: type2
          } = this.state;
          if (type2 === 56 && prevType === 138) {
            context.splice(-2, 2, types$3.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type2 === 138) {
            context.push(types$3.j_oTag);
          } else if (type2 === 139) {
            const out = context[context.length - 1];
            if (out === types$3.j_oTag && prevType === 56 || out === types$3.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types$3.j_expr;
            } else {
              this.setContext(types$3.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type2);
          }
        }
      };
      class TypeScriptScope extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      }
      class TypeScriptScopeHandler extends ScopeHandler {
        createScope(flags) {
          return new TypeScriptScope(flags);
        }
        declareName(name2, bindingType, loc) {
          const scope2 = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope2, name2);
            scope2.exportOnlyBindings.add(name2);
            return;
          }
          super.declareName(...arguments);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
              this.maybeExportDefined(scope2, name2);
            }
            scope2.types.add(name2);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM)
            scope2.enums.add(name2);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
            scope2.constEnums.add(name2);
          if (bindingType & BIND_FLAGS_CLASS)
            scope2.classes.add(name2);
        }
        isRedeclaredInScope(scope2, name2, bindingType) {
          if (scope2.enums.has(name2)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope2.constEnums.has(name2);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope2.classes.has(name2)) {
            if (scope2.lexical.has(name2)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope2.types.has(name2)) {
            return true;
          }
          return super.isRedeclaredInScope(...arguments);
        }
        checkLocalExport(id2) {
          const topLevelScope = this.scopeStack[0];
          const {
            name: name2
          } = id2;
          if (!topLevelScope.types.has(name2) && !topLevelScope.exportOnlyBindings.has(name2)) {
            super.checkLocalExport(id2);
          }
        }
      }
      const getOwn$1 = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key];
      function nonNull(x) {
        if (x == null) {
          throw new Error(`Unexpected ${x} value.`);
        }
        return x;
      }
      function assert$1(x) {
        if (!x) {
          throw new Error("Assert fail");
        }
      }
      const TSErrors = ParseErrorEnum`typescript`((_) => ({
        AbstractMethodHasImplementation: _(({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`),
        AbstractPropertyHasInitializer: _(({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`),
        AccesorCannotDeclareThisParameter: _("'get' and 'set' accessors cannot declare 'this' parameters."),
        AccesorCannotHaveTypeParameters: _("An accessor cannot have type parameters."),
        CannotFindName: _(({
          name: name2
        }) => `Cannot find name '${name2}'.`),
        ClassMethodHasDeclare: _("Class methods cannot have the 'declare' modifier."),
        ClassMethodHasReadonly: _("Class methods cannot have the 'readonly' modifier."),
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: _("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
        ConstructorHasTypeParameters: _("Type parameters cannot appear on a constructor declaration."),
        DeclareAccessor: _(({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`),
        DeclareClassFieldHasInitializer: _("Initializers are not allowed in ambient contexts."),
        DeclareFunctionHasImplementation: _("An implementation cannot be declared in ambient contexts."),
        DuplicateAccessibilityModifier: _(({
          modifier
        }) => `Accessibility modifier already seen.`),
        DuplicateModifier: _(({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`),
        EmptyHeritageClauseType: _(({
          token
        }) => `'${token}' list cannot be empty.`),
        EmptyTypeArguments: _("Type argument list cannot be empty."),
        EmptyTypeParameters: _("Type parameter list cannot be empty."),
        ExpectedAmbientAfterExportDeclare: _("'export declare' must be followed by an ambient declaration."),
        ImportAliasHasImportType: _("An import alias can not use 'import type'."),
        IncompatibleModifiers: _(({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`),
        IndexSignatureHasAbstract: _("Index signatures cannot have the 'abstract' modifier."),
        IndexSignatureHasAccessibility: _(({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`),
        IndexSignatureHasDeclare: _("Index signatures cannot have the 'declare' modifier."),
        IndexSignatureHasOverride: _("'override' modifier cannot appear on an index signature."),
        IndexSignatureHasStatic: _("Index signatures cannot have the 'static' modifier."),
        InitializerNotAllowedInAmbientContext: _("Initializers are not allowed in ambient contexts."),
        InvalidModifierOnTypeMember: _(({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`),
        InvalidModifierOnTypeParameter: _(({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`),
        InvalidModifierOnTypeParameterPositions: _(({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`),
        InvalidModifiersOrder: _(({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`),
        InvalidPropertyAccessAfterInstantiationExpression: _("Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments."),
        InvalidTupleMemberLabel: _("Tuple members must be labeled with a simple identifier."),
        MissingInterfaceName: _("'interface' declarations must be followed by an identifier."),
        MixedLabeledAndUnlabeledElements: _("Tuple members must all have names or all not have names."),
        NonAbstractClassHasAbstractMethod: _("Abstract methods can only appear within an abstract class."),
        NonClassMethodPropertyHasAbstractModifer: _("'abstract' modifier can only appear on a class, method, or property declaration."),
        OptionalTypeBeforeRequired: _("A required element cannot follow an optional element."),
        OverrideNotInSubClass: _("This member cannot have an 'override' modifier because its containing class does not extend another class."),
        PatternIsOptional: _("A binding pattern parameter cannot be optional in an implementation signature."),
        PrivateElementHasAbstract: _("Private elements cannot have the 'abstract' modifier."),
        PrivateElementHasAccessibility: _(({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`),
        ReadonlyForMethodSignature: _("'readonly' modifier can only appear on a property declaration or index signature."),
        ReservedArrowTypeParam: _("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."),
        ReservedTypeAssertion: _("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
        SetAccesorCannotHaveOptionalParameter: _("A 'set' accessor cannot have an optional parameter."),
        SetAccesorCannotHaveRestParameter: _("A 'set' accessor cannot have rest parameter."),
        SetAccesorCannotHaveReturnType: _("A 'set' accessor cannot have a return type annotation."),
        SingleTypeParameterWithoutTrailingComma: _(({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`),
        StaticBlockCannotHaveModifier: _("Static class blocks cannot have any modifier."),
        TypeAnnotationAfterAssign: _("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
        TypeImportCannotSpecifyDefaultAndNamed: _("A type-only import can specify a default import or named bindings, but not both."),
        TypeModifierIsUsedInTypeExports: _("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
        TypeModifierIsUsedInTypeImports: _("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
        UnexpectedParameterModifier: _("A parameter property is only allowed in a constructor implementation."),
        UnexpectedReadonly: _("'readonly' type modifier is only permitted on array and tuple literal types."),
        UnexpectedTypeAnnotation: _("Did not expect a type annotation here."),
        UnexpectedTypeCastInParameter: _("Unexpected type cast in parameter position."),
        UnsupportedImportTypeArgument: _("Argument in a type import must be a string literal."),
        UnsupportedParameterPropertyKind: _("A parameter property may not be declared using a binding pattern."),
        UnsupportedSignatureParameterKind: _(({
          type: type2
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type2}.`)
      }));
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class extends superClass {
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          modified,
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier)
              break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(kind, parseElement2) {
          const result2 = [];
          while (!this.tsIsListTerminator(kind)) {
            result2.push(parseElement2());
          }
          return result2;
        }
        tsParseDelimitedList(kind, parseElement2, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement2, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement2, expectSuccess, refTrailingCommaPos) {
          const result2 = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement2();
            if (element == null) {
              return void 0;
            }
            result2.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result2;
        }
        tsParseBracketedList(kind, parseElement2, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result2 = this.tsParseDelimitedList(kind, parseElement2, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result2;
        }
        tsParseImportType() {
          const node2 = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(129)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node2.argument = this.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node2.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node2.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node2, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node2 = this.startNodeAtNode(entity);
            node2.left = entity;
            node2.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node2, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node2 = this.startNode();
          node2.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node2.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node2, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node2 = this.startNodeAtNode(lhs);
          node2.parameterName = lhs;
          node2.typeAnnotation = this.tsParseTypeAnnotation(false);
          node2.asserts = false;
          return this.finishNode(node2, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "TSThisType");
        }
        tsParseTypeQuery() {
          const node2 = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node2.exprName = this.tsParseImportType();
          } else {
            node2.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node2.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node2, "TSTypeQuery");
        }
        tsParseInOutModifiers(node2) {
          this.tsParseModifiers({
            modified: node2,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        tsParseNoneModifiers(node2) {
          this.tsParseModifiers({
            modified: node2,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
        tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
          const node2 = this.startNode();
          parseModifiers(node2);
          node2.name = this.tsParseTypeParameterName();
          node2.constraint = this.tsEatThenParseType(81);
          node2.default = this.tsEatThenParseType(29);
          return this.finishNode(node2, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node2 = this.startNode();
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node2.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node2
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node2, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node2, "TSTypeParameterDeclaration");
        }
        tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75)
            return null;
          this.next();
          const typeReference = this.tsParseTypeReference();
          if (typeReference.typeParameters) {
            this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            });
          }
          return typeReference;
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          return this.parseBindingList(11, 41).map((pattern) => {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }
            return pattern;
          });
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node2) {
          this.tsFillSignature(14, node2);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node2, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node2) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return void 0;
          }
          this.expect(0);
          const id2 = this.parseIdentifier();
          id2.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id2);
          this.expect(3);
          node2.parameters = [id2];
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2)
            node2.typeAnnotation = type2;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node2, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node2, readonly) {
          if (this.eat(17))
            node2.optional = true;
          const nodeAny = node2;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node2
              });
            }
            const method2 = nodeAny;
            if (method2.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method2);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method2.kind === "get") {
              if (method2[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method2[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method2.kind === "set") {
              if (method2[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method2[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method2[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method2[returnTypeKey]
                });
              }
            } else {
              method2.kind = "method";
            }
            return this.finishNode(method2, "TSMethodSignature");
          } else {
            const property = nodeAny;
            if (readonly)
              property.readonly = true;
            const type2 = this.tsTryParseTypeAnnotation();
            if (type2)
              property.typeAnnotation = type2;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node2 = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
          }
          if (this.match(77)) {
            const id2 = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
            } else {
              node2.key = this.createIdentifier(id2, "new");
              return this.tsParsePropertyOrMethodSignature(node2, false);
            }
          }
          this.tsParseModifiers({
            modified: node2,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          const idx = this.tsTryParseIndexSignature(node2);
          if (idx) {
            return idx;
          }
          this.parsePropertyName(node2);
          if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node2.kind = node2.key.name;
            this.parsePropertyName(node2);
          }
          return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
        }
        tsParseTypeLiteral() {
          const node2 = this.startNode();
          node2.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node2, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(118);
          }
          if (this.isContextual(118)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node2 = this.startNode();
          node2.name = this.tsParseTypeParameterName();
          node2.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node2, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node2 = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node2.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
          } else if (this.eatContextual(118)) {
            node2.readonly = true;
          }
          this.expect(0);
          node2.typeParameter = this.tsParseMappedTypeParameter();
          node2.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node2.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node2.optional = true;
          }
          node2.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node2, "TSMappedType");
        }
        tsParseTupleType() {
          const node2 = this.startNode();
          node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node2.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            let {
              type: type2
            } = elementNode;
            if (seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement = seenOptionalElement || type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType";
            if (type2 === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              type2 = elementNode.type;
            }
            const isLabeled = type2 === "TSNamedTupleMember";
            labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node2, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            start: startPos,
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let type2 = this.tsParseType();
          const optional = this.eat(17);
          const labeled = this.eat(14);
          if (labeled) {
            const labeledNode = this.startNodeAtNode(type2);
            labeledNode.optional = optional;
            if (type2.type === "TSTypeReference" && !type2.typeParameters && type2.typeName.type === "Identifier") {
              labeledNode.label = type2.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type2
              });
              labeledNode.label = type2;
            }
            labeledNode.elementType = this.tsParseType();
            type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type2);
            optionalTypeNode.typeAnnotation = type2;
            type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type2;
            type2 = this.finishNode(restNode, "TSRestType");
          }
          return type2;
        }
        tsParseParenthesizedType() {
          const node2 = this.startNode();
          this.expect(10);
          node2.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node2, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type2, abstract) {
          const node2 = this.startNode();
          if (type2 === "TSConstructorType") {
            node2.abstract = !!abstract;
            if (abstract)
              this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2));
          return this.finishNode(node2, type2);
        }
        tsParseLiteralTypeNode() {
          const node2 = this.startNode();
          node2.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return this.parseExprAtom();
              default:
                throw this.unexpected();
            }
          })();
          return this.finishNode(node2, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node2 = this.startNode();
          node2.literal = this.parseTemplate(false);
          return this.finishNode(node2, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType)
            return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node2 = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 130 && nextToken.type !== 131) {
                  throw this.unexpected();
                }
                node2.literal = this.parseMaybeUnary();
                return this.finishNode(node2, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type: type2
              } = this.state;
              if (tokenIsIdentifier(type2) || type2 === 88 || type2 === 84) {
                const nodeType = type2 === 88 ? "TSVoidKeyword" : type2 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node2 = this.startNode();
                  this.next();
                  return this.finishNode(node2, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type2 = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node2 = this.startNodeAtNode(type2);
              node2.elementType = type2;
              this.expect(3);
              type2 = this.finishNode(node2, "TSArrayType");
            } else {
              const node2 = this.startNodeAtNode(type2);
              node2.objectType = type2;
              node2.indexType = this.tsParseType();
              this.expect(3);
              type2 = this.finishNode(node2, "TSIndexedAccessType");
            }
          }
          return type2;
        }
        tsParseTypeOperator() {
          const node2 = this.startNode();
          const operator = this.state.value;
          this.next();
          node2.operator = operator;
          node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node2);
          }
          return this.finishNode(node2, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node2) {
          switch (node2.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node2
              });
          }
        }
        tsParseInferType() {
          const node2 = this.startNode();
          this.expectContextual(112);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node2, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node2 = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node2.types = types2;
          return this.finishNode(node2, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors: errors2
            } = this.state;
            const previousErrorCount = errors2.length;
            try {
              this.parseObjectLike(8, true);
              return errors2.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors: errors2
            } = this.state;
            const previousErrorCount = errors2.length;
            try {
              this.parseBindingList(3, 93, true);
              return errors2.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t2 = this.startNode();
            this.expect(returnToken);
            const node2 = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node2.parameterName = thisTypePredicate;
                node2.asserts = true;
                node2.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node2);
                thisTypePredicate.asserts = true;
              }
              t2.typeAnnotation = thisTypePredicate;
              return this.finishNode(t2, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t2);
              }
              node2.parameterName = this.parseIdentifier();
              node2.asserts = asserts;
              node2.typeAnnotation = null;
              t2.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
              return this.finishNode(t2, "TSTypeAnnotation");
            }
            const type2 = this.tsParseTypeAnnotation(false);
            node2.parameterName = typePredicateVariable;
            node2.typeAnnotation = type2;
            node2.asserts = asserts;
            t2.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
            return this.finishNode(t2, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id2 = this.parseIdentifier();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id2;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
          this.tsInType(() => {
            if (eatColon)
              this.expect(14);
            t2.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t2, "TSTypeAnnotation");
        }
        tsParseType() {
          assert$1(this.state.inType);
          const type2 = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type2;
          }
          const node2 = this.startNodeAtNode(type2);
          node2.checkType = type2;
          node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node2, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node2 = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node2.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(48);
          node2.expression = this.parseMaybeUnary();
          return this.finishNode(node2, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node2 = this.startNode();
            node2.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node2.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node2, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node2, properties = {}) {
          if (this.hasFollowingLineBreak())
            return null;
          this.expectContextual(125);
          if (properties.declare)
            node2.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node2.id = this.parseIdentifier();
            this.checkIdentifier(node2.id, BIND_TS_INTERFACE);
          } else {
            node2.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (this.eat(81)) {
            node2.extends = this.tsParseHeritageClause("extends");
          }
          const body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node2.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node2, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node2) {
          node2.id = this.parseIdentifier();
          this.checkIdentifier(node2.id, BIND_TS_TYPE);
          node2.typeAnnotation = this.tsInType(() => {
            node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
            this.expect(29);
            if (this.isContextual(111) && this.lookahead().type !== 16) {
              const node3 = this.startNode();
              this.next();
              return this.finishNode(node3, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node2, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          return !this.match(token) ? void 0 : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
          return this.tsDoThenParseType(() => this.expect(token));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(cb) {
          return this.tsInType(() => {
            cb();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node2 = this.startNode();
          node2.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
          if (this.eat(29)) {
            node2.initializer = this.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node2, "TSEnumMember");
        }
        tsParseEnumDeclaration(node2, properties = {}) {
          if (properties.const)
            node2.const = true;
          if (properties.declare)
            node2.declare = true;
          this.expectContextual(122);
          node2.id = this.parseIdentifier();
          this.checkIdentifier(node2.id, node2.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node2, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node2 = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          this.parseBlockOrModuleBlockBody(node2.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node2, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
          node2.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node2.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node2.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node2.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node2, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node2) {
          if (this.isContextual(109)) {
            node2.global = true;
            node2.id = this.parseIdentifier();
          } else if (this.match(129)) {
            node2.id = this.parseExprAtom();
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node2.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node2, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node2, isExport) {
          node2.isExport = isExport || false;
          node2.id = this.parseIdentifier();
          this.checkIdentifier(node2.id, BIND_LEXICAL);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node2.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node2, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node2 = this.startNode();
          this.expectContextual(116);
          this.expect(10);
          if (!this.match(129)) {
            throw this.unexpected();
          }
          node2.expression = this.parseExprAtom();
          this.expect(11);
          return this.finishNode(node2, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
          const state = this.state.clone();
          const res = f();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f) {
          const result2 = this.tryParse((abort) => f() || abort());
          if (result2.aborted || !result2.node)
            return void 0;
          if (result2.error)
            this.state = result2.failState;
          return result2.node;
        }
        tsTryParse(f) {
          const state = this.state.clone();
          const result2 = f();
          if (result2 !== void 0 && result2 !== false) {
            return result2;
          } else {
            this.state = state;
            return void 0;
          }
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let starttype = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            if (starttype === 68) {
              nany.declare = true;
              return this.parseFunctionStatement(nany, false, true);
            }
            if (starttype === 80) {
              nany.declare = true;
              return this.parseClass(nany, true, false);
            }
            if (starttype === 122) {
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }
            if (starttype === 109) {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            }
            if (starttype === 75 || starttype === 74) {
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            }
            if (starttype === 125) {
              const result2 = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result2)
                return result2;
            }
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true);
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
        tsParseExpressionStatement(node2, expr) {
          switch (expr.name) {
            case "declare": {
              const declaration2 = this.tsTryParseDeclare(node2);
              if (declaration2) {
                declaration2.declare = true;
                return declaration2;
              }
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node2;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node2, expr.name, false);
          }
        }
        tsParseDeclaration(node2, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node2);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(129)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node2);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node2);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node2);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node2);
              }
              break;
          }
        }
        tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak())
              return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          if (!this.match(47)) {
            return void 0;
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.typeParameters = this.tsParseTypeParameters();
            super.parseFunctionParams(node2);
            node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node2;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res) {
            return void 0;
          }
          return this.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return void 0;
          }
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node2 = this.startNode();
          node2.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node2.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node2
            });
          }
          this.expect(48);
          return this.finishNode(node2, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart())
            return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let accessibility;
          let readonly = false;
          let override = false;
          if (allowModifiers !== void 0) {
            const modified = {};
            this.tsParseModifiers({
              modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;
            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startPos, startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility)
              pp.accessibility = accessibility;
            if (readonly)
              pp.readonly = readonly;
            if (override)
              pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node2) {
          return node2.type === "TSParameterProperty" && super.isSimpleParameter(node2.parameter) || super.isSimpleParameter(node2);
        }
        parseFunctionBodyAndFinish(node2, type2, isMethod = false) {
          if (this.match(14)) {
            node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type2 === "FunctionDeclaration" ? "TSDeclareFunction" : type2 === "ClassMethod" || type2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            this.finishNode(node2, bodilessType);
            return;
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node2
            });
            if (node2.declare) {
              super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
              return;
            }
          }
          super.parseFunctionBodyAndFinish(node2, type2, isMethod);
        }
        registerFunctionStatementId(node2) {
          if (!node2.body && node2.id) {
            this.checkIdentifier(node2.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(...arguments);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node2) => {
            if ((node2 == null ? void 0 : node2.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node2.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(...args) {
          const node2 = super.parseArrayLike(...args);
          if (node2.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node2.elements);
          }
          return node2;
        }
        parseSubscript(base2, startPos, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base2;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base2;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result2 = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base2)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments)
                return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result3 = this.parseTaggedTemplateExpression(base2, startPos, startLoc, state);
                result3.typeParameters = typeArguments;
                return result3;
              }
              if (!noCalls && this.eat(10)) {
                const node3 = this.startNodeAt(startPos, startLoc);
                node3.callee = base2;
                node3.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node3.arguments);
                node3.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node3.optional = isOptionalCall;
                }
                return this.finishCallExpression(node3, state.optionalChainMember);
              }
              const tokenType = this.state.type;
              if (tokenType === 48 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.expression = base2;
              node2.typeParameters = typeArguments;
              return this.finishNode(node2, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result2) {
              if (result2.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result2;
            }
          }
          return super.parseSubscript(base2, startPos, startLoc, noCalls, state);
        }
        parseNewCallee(node2) {
          var _callee$extra;
          super.parseNewCallee(node2);
          const {
            callee
          } = node2;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node2.typeParameters = callee.typeParameters;
            node2.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
            const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
            node2.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node2.typeAnnotation = _const;
            } else {
              node2.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node2, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
        }
        checkReservedWord(word2, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word2, startLoc, checkKeywords, isBinding);
          }
        }
        checkDuplicateExports() {
        }
        parseImport(node2) {
          node2.importKind = "value";
          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            let ahead = this.lookahead();
            if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node2.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }
            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node2);
            }
          }
          const importNode = super.parseImport(node2);
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node2) {
          if (this.match(83)) {
            this.next();
            if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
              node2.importKind = "type";
              this.next();
            } else {
              node2.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node2, true);
          } else if (this.eat(29)) {
            const assign = node2;
            assign.expression = this.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node2;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(126) && this.lookahead().type === 5) {
              this.next();
              node2.exportKind = "type";
            } else {
              node2.exportKind = "value";
            }
            return super.parseExport(node2);
          }
        }
        isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            this.parseClass(cls, true, true);
            return cls;
          }
          if (this.match(125)) {
            const result2 = this.tsParseInterfaceDeclaration(this.startNode());
            if (result2)
              return result2;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node2, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration2 = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext)
            return declaration2;
          for (const {
            id: id2,
            init: init2
          } of declaration2.declarations) {
            if (!init2)
              continue;
            if (kind !== "const" || !!id2.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init2
              });
            } else if (init2.type !== "StringLiteral" && init2.type !== "BooleanLiteral" && init2.type !== "NumericLiteral" && init2.type !== "BigIntLiteral" && (init2.type !== "TemplateLiteral" || init2.expressions.length > 0) && !isPossiblyLiteralEnum(init2)) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init2
              });
            }
          }
          return declaration2;
        }
        parseStatementContent(context, topLevel) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node2 = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node2, {
              const: true
            });
          }
          if (this.isContextual(122)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(125)) {
            const result2 = this.tsParseInterfaceDeclaration(this.startNode());
            if (result2)
              return result2;
          }
          return super.parseStatementContent(context, topLevel);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              this.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional)
            methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node2, expr) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr) : void 0;
          return decl || super.parseExpressionStatement(node2, expr);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart())
            return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
          }
          const result2 = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
          if (!result2.node) {
            if (result2.error) {
              super.setOptionalParametersError(refExpressionErrors, result2.error);
            }
            return expr;
          }
          if (result2.error)
            this.state = result2.failState;
          return result2.node;
        }
        parseParenItem(node2, startPos, startLoc) {
          node2 = super.parseParenItem(node2, startPos, startLoc);
          if (this.eat(17)) {
            node2.optional = true;
            this.resetEndLocation(node2);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node2;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node2;
        }
        parseExportDeclaration(node2) {
          if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node2));
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(121);
          if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier2 = tokenIsIdentifier(this.state.type);
          const declaration2 = isIdentifier2 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node2);
          if (!declaration2)
            return null;
          if (declaration2.type === "TSInterfaceDeclaration" || declaration2.type === "TSTypeAliasDeclaration" || isDeclare) {
            node2.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration2, startPos, startLoc);
            declaration2.declare = true;
          }
          return declaration2;
        }
        parseClassId(node2, isStatement, optionalId) {
          if ((!isStatement || optionalId) && this.isContextual(110)) {
            return;
          }
          super.parseClassId(node2, isStatement, optionalId, node2.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters)
            node2.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node2) {
          if (!node2.optional && this.eat(35)) {
            node2.definite = true;
          }
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2)
            node2.typeAnnotation = type2;
        }
        parseClassProperty(node2) {
          this.parseClassPropertyAnnotation(node2);
          if (this.state.isAmbientContext && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node2.abstract && this.match(29)) {
            const {
              key
            } = node2;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node2);
        }
        parseClassPrivateProperty(node2) {
          if (node2.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node2
            });
          }
          if (node2.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node2,
              modifier: node2.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node2);
          return super.parseClassPrivateProperty(node2);
        }
        pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method2;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method2,
              kind
            });
          }
          if (typeParameters)
            method2.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method2, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            method2.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method2, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node2, kind) {
          if (node2.type === "TSDeclareMethod")
            return;
          if (node2.type === "MethodDefinition" && !node2.value.body)
            return;
          super.declareClassPrivateMethodInScope(node2, kind);
        }
        parseClassSuper(node2) {
          super.parseClassSuper(node2);
          if (node2.superClass && (this.match(47) || this.match(51))) {
            node2.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(110)) {
            node2.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, ...args) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            prop.typeParameters = typeParameters;
          super.parseObjPropValue(prop, ...args);
        }
        parseFunctionParams(node2, allowModifiers) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            node2.typeParameters = typeParameters;
          super.parseFunctionParams(node2, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2) {
            decl.id.typeAnnotation = type2;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node2, call) {
          if (this.match(14)) {
            node2.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node2, call);
        }
        parseMaybeAssign(...args) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types$3.j_oTag || currentContext === types$3.j_expr) {
              context.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(...args);
          }
          if (!state || state === this.state)
            state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters();
            const expr = super.parseMaybeAssign(...args);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert$1(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
            if (!typeCast.error)
              return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
            throw typeCast.error;
          throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node2) {
          var _node$extra;
          if (node2.params.length === 1 && !((_node$extra = node2.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node2
            });
          }
        }
        parseMaybeUnary(refExpressionErrors) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return super.parseMaybeUnary(refExpressionErrors);
          }
        }
        parseArrow(node2) {
          if (this.match(14)) {
            const result2 = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19))
                abort();
              return returnType;
            });
            if (result2.aborted)
              return;
            if (!result2.thrown) {
              if (result2.error)
                this.state = result2.failState;
              node2.returnType = result2.node;
            }
          }
          return super.parseArrow(node2);
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2)
            param.typeAnnotation = type2;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node2, isBinding) {
          switch (node2.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node2.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node2, isBinding);
          }
        }
        toAssignable(node2, isLHS = false) {
          switch (node2.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node2, isLHS);
              break;
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node2
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node2
                });
              }
              this.toAssignable(node2.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node2.left.type === "TSTypeCastExpression") {
                node2.left = this.typeCastToParameter(node2.left);
              }
            default:
              super.toAssignable(node2, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node2, isLHS) {
          switch (node2.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node2.expression, isLHS);
              break;
            default:
              super.toAssignable(node2, isLHS);
          }
        }
        checkToRestConversion(node2, allowPattern) {
          switch (node2.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node2.expression, false);
              break;
            default:
              super.checkToRestConversion(node2, allowPattern);
          }
        }
        isValidLVal(type2, isUnparenthesizedInAssign, binding2) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding2 !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding2 !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type2) || super.isValidLVal(type2, isUnparenthesizedInAssign, binding2);
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return super.checkCommaAfterRest(close);
          }
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(...args) {
          const node2 = super.parseMaybeDefault(...args);
          if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node2.typeAnnotation
            });
          }
          return node2;
        }
        getTokenFromCode(code2) {
          if (this.state.inType) {
            if (code2 === 62) {
              return this.finishOp(48, 1);
            }
            if (code2 === 60) {
              return this.finishOp(47, 1);
            }
          }
          return super.getTokenFromCode(code2);
        }
        reScan_lt_gt() {
          const {
            type: type2
          } = this.state;
          if (type2 === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type2 === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type: type2
          } = this.state;
          if (type2 === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type2;
        }
        toAssignableList(exprList) {
          for (let i2 = 0; i2 < exprList.length; i2++) {
            const expr = exprList[i2];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i2] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(...arguments);
        }
        typeCastToParameter(node2) {
          node2.expression.typeAnnotation = node2.typeAnnotation;
          this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
          return node2.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node2) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments)
              node2.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node2);
        }
        getGetterSetterExpectedParamCount(method2) {
          const baseCount = super.getGetterSetterExpectedParamCount(method2);
          const params = this.getObjectOrClassMethodParams(method2);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2) {
            param.typeAnnotation = type2;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node2, ...args) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node2.abstract;
          try {
            return super.parseClass(node2, ...args);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node2) {
          if (this.match(80)) {
            node2.abstract = true;
            return this.parseClass(node2, true, false);
          } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
              node2.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node2
              });
              return this.tsParseInterfaceDeclaration(node2);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(...args) {
          const method2 = super.parseMethod(...args);
          if (method2.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method2.value.body : !!method2.body;
            if (hasBody) {
              const {
                key
              } = method2;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method2,
                methodName: key.type === "Identifier" && !method2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method2;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
          if (!isString2 && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport);
            return this.finishNode(node2, "ExportSpecifier");
          }
          node2.exportKind = "value";
          return super.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
        }
        parseTypeOnlyImportExportSpecifier(node2, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node2[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node2[leftOfAsKey] = leftOfAs;
          node2[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node2[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node2[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node2[rightOfAsKey]) {
            node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node2[rightOfAsKey], BIND_LEXICAL);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression")
          return false;
        const {
          computed,
          property
        } = expression;
        if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier")
          return true;
        if (expression.type !== "MemberExpression")
          return false;
        if (expression.computed)
          return false;
        return isUncomputedMemberExpressionChain(expression.object);
      }
      const PlaceholderErrors = ParseErrorEnum`placeholders`((_) => ({
        ClassNameIsRequired: _("A class name is required."),
        UnexpectedSpace: _("Unexpected space in placeholder.")
      }));
      var placeholders = (superClass) => class extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(140)) {
            const node2 = this.startNode();
            this.next();
            this.assertNoSpace();
            node2.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(140);
            return this.finishPlaceholder(node2, expectedNode);
          }
        }
        finishPlaceholder(node2, expectedNode) {
          const isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
          node2.expectedNode = expectedNode;
          return isFinished ? node2 : this.finishNode(node2, "Placeholder");
        }
        getTokenFromCode(code2) {
          if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(140, 2);
          }
          return super.getTokenFromCode(...arguments);
        }
        parseExprAtom() {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
        }
        parseIdentifier() {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
        }
        checkReservedWord(word2) {
          if (word2 !== void 0)
            super.checkReservedWord(...arguments);
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
        }
        isValidLVal(type2, ...rest) {
          return type2 === "Placeholder" || super.isValidLVal(type2, ...rest);
        }
        toAssignable(node2) {
          if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
            node2.expectedNode = "Pattern";
          } else {
            super.toAssignable(...arguments);
          }
        }
        isLet(context) {
          if (super.isLet(context)) {
            return true;
          }
          if (!this.isContextual(99)) {
            return false;
          }
          if (context)
            return false;
          const nextToken = this.lookahead();
          if (nextToken.type === 140) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node2) {
          if (node2.label && node2.label.type === "Placeholder")
            return;
          super.verifyBreakContinue(...arguments);
        }
        parseExpressionStatement(node2, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(...arguments);
          }
          if (this.match(14)) {
            const stmt = node2;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = this.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node2.name = expr.name;
          return this.finishPlaceholder(node2, "Statement");
        }
        parseBlock() {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
        }
        parseFunctionId() {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
        }
        parseClass(node2, isStatement, optionalId) {
          const type2 = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node2);
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(140) || this.match(5)) {
              node2.id = placeholder;
            } else if (optionalId || !isStatement) {
              node2.id = null;
              node2.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node2, type2);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node2, isStatement, optionalId);
          }
          this.parseClassSuper(node2);
          node2.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node2.superClass, oldStrict);
          return this.finishNode(node2, type2);
        }
        parseExport(node2) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseExport(...arguments);
          if (!this.isContextual(97) && !this.match(12)) {
            node2.specifiers = [];
            node2.source = null;
            node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node2, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node2);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next = this.nextTokenStart();
            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node2) {
          if (node2.specifiers && node2.specifiers.length > 0) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(...arguments);
        }
        checkExport(node2) {
          const {
            specifiers
          } = node2;
          if (specifiers != null && specifiers.length) {
            node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
          }
          super.checkExport(node2);
          node2.specifiers = specifiers;
        }
        parseImport(node2) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseImport(...arguments);
          node2.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node2, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          this.finishNode(specifier, "ImportDefaultSpecifier");
          node2.specifiers.push(specifier);
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node2);
            if (!hasStarImport)
              this.parseNamedImportSpecifiers(node2);
          }
          this.expectContextual(97);
          node2.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node2, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node2 = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name2 = this.parseIdentifierName(this.state.start);
              const identifier = this.createIdentifier(node2, name2);
              identifier.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom() {
          return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p) => {
          if (typeof p === "string") {
            return expectedOptionsIsEmpty && p === expectedName;
          } else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name2, option) {
        const plugin2 = plugins.find((plugin3) => {
          if (Array.isArray(plugin3)) {
            return plugin3[0] === name2;
          } else {
            return plugin3 === name2;
          }
        });
        if (plugin2 && Array.isArray(plugin2)) {
          return plugin2[1][option];
        }
        return null;
      }
      const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      const TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport == null) {
            throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
          } else if (typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error2.missingPlugins = "doExpressions";
          throw error2;
        }
      }
      const mixinPlugins = {
        estree,
        jsx,
        flow: flow$1,
        typescript,
        v8intrinsic,
        placeholders
      };
      const mixinPluginNames = Object.keys(mixinPlugins);
      const defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true
      };
      function getOptions$2(opts) {
        const options2 = {};
        for (const key of Object.keys(defaultOptions)) {
          options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options2;
      }
      const getOwn = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key];
      const unwrapParenthesizedExpression = (node2) => {
        return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
      };
      class LValParser extends NodeUtils {
        toAssignable(node2, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node2);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node2
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node2
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node2
              });
            }
          }
          switch (node2.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node2.type = "ObjectPattern";
              for (let i2 = 0, length = node2.properties.length, last2 = length - 1; i2 < length; i2++) {
                var _node$extra2;
                const prop = node2.properties[i2];
                const isLast = i2 === last2;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node2.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node2;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node2.type = "ArrayPattern";
              this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node2.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node2.left.loc.end
                });
              }
              node2.type = "AssignmentPattern";
              delete node2.operator;
              this.toAssignable(node2.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i2 = 0; i2 <= end; i2++) {
            const elt = exprList[i2];
            if (!elt)
              continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i2 < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node2, isBinding) {
          switch (node2.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last2 = node2.properties.length - 1;
              return node2.properties.every((prop, i2) => {
                return prop.type !== "ObjectMethod" && (i2 === last2 || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node2.value);
            case "SpreadElement":
              return this.isAssignable(node2.argument);
            case "ArrayExpression":
              return node2.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node2.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node2.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors, refNeedsArrowPos) {
          const node2 = this.startNode();
          this.next();
          node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
          return this.finishNode(node2, "SpreadElement");
        }
        parseRestBinding() {
          const node2 = this.startNode();
          this.next();
          node2.argument = this.parseBindingAtom();
          return this.finishNode(node2, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node2 = this.startNode();
              this.next();
              node2.elements = this.parseBindingList(3, 93, true);
              return this.finishNode(node2, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type: type2,
            start: startPos,
            startLoc
          } = this.state;
          if (type2 === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type2 === 134) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
          return prop;
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          var _startLoc, _startPos, _left;
          startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
          startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29))
            return left;
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.left = left;
          node2.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node2, "AssignmentPattern");
        }
        isValidLVal(type2, isUnparenthesizedInAssign, binding2) {
          return getOwn({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type2);
        }
        checkLVal(expression, {
          in: ancestor,
          binding: binding2 = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          allowingSloppyLetBinding = !(binding2 & BIND_SCOPE_LEXICAL),
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type2 = expression.type;
          if (this.isObjectMethod(expression))
            return;
          if (type2 === "MemberExpression") {
            if (binding2 !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (expression.type === "Identifier") {
            this.checkIdentifier(expression, binding2, strictModeChanged, allowingSloppyLetBinding);
            const {
              name: name2
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name2)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name2);
              }
            }
            return;
          }
          const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding2);
          if (validity === true)
            return;
          if (validity === false) {
            const ParseErrorClass = binding2 === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor: ancestor.type === "UpdateExpression" ? {
                type: "UpdateExpression",
                prefix: ancestor.prefix
              } : {
                type: ancestor.type
              }
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type2 === "ParenthesizedExpression"];
          const nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding: binding2,
                checkClashes,
                allowingSloppyLetBinding,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at2, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at: at2,
                referenceName: at2.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at: at2,
                bindingName: at2.name
              });
            }
          }
          if (!allowLetBinding && at2.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at: at2
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at2, bindingType);
          }
        }
        declareNameFromIdentifier(identifier, binding2) {
          this.scope.declareName(identifier.name, binding2, identifier.loc.start);
        }
        checkToRestConversion(node2, allowPattern) {
          switch (node2.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node2.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern)
                break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node2
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      }
      class ExpressionParser extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name2 = key.type === "Identifier" ? key.name : key.value;
          if (name2 === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(135)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.expressions = [expr];
            while (this.eat(12)) {
              node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node2.expressions);
            return this.finishNode(node2, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          if (this.isContextual(105)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startPos, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type: type2
          } = this.state;
          if (type2 === 10 || tokenIsIdentifier(type2)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            const operator = this.state.value;
            node2.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node2.left = left;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node2.left = left;
            }
            this.next();
            node2.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node2, "AssignmentExpression")
            });
            return node2;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.test = expr;
            node2.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node2.alternate = this.parseMaybeAssign();
            return this.finishNode(node2, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startPos, startLoc, -1);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node2 = this.startNodeAt(leftStartPos, leftStartLoc);
              node2.left = left;
              node2.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node2.right = this.parseExprOpRightExpr(op, prec);
              this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(105)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
          if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body;
        }
        checkExponentialAfterUnary(node2) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node2.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startPos, startLoc);
            if (!sawUnary)
              this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node2 = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node2.operator = this.state.value;
            node2.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node2.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node2.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node2
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node2
                });
              }
            }
            if (!update) {
              if (!sawUnary)
                this.checkExponentialAfterUnary(node2);
              return this.finishNode(node2, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node2, update, refExpressionErrors);
          if (isAwait) {
            const {
              type: type2
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startPos, startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node2, update, refExpressionErrors) {
          if (update) {
            this.checkLVal(node2.argument, {
              in: this.finishNode(node2, "UpdateExpression")
            });
            return node2;
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node3 = this.startNodeAt(startPos, startLoc);
            node3.operator = this.state.value;
            node3.prefix = false;
            node3.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node3, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startPos, startLoc);
        }
        parseSubscripts(base2, startPos, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
            stop: false
          };
          do {
            base2 = this.parseSubscript(base2, startPos, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base2;
        }
        parseSubscript(base2, startPos, startLoc, noCalls, state) {
          const {
            type: type2
          } = this.state;
          if (!noCalls && type2 === 15) {
            return this.parseBind(base2, startPos, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type2)) {
            return this.parseTaggedTemplateExpression(base2, startPos, startLoc, state);
          }
          let optional = false;
          if (type2 === 18) {
            if (noCalls && this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base2;
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional);
          } else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) {
              return this.parseMember(base2, startPos, startLoc, state, computed, optional);
            } else {
              state.stop = true;
              return base2;
            }
          }
        }
        parseMember(base2, startPos, startLoc, state, computed, optional) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base2;
          node2.computed = computed;
          if (computed) {
            node2.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(134)) {
            if (base2.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node2.property = this.parsePrivateName();
          } else {
            node2.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node2.optional = optional;
            return this.finishNode(node2, "OptionalMemberExpression");
          } else {
            return this.finishNode(node2, "MemberExpression");
          }
        }
        parseBind(base2, startPos, startLoc, noCalls, state) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base2;
          this.next();
          node2.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startPos, startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          let node2 = this.startNodeAt(startPos, startLoc);
          node2.callee = base2;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node2.optional = optional;
          }
          if (optional) {
            node2.arguments = this.parseCallExpressionArguments(11);
          } else {
            node2.arguments = this.parseCallExpressionArguments(11, base2.type === "Import", base2.type !== "Super", node2, refExpressionErrors);
          }
          this.finishCallExpression(node2, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            node2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node2);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(node2);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node2;
        }
        toReferencedArguments(node2, isParenthesizedExpr) {
          this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base2, startPos, startLoc, state) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.tag = base2;
          node2.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node2, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base2) {
          return base2.type === "Identifier" && base2.name === "async" && this.state.lastTokEndLoc.index === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && base2.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node2, optional) {
          if (node2.callee.type === "Import") {
            if (node2.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
            }
            if (node2.arguments.length === 0 || node2.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node2,
                maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node2.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node2, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node2, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node2, call.callee.trailingComments);
          }
          return node2;
        }
        parseNoCallExpr() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node2;
          const {
            type: type2
          } = this.state;
          switch (type2) {
            case 79:
              return this.parseSuper();
            case 83:
              node2 = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node2);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node2, "Import");
            case 78:
              node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 130:
              return this.parseNumericLiteral(this.state.value);
            case 131:
              return this.parseBigIntLiteral(this.state.value);
            case 132:
              return this.parseDecimalLiteral(this.state.value);
            case 129:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              this.parseDecorators();
            case 80:
              node2 = this.startNode();
              this.takeDecorators(node2);
              return this.parseClass(node2, false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node2 = this.startNode();
              this.next();
              node2.object = null;
              const callee = node2.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node2, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 134: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              } else {
                throw this.unexpected();
              }
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else {
                throw this.unexpected();
              }
            }
            default:
              if (tokenIsIdentifier(type2)) {
                if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id2 = this.parseIdentifier();
                if (!containsEsc && id2.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type3
                  } = this.state;
                  if (type3 === 68) {
                    this.resetPreviousNodeTrailingComments(id2);
                    this.next();
                    return this.parseFunction(this.startNodeAtNode(id2), void 0, true);
                  } else if (tokenIsIdentifier(type3)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id2));
                    } else {
                      return id2;
                    }
                  } else if (type3 === 90) {
                    this.resetPreviousNodeTrailingComments(id2);
                    return this.parseDo(this.startNodeAtNode(id2), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id2), [id2], false);
                }
                return id2;
              } else {
                throw this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            throw this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node2 = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType = this.state.type;
          this.next();
          return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node2, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType)
              }]);
            }
            case "smart":
              return tokenType === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node2) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          this.parseArrowExpression(node2, params, true);
          return node2;
        }
        parseDo(node2, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node2.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node2.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node2.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node2, "DoExpression");
        }
        parseSuper() {
          const node2 = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node2
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node2
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node2
            });
          }
          return this.finishNode(node2, "Super");
        }
        parsePrivateName() {
          const node2 = this.startNode();
          const id2 = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
          const name2 = this.state.value;
          this.next();
          node2.id = this.createIdentifier(id2, name2);
          return this.finishNode(node2, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node2 = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node2, meta, "sent");
          }
          return this.parseFunction(node2);
        }
        parseMetaProperty(node2, meta, propertyName) {
          node2.meta = meta;
          const containsEsc = this.state.containsEsc;
          node2.property = this.parseIdentifier(true);
          if (node2.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node2.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node2, "MetaProperty");
        }
        parseImportMetaProperty(node2) {
          const id2 = this.createIdentifier(this.startNodeAtNode(node2), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id2
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node2, id2, "meta");
        }
        parseLiteralAtNode(value, type2, node2) {
          this.addExtra(node2, "rawValue", value);
          this.addExtra(node2, "raw", this.input.slice(node2.start, this.state.end));
          node2.value = value;
          this.next();
          return this.finishNode(node2, type2);
        }
        parseLiteral(value, type2) {
          const node2 = this.startNode();
          return this.parseLiteralAtNode(value, type2, node2);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node2 = this.parseLiteral(value.value, "RegExpLiteral");
          node2.pattern = value.pattern;
          node2.flags = value.flags;
          return node2;
        }
        parseBooleanLiteral(value) {
          const node2 = this.startNode();
          node2.value = value;
          this.next();
          return this.finishNode(node2, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartPos = this.state.start;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartPos = this.state.start;
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startPos, startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startPos, startLoc, val);
        }
        wrapParenthesis(startPos, startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startPos);
            this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startPos, startLoc);
          parenExpression.expression = expression;
          this.finishNode(parenExpression, "ParenthesizedExpression");
          return parenExpression;
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node2) {
          if (this.eat(19)) {
            return node2;
          }
        }
        parseParenItem(node2, startPos, startLoc) {
          return node2;
        }
        parseNewOrNewTarget() {
          const node2 = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node2, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node2);
        }
        parseNew(node2) {
          this.parseNewCallee(node2);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node2.arguments = args;
          } else {
            node2.arguments = [];
          }
          return this.finishNode(node2, "NewExpression");
        }
        parseNewCallee(node2) {
          node2.callee = this.parseNoCallExpr();
          if (node2.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node2.callee
            });
          } else if (this.isOptionalChain(node2.callee)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.lastTokEndLoc
            });
          } else if (this.eat(18)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(startLoc, 2)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return elem;
        }
        parseTemplate(isTagged) {
          const node2 = this.startNode();
          node2.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node2.quasis = [curElt];
          while (!curElt.tail) {
            node2.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node2, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node2 = this.startNode();
          node2.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node2);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node2.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type2 = "ObjectExpression";
          if (isPattern) {
            type2 = "ObjectPattern";
          } else if (isRecord) {
            type2 = "RecordExpression";
          }
          return this.finishNode(node2, type2);
        }
        addTrailingCommaExtraToNode(node2) {
          this.addExtra(node2, "trailingComma", this.state.lastTokStart);
          this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startPos;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length)
              this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startPos = this.state.start;
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
          return prop;
        }
        getGetterSetterExpectedParamCount(method2) {
          return method2.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method2) {
          return method2.params;
        }
        checkGetterSetterParams(method2) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method2);
          const params = this.getObjectOrClassMethodParams(method2);
          if (params.length !== paramCount) {
            this.raise(method2.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method2
            });
          }
          if (method2.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method2
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(prop);
            return prop;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern)
              this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node2 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (!node2)
            this.unexpected();
          return node2;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type: type2,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type2)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type2) {
                case 130:
                  key = this.parseNumericLiteral(value);
                  break;
                case 129:
                  key = this.parseStringLiteral(value);
                  break;
                case 131:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 132:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 134: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            prop.key = key;
            if (type2 !== 134) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node2, isAsync) {
          node2.id = null;
          node2.generator = false;
          node2.async = !!isAsync;
        }
        parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = false) {
          this.initFunction(node2, isAsync);
          node2.generator = !!isGenerator;
          const allowModifiers = isConstructor;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node2.generator));
          this.parseFunctionParams(node2, allowModifiers);
          this.parseFunctionBodyAndFinish(node2, type2, true);
          this.prodParam.exit();
          this.scope.exit();
          return node2;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node2, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node2, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node2, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node2, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node2, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node2.params = params;
        }
        parseFunctionBodyAndFinish(node2, type2, isMethod = false) {
          this.parseFunctionBody(node2, false, isMethod);
          this.finishNode(node2, type2);
        }
        parseFunctionBody(node2, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node2.body = this.parseMaybeAssign();
            this.checkParams(node2, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node2.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.loc.end : node2
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node2.id) {
                this.checkIdentifier(node2.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node2) {
          return node2.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i2 = 0, len = params.length; i2 < len; i2++) {
            if (!this.isSimpleParameter(params[i2]))
              return false;
          }
          return true;
        }
        checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node2.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node2 = this.startNode();
            this.next();
            elt = this.finishNode(node2, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node2 = this.startNode();
          const name2 = this.parseIdentifierName(node2.start, liberal);
          return this.createIdentifier(node2, name2);
        }
        createIdentifier(node2, name2) {
          node2.name = name2;
          node2.loc.identifierName = name2;
          return this.finishNode(node2, "Identifier");
        }
        parseIdentifierName(pos, liberal) {
          let name2;
          const {
            startLoc,
            type: type2
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type2)) {
            name2 = this.state.value;
          } else {
            throw this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type2);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(128);
            }
          } else {
            this.checkReservedWord(name2, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name2;
        }
        checkReservedWord(word2, startLoc, checkKeywords, isBinding) {
          if (word2.length > 10) {
            return;
          }
          if (!canBeReservedWord(word2)) {
            return;
          }
          if (word2 === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word2 === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word2 === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
          if (checkKeywords && isKeyword(word2)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word2
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word2, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word2
            });
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait)
            return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startPos, startLoc) {
          const node2 = this.startNodeAt(startPos, startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node2
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node2
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node2.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node2, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak())
            return true;
          const {
            type: type2
          } = this.state;
          return type2 === 53 || type2 === 10 || type2 === 0 || tokenIsTemplate(type2) || type2 === 133 || type2 === 56 || this.hasPlugin("v8intrinsic") && type2 === 54;
        }
        parseYield() {
          const node2 = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node2
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 135:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating)
                  break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node2.delegate = delegating;
          node2.argument = argument;
          return this.finishNode(node2, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
          const bodyNode = this.startNodeAt(startPos, startLoc);
          if (this.isSimpleReference(childExpr)) {
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node2 = this.startNode();
          this.next();
          this.eat(5);
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          const program = this.startNode();
          try {
            node2.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          this.eat(8);
          return this.finishNode(node2, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      }
      const loopLabel = {
        kind: "loop"
      }, switchLabel = {
        kind: "switch"
      };
      const FUNC_NO_FLAGS = 0, FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      const loneSurrogate = /[\uD800-\uDFFF]/u;
      const keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input2) {
        for (let i2 = 0; i2 < tokens.length; i2++) {
          const token = tokens[i2];
          const {
            type: type2
          } = token;
          if (typeof type2 === "number") {
            {
              if (type2 === 134) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i2, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(128),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i2++;
                continue;
              }
              if (tokenIsTemplate(type2)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input2.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type2 === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i2, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i2 += 2;
                continue;
              }
            }
            token.type = getExportedToken(type2);
          }
        }
        return tokens;
      }
      class StatementParser extends ExpressionParser {
        parseTopLevel(file, program) {
          file.program = this.parseProgram(program);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program, end = 135, sourceType = this.options.sourceType) {
          program.sourceType = sourceType;
          program.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at2] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at: at2,
                localName
              });
            }
          }
          return this.finishNode(program, "Program");
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node2 = this.startNode();
          node2.value = this.state.value;
          this.next();
          return this.finishNode(node2, "InterpreterDirective");
        }
        isLet(context) {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.isLetKeyword(context);
        }
        isLetKeyword(context) {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh === 92 || nextCh === 91) {
            return true;
          }
          if (context)
            return false;
          if (nextCh === 123)
            return true;
          if (isIdentifierStart(nextCh)) {
            keywordRelationalOperator.lastIndex = next;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        parseStatement(context, topLevel) {
          if (this.match(26)) {
            this.parseDecorators(true);
          }
          return this.parseStatementContent(context, topLevel);
        }
        parseStatementContent(context, topLevel) {
          let starttype = this.state.type;
          const node2 = this.startNode();
          let kind;
          if (this.isLet(context)) {
            starttype = 74;
            kind = "let";
          }
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node2, true);
            case 63:
              return this.parseBreakContinueStatement(node2, false);
            case 64:
              return this.parseDebuggerStatement(node2);
            case 90:
              return this.parseDoStatement(node2);
            case 91:
              return this.parseForStatement(node2);
            case 68:
              if (this.lookaheadCharCode() === 46)
                break;
              if (context) {
                if (this.state.strict) {
                  this.raise(Errors.StrictFunction, {
                    at: this.state.startLoc
                  });
                } else if (context !== "if" && context !== "label") {
                  this.raise(Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
              }
              return this.parseFunctionStatement(node2, false, !context);
            case 80:
              if (context)
                this.unexpected();
              return this.parseClass(node2, true);
            case 69:
              return this.parseIfStatement(node2);
            case 70:
              return this.parseReturnStatement(node2);
            case 71:
              return this.parseSwitchStatement(node2);
            case 72:
              return this.parseThrowStatement(node2);
            case 73:
              return this.parseTryStatement(node2);
            case 75:
            case 74:
              kind = kind || this.state.value;
              if (context && kind !== "var") {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node2, kind);
            case 92:
              return this.parseWhileStatement(node2);
            case 76:
              return this.parseWithStatement(node2);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node2);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result2;
              if (starttype === 83) {
                result2 = this.parseImport(node2);
                if (result2.type === "ImportDeclaration" && (!result2.importKind || result2.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result2 = this.parseExport(node2);
                if (result2.type === "ExportNamedDeclaration" && (!result2.exportKind || result2.exportKind === "value") || result2.type === "ExportAllDeclaration" && (!result2.exportKind || result2.exportKind === "value") || result2.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(node2);
              return result2;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (context) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node2, true, !context);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
        }
        assertModuleNodeAllowed(node2) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node2
            });
          }
        }
        takeDecorators(node2) {
          const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (decorators.length) {
            node2.decorators = decorators;
            this.resetStartLocationFromNode(node2, decorators[0]);
            this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
          }
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          while (this.match(26)) {
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
          }
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node2 = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startPos2 = this.state.start;
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startPos2, startLoc2, expr);
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node3 = this.startNodeAt(startPos, startLoc);
                node3.object = expr;
                node3.property = this.parseIdentifier(true);
                node3.computed = false;
                expr = this.finishNode(node3, "MemberExpression");
              }
            }
            node2.expression = this.parseMaybeDecoratorArguments(expr);
            this.state.decoratorStack.pop();
          } else {
            node2.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node2, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node2 = this.startNodeAtNode(expr);
            node2.callee = expr;
            node2.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node2.arguments);
            return this.finishNode(node2, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node2, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node2.label = null;
          } else {
            node2.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node2, isBreak);
          return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node2, isBreak) {
          let i2;
          for (i2 = 0; i2 < this.state.labels.length; ++i2) {
            const lab = this.state.labels[i2];
            if (node2.label == null || lab.name === node2.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop"))
                break;
              if (node2.label && isBreak)
                break;
            }
          }
          if (i2 === this.state.labels.length) {
            const type2 = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node2,
              type: type2
            });
          }
        }
        parseDebuggerStatement(node2) {
          this.next();
          this.semicolon();
          return this.finishNode(node2, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoStatement(node2) {
          this.next();
          this.state.labels.push(loopLabel);
          node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
          this.state.labels.pop();
          this.expect(92);
          node2.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node2, "DoWhileStatement");
        }
        parseForStatement(node2) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node2, null);
          }
          const startsWithLet = this.isContextual(99);
          const isLet = startsWithLet && this.isLetKeyword();
          if (this.match(74) || this.match(75) || isLet) {
            const init3 = this.startNode();
            const kind = isLet ? "let" : this.state.value;
            this.next();
            this.parseVar(init3, true, kind);
            this.finishNode(init3, "VariableDeclaration");
            if ((this.match(58) || this.isContextual(101)) && init3.declarations.length === 1) {
              return this.parseForIn(node2, init3, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node2, init3);
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init2 = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init2
              });
            }
            if (awaitAt === null && startsWithAsync && init2.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init2
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init2, true);
            const type2 = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init2, {
              in: {
                type: type2
              }
            });
            return this.parseForIn(node2, init2, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init2);
        }
        parseFunctionStatement(node2, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
        }
        parseIfStatement(node2) {
          this.next();
          node2.test = this.parseHeaderExpression();
          node2.consequent = this.parseStatement("if");
          node2.alternate = this.eat(66) ? this.parseStatement("if") : null;
          return this.finishNode(node2, "IfStatement");
        }
        parseReturnStatement(node2) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node2.argument = null;
          } else {
            node2.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node2, "ReturnStatement");
        }
        parseSwitchStatement(node2) {
          this.next();
          node2.discriminant = this.parseHeaderExpression();
          const cases = node2.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur)
                this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatement(null));
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur)
            this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node2, "SwitchStatement");
        }
        parseThrowStatement(node2) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node2.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node2, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          const simple = param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_LEXICAL,
            allowingSloppyLetBinding: true
          });
          return param;
        }
        parseTryStatement(node2) {
          this.next();
          node2.block = this.parseBlock();
          node2.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node2.handler = this.finishNode(clause, "CatchClause");
          }
          node2.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node2.handler && !node2.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node2
            });
          }
          return this.finishNode(node2, "TryStatement");
        }
        parseVarStatement(node2, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node2, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node2, "VariableDeclaration");
        }
        parseWhileStatement(node2) {
          this.next();
          node2.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
          this.state.labels.pop();
          return this.finishNode(node2, "WhileStatement");
        }
        parseWithStatement(node2) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node2.object = this.parseHeaderExpression();
          node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
          return this.finishNode(node2, "WithStatement");
        }
        parseEmptyStatement(node2) {
          this.next();
          return this.finishNode(node2, "EmptyStatement");
        }
        parseLabeledStatement(node2, maybeName, expr, context) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i2 = this.state.labels.length - 1; i2 >= 0; i2--) {
            const label = this.state.labels[i2];
            if (label.statementStart === node2.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.state.labels.pop();
          node2.label = expr;
          return this.finishNode(node2, "LabeledStatement");
        }
        parseExpressionStatement(node2, expr) {
          node2.expression = expr;
          this.semicolon();
          return this.finishNode(node2, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node2 = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node2, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node2.body = [];
          const directives = node2.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = this.parseStatement(null, topLevel);
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node2, init2) {
          node2.init = init2;
          this.semicolon(false);
          node2.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node2.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node2, "ForStatement");
        }
        parseForIn(node2, init2, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null)
              this.unexpected(awaitAt);
          } else {
            node2.await = awaitAt !== null;
          }
          if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.state.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init2,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init2.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init2,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node2.left = init2;
          node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node2, isFor, kind, allowMissingInitializer = false) {
          const declarations = node2.declarations = [];
          node2.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12))
              break;
          }
          return node2;
        }
        parseVarId(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
        }
        parseFunction(node2, statement = FUNC_NO_FLAGS, isAsync = false) {
          const isStatement = statement & FUNC_STATEMENT;
          const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
          const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
          this.initFunction(node2, isAsync);
          if (this.match(55) && isHangingStatement) {
            this.raise(Errors.GeneratorInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          node2.generator = this.eat(55);
          if (isStatement) {
            node2.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node2.generator));
          if (!isStatement) {
            node2.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node2, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node2, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isStatement && !isHangingStatement) {
            this.registerFunctionStatementId(node2);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node2;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node2, allowModifiers) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node2.params = this.parseBindingList(11, 41, false, allowModifiers);
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node2) {
          if (!node2.id)
            return;
          this.scope.declareName(node2.id.name, this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node2.id.loc.start);
        }
        parseClass(node2, isStatement, optionalId) {
          this.next();
          this.takeDecorators(node2);
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node2, isStatement, optionalId);
          this.parseClassSuper(node2);
          node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
          return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method2) {
          return !method2.computed && !method2.static && (method2.key.name === "constructor" || method2.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method2 = member;
            method2.kind = "method";
            method2.computed = false;
            method2.key = key;
            method2.static = false;
            this.pushClassMethod(classBody, method2, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method2 = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method2.kind = "method";
            const isPrivateName = this.match(134);
            this.parseClassElementName(method2);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(134);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method2.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method2.kind = "method";
            const isPrivate2 = this.match(134);
            this.parseClassElementName(method2);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method2.kind = key.name;
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type: type2,
            value
          } = this.state;
          if ((type2 === 128 || type2 === 129) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type2 === 134) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node2 = this.parseClassPrivateProperty(prop);
          classBody.body.push(node2);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node2 = this.parseClassAccessorProperty(prop);
          classBody.body.push(node2);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.loc.start);
          }
        }
        pushClassMethod(classBody, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method2, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method2, isGenerator, isAsync) {
          const node2 = this.parseMethod(method2, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node2);
          const kind = node2.kind === "get" ? node2.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node2.kind === "set" ? node2.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node2, kind);
        }
        declareClassPrivateMethodInScope(node2, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node2) {
          this.parseInitializer(node2);
          this.semicolon();
          return this.finishNode(node2, "ClassPrivateProperty");
        }
        parseClassProperty(node2) {
          this.parseInitializer(node2);
          this.semicolon();
          return this.finishNode(node2, "ClassProperty");
        }
        parseClassAccessorProperty(node2) {
          this.parseInitializer(node2);
          this.semicolon();
          return this.finishNode(node2, "ClassAccessorProperty");
        }
        parseInitializer(node2) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node2, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node2.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node2.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node2.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node2) {
          node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node2) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node2);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node2);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault)
              this.unexpected();
            this.parseExportFrom(node2, true);
            return this.finishNode(node2, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
            throw this.unexpected(null, 5);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            this.parseExportFrom(node2, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node2);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            this.checkExport(node2, true, false, !!node2.source);
            return this.finishNode(node2, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            node2.declaration = this.parseExportDefaultExpression();
            this.checkExport(node2, true, true);
            return this.finishNode(node2, "ExportDefaultDeclaration");
          }
          throw this.unexpected(null, 5);
        }
        eatExportStar(node2) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node2) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node2) {
          if (this.isContextual(93)) {
            if (!node2.specifiers)
              node2.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node2) {
          if (this.match(5)) {
            if (!node2.specifiers)
              node2.specifiers = [];
            const isTypeExport = node2.exportKind === "type";
            node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node2.source = null;
            node2.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node2.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node2) {
          if (this.shouldParseExportDeclaration()) {
            node2.specifiers = [];
            node2.source = null;
            if (this.hasPlugin("importAssertions")) {
              node2.assertions = [];
            }
            node2.declaration = this.parseExportDeclaration(node2);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95))
            return false;
          const next = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          const isAsync = this.isAsyncFunction();
          if (this.match(68) || isAsync) {
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            this.parseDecorators(false);
            return this.parseClass(expr, true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node2) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          const {
            type: type2
          } = this.state;
          if (tokenIsIdentifier(type2)) {
            if (type2 === 95 && !this.state.containsEsc || type2 === 99) {
              return false;
            }
            if ((type2 === 126 || type2 === 125) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next, "from");
          if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node2, expect) {
          if (this.eatContextual(97)) {
            node2.source = this.parseImportSource();
            this.checkExport(node2);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node2.assertions = assertions;
              this.checkJSONModuleImport(node2);
            }
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type: type2
          } = this.state;
          if (type2 === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                throw this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type2 === 74 || type2 === 75 || type2 === 68 || type2 === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node2, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node2, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration2 = node2.declaration;
                if (declaration2.type === "Identifier" && declaration2.name === "from" && declaration2.end - declaration2.start === 4 && !((_declaration$extra = declaration2.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration2
                  });
                }
              }
            } else if (node2.specifiers && node2.specifiers.length) {
              for (const specifier of node2.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node2.declaration) {
              if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
                const id2 = node2.declaration.id;
                if (!id2)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(node2, id2.name);
              } else if (node2.declaration.type === "VariableDeclaration") {
                for (const declaration2 of node2.declaration.declarations) {
                  this.checkDeclaration(declaration2.id);
                }
              }
            }
          }
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (currentContextDecorators.length) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node2
            });
          }
        }
        checkDeclaration(node2) {
          if (node2.type === "Identifier") {
            this.checkDuplicateExports(node2, node2.name);
          } else if (node2.type === "ObjectPattern") {
            for (const prop of node2.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node2.type === "ArrayPattern") {
            for (const elem of node2.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node2.type === "ObjectProperty") {
            this.checkDeclaration(node2.value);
          } else if (node2.type === "RestElement") {
            this.checkDeclaration(node2.argument);
          } else if (node2.type === "AssignmentPattern") {
            this.checkDeclaration(node2.left);
          }
        }
        checkDuplicateExports(node2, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node2
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node2,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const isMaybeTypeOnly = this.isContextual(126);
            const isString2 = this.match(129);
            const node2 = this.startNode();
            node2.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node2.exported = this.parseModuleExportName();
          } else if (isString2) {
            node2.exported = cloneStringLiteral(node2.local);
          } else if (!node2.exported) {
            node2.exported = cloneIdentifier(node2.local);
          }
          return this.finishNode(node2, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(129)) {
            const result2 = this.parseStringLiteral(this.state.value);
            const surrogate = result2.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result2,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result2;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node2) {
          if (node2.assertions != null) {
            return node2.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkJSONModuleImport(node2) {
          if (this.isJSONModuleImport(node2) && node2.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node2;
            if (node2.specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        parseImport(node2) {
          node2.specifiers = [];
          if (!this.match(129)) {
            const hasDefault = this.maybeParseDefaultImportSpecifier(node2);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
            if (parseNext && !hasStar)
              this.parseNamedImportSpecifiers(node2);
            this.expectContextual(97);
          }
          node2.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node2.assertions = assertions;
          } else {
            const attributes2 = this.maybeParseModuleAttributes();
            if (attributes2) {
              node2.attributes = attributes2;
            }
          }
          this.checkJSONModuleImport(node2);
          this.semicolon();
          return this.finishNode(node2, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(129))
            this.unexpected();
          return this.parseExprAtom();
        }
        shouldParseDefaultImport(node2) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node2, specifier, type2) {
          specifier.local = this.parseIdentifier();
          node2.specifiers.push(this.finishImportSpecifier(specifier, type2));
        }
        finishImportSpecifier(specifier, type2) {
          this.checkLVal(specifier.local, {
            in: specifier,
            binding: BIND_LEXICAL
          });
          return this.finishNode(specifier, type2);
        }
        parseAssertEntries() {
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node2 = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(129)) {
              node2.key = this.parseStringLiteral(keyName);
            } else {
              node2.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node2.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node2, "ImportAttribute");
            attrs.push(node2);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
          } else {
            if (this.hasPlugin("moduleAttributes"))
              return [];
            return null;
          }
          const attrs = [];
          const attributes2 = /* @__PURE__ */ new Set();
          do {
            const node2 = this.startNode();
            node2.key = this.parseIdentifier(true);
            if (node2.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node2.key
              });
            }
            if (attributes2.has(node2.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node2.key,
                key: node2.key.name
              });
            }
            attributes2.add(node2.key.name);
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node2.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node2, "ImportAttribute");
            attrs.push(node2);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
          } else {
            if (this.hasPlugin("importAssertions"))
              return [];
            return null;
          }
          this.eat(5);
          const attrs = this.parseAssertEntries();
          this.eat(8);
          return attrs;
        }
        maybeParseDefaultImportSpecifier(node2) {
          if (this.shouldParseDefaultImport(node2)) {
            this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node2) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node2) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(129);
            const isMaybeTypeOnly = this.isContextual(126);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node2.importKind === "type" || node2.importKind === "typeof", isMaybeTypeOnly);
            node2.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      }
      class Parser$3 extends StatementParser {
        constructor(options2, input2) {
          options2 = getOptions$2(options2);
          super(options2, input2);
          this.options = options2;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options2.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program);
          file.errors = this.state.errors;
          return file;
        }
      }
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin2 of plugins) {
          const [name2, options2] = Array.isArray(plugin2) ? plugin2 : [plugin2, {}];
          if (!pluginMap.has(name2))
            pluginMap.set(name2, options2 || {});
        }
        return pluginMap;
      }
      function parse$j(input2, options2) {
        var _options;
        if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options2 = Object.assign({}, options2);
          try {
            options2.sourceType = "module";
            const parser2 = getParser(options2, input2);
            const ast = parser2.parse();
            if (parser2.sawUnambiguousESM) {
              return ast;
            }
            if (parser2.ambiguousScriptDifferentAst) {
              try {
                options2.sourceType = "script";
                return getParser(options2, input2).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options2.sourceType = "script";
              return getParser(options2, input2).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options2, input2).parse();
        }
      }
      function parseExpression(input2, options2) {
        const parser2 = getParser(options2, input2);
        if (parser2.options.strictMode) {
          parser2.state.strict = true;
        }
        return parser2.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      const tokTypes = generateExportedTokenTypes(tt);
      function getParser(options2, input2) {
        let cls = Parser$3;
        if (options2 != null && options2.plugins) {
          validatePlugins(options2.plugins);
          cls = getParserClass(options2.plugins);
        }
        return new cls(options2, input2);
      }
      const parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name2) => hasPlugin(pluginsFromOptions, name2));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser$3;
          for (const plugin2 of pluginList) {
            cls = mixinPlugins[plugin2](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      lib$3.parse = parse$j;
      lib$3.parseExpression = parseExpression;
      lib$3.tokTypes = tokTypes;
      const recast$4 = main$3;
      const babelParse = lib$3;
      var parse$i = function(code2, options2) {
        options2 = options2 || commonjsGlobal.parseOptions;
        let plugins = (options2 && options2.plugins ? options2.plugins : []).concat([
          "plugin-syntax-typescript",
          "typescript",
          "asyncGenerators",
          "bigInt",
          "classProperties",
          "classPrivateProperties",
          "classPrivateMethods",
          "doExpressions",
          "dynamicImport",
          "exportDefaultFrom",
          "exportNamespaceFrom",
          "functionBind",
          "functionSent",
          "importMeta",
          "logicalAssignment",
          "nullishCoalescingOperator",
          "numericSeparator",
          "objectRestSpread",
          "optionalCatchBinding",
          "optionalChaining",
          "partialApplication",
          ["pipelineOperator", { "proposal": "smart" }],
          "throwExpressions",
          "topLevelAwait",
          "decorators-legacy",
          ["@babel/plugin-syntax-decorators", "decorators", { decoratorsBeforeExport: true }]
        ]);
        const parseOptions = {
          // sourceType: 'module',
          allowHashBang: true,
          ecmaVersion: Infinity,
          allowImportExportEverywhere: true,
          allowReturnOutsideFunction: true,
          allowAwaitOutsideFunction: true,
          allowUndeclaredExports: true,
          allowSuperOutsideMethod: true,
          startLine: 1,
          tokens: true,
          ...options2 || {},
          plugins
        };
        return recast$4.parse(code2, {
          parser: {
            parse(code3) {
              try {
                try {
                  return babelParse.parse(code3, parseOptions);
                } catch (e) {
                  if (parseOptions.plugins) {
                    const jsxIndex = parseOptions.plugins.indexOf("jsx");
                    if (jsxIndex == -1) {
                      parseOptions.plugins.push("jsx");
                    } else {
                      parseOptions.plugins.splice(jsxIndex, 1);
                    }
                  }
                  return babelParse.parse(code3, parseOptions);
                }
              } catch (e) {
                throw Error(e.message);
              }
            }
          }
        });
      };
      function isObject$7(value) {
        return typeof value == "object" && value;
      }
      const hasOwn$3 = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
      function escapeRegExp$2(string2) {
        return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      var util$2 = {
        isObject: isObject$7,
        hasOwn: hasOwn$3,
        escapeRegExp: escapeRegExp$2
      };
      const { isObject: isObject$6 } = util$2;
      const Props$1 = [
        "computed",
        "range",
        "loc",
        "type",
        "raw",
        "start",
        "end",
        "shorthand",
        "extra",
        "static",
        "trailing",
        "leading",
        "method",
        "__clone",
        "__proto__"
      ];
      const ignoreTypeList = [
        "Super",
        "Import",
        "ImportSpecifier",
        "ImportDefaultSpecifier",
        "ImportNamespaceSpecifier",
        "exportSpecifier",
        "exportDefaultSpecifier",
        "exportNamespaceSpecifier",
        "ThisExpression",
        "ReturnStatement"
      ];
      const filterProps$5 = function(node2, structure, propList, expando) {
        const props = propList || Props$1;
        for (const key in node2) {
          if (key === "type" && ignoreTypeList.indexOf(node2[key]) > -1 || props.indexOf(key) == -1 && (node2[key] !== void 0 && node2[key] !== null)) {
            if (isObject$6(node2[key])) {
              if (Array.isArray(node2[key])) {
                structure[key] = [];
                node2[key].forEach((n2, i2) => {
                  structure[key][i2] = {};
                  filterProps$5(n2, structure[key][i2], props);
                });
              } else {
                structure[key] = {};
                filterProps$5(node2[key], structure[key], props);
              }
            } else if (expando) {
              if (typeof node2[key] == "string") {
                node2[key] = node2[key].replace(/\$_\$/g, expando).replace(/\$\$\$/g, expando.slice(0, -1) + "$3").replace(/\/\$_\/\$/g, "$_$").replace(/\/\$\/\$\/\$/g, "$$$$$$");
                structure[key] = node2[key];
              }
            } else {
              structure[key] = node2[key];
            }
          }
        }
      };
      var filterProp$2 = filterProps$5;
      const recast$3 = main$3;
      const parse$h = parse$i;
      const visit$3 = recast$3.types.visit;
      const filterProps$4 = filterProp$2;
      function getSelector$3(selectorCode, parseOptions, expando) {
        const selector2 = { nodeType: "", structure: {} };
        if (typeof selectorCode != "string") {
          selector2.nodeType = selectorCode.type;
          filterProps$4(selectorCode, selector2.structure, "", expando);
          selector2.type = selectorCode.type;
          return selector2;
        } else {
          selectorCode = selectorCode.replace(/\$_\$/g, expando).replace(/\$\$\$/g, expando.slice(0, -1) + "$3").replace(/\/\$_\/\$/g, "$_$").replace(/\/\$\/\$\/\$/g, "$$$$$$");
        }
        if (selectorCode.match(/^{((.|\s)+(:|\(\))(.|\s)+)+}$/)) {
          let ast = parse$h(`var o = ${selectorCode}`);
          ast = ast.program.body[0].declarations[0].init;
          selector2.nodeType = "ObjectExpression";
          filterProps$4(ast, selector2.structure);
          return selector2;
        }
        let seletorAst;
        try {
          seletorAst = parse$h(selectorCode, parseOptions);
          if (seletorAst.program.body.length == 0) {
            if (seletorAst.program.directives.length) {
              return {
                nodeType: "StringLiteral",
                structure: {
                  value: selectorCode ? selectorCode.slice(1, -1) : ""
                }
              };
            } else if (seletorAst.program.comments.length) {
              let ast = seletorAst.program.comments[0];
              selector2.nodeType = ast.type;
              filterProps$4(ast, selector2.structure);
              return selector2;
            }
          } else if (seletorAst.program.body[0] && seletorAst.program.body[0].type == "LabeledStatement") {
            throw new Error("Missing semicolon");
          }
        } catch (e) {
          try {
            seletorAst = parse$h(`({${selectorCode}})`, parseOptions);
            seletorAst = seletorAst.program.body[0].expression.properties[0];
          } catch (e2) {
            seletorAst = null;
          }
          let clsSelectorAst = null;
          try {
            clsSelectorAst = parse$h(`class a$_$ { ${selectorCode} }`, parseOptions);
            clsSelectorAst = clsSelectorAst.program.body[0].body.body[0];
          } catch (e2) {
          }
          const result2 = [seletorAst, clsSelectorAst].filter((s) => !!s).map((sel) => {
            const selector3 = {
              nodeType: sel.type,
              structure: {}
            };
            filterProps$4(sel, selector3.structure);
            return selector3;
          });
          if (result2.length) {
            return result2;
          } else {
            throw new Error("parse error!" + e.message);
          }
        }
        visit$3(seletorAst, {
          visitExpressionStatement(path2) {
            const expression = path2.value.expression;
            if (!expression)
              return;
            selector2.nodeType = expression.type;
            filterProps$4(expression, selector2.structure);
            this.abort();
          },
          visitStatement(path2) {
            const expression = path2.value;
            if (!expression)
              return;
            selector2.nodeType = expression.type;
            filterProps$4(expression, selector2.structure);
            this.abort();
          },
          visitDeclaration(path2) {
            const declaration2 = path2.value;
            if (!declaration2)
              return;
            selector2.nodeType = declaration2.type;
            filterProps$4(declaration2, selector2.structure);
            this.abort();
          }
        });
        if (selector2.nodeType == "AssignmentExpression") {
          try {
            const selectorAstList = [selector2];
            const classPropSelector = { nodeType: "", structure: {} };
            const classPropSelectorAst = parse$h(`class A { ${selectorCode} }`, parseOptions).program.body[0].body.body[0];
            classPropSelector.nodeType = classPropSelectorAst.type;
            filterProps$4(classPropSelectorAst, classPropSelector.structure);
            selectorAstList.push(classPropSelector);
            return selectorAstList;
          } catch (e) {
          }
        } else if (selector2.nodeType == "MemberExpression") {
          try {
            const selectorAstList = [selector2];
            const classPropSelector = { nodeType: "", structure: {} };
            const classPropSelectorAst = parse$h(`type a = ${selectorCode}`, parseOptions).program.body[0].typeAnnotation.typeName;
            classPropSelector.nodeType = classPropSelectorAst.type;
            filterProps$4(classPropSelectorAst, classPropSelector.structure);
            selectorAstList.push(classPropSelector);
            return selectorAstList;
          } catch (e) {
          }
        }
        return selector2;
      }
      var getSelector_1$1 = getSelector$3;
      const recast$2 = main$3;
      var generate$8 = function(ast, isPretty) {
        return isPretty ? recast$2.prettyPrint(ast).code : recast$2.print(ast).code;
      };
      const generate$7 = generate$8;
      var specific = function handleSpecific2({ full, partial, prop, extraData, Expando: Expando2, find$$$: find$$$2 } = {}) {
        let specific2, result2;
        if (prop == "body") {
          try {
            let bodyContent = partial.body;
            if (Array.isArray(partial.body)) {
              bodyContent = partial.body[0] || partial.body.body[0];
            } else if (partial.body && partial.body.body) {
              bodyContent = partial.body.body[0];
            }
            let name2 = "";
            if (bodyContent) {
              name2 = bodyContent.expression ? bodyContent.expression.name : bodyContent.name ? bodyContent.name : "";
            }
            if (name2 && name2.match) {
              if (name2.match(Expando2)) {
                const expandoKey = name2.replace(Expando2, "") || "0";
                extraData[expandoKey] = extraData[expandoKey] || [];
                let bodyStr = generate$7(full.body) || "";
                if (bodyStr.trim()[0] == "{") {
                  bodyStr = bodyStr.slice(1, -2);
                }
                extraData[expandoKey].push({ node: full.body, value: bodyStr });
                specific2 = "body";
                result2 = true;
              }
            }
          } catch (e) {
          }
        }
        if (partial && partial.typeName && !partial.typeParameters) {
          if (partial.typeName.name.match(Expando2)) {
            specific2 = "TypeAnnotation";
            const expandoKey = partial.typeName.name.replace(Expando2, "") || "0";
            extraData[expandoKey] = extraData[expandoKey] || [];
            extraData[expandoKey].push(full);
            result2 = true;
          }
        }
        if (prop == "specifiers") {
          if ((!full[prop] || full[prop].length == 0) && partial[prop].length > 0) {
            specific2 = "specifiers", result2 = false;
          }
        }
        return { specific: specific2, result: result2 };
      };
      const { isObject: isObject$5, hasOwn: hasOwn$2 } = util$2;
      const recast$1 = main$3;
      const visit$2 = recast$1.types.visit;
      const filterProps$3 = filterProp$2;
      const generate$6 = generate$8;
      const handleSpecific = specific;
      const strictSequenceAttrList = ["arguments", "params"];
      let Expando$1 = "g123o456g789o";
      function checkIsMatch$1(full, partial, extraData, strictSequence) {
        return Object.keys(partial).every((prop) => {
          const { specific: specific2, result: result2 } = handleSpecific({ full, partial, prop, extraData, Expando: Expando$1, find$$$: find$$$$1 });
          if (specific2) {
            return result2;
          }
          if (!full || !partial) {
            return false;
          } else if (isObject$5(partial[prop])) {
            let res = false;
            let has$$$ = false;
            if (Array.isArray(partial[prop])) {
              has$$$ = find$$$$1(partial[prop], full[prop], extraData, strictSequence);
            }
            if (Array.isArray(partial[prop]) && !strictSequence && strictSequenceAttrList.indexOf(prop) == -1) {
              if (hasOwn$2(full, prop)) {
                res = partial[prop].every((p) => {
                  let a = false;
                  if (!full[prop].length && partial[prop].length == 1 && has$$$) {
                    return true;
                  }
                  full[prop] && full[prop].forEach((f) => {
                    if (f && f.type == "ObjectProperty") {
                      f.key.name && (f.key.value = f.key.name);
                      f.key.value && (f.key.name = f.key.value);
                    }
                    if (checkIsMatch$1(
                      f,
                      p,
                      extraData,
                      strictSequence
                    )) {
                      a = true;
                    }
                  });
                  return a;
                });
              } else {
                res = false;
              }
            } else {
              try {
                let fullProp = full[prop];
                if (!fullProp && !Array.isArray(full)) {
                  if (partial[prop] && typeof partial[prop].name == "string" && (partial[prop].name.match(Expando$1) || partial[prop].name.match(new RegExp(Expando$1.slice(0, -1) + "\\$3")))) {
                    if (full.type == "VariableDeclarator" && prop == "init" && partial[prop].name.match(Expando$1)) {
                      const expandoKey = partial[prop].name.replace(Expando$1, "") || "0";
                      extraData[expandoKey] = extraData[expandoKey] || [];
                      extraData[expandoKey].push({ node: null, value: null });
                      return true;
                    } else {
                      fullProp = full;
                    }
                  }
                }
                res = // hasOwn(full, prop) 
                // &&
                checkIsMatch$1(
                  fullProp,
                  partial[prop],
                  extraData,
                  strictSequence
                );
              } catch (e) {
                console.log(e);
              }
            }
            return res;
          } else {
            if (partial[prop].match && partial[prop].match(new RegExp(Expando$1.slice(0, -1) + "\\$3"))) {
              return true;
            }
            if (partial[prop].match && partial[prop].match(Expando$1)) {
              if (!full)
                return;
              let extra = {
                node: full
              };
              const expandoKey = partial[prop].replace(Expando$1, "") || "0";
              extraData[expandoKey] = extraData[expandoKey] || [];
              switch (full.type) {
                case "Identifier":
                  extra.value = full.name;
                  break;
                case "ThisExpression":
                  extra.value = "this";
                  break;
                case "StringLiteral":
                  extra.raw = `'${full.value}'`;
                  extra.value = full.value;
                  break;
                case "NumericLiteral":
                case "BooleanLiteral":
                  extra.value = full.value;
                  break;
                case "NullLiteral":
                  extra.value = null;
                  break;
                case "CommentLine":
                case "CommentBlock":
                  extra.value = full.value;
                  break;
                default:
                  try {
                    extra.value = generate$6(full);
                  } catch (e) {
                    if (full[prop]) {
                      extra.value = full[prop];
                    } else {
                      extra.value = {};
                      filterProps$3(full, extra.value);
                    }
                  }
              }
              extraData[expandoKey].push(extra);
              return true;
            } else if (partial[prop])
              ;
            if (full && full.type == "ObjectProperty") {
              full.key.name && (full.key.value = full.key.name);
              full.key.value && (full.key.name = full.key.value);
            }
            return full ? full[prop] == partial[prop] : false;
          }
        });
      }
      function find$$$$1(partial, full, extraData, strictSequence) {
        let key$$$;
        let index$$$ = -1;
        partial.forEach((p, i2) => {
          for (const key in p) {
            const value = p[key] ? p[key].name || p[key].value || p[key] : null;
            if (value && value.match && value.match(new RegExp(Expando$1.slice(0, -1) + "\\$3"))) {
              key$$$ = value.replace(new RegExp(Expando$1.slice(0, -1) + "\\$3"), "") || "$";
              index$$$ = i2;
              break;
            }
          }
        });
        if (!key$$$) {
          return false;
        }
        const extraNodeList = full ? full.slice(0) : [];
        partial.forEach((p, i2) => {
          if (i2 == index$$$) {
            return;
          }
          let fi = 0;
          while (extraNodeList[fi]) {
            if (checkIsMatch$1(extraNodeList[fi], p, {}, strictSequence)) {
              extraNodeList.splice(fi, 1);
            } else {
              fi++;
            }
          }
        });
        extraData[`$$$${key$$$}`] = (extraData[`$$$${key$$$}`] || []).concat(extraNodeList);
        return true;
      }
      function find$3(nodeType, structure, strictSequence, deep = "nn", expando = "g123o456g789o") {
        const nodePathList = [];
        const matchWildCardList = [];
        let isMatch = false;
        Expando$1 = expando;
        visit$2(this, {
          [`visit${nodeType}`](path2) {
            const extraData = {};
            isMatch = checkIsMatch$1(
              path2.value,
              structure,
              extraData,
              strictSequence
            );
            if (isMatch) {
              nodePathList.push(path2);
              matchWildCardList.push(extraData);
            }
            switch (deep) {
              case "1":
                this.abort();
                break;
              case "n":
                return false;
              case "nn":
                this.traverse(path2);
                break;
              default:
                return false;
            }
          },
          visitComment() {
            return false;
          }
        });
        return { nodePathList, matchWildCardList };
      }
      var general = { find: find$3, visit: visit$2 };
      var nodeLinkMap$1 = {
        "JSXAttribute": " ",
        "JSXText": "\n",
        "ObjectProperty": ", \n",
        "ObjectMethod": ", \n",
        "Identifier": ",",
        "StringLiteral": ",",
        "JSXElement": "\n",
        "ImportSpecifier": ",",
        "TSEnumMember": ",",
        "SpreadElement": ",",
        "AssignmentPattern": ","
      };
      const parse$g = parse$i;
      var buildMap$1 = {
        ObjectExpression(str2) {
          return parse$g(`var o = ${str2}`).program.body[0].declarations[0].init;
        },
        DestructuringParam(str2) {
          return parse$g(`(${str2}) => {}`).program.body[0].expression.params[0];
        },
        ObjectProperty(str2) {
          return parse$g(`({${str2}})`).program.body[0].expression.properties[0];
        },
        ObjectMethod(str2) {
          return parse$g(`({${str2}})`).program.body[0].expression.properties[0];
        },
        Decorators(str2) {
          return parse$g(
            `${str2}
            class A {}`
          ).program.body[0].decorators;
        },
        ClassMethod(str2) {
          return parse$g(`class a$ {${str2}}`).program.body[0].body.body[0];
        },
        ClassProperty(str2) {
          return parse$g(`class a$ {${str2}}`).program.body[0].body.body[0];
        }
      };
      const getSelector$2 = getSelector_1$1;
      const { find: find$2, visit: visit$1 } = general;
      const parse$f = parse$i;
      const generate$5 = generate$8;
      const nodeLinkMap = nodeLinkMap$1;
      const buildMap = buildMap$1;
      const core$3 = {
        // 通过选择器获取，返回ast片段
        getAstsBySelector(ast, selector2, { strictSequence, deep, parseOptions, expando = "g123o456g789o" } = {}) {
          if (!Array.isArray(selector2)) {
            selector2 = [selector2];
          }
          let nodePathList = [];
          let matchWildCardList = [];
          const selectorAst = [];
          selector2.forEach((item) => {
            let sels = getSelector$2(item, this.parseOptions || parseOptions, expando);
            !Array.isArray(sels) && (sels = [sels]);
            sels.forEach((sel) => {
              if (!sel.nodeType) {
                throw new Error("语句类型缺失，请在 https://github.com/thx/gogocode/issues 上提供您的代码样例");
              }
              selectorAst.push(sel);
            });
          });
          const posStrList = [];
          selectorAst.forEach((item) => {
            const res = find$2.call(ast, item.nodeType, item.structure, strictSequence, deep, expando);
            res.nodePathList.forEach((p, i2) => {
              const posStr = `${p.node.start},${p.node.end}`;
              if (posStrList.indexOf(posStr) == -1 || item.nodeType.match("Comment")) {
                nodePathList.push(p);
                matchWildCardList.push(res.matchWildCardList[i2]);
                posStrList.push(posStr);
              }
            });
          });
          return {
            nodePathList,
            matchWildCardList,
            pathList: nodePathList,
            extraDataList: matchWildCardList
          };
        },
        getParentListByAst(path2) {
          const list2 = [];
          while (path2 && path2.parentPath) {
            list2.push(path2.parentPath);
            path2 = path2.parentPath;
          }
          return list2;
        },
        getPrevAst(path2) {
          let parent = path2.parentPath;
          while (parent.value && !Array.isArray(parent.value)) {
            path2 = parent;
            parent = parent.parentPath;
          }
          parent = parent.value;
          if (parent) {
            const index = parent.indexOf(path2.node);
            if (index > 0) {
              return parent[index - 1];
            } else
              return null;
          }
          return null;
        },
        getNextAst(path2) {
          let parent = path2.parentPath;
          while (parent.value && !Array.isArray(parent.value)) {
            path2 = parent;
            parent = parent.parentPath;
          }
          parent = parent.value;
          if (parent) {
            const index = parent.indexOf(path2.node);
            if (parent[index + 1]) {
              return parent[index + 1];
            } else
              return null;
          }
          return null;
        },
        hasChildrenSelector(path2, childSelector, expando) {
          const childCache = path2.__childCache || {};
          for (const childKey in childCache) {
            if (["type", "directives"].indexOf(childKey) > -1) {
              continue;
            }
            const child = childCache[childKey];
            const { nodePathList } = core$3.getAstsBySelector(child, childSelector, { deep: "nn", expando });
            if (nodePathList.length > 0) {
              return true;
            }
          }
        },
        buildAstByAstStr(str2, astPatialMap = {}, { isProgram = false, parseOptions } = {}) {
          try {
            let ast;
            try {
              ast = parse$f(str2, parseOptions);
              const program = core$3.replaceStrByAst(ast, astPatialMap);
              if (program) {
                if (isProgram) {
                  return program;
                } else {
                  if (program.program.body.length > 1) {
                    return program.program.body;
                  } else if (program.program.body.length == 1) {
                    return program.program.body[0];
                  } else if (program.program.comments && program.program.comments[0]) {
                    return program.program.comments[0];
                  } else if (program.program.directives && program.program.directives[0] && program.program.directives[0].value && program.program.directives[0].value.value) {
                    return {
                      type: "StringLiteral",
                      value: program.program.directives[0].value.value
                    };
                  } else {
                    return program.program;
                  }
                }
              } else {
                return null;
              }
            } catch (e) {
              if (str2.match(/^{(\s|.)+\}$/)) {
                if (str2.match("...") && str2.match("=")) {
                  ast = buildMap.DestructuringParam(str2);
                } else {
                  ast = buildMap.ObjectExpression(str2);
                }
                return ast;
              } else if (e.message.match("Missing semicolon")) {
                ast = buildMap.ObjectProperty(str2);
                return ast;
              } else if (e.message.match("Leading decorators must be attached to a class declaration")) {
                ast = buildMap.Decorators(str2);
                return ast;
              } else {
                throw new Error(`buildAstByAstStr failed:${str2}`);
              }
            }
          } catch (error2) {
            throw new Error(`buildAstByAstStr failed:${str2}`);
          }
        },
        replaceStrByAst(ast, astPatialMap = {}) {
          for (let key in astPatialMap) {
            const valueAst = astPatialMap[key];
            const { nodePathList } = core$3.getAstsBySelector(ast, [
              { type: "Identifier", name: `$_$${key}$_$` },
              { type: "StringLiteral", value: `$_$${key}$_$` }
            ]);
            if (nodePathList.length > 0) {
              nodePathList[0].replace(valueAst);
            }
          }
          return ast;
        },
        replaceAstByAst(oldAst, newAst) {
          if (Array.isArray(newAst)) {
            const { arrPath = {}, index } = getArrPath(oldAst);
            if (Array.isArray(arrPath.value) && index > -1) {
              arrPath.value.splice(index, 1, ...newAst);
              return;
            }
          }
          if (newAst.type == "BlockStatement" && Array.isArray(oldAst.parentPath.value)) {
            const parentNode = oldAst.parentPath.value;
            const oldIndex = parentNode.indexOf(oldAst.node);
            parentNode.splice(oldIndex, 1);
            newAst.body.forEach((replacer2, index) => {
              oldAst.parentPath.value.splice(oldIndex + index, 0, replacer2);
            });
          } else if (!oldAst.parent && oldAst.node.type == "File") {
            oldAst.node.program.body = [newAst];
          } else {
            oldAst.replace(newAst);
          }
        },
        replaceSelBySel(ast, selector2, replacer2, strictSequence, parseOptions, expando = "g123o456g789o") {
          const { nodePathList, matchWildCardList } = core$3.getAstsBySelector(ast, selector2, { strictSequence, deep: "nn", parseOptions: this.parseOptions || parseOptions, expando });
          const originReplacer = replacer2;
          nodePathList.forEach((path2, i2) => {
            const extra = matchWildCardList[i2];
            replacer2 = originReplacer;
            if (typeof replacer2 == "function") {
              replacer2 = replacer2(extra, path2);
              if (replacer2 === null) {
                return;
              }
            }
            if (Object.keys(extra).length > 0 && typeof replacer2 == "string") {
              let newReplacer = replacer2;
              for (let key in extra) {
                if (key.match(/\$\$\$/)) {
                  let key$$$ = key.replace(/\$\$\$/, "");
                  key$$$ == "$" && (key$$$ = "");
                  let join2 = "\n";
                  let wildCardCode = extra[key].map((item) => {
                    let codeStr = generate$5(item);
                    try {
                      const childAst = core$3.buildAstByAstStr(codeStr, {}, { parseOptions });
                      core$3.replaceSelBySel(childAst, selector2, replacer2, strictSequence, parseOptions, expando);
                      codeStr = generate$5(childAst);
                    } catch (e) {
                    }
                    nodeLinkMap[item.type] && (join2 = nodeLinkMap[item.type]);
                    return codeStr;
                  }).join(join2);
                  if (!wildCardCode) {
                    newReplacer = newReplacer.replace(new RegExp(`\\$\\$\\$${key$$$}\\s*,`), "");
                  }
                  newReplacer = newReplacer.replace("$$$" + key$$$, wildCardCode.replace(/\$/g, "$$$$"));
                } else {
                  let realKey = key == "0" ? "" : key;
                  const matchLength = (newReplacer.match(new RegExp(`\\$_\\$${realKey}`, "g")) || []).length;
                  if (matchLength == extra[key].length) {
                    extra[key].forEach((ext) => {
                      newReplacer = newReplacer.replace(`'$_$${realKey}'`, `'${ext.value}'`).replace(`"$_$${realKey}"`, `"${ext.value}"`).replace("$_$" + realKey, ext.raw || ext.value);
                    });
                  } else {
                    let wildCardCode = extra[key].map(
                      (item) => typeof item.value !== "object" ? item.raw || item.value : ``
                    ).join(", ");
                    let wildCardCodeNoQuot = extra[key].map(
                      (item) => typeof item.value !== "object" ? item.value : ``
                    ).join(", ");
                    newReplacer = newReplacer.replace(new RegExp(`'\\$_\\$${realKey}'`, "g"), `'` + wildCardCodeNoQuot.replace(/\$/g, "$$$$") + `'`).replace(new RegExp(`"\\$_\\$${realKey}"`, "g"), `"` + wildCardCodeNoQuot.replace(/\$/g, "$$$$") + `"`).replace(new RegExp(`\\$_\\$${realKey}`, "g"), wildCardCode.replace(/\$/g, "$$$$"));
                  }
                }
              }
              if (!replacer2) {
                core$3.removePathSafe(path2);
              } else {
                let replacerAst = null;
                try {
                  replacerAst = core$3.buildAstByAstStr(newReplacer, {}, { parseOptions });
                } catch (e) {
                }
                if (buildMap[path2.node.type]) {
                  try {
                    if (buildMap[path2.node.type](newReplacer)) {
                      replacerAst = buildMap[path2.node.type](newReplacer);
                    }
                  } catch (e) {
                  }
                }
                if (!replacerAst) {
                  throw new Error(`replace failed: ${newReplacer} cannot be parsed!`);
                }
                if (replacerAst.expression && replacerAst.expression.type != "AssignmentExpression" && path2.parentPath.name != "body") {
                  replacerAst = replacerAst.expression;
                }
                path2 && core$3.replaceAstByAst(path2, replacerAst);
              }
            } else {
              if (!replacer2) {
                core$3.removePathSafe(path2);
              } else if (typeof replacer2 == "string") {
                let replacerAst = replacer2.type ? replacer2 : core$3.buildAstByAstStr(replacer2, {}, { parseOptions });
                if (!replacer2.type && buildMap[path2.node.type]) {
                  try {
                    if (buildMap[path2.node.type](replacer2)) {
                      replacerAst = buildMap[path2.node.type](replacer2);
                    }
                  } catch (e) {
                  }
                }
                if (replacerAst.expression && replacerAst.expression.type != "AssignmentExpression" && path2.parentPath.name != "body") {
                  replacerAst = replacerAst.expression;
                }
                path2 && core$3.replaceAstByAst(path2, replacerAst);
              } else {
                if (replacer2[0] && replacer2[0].nodePath) {
                  path2.replace(replacer2[0].nodePath.node);
                } else {
                  core$3.replaceAstByAst(path2, replacer2);
                }
              }
            }
          });
        },
        insertAstListBefore(path2, nodeList) {
          if (!Array.isArray(nodeList)) {
            nodeList = [nodeList];
          }
          for (let i2 = 0; i2 < 3; i2++) {
            const pNode = path2.parentPath;
            if (pNode && pNode.value && Array.isArray(pNode.value)) {
              const index = pNode.value.indexOf(path2.value);
              nodeList.reverse().forEach((item) => {
                pNode.value.splice(index, 0, item);
              });
              i2 = 3;
            } else {
              path2 = pNode;
            }
          }
        },
        insertAstListAfter(path2, nodeList) {
          if (!Array.isArray(nodeList)) {
            nodeList = [nodeList];
          }
          for (let i2 = 0; i2 < 3; i2++) {
            const pNode = path2.parentPath;
            if (pNode && pNode.value && Array.isArray(pNode.value)) {
              const index = pNode.value.indexOf(path2.value) + 1;
              nodeList.reverse().forEach((item) => {
                pNode.value.splice(index, 0, item);
              });
              i2 = 3;
            } else {
              path2 = pNode;
            }
          }
        },
        removeAst(ast, selector2, { strictSequence, parseOptions, expando } = {}) {
          if (!ast || typeof ast !== "object") {
            throw new Error("remove failed! first argument mast be object");
          }
          if (!selector2 || typeof selector2 !== "object" && typeof selector2 !== "string" && !Array.isArray(selector2)) {
            throw new Error("remove failed! first argument mast be object、string or string array");
          }
          const { nodePathList } = core$3.getAstsBySelector(ast, selector2, { strictSequence, parseOptions, expando });
          nodePathList.forEach((path2) => {
            if (!path2.parentPath.value.length || path2.parentPath.value.length == 1) {
              core$3.removePathSafe(path2.parent);
            } else {
              core$3.removePathSafe(path2);
            }
          });
        },
        remove(path2) {
          try {
            core$3.removePathSafe(path2);
          } catch (e) {
            throw `remove failed: ${e}`;
          }
        },
        removePathSafe(path2) {
          if (path2.name == "expression") {
            path2.parent.replace();
          } else {
            path2.replace();
          }
        },
        appendJsxAttr(ast, obj) {
          if (!ast || typeof ast !== "object") {
            throw new Error("appendJsxAttr failed! first argument mast be object");
          }
          if (!obj || typeof obj !== "object") {
            throw new Error("appendJsxAttr failed! second argument mast be object");
          }
          const attrs = [];
          for (let o in obj) {
            attrs.push(`${o}=${obj[o]}`.replace(/'\$'/g, "$"));
          }
          try {
            const jsxPartial = core$3.buildAstByAstStr(`<div ${attrs.join(" ")}></div>`);
            const newAttrs = jsxPartial.expression.openingElement.attributes;
            if (ast.value) {
              ast.value.openingElement.attributes = ast.value.openingElement.attributes.concat(newAttrs);
            } else {
              ast.expression.openingElement.attributes = ast.expression.openingElement.attributes.concat(newAttrs);
            }
          } catch (e) {
            throw new Error("appendJsxAttr failed!" + e);
          }
        },
        visit() {
          visit$1.call(this, ...Array.from(arguments));
        },
        traverse(node2, cb, parentNode) {
          if (!node2 || typeof node2 !== "object") {
            throw new Error("traverse failed! first argument mast be object");
          }
          if (!cb || typeof cb !== "function") {
            throw new Error("traverse failed! second argument mast be function");
          }
          if (node2.type && typeof node2.type == "string") {
            if (["File", "Program"].indexOf(node2.type) == -1) {
              cb(node2, { parentNode });
            }
            for (let attr in node2) {
              const child = node2[attr];
              if (child) {
                if (Array.isArray(child)) {
                  let i2 = 0;
                  while (child[i2]) {
                    const c = child[i2];
                    core$3.traverse(c, cb, child);
                    i2 = child.indexOf(c);
                    i2++;
                  }
                } else if (child.type) {
                  core$3.traverse(child, cb, node2);
                }
              }
            }
          }
        },
        initComment(ast) {
          core$3.traverse(ast, (node2, { parentNode }) => {
            if (Array.isArray(parentNode)) {
              const index = parentNode.indexOf(node2);
              if (index == parentNode.length - 1) {
                if (node2.trailingComments) {
                  node2.trailingComments.forEach((comment2) => {
                    parentNode.push(comment2);
                  });
                }
              }
              if (node2.leadingComments) {
                node2.leadingComments.reverse().forEach((comment2) => {
                  parentNode.splice(index, 0, comment2);
                });
              }
            }
          });
        },
        removeComments(ast) {
          core$3.traverse(ast, (node2, { parentNode }) => {
            if (Array.isArray(parentNode)) {
              if (!parentNode.every((item) => typeof item.type == "string" && item.type.match("Comment"))) {
                let i2 = 0;
                while (parentNode[i2]) {
                  const node3 = parentNode[i2];
                  if (node3 && typeof node3.type == "string" && node3.type.match("Comment")) {
                    parentNode.splice(i2, 1);
                    i2--;
                  }
                  i2++;
                }
              }
            }
          });
        }
      };
      function getArrPath(path2) {
        let arrPath = path2;
        if (!arrPath)
          return;
        let lastNode = path2.node;
        let i2 = 0;
        while (!Array.isArray(arrPath.value) && i2 < 3) {
          lastNode = arrPath.node;
          arrPath = arrPath.parentPath;
          i2++;
        }
        if (Array.isArray(arrPath.value)) {
          return { arrPath, index: arrPath.value.indexOf(lastNode) };
        } else {
          return { arrPath: {}, index: -1 };
        }
      }
      var core_1$2 = core$3;
      var _hyntaxYx_1_0_9_hyntaxYx = {};
      const OPEN_TAG_NAME_PATTERN = /^<(\S+)/;
      const CLOSE_TAG_NAME_PATTERN = /^<\/((?:.|\n|\r\n)*)>$/;
      function prettyJSON(obj) {
        return JSON.stringify(obj, null, 2);
      }
      function clearAst(ast) {
        const cleanAst = ast;
        delete cleanAst.parentRef;
        if (Array.isArray(ast.content.children)) {
          cleanAst.content.children = ast.content.children.map((node2) => {
            return clearAst(node2);
          });
        }
        return cleanAst;
      }
      function parseOpenTagName$2(openTagStartTokenContent) {
        const match = openTagStartTokenContent.match(OPEN_TAG_NAME_PATTERN);
        if (match === null) {
          throw new Error(
            `Unable to parse open tag name.
${openTagStartTokenContent} does not match pattern of opening tag.`
          );
        }
        return match[1];
      }
      function parseCloseTagName$1(closeTagTokenContent) {
        const match = closeTagTokenContent.match(CLOSE_TAG_NAME_PATTERN);
        if (match === null) {
          throw new Error(
            `Unable to parse close tag name.
${closeTagTokenContent} does not match pattern of closing tag.`
          );
        }
        return match[1].trim();
      }
      function calculateTokenCharactersRange$f(state, { keepBuffer }) {
        if (keepBuffer === void 0) {
          throw new Error(
            'Unable to calculate characters range for token.\n"keepBuffer" parameter is not specified to decide if the decision buffer is a part of characters range.'
          );
        }
        const startPosition = state.caretPosition - (state.accumulatedContent.length - 1) - state.decisionBuffer.length;
        let endPosition;
        if (!keepBuffer) {
          endPosition = state.caretPosition - state.decisionBuffer.length;
        } else {
          endPosition = state.caretPosition;
        }
        return { startPosition, endPosition };
      }
      function isWhitespace$8(char) {
        return char === " " || char === "\n" || char === "	";
      }
      var helpers = {
        prettyJSON,
        clearAst,
        parseOpenTagName: parseOpenTagName$2,
        parseCloseTagName: parseCloseTagName$1,
        calculateTokenCharactersRange: calculateTokenCharactersRange$f,
        isWhitespace: isWhitespace$8
      };
      var tokenTypes$2 = {
        TOKEN_TEXT: "token:text",
        TOKEN_OPEN_TAG_START: "token:open-tag-start",
        TOKEN_ATTRIBUTE_KEY: "token:attribute-key",
        TOKEN_ATTRIBUTE_ASSIGNMENT: "token:attribute-assignment",
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_START: "token:attribute-value-wrapper-start",
        TOKEN_ATTRIBUTE_VALUE: "token:attribute-value",
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_END: "token:attribute-value-wrapper-end",
        TOKEN_OPEN_TAG_END: "token:open-tag-end",
        TOKEN_CLOSE_TAG: "token:close-tag",
        TOKEN_OPEN_TAG_START_SCRIPT: "token:open-tag-start-script",
        TOKEN_SCRIPT_TAG_CONTENT: "token:script-tag-content",
        TOKEN_OPEN_TAG_END_SCRIPT: "token:open-tag-end-script",
        TOKEN_CLOSE_TAG_SCRIPT: "token:close-tag-script",
        TOKEN_OPEN_TAG_START_STYLE: "token:open-tag-start-style",
        TOKEN_STYLE_TAG_CONTENT: "token:style-tag-content",
        TOKEN_OPEN_TAG_END_STYLE: "token:open-tag-end-style",
        TOKEN_CLOSE_TAG_STYLE: "token:close-tag-style",
        TOKEN_DOCTYPE_START: "token:doctype-start",
        TOKEN_DOCTYPE_END: "token:doctype-end",
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START: "token:doctype-attribute-wrapper-start",
        TOKEN_DOCTYPE_ATTRIBUTE: "token:doctype-attribute",
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END: "token:doctype-attribute-wrapper-end",
        TOKEN_COMMENT_START: "token:comment-start",
        TOKEN_COMMENT_CONTENT: "token:comment-content",
        TOKEN_COMMENT_END: "token:comment-end"
      };
      var tokenizerContexts = {
        DATA_CONTEXT: "tokenizer-context:data",
        OPEN_TAG_START_CONTEXT: "tokenizer-context:open-tag-start",
        CLOSE_TAG_CONTEXT: "tokenizer-context:close-tag",
        ATTRIBUTES_CONTEXT: "tokenizer-context:attributes",
        OPEN_TAG_END_CONTEXT: "tokenizer-context:open-tag-end",
        ATTRIBUTE_KEY_CONTEXT: "tokenizer-context:attribute-key",
        ATTRIBUTE_VALUE_CONTEXT: "tokenizer-context:attribute-value",
        ATTRIBUTE_VALUE_BARE_CONTEXT: "tokenizer-context:attribute-value-bare",
        ATTRIBUTE_VALUE_WRAPPED_CONTEXT: "tokenizer-context:attribute-value-wrapped",
        SCRIPT_CONTENT_CONTEXT: "tokenizer-context:script-content",
        STYLE_CONTENT_CONTEXT: "tokenizer-context:style-content",
        DOCTYPE_START_CONTEXT: "tokenizer-context:doctype-start",
        DOCTYPE_END_CONTEXT: "tokenizer-context:doctype-end",
        DOCTYPE_ATTRIBUTES_CONTEXT: "tokenizer-context:doctype-attributes",
        DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT: "tokenizer-context:doctype-attribute-wrapped",
        DOCTYPE_ATTRIBUTE_BARE_CONTEXT: "tokenizer-context:doctype-attribute-bare",
        COMMENT_START_CONTEXT: "tokenizer-context:comment-start",
        COMMENT_CONTENT_CONTEXT: "tokenizer-context:comment-content",
        COMMENT_END_CONTEXT: "tokenizer-context:comment-end"
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$e } = helpers;
      const {
        TOKEN_TEXT: TOKEN_TEXT$1,
        TOKEN_COMMENT_START: TOKEN_COMMENT_START$2
      } = tokenTypes$2;
      const {
        OPEN_TAG_START_CONTEXT: OPEN_TAG_START_CONTEXT$1,
        CLOSE_TAG_CONTEXT: CLOSE_TAG_CONTEXT$1,
        DOCTYPE_START_CONTEXT: DOCTYPE_START_CONTEXT$1,
        COMMENT_CONTENT_CONTEXT: COMMENT_CONTENT_CONTEXT$1
      } = tokenizerContexts;
      const COMMENT_START = "<!--";
      function generateTextToken(state) {
        const range2 = calculateTokenCharactersRange$e(state, { keepBuffer: false });
        return {
          type: TOKEN_TEXT$1,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        };
      }
      function openingCornerBraceWithText(state, tokens) {
        if (state.accumulatedContent.length !== 0) {
          tokens.push(generateTextToken(state));
        }
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = OPEN_TAG_START_CONTEXT$1;
        state.caretPosition++;
      }
      function openingCornerBraceWithSlash(state, tokens) {
        if (state.accumulatedContent.length !== 0) {
          tokens.push(generateTextToken(state));
        }
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = CLOSE_TAG_CONTEXT$1;
        state.caretPosition++;
      }
      function doctypeStart$1(state, tokens) {
        if (state.accumulatedContent.length !== 0) {
          tokens.push(generateTextToken(state));
        }
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_START_CONTEXT$1;
        state.caretPosition++;
      }
      function commentStart(state, tokens) {
        if (state.accumulatedContent.length !== 0) {
          tokens.push(generateTextToken(state));
        }
        const commentStartRange = {
          startPosition: state.caretPosition - (COMMENT_START.length - 1),
          endPosition: state.caretPosition
        };
        tokens.push({
          type: TOKEN_COMMENT_START$2,
          content: state.decisionBuffer,
          startPosition: commentStartRange.startPosition,
          endPosition: commentStartRange.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = COMMENT_CONTENT_CONTEXT$1;
        state.caretPosition++;
      }
      function handleContentEnd(state, tokens) {
        const textContent = state.accumulatedContent + state.decisionBuffer;
        if (textContent.length !== 0) {
          const range2 = calculateTokenCharactersRange$e(state, { keepBuffer: false });
          tokens.push({
            type: TOKEN_TEXT$1,
            content: textContent,
            startPosition: range2.startPosition,
            endPosition: range2.endPosition
          });
        }
      }
      function isIncompleteDoctype(chars2) {
        const charsUpperCase = chars2.toUpperCase();
        return charsUpperCase === "<!" || charsUpperCase === "<!D" || charsUpperCase === "<!DO" || charsUpperCase === "<!DOC" || charsUpperCase === "<!DOCT" || charsUpperCase === "<!DOCTY" || charsUpperCase === "<!DOCTYP";
      }
      const OPEN_TAG_START_PATTERN = /^<\w/;
      function parseSyntax$g(chars2, state, tokens, nextChar, nextNoWhiteChar, fullChars, charIndex) {
        if (OPEN_TAG_START_PATTERN.test(chars2)) {
          return openingCornerBraceWithText(state, tokens);
        }
        if (chars2 === "</") {
          return openingCornerBraceWithSlash(state, tokens);
        }
        if (chars2 === "<") {
          const preChars = fullChars ? fullChars.slice(0, charIndex - 1) : "";
          const restChars = fullChars ? fullChars.slice(charIndex + 1) : "";
          const restStartIndex = restChars.indexOf("{{");
          const restEndIndex = restChars.indexOf("}}");
          if (preChars.lastIndexOf("{{") > preChars.lastIndexOf("}}") && restEndIndex > -1 && restStartIndex == -1 || restEndIndex < restStartIndex)
            ;
          else {
            if (nextNoWhiteChar.match(/[a-z]|[A-Z]|\/|\!|\-/)) {
              state.caretPosition++;
              return;
            }
          }
        }
        if (chars2 === "<!" || chars2 === "<!-") {
          state.caretPosition++;
          return;
        }
        if (chars2 === COMMENT_START) {
          return commentStart(state, tokens);
        }
        if (isIncompleteDoctype(chars2)) {
          state.caretPosition++;
          return;
        }
        if (chars2.toUpperCase() === "<!DOCTYPE") {
          return doctypeStart$1(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var data = {
        parseSyntax: parseSyntax$g,
        handleContentEnd
      };
      const {
        parseOpenTagName: parseOpenTagName$1,
        isWhitespace: isWhitespace$7,
        calculateTokenCharactersRange: calculateTokenCharactersRange$d
      } = helpers;
      const {
        TOKEN_OPEN_TAG_START: TOKEN_OPEN_TAG_START$3,
        TOKEN_OPEN_TAG_START_SCRIPT: TOKEN_OPEN_TAG_START_SCRIPT$2,
        TOKEN_OPEN_TAG_START_STYLE: TOKEN_OPEN_TAG_START_STYLE$2
      } = tokenTypes$2;
      const {
        OPEN_TAG_END_CONTEXT: OPEN_TAG_END_CONTEXT$3,
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$a
      } = tokenizerContexts;
      const tokensMap$1 = {
        "script": TOKEN_OPEN_TAG_START_SCRIPT$2,
        "style": TOKEN_OPEN_TAG_START_STYLE$2,
        "default": TOKEN_OPEN_TAG_START$3
      };
      function tagEnd$2(state, tokens) {
        const tagName2 = parseOpenTagName$1(state.accumulatedContent);
        const range2 = calculateTokenCharactersRange$d(state, { keepBuffer: false });
        tokens.push({
          type: tokensMap$1[tagName2] || tokensMap$1.default,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.decisionBuffer = "";
        state.accumulatedContent = "";
        state.currentContext = OPEN_TAG_END_CONTEXT$3;
        state.contextParams[OPEN_TAG_END_CONTEXT$3] = { tagName: tagName2 };
      }
      function whitespace$2(state, tokens) {
        const tagName2 = parseOpenTagName$1(state.accumulatedContent);
        const range2 = calculateTokenCharactersRange$d(state, { keepBuffer: false });
        tokens.push({
          type: tokensMap$1[tagName2] || tokensMap$1.default,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTES_CONTEXT$a;
        state.contextParams[ATTRIBUTES_CONTEXT$a] = { tagName: tagName2 };
        state.caretPosition++;
      }
      function parseSyntax$f(chars2, state, tokens) {
        if (chars2 === ">" || chars2 === "/") {
          return tagEnd$2(state, tokens);
        }
        if (isWhitespace$7(chars2)) {
          return whitespace$2(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var openTagStart = {
        parseSyntax: parseSyntax$f
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$c } = helpers;
      const { TOKEN_CLOSE_TAG: TOKEN_CLOSE_TAG$2 } = tokenTypes$2;
      const { DATA_CONTEXT: DATA_CONTEXT$6 } = tokenizerContexts;
      function closingCornerBrace$4(state, tokens) {
        const range2 = calculateTokenCharactersRange$c(state, { keepBuffer: true });
        tokens.push({
          type: TOKEN_CLOSE_TAG$2,
          content: state.accumulatedContent + state.decisionBuffer,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DATA_CONTEXT$6;
        state.caretPosition++;
      }
      function parseSyntax$e(chars2, state, tokens) {
        if (chars2 === ">") {
          return closingCornerBrace$4(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var closeTag = {
        parseSyntax: parseSyntax$e
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$b } = helpers;
      const {
        TOKEN_OPEN_TAG_END: TOKEN_OPEN_TAG_END$4,
        TOKEN_OPEN_TAG_END_SCRIPT: TOKEN_OPEN_TAG_END_SCRIPT$4,
        TOKEN_OPEN_TAG_END_STYLE: TOKEN_OPEN_TAG_END_STYLE$4
      } = tokenTypes$2;
      const {
        OPEN_TAG_END_CONTEXT: OPEN_TAG_END_CONTEXT$2,
        DATA_CONTEXT: DATA_CONTEXT$5,
        SCRIPT_CONTENT_CONTEXT: SCRIPT_CONTENT_CONTEXT$1,
        STYLE_CONTENT_CONTEXT: STYLE_CONTENT_CONTEXT$1
      } = tokenizerContexts;
      const tokensMap = {
        "script": TOKEN_OPEN_TAG_END_SCRIPT$4,
        "style": TOKEN_OPEN_TAG_END_STYLE$4,
        "default": TOKEN_OPEN_TAG_END$4
      };
      const contextsMap$1 = {
        "script": SCRIPT_CONTENT_CONTEXT$1,
        "style": STYLE_CONTENT_CONTEXT$1,
        "default": DATA_CONTEXT$5
      };
      function closingCornerBrace$3(state, tokens) {
        const range2 = calculateTokenCharactersRange$b(state, { keepBuffer: true });
        const tagName2 = state.contextParams[OPEN_TAG_END_CONTEXT$2].tagName;
        tokens.push({
          type: tokensMap[tagName2] || tokensMap.default,
          content: state.accumulatedContent + state.decisionBuffer,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = contextsMap$1[tagName2] || contextsMap$1.default;
        state.caretPosition++;
        state.contextParams[OPEN_TAG_END_CONTEXT$2] = void 0;
      }
      function parseSyntax$d(chars2, state, tokens) {
        if (chars2 === ">") {
          return closingCornerBrace$3(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var openTagEnd = {
        parseSyntax: parseSyntax$d
      };
      const {
        isWhitespace: isWhitespace$6,
        calculateTokenCharactersRange: calculateTokenCharactersRange$a
      } = helpers;
      const {
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$9,
        OPEN_TAG_END_CONTEXT: OPEN_TAG_END_CONTEXT$1,
        ATTRIBUTE_VALUE_CONTEXT: ATTRIBUTE_VALUE_CONTEXT$3,
        ATTRIBUTE_KEY_CONTEXT: ATTRIBUTE_KEY_CONTEXT$1
      } = tokenizerContexts;
      const { TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$6 } = tokenTypes$2;
      function tagEnd$1(state) {
        const tagName2 = state.contextParams[ATTRIBUTES_CONTEXT$9].tagName;
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = OPEN_TAG_END_CONTEXT$1;
        state.contextParams[OPEN_TAG_END_CONTEXT$1] = { tagName: tagName2 };
        state.contextParams[ATTRIBUTES_CONTEXT$9] = void 0;
      }
      function noneWhitespace(state) {
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTE_KEY_CONTEXT$1;
        state.caretPosition++;
      }
      function equal(state, tokens) {
        const range2 = calculateTokenCharactersRange$a(state, { keepBuffer: true });
        tokens.push({
          type: TOKEN_ATTRIBUTE_ASSIGNMENT$6,
          content: state.decisionBuffer,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTE_VALUE_CONTEXT$3;
        state.caretPosition++;
      }
      function parseSyntax$c(chars2, state, tokens, next, nextNoWhiteChar) {
        if (chars2 === ">" || chars2 === "/" && nextNoWhiteChar === ">") {
          return tagEnd$1(state);
        }
        if (chars2 === "=") {
          return equal(state, tokens);
        }
        if (!isWhitespace$6(chars2)) {
          return noneWhitespace(state);
        }
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var attributes$2 = {
        parseSyntax: parseSyntax$c
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$9 } = helpers;
      const { TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$6 } = tokenTypes$2;
      const { ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$8 } = tokenizerContexts;
      function keyEnd(state, tokens) {
        const range2 = calculateTokenCharactersRange$9(state, { keepBuffer: false });
        tokens.push({
          type: TOKEN_ATTRIBUTE_KEY$6,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTES_CONTEXT$8;
      }
      function isKeyBreak(chars2) {
        return chars2 === "=" || chars2 === " " || chars2 === "\n" || chars2 === "	" || chars2 === "/" || chars2 === ">";
      }
      function parseSyntax$b(chars2, state, tokens) {
        if (isKeyBreak(chars2)) {
          return keyEnd(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var attributeKey = {
        parseSyntax: parseSyntax$b
      };
      const { isWhitespace: isWhitespace$5 } = helpers;
      const {
        ATTRIBUTE_VALUE_WRAPPED_CONTEXT: ATTRIBUTE_VALUE_WRAPPED_CONTEXT$2,
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$7,
        ATTRIBUTE_VALUE_BARE_CONTEXT: ATTRIBUTE_VALUE_BARE_CONTEXT$1
      } = tokenizerContexts;
      const {
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_START: TOKEN_ATTRIBUTE_VALUE_WRAPPER_START$1
      } = tokenTypes$2;
      function wrapper$3(state, tokens) {
        const wrapper2 = state.decisionBuffer;
        tokens.push({
          type: TOKEN_ATTRIBUTE_VALUE_WRAPPER_START$1,
          content: wrapper2,
          startPosition: state.caretPosition,
          endPosition: state.caretPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTE_VALUE_WRAPPED_CONTEXT$2;
        state.contextParams[ATTRIBUTE_VALUE_WRAPPED_CONTEXT$2] = { wrapper: wrapper2 };
        state.caretPosition++;
      }
      function bare$1(state) {
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTE_VALUE_BARE_CONTEXT$1;
        state.caretPosition++;
      }
      function tagEnd(state) {
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTES_CONTEXT$7;
      }
      function parseSyntax$a(chars2, state, tokens) {
        if (chars2 === '"' || chars2 === "'") {
          return wrapper$3(state, tokens);
        }
        if (chars2 === ">" || chars2 === "/") {
          return tagEnd(state);
        }
        if (!isWhitespace$5(chars2)) {
          return bare$1(state);
        }
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var attributeValue$2 = {
        parseSyntax: parseSyntax$a
      };
      const {
        calculateTokenCharactersRange: calculateTokenCharactersRange$8,
        isWhitespace: isWhitespace$4
      } = helpers;
      const { TOKEN_ATTRIBUTE_VALUE: TOKEN_ATTRIBUTE_VALUE$2 } = tokenTypes$2;
      const { ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$6 } = tokenizerContexts;
      function valueEnd(state, tokens) {
        const range2 = calculateTokenCharactersRange$8(state, { keepBuffer: false });
        tokens.push({
          type: TOKEN_ATTRIBUTE_VALUE$2,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTES_CONTEXT$6;
      }
      function parseSyntax$9(chars2, state, tokens) {
        if ((!state.accumulatedContent.match("{{") || state.accumulatedContent.match("}}")) && (isWhitespace$4(chars2) || chars2 === ">" || chars2 === "/")) {
          return valueEnd(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var attributeValueBare = {
        parseSyntax: parseSyntax$9
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$7 } = helpers;
      const {
        TOKEN_ATTRIBUTE_VALUE: TOKEN_ATTRIBUTE_VALUE$1,
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_END: TOKEN_ATTRIBUTE_VALUE_WRAPPER_END$1
      } = tokenTypes$2;
      const {
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$5,
        ATTRIBUTE_VALUE_WRAPPED_CONTEXT: ATTRIBUTE_VALUE_WRAPPED_CONTEXT$1
      } = tokenizerContexts;
      function wrapper$2(state, tokens) {
        const range2 = calculateTokenCharactersRange$7(state, { keepBuffer: false });
        const endWrapperPosition = range2.endPosition + 1;
        tokens.push(
          {
            type: TOKEN_ATTRIBUTE_VALUE$1,
            content: state.accumulatedContent,
            startPosition: range2.startPosition,
            endPosition: range2.endPosition
          },
          {
            type: TOKEN_ATTRIBUTE_VALUE_WRAPPER_END$1,
            content: state.decisionBuffer,
            startPosition: endWrapperPosition,
            endPosition: endWrapperPosition
          }
        );
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = ATTRIBUTES_CONTEXT$5;
        state.caretPosition++;
        state.contextParams[ATTRIBUTE_VALUE_WRAPPED_CONTEXT$1] = void 0;
      }
      function parseSyntax$8(chars2, state, tokens) {
        const wrapperChar = state.contextParams[ATTRIBUTE_VALUE_WRAPPED_CONTEXT$1].wrapper;
        if (chars2 === wrapperChar) {
          return wrapper$2(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var attributeValueWrapped = {
        parseSyntax: parseSyntax$8
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$6 } = helpers;
      const {
        TOKEN_SCRIPT_TAG_CONTENT: TOKEN_SCRIPT_TAG_CONTENT$1,
        TOKEN_CLOSE_TAG_SCRIPT: TOKEN_CLOSE_TAG_SCRIPT$1
      } = tokenTypes$2;
      const { DATA_CONTEXT: DATA_CONTEXT$4 } = tokenizerContexts;
      function closingScriptTag(state, tokens) {
        if (state.accumulatedContent !== "") {
          const range2 = calculateTokenCharactersRange$6(state, { keepBuffer: false });
          tokens.push({
            type: TOKEN_SCRIPT_TAG_CONTENT$1,
            content: state.accumulatedContent,
            startPosition: range2.startPosition,
            endPosition: range2.endPosition
          });
        }
        tokens.push({
          type: TOKEN_CLOSE_TAG_SCRIPT$1,
          content: state.decisionBuffer,
          startPosition: state.caretPosition - (state.decisionBuffer.length - 1),
          endPosition: state.caretPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DATA_CONTEXT$4;
        state.caretPosition++;
      }
      const INCOMPLETE_CLOSING_TAG_PATTERN$1 = /<\/[^>]+$/;
      const CLOSING_SCRIPT_TAG_PATTERN = /<\/script\s*>/i;
      function parseSyntax$7(chars2, state, tokens) {
        if (chars2 === "<" || chars2 === "</" || INCOMPLETE_CLOSING_TAG_PATTERN$1.test(chars2)) {
          state.caretPosition++;
          return;
        }
        if (CLOSING_SCRIPT_TAG_PATTERN.test(chars2)) {
          return closingScriptTag(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var scriptTagContent = {
        parseSyntax: parseSyntax$7
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$5 } = helpers;
      const {
        TOKEN_STYLE_TAG_CONTENT: TOKEN_STYLE_TAG_CONTENT$1,
        TOKEN_CLOSE_TAG_STYLE: TOKEN_CLOSE_TAG_STYLE$1
      } = tokenTypes$2;
      const { DATA_CONTEXT: DATA_CONTEXT$3 } = tokenizerContexts;
      function closingStyleTag(state, tokens) {
        if (state.accumulatedContent !== "") {
          const range2 = calculateTokenCharactersRange$5(state, { keepBuffer: false });
          tokens.push({
            type: TOKEN_STYLE_TAG_CONTENT$1,
            content: state.accumulatedContent,
            startPosition: range2.startPosition,
            endPosition: range2.endPosition
          });
        }
        tokens.push({
          type: TOKEN_CLOSE_TAG_STYLE$1,
          content: state.decisionBuffer,
          startPosition: state.caretPosition - (state.decisionBuffer.length - 1),
          endPosition: state.caretPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DATA_CONTEXT$3;
        state.caretPosition++;
      }
      const INCOMPLETE_CLOSING_TAG_PATTERN = /<\/[^>]+$/;
      const CLOSING_STYLE_TAG_PATTERN = /<\/style\s*>/i;
      function parseSyntax$6(chars2, state, tokens) {
        if (chars2 === "<" || chars2 === "</" || INCOMPLETE_CLOSING_TAG_PATTERN.test(chars2)) {
          state.caretPosition++;
          return;
        }
        if (CLOSING_STYLE_TAG_PATTERN.test(chars2)) {
          return closingStyleTag(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var styleTagContent = {
        parseSyntax: parseSyntax$6
      };
      const { isWhitespace: isWhitespace$3, calculateTokenCharactersRange: calculateTokenCharactersRange$4 } = helpers;
      const {
        TOKEN_DOCTYPE_START: TOKEN_DOCTYPE_START$2
      } = tokenTypes$2;
      const {
        DOCTYPE_END_CONTEXT: DOCTYPE_END_CONTEXT$2,
        DOCTYPE_ATTRIBUTES_CONTEXT: DOCTYPE_ATTRIBUTES_CONTEXT$5
      } = tokenizerContexts;
      function generateDoctypeStartToken(state) {
        const range2 = calculateTokenCharactersRange$4(state, { keepBuffer: false });
        return {
          type: TOKEN_DOCTYPE_START$2,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        };
      }
      function closingCornerBrace$2(state, tokens) {
        tokens.push(generateDoctypeStartToken(state));
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_END_CONTEXT$2;
      }
      function whitespace$1(state, tokens) {
        tokens.push(generateDoctypeStartToken(state));
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_ATTRIBUTES_CONTEXT$5;
      }
      function parseSyntax$5(chars2, state, tokens) {
        if (isWhitespace$3(chars2)) {
          return whitespace$1(state, tokens);
        }
        if (chars2 === ">") {
          return closingCornerBrace$2(state, tokens);
        }
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var doctypeStart = {
        parseSyntax: parseSyntax$5
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$3 } = helpers;
      const { TOKEN_DOCTYPE_END: TOKEN_DOCTYPE_END$3 } = tokenTypes$2;
      const { DATA_CONTEXT: DATA_CONTEXT$2 } = tokenizerContexts;
      function closingCornerBrace$1(state, tokens) {
        const range2 = calculateTokenCharactersRange$3(state, { keepBuffer: true });
        tokens.push({
          type: TOKEN_DOCTYPE_END$3,
          content: state.decisionBuffer,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DATA_CONTEXT$2;
        state.caretPosition++;
      }
      function parseSyntax$4(chars2, state, tokens) {
        return closingCornerBrace$1(state, tokens);
      }
      var doctypeEnd = {
        parseSyntax: parseSyntax$4
      };
      const { isWhitespace: isWhitespace$2 } = helpers;
      const {
        DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT: DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$2,
        DOCTYPE_ATTRIBUTE_BARE_CONTEXT: DOCTYPE_ATTRIBUTE_BARE_CONTEXT$1,
        DOCTYPE_END_CONTEXT: DOCTYPE_END_CONTEXT$1
      } = tokenizerContexts;
      const {
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$3
      } = tokenTypes$2;
      function wrapper$1(state, tokens) {
        const wrapper2 = state.decisionBuffer;
        tokens.push({
          type: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$3,
          content: wrapper2,
          startPosition: state.caretPosition,
          endPosition: state.caretPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$2;
        state.contextParams[DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$2] = { wrapper: wrapper2 };
        state.caretPosition++;
      }
      function bare(state) {
        state.accumulatedContent = state.decisionBuffer;
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_ATTRIBUTE_BARE_CONTEXT$1;
        state.caretPosition++;
      }
      function closingCornerBrace(state) {
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_END_CONTEXT$1;
      }
      function parseSyntax$3(chars2, state, tokens) {
        if (chars2 === '"' || chars2 === "'") {
          return wrapper$1(state, tokens);
        }
        if (chars2 === ">") {
          return closingCornerBrace(state);
        }
        if (!isWhitespace$2(chars2)) {
          return bare(state);
        }
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var doctypeAttributes$2 = {
        parseSyntax: parseSyntax$3
      };
      const { calculateTokenCharactersRange: calculateTokenCharactersRange$2 } = helpers;
      const {
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END$1,
        TOKEN_DOCTYPE_ATTRIBUTE: TOKEN_DOCTYPE_ATTRIBUTE$4
      } = tokenTypes$2;
      const {
        DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT: DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$1,
        DOCTYPE_ATTRIBUTES_CONTEXT: DOCTYPE_ATTRIBUTES_CONTEXT$4
      } = tokenizerContexts;
      function wrapper(state, tokens) {
        const range2 = calculateTokenCharactersRange$2(state, { keepBuffer: false });
        const endWrapperPosition = range2.endPosition + 1;
        tokens.push({
          type: TOKEN_DOCTYPE_ATTRIBUTE$4,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        tokens.push({
          type: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END$1,
          content: state.decisionBuffer,
          startPosition: endWrapperPosition,
          endPosition: endWrapperPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_ATTRIBUTES_CONTEXT$4;
        state.caretPosition++;
        state.contextParams[DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$1] = void 0;
      }
      function parseSyntax$2(chars2, state, tokens) {
        const wrapperChar = state.contextParams[DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT$1].wrapper;
        if (chars2 === wrapperChar) {
          return wrapper(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var doctypeAttributeWrapped = {
        parseSyntax: parseSyntax$2
      };
      const { isWhitespace: isWhitespace$1, calculateTokenCharactersRange: calculateTokenCharactersRange$1 } = helpers;
      const {
        TOKEN_DOCTYPE_ATTRIBUTE: TOKEN_DOCTYPE_ATTRIBUTE$3
      } = tokenTypes$2;
      const {
        DOCTYPE_ATTRIBUTES_CONTEXT: DOCTYPE_ATTRIBUTES_CONTEXT$3
      } = tokenizerContexts;
      function attributeEnd(state, tokens) {
        const range2 = calculateTokenCharactersRange$1(state, { keepBuffer: false });
        tokens.push({
          type: TOKEN_DOCTYPE_ATTRIBUTE$3,
          content: state.accumulatedContent,
          startPosition: range2.startPosition,
          endPosition: range2.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DOCTYPE_ATTRIBUTES_CONTEXT$3;
      }
      function parseSyntax$1(chars2, state, tokens) {
        if (isWhitespace$1(chars2) || chars2 === ">") {
          return attributeEnd(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var doctypeAttributeBare = {
        parseSyntax: parseSyntax$1
      };
      const { calculateTokenCharactersRange } = helpers;
      const {
        TOKEN_COMMENT_END: TOKEN_COMMENT_END$1,
        TOKEN_COMMENT_CONTENT: TOKEN_COMMENT_CONTENT$1
      } = tokenTypes$2;
      const {
        DATA_CONTEXT: DATA_CONTEXT$1
      } = tokenizerContexts;
      const COMMENT_END = "-->";
      function commentEnd(state, tokens) {
        const contentRange = calculateTokenCharactersRange(state, { keepBuffer: false });
        const commentEndRange = {
          startPosition: contentRange.endPosition + 1,
          endPosition: contentRange.endPosition + COMMENT_END.length
        };
        tokens.push({
          type: TOKEN_COMMENT_CONTENT$1,
          content: state.accumulatedContent,
          startPosition: contentRange.startPosition,
          endPosition: contentRange.endPosition
        });
        tokens.push({
          type: TOKEN_COMMENT_END$1,
          content: state.decisionBuffer,
          startPosition: commentEndRange.startPosition,
          endPosition: commentEndRange.endPosition
        });
        state.accumulatedContent = "";
        state.decisionBuffer = "";
        state.currentContext = DATA_CONTEXT$1;
        state.caretPosition++;
      }
      function parseSyntax(chars2, state, tokens) {
        if (chars2 === "-" || chars2 === "--") {
          state.caretPosition++;
          return;
        }
        if (chars2 === COMMENT_END) {
          return commentEnd(state, tokens);
        }
        state.accumulatedContent += state.decisionBuffer;
        state.decisionBuffer = "";
        state.caretPosition++;
      }
      var commentContent = {
        parseSyntax
      };
      const dataContext = data;
      const openTagStartContext = openTagStart;
      const closeTagContext = closeTag;
      const openTagEndContext = openTagEnd;
      const attributesContext = attributes$2;
      const attributeKeyContext = attributeKey;
      const attributeValueContext = attributeValue$2;
      const attributeValueBareContext = attributeValueBare;
      const attributeValueWrappedContext = attributeValueWrapped;
      const scriptContentContext = scriptTagContent;
      const styleContentContext = styleTagContent;
      const doctypeStartContext = doctypeStart;
      const doctypeEndContextFactory = doctypeEnd;
      const doctypeAttributesContext = doctypeAttributes$2;
      const doctypeAttributeWrappedContext = doctypeAttributeWrapped;
      const doctypeAttributeBareEndContext = doctypeAttributeBare;
      const commentContentContext = commentContent;
      const { isWhitespace } = helpers;
      const {
        DATA_CONTEXT,
        OPEN_TAG_START_CONTEXT,
        CLOSE_TAG_CONTEXT,
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$4,
        OPEN_TAG_END_CONTEXT,
        ATTRIBUTE_KEY_CONTEXT,
        ATTRIBUTE_VALUE_CONTEXT: ATTRIBUTE_VALUE_CONTEXT$2,
        ATTRIBUTE_VALUE_BARE_CONTEXT,
        ATTRIBUTE_VALUE_WRAPPED_CONTEXT,
        SCRIPT_CONTENT_CONTEXT,
        STYLE_CONTENT_CONTEXT,
        DOCTYPE_START_CONTEXT,
        DOCTYPE_END_CONTEXT,
        DOCTYPE_ATTRIBUTES_CONTEXT: DOCTYPE_ATTRIBUTES_CONTEXT$2,
        DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT,
        DOCTYPE_ATTRIBUTE_BARE_CONTEXT,
        COMMENT_CONTENT_CONTEXT
      } = tokenizerContexts;
      const contextHandlersMap = {
        [DATA_CONTEXT]: dataContext,
        [OPEN_TAG_START_CONTEXT]: openTagStartContext,
        [CLOSE_TAG_CONTEXT]: closeTagContext,
        [ATTRIBUTES_CONTEXT$4]: attributesContext,
        [OPEN_TAG_END_CONTEXT]: openTagEndContext,
        [ATTRIBUTE_KEY_CONTEXT]: attributeKeyContext,
        [ATTRIBUTE_VALUE_CONTEXT$2]: attributeValueContext,
        [ATTRIBUTE_VALUE_BARE_CONTEXT]: attributeValueBareContext,
        [ATTRIBUTE_VALUE_WRAPPED_CONTEXT]: attributeValueWrappedContext,
        [SCRIPT_CONTENT_CONTEXT]: scriptContentContext,
        [STYLE_CONTENT_CONTEXT]: styleContentContext,
        [DOCTYPE_START_CONTEXT]: doctypeStartContext,
        [DOCTYPE_END_CONTEXT]: doctypeEndContextFactory,
        [DOCTYPE_ATTRIBUTES_CONTEXT$2]: doctypeAttributesContext,
        [DOCTYPE_ATTRIBUTE_WRAPPED_CONTEXT]: doctypeAttributeWrappedContext,
        [DOCTYPE_ATTRIBUTE_BARE_CONTEXT]: doctypeAttributeBareEndContext,
        [COMMENT_CONTENT_CONTEXT]: commentContentContext
      };
      function tokenizeChars(chars2, state, tokens, { isFinalChunk, positionOffset }) {
        let charIndex = state.caretPosition - positionOffset;
        while (charIndex < chars2.length) {
          const context = contextHandlersMap[state.currentContext];
          state.decisionBuffer += chars2[charIndex];
          const nextChar = chars2[charIndex + 1];
          let nextNoWhiteChar = nextChar;
          let nextNoWhiteIndex = charIndex + 1;
          while (isWhitespace(nextNoWhiteChar)) {
            nextNoWhiteIndex += 1;
            nextNoWhiteChar = chars2[nextNoWhiteIndex];
          }
          context.parseSyntax(state.decisionBuffer, state, tokens, nextChar, nextNoWhiteChar, chars2, charIndex);
          charIndex = state.caretPosition - positionOffset;
        }
        if (isFinalChunk) {
          const context = contextHandlersMap[state.currentContext];
          state.caretPosition--;
          if (context.handleContentEnd !== void 0) {
            context.handleContentEnd(state, tokens);
          }
        }
      }
      function tokenize$7(content = "", existingState, { isFinalChunk } = {}) {
        isFinalChunk = isFinalChunk === void 0 ? true : isFinalChunk;
        let state;
        if (existingState !== void 0) {
          state = Object.assign({}, existingState);
        } else {
          state = {
            currentContext: DATA_CONTEXT,
            contextParams: {},
            decisionBuffer: "",
            accumulatedContent: "",
            caretPosition: 0
          };
        }
        const chars2 = state.decisionBuffer + content;
        const tokens = [];
        const positionOffset = state.caretPosition - state.decisionBuffer.length;
        tokenizeChars(chars2, state, tokens, {
          isFinalChunk,
          positionOffset
        });
        return { state, tokens };
      }
      var tokenize_1 = tokenize$7;
      var treeConstructorContexts = {
        TAG_CONTENT_CONTEXT: "tree-constructor-context:tag-content",
        TAG_CONTEXT: "tree-constructor-context:tag",
        TAG_NAME_CONTEXT: "tree-constructor-context:tag-name",
        ATTRIBUTES_CONTEXT: "tree-constructor-context:attributes",
        ATTRIBUTE_CONTEXT: "tree-constructor-context:attribute",
        ATTRIBUTE_VALUE_CONTEXT: "tree-constructor-context:attribute-value",
        COMMENT_CONTEXT: "tree-constructor-context:comment",
        DOCTYPE_CONTEXT: "tree-constructor-context:doctype",
        DOCTYPE_ATTRIBUTES_CONTEXT: "tree-constructor-context:doctype-attributes",
        DOCTYPE_ATTRIBUTE_CONTEXT: "tree-constructor-context:doctype-attribute",
        SCRIPT_TAG_CONTEXT: "tree-constructor-context:script-tag",
        STYLE_TAG_CONTEXT: "tree-constructor-context:style-tag"
      };
      const {
        TOKEN_OPEN_TAG_START: TOKEN_OPEN_TAG_START$2,
        TOKEN_OPEN_TAG_END: TOKEN_OPEN_TAG_END$3,
        TOKEN_CLOSE_TAG: TOKEN_CLOSE_TAG$1,
        TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$5,
        TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$5
      } = tokenTypes$2;
      const {
        TAG_NAME_CONTEXT: TAG_NAME_CONTEXT$1,
        ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$3,
        TAG_CONTENT_CONTEXT: TAG_CONTENT_CONTEXT$1
      } = treeConstructorContexts;
      function handleOpenTagStart$1(state, token) {
        state.currentNode.content.openStart = token;
        state.currentContext = {
          parentRef: state.currentContext,
          type: TAG_NAME_CONTEXT$1
        };
        return state;
      }
      function handleAttributeStart(state) {
        state.currentContext = {
          parentRef: state.currentContext,
          type: ATTRIBUTES_CONTEXT$3
        };
        return state;
      }
      function handleOpenTagEnd$2(state, token) {
        const SELF_CLOSING_TAGS = [
          "area",
          "base",
          "br",
          "col",
          "embed",
          "hr",
          "img",
          "input",
          "keygen",
          "link",
          "meta",
          "param",
          "source",
          "track",
          "wbr"
        ].concat((state.parseOptions || {}).selfClosingTag || []);
        const tagName2 = state.currentNode.content.name;
        state.currentNode.content.openEnd = token;
        if (token.content.match(/\/\s*>/) || SELF_CLOSING_TAGS.indexOf(tagName2) !== -1) {
          state.currentNode.content.selfClosing = true;
          state.currentNode = state.currentNode.parentRef;
          state.currentContext = state.currentContext.parentRef;
          state.caretPosition++;
          return state;
        }
        state.currentNode.content.selfClosing = false;
        state.currentContext = {
          parentRef: state.currentContext,
          type: TAG_CONTENT_CONTEXT$1
        };
        state.caretPosition++;
        return state;
      }
      function handleCloseTag$1(state, token) {
        state.currentNode.content.close = token;
        state.currentNode = state.currentNode.parentRef;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      var tag$5 = function tag2(token, state) {
        if (token.type === TOKEN_OPEN_TAG_START$2) {
          return handleOpenTagStart$1(state, token);
        }
        const ATTRIBUTE_START_TOKENS = [
          TOKEN_ATTRIBUTE_KEY$5,
          TOKEN_ATTRIBUTE_ASSIGNMENT$5
        ];
        if (ATTRIBUTE_START_TOKENS.indexOf(token.type) !== -1) {
          return handleAttributeStart(state);
        }
        if (token.type === TOKEN_OPEN_TAG_END$3) {
          return handleOpenTagEnd$2(state, token);
        }
        if (token.type === TOKEN_CLOSE_TAG$1) {
          return handleCloseTag$1(state, token);
        }
        state.caretPosition++;
        return state;
      };
      var astNodes = {
        NODE_DOCUMENT: "document",
        NODE_TAG: "tag",
        NODE_TEXT: "text",
        NODE_DOCTYPE: "doctype",
        NODE_COMMENT: "comment",
        NODE_SCRIPT: "script",
        NODE_STYLE: "style"
      };
      const parseCloseTagName = helpers.parseCloseTagName;
      const {
        TOKEN_OPEN_TAG_START: TOKEN_OPEN_TAG_START$1,
        TOKEN_CLOSE_TAG,
        TOKEN_COMMENT_START: TOKEN_COMMENT_START$1,
        TOKEN_DOCTYPE_START: TOKEN_DOCTYPE_START$1,
        TOKEN_TEXT,
        TOKEN_OPEN_TAG_START_SCRIPT: TOKEN_OPEN_TAG_START_SCRIPT$1,
        TOKEN_OPEN_TAG_START_STYLE: TOKEN_OPEN_TAG_START_STYLE$1
      } = tokenTypes$2;
      const {
        TAG_CONTEXT: TAG_CONTEXT$1,
        COMMENT_CONTEXT: COMMENT_CONTEXT$1,
        DOCTYPE_CONTEXT: DOCTYPE_CONTEXT$1,
        SCRIPT_TAG_CONTEXT: SCRIPT_TAG_CONTEXT$1,
        STYLE_TAG_CONTEXT: STYLE_TAG_CONTEXT$1
      } = treeConstructorContexts;
      const {
        NODE_TAG: NODE_TAG$1,
        NODE_TEXT: NODE_TEXT$1,
        NODE_DOCTYPE: NODE_DOCTYPE$1,
        NODE_COMMENT: NODE_COMMENT$1,
        NODE_SCRIPT: NODE_SCRIPT$1,
        NODE_STYLE: NODE_STYLE$1
      } = astNodes;
      function handleOpenTagStart(state) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const tagNode = {
          nodeType: NODE_TAG$1,
          parentRef: state.currentNode,
          content: {}
        };
        state.currentNode.content.children.push(tagNode);
        state.currentNode = tagNode;
        state.currentContext = {
          parentRef: state.currentContext,
          type: TAG_CONTEXT$1
        };
        return state;
      }
      function handleCloseTag(state, token) {
        const closeTagName = parseCloseTagName(token.content);
        if (closeTagName !== state.currentNode.content.name) {
          state.caretPosition++;
          return state;
        }
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      function handleCommentStart$1(state) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const commentNode = {
          nodeType: NODE_COMMENT$1,
          parentRef: state.currentNode,
          content: {}
        };
        state.currentNode.content.children.push(commentNode);
        state.currentNode = commentNode;
        state.currentContext = {
          parentRef: state.currentContext,
          type: COMMENT_CONTEXT$1
        };
        return state;
      }
      function handleDoctypeStart$1(state) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const doctypeNode = {
          nodeType: NODE_DOCTYPE$1,
          parentRef: state.currentNode,
          content: {}
        };
        state.currentNode.content.children.push(doctypeNode);
        state.currentNode = doctypeNode;
        state.currentContext = {
          parentRef: state.currentContext,
          type: DOCTYPE_CONTEXT$1
        };
        return state;
      }
      function handleText(state, token) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const textNode = {
          nodeType: NODE_TEXT$1,
          parentRef: state.currentNode,
          content: {
            value: token
          }
        };
        state.currentNode.content.children.push(textNode);
        state.caretPosition++;
        return state;
      }
      function handleOpenTagStartScript$1(state) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const scriptNode = {
          nodeType: NODE_SCRIPT$1,
          parentRef: state.currentNode,
          content: {}
        };
        state.currentNode.content.children.push(scriptNode);
        state.currentNode = scriptNode;
        state.currentContext = {
          type: SCRIPT_TAG_CONTEXT$1,
          parentRef: state.currentContext
        };
        return state;
      }
      function handleOpenTagStartStyle$1(state) {
        if (state.currentNode.content.children === void 0) {
          state.currentNode.content.children = [];
        }
        const styleNode = {
          nodeType: NODE_STYLE$1,
          parentRef: state.currentNode,
          content: {}
        };
        state.currentNode.content.children.push(styleNode);
        state.currentNode = styleNode;
        state.currentContext = {
          type: STYLE_TAG_CONTEXT$1,
          parentRef: state.currentContext
        };
        return state;
      }
      var tagContent$1 = function tagContent2(token, state) {
        if (token.type === TOKEN_OPEN_TAG_START$1) {
          return handleOpenTagStart(state);
        }
        if (token.type === TOKEN_TEXT) {
          return handleText(state, token);
        }
        if (token.type === TOKEN_CLOSE_TAG) {
          return handleCloseTag(state, token);
        }
        if (token.type === TOKEN_COMMENT_START$1) {
          return handleCommentStart$1(state);
        }
        if (token.type === TOKEN_DOCTYPE_START$1) {
          return handleDoctypeStart$1(state);
        }
        if (token.type === TOKEN_OPEN_TAG_START_SCRIPT$1) {
          return handleOpenTagStartScript$1(state);
        }
        if (token.type === TOKEN_OPEN_TAG_START_STYLE$1) {
          return handleOpenTagStartStyle$1(state);
        }
        state.caretPosition++;
        return state;
      };
      const parseOpenTagName = helpers.parseOpenTagName;
      const {
        TOKEN_OPEN_TAG_START
      } = tokenTypes$2;
      function handleTagOpenStart(state, token) {
        state.currentNode.content.name = parseOpenTagName(token.content);
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      var tagName$1 = function tagName2(token, state) {
        if (token.type === TOKEN_OPEN_TAG_START) {
          handleTagOpenStart(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$4,
        TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$4,
        TOKEN_OPEN_TAG_END: TOKEN_OPEN_TAG_END$2,
        TOKEN_OPEN_TAG_END_SCRIPT: TOKEN_OPEN_TAG_END_SCRIPT$3,
        TOKEN_OPEN_TAG_END_STYLE: TOKEN_OPEN_TAG_END_STYLE$3
      } = tokenTypes$2;
      const {
        ATTRIBUTE_CONTEXT: ATTRIBUTE_CONTEXT$1
      } = treeConstructorContexts;
      function handlerAttributeStart(state) {
        if (state.currentNode.content.attributes === void 0) {
          state.currentNode.content.attributes = [];
        }
        state.currentNode.content.attributes.push({});
        state.currentContext = {
          parentRef: state.currentContext,
          type: ATTRIBUTE_CONTEXT$1
        };
        return state;
      }
      function handleOpenTagEnd$1(state) {
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      var attributes$1 = function attributes2(token, state) {
        const ATTRIBUTE_START_TOKENS = [
          TOKEN_ATTRIBUTE_KEY$4,
          TOKEN_ATTRIBUTE_ASSIGNMENT$4
        ];
        if (ATTRIBUTE_START_TOKENS.indexOf(token.type) !== -1) {
          return handlerAttributeStart(state);
        }
        const ATTRIBUTES_END_TOKENS = [
          TOKEN_OPEN_TAG_END$2,
          TOKEN_OPEN_TAG_END_SCRIPT$3,
          TOKEN_OPEN_TAG_END_STYLE$3
        ];
        if (ATTRIBUTES_END_TOKENS.indexOf(token.type) !== -1) {
          return handleOpenTagEnd$1(state);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_OPEN_TAG_END: TOKEN_OPEN_TAG_END$1,
        TOKEN_OPEN_TAG_END_SCRIPT: TOKEN_OPEN_TAG_END_SCRIPT$2,
        TOKEN_OPEN_TAG_END_STYLE: TOKEN_OPEN_TAG_END_STYLE$2,
        TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$3,
        TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$3
      } = tokenTypes$2;
      const {
        ATTRIBUTE_VALUE_CONTEXT: ATTRIBUTE_VALUE_CONTEXT$1
      } = treeConstructorContexts;
      function getLastAttribute$2(state) {
        const attributes2 = state.currentNode.content.attributes;
        return attributes2[attributes2.length - 1];
      }
      function handleOpenTagEnd(state) {
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      function handleAttributeKey(state, token) {
        const attribute2 = getLastAttribute$2(state);
        if (attribute2.key !== void 0 || attribute2.value !== void 0) {
          state.currentContext = state.currentContext.parentRef;
          return state;
        }
        attribute2.key = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeAssignment(state) {
        const attribute2 = getLastAttribute$2(state);
        if (attribute2.value !== void 0) {
          state.currentContext = state.currentContext.parentRef;
          return state;
        }
        state.currentContext = {
          parentRef: state.currentContext,
          type: ATTRIBUTE_VALUE_CONTEXT$1
        };
        state.caretPosition++;
        return state;
      }
      var attribute$5 = function attribute2(token, state) {
        const OPEN_TAG_END_TOKENS = [
          TOKEN_OPEN_TAG_END$1,
          TOKEN_OPEN_TAG_END_SCRIPT$2,
          TOKEN_OPEN_TAG_END_STYLE$2
        ];
        if (OPEN_TAG_END_TOKENS.indexOf(token.type) !== -1) {
          return handleOpenTagEnd(state);
        }
        if (token.type === TOKEN_ATTRIBUTE_KEY$3) {
          return handleAttributeKey(state, token);
        }
        if (token.type === TOKEN_ATTRIBUTE_ASSIGNMENT$3) {
          return handleAttributeAssignment(state);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_OPEN_TAG_END,
        TOKEN_OPEN_TAG_END_SCRIPT: TOKEN_OPEN_TAG_END_SCRIPT$1,
        TOKEN_OPEN_TAG_END_STYLE: TOKEN_OPEN_TAG_END_STYLE$1,
        TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$2,
        TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$2,
        TOKEN_ATTRIBUTE_VALUE,
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_START,
        TOKEN_ATTRIBUTE_VALUE_WRAPPER_END
      } = tokenTypes$2;
      function getLastAttribute$1(state) {
        const attributes2 = state.currentNode.content.attributes;
        return attributes2[attributes2.length - 1];
      }
      function handleValueEnd(state) {
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      function handleAttributeValue$1(state, token) {
        const attribute2 = getLastAttribute$1(state);
        attribute2.value = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeValueWrapperStart(state, token) {
        const attribute2 = getLastAttribute$1(state);
        attribute2.startWrapper = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeValueWrapperEnd(state, token) {
        const attribute2 = getLastAttribute$1(state);
        attribute2.endWrapper = token;
        state.caretPosition++;
        return state;
      }
      var attributeValue$1 = function attributeValue2(token, state) {
        const VALUE_END_TOKENS = [
          TOKEN_OPEN_TAG_END,
          TOKEN_OPEN_TAG_END_SCRIPT$1,
          TOKEN_OPEN_TAG_END_STYLE$1,
          TOKEN_ATTRIBUTE_KEY$2,
          TOKEN_ATTRIBUTE_ASSIGNMENT$2
        ];
        if (VALUE_END_TOKENS.indexOf(token.type) !== -1) {
          return handleValueEnd(state);
        }
        if (token.type === TOKEN_ATTRIBUTE_VALUE) {
          return handleAttributeValue$1(state, token);
        }
        if (token.type === TOKEN_ATTRIBUTE_VALUE_WRAPPER_START) {
          return handleAttributeValueWrapperStart(state, token);
        }
        if (token.type === TOKEN_ATTRIBUTE_VALUE_WRAPPER_END) {
          return handleAttributeValueWrapperEnd(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_COMMENT_START,
        TOKEN_COMMENT_END,
        TOKEN_COMMENT_CONTENT
      } = tokenTypes$2;
      function handleCommentStart(state, token) {
        state.currentNode.content.start = token;
        state.caretPosition++;
        return state;
      }
      function handleCommentContent(state, token) {
        state.currentNode.content.value = token;
        state.caretPosition++;
        return state;
      }
      function handleCommentEnd(state, token) {
        state.currentNode.content.end = token;
        state.currentNode = state.currentNode.parentRef;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      var comment$8 = function comment2(token, state) {
        if (token.type === TOKEN_COMMENT_START) {
          return handleCommentStart(state, token);
        }
        if (token.type === TOKEN_COMMENT_CONTENT) {
          return handleCommentContent(state, token);
        }
        if (token.type === TOKEN_COMMENT_END) {
          return handleCommentEnd(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_DOCTYPE_END: TOKEN_DOCTYPE_END$2,
        TOKEN_DOCTYPE_ATTRIBUTE: TOKEN_DOCTYPE_ATTRIBUTE$2,
        TOKEN_DOCTYPE_START,
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$2
      } = tokenTypes$2;
      const {
        DOCTYPE_ATTRIBUTES_CONTEXT: DOCTYPE_ATTRIBUTES_CONTEXT$1
      } = treeConstructorContexts;
      function handleDoctypeStart(state, token) {
        state.currentNode.content.start = token;
        state.caretPosition++;
        return state;
      }
      function handleDoctypeEnd$2(state, token) {
        state.currentNode.content.end = token;
        state.currentNode = state.currentNode.parentRef;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      function handleDoctypeAttributes(state) {
        state.currentContext = {
          parentRef: state.currentContext,
          type: DOCTYPE_ATTRIBUTES_CONTEXT$1
        };
        return state;
      }
      var doctype$1 = function doctype2(token, state) {
        if (token.type === TOKEN_DOCTYPE_START) {
          return handleDoctypeStart(state, token);
        }
        if (token.type === TOKEN_DOCTYPE_END$2) {
          return handleDoctypeEnd$2(state, token);
        }
        const ATTRIBUTES_START_TOKENS = [
          TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$2,
          TOKEN_DOCTYPE_ATTRIBUTE$2
        ];
        if (ATTRIBUTES_START_TOKENS.indexOf(token.type) !== -1) {
          return handleDoctypeAttributes(state);
        }
        state.caretPosition++;
        return state;
      };
      const {
        DOCTYPE_ATTRIBUTE_CONTEXT: DOCTYPE_ATTRIBUTE_CONTEXT$1
      } = treeConstructorContexts;
      const {
        TOKEN_DOCTYPE_END: TOKEN_DOCTYPE_END$1,
        TOKEN_DOCTYPE_ATTRIBUTE: TOKEN_DOCTYPE_ATTRIBUTE$1,
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START: TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$1
      } = tokenTypes$2;
      function handleDoctypeEnd$1(state) {
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      function handleAttribute(state) {
        if (state.currentNode.content.attributes === void 0) {
          state.currentNode.content.attributes = [];
        }
        state.currentNode.content.attributes.push({});
        state.currentContext = {
          type: DOCTYPE_ATTRIBUTE_CONTEXT$1,
          parentRef: state.currentContext
        };
        return state;
      }
      var doctypeAttributes$1 = function doctypeAttributes2(token, state) {
        if (token.type === TOKEN_DOCTYPE_END$1) {
          return handleDoctypeEnd$1(state);
        }
        const ATTRIBUTE_START_TOKENS = [
          TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START$1,
          TOKEN_DOCTYPE_ATTRIBUTE$1
        ];
        if (ATTRIBUTE_START_TOKENS.indexOf(token.type) !== -1) {
          return handleAttribute(state);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_DOCTYPE_END,
        TOKEN_DOCTYPE_ATTRIBUTE,
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START,
        TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END
      } = tokenTypes$2;
      function getLastAttribute(state) {
        const attributes2 = state.currentNode.content.attributes;
        return attributes2[attributes2.length - 1];
      }
      function handleDoctypeEnd(state) {
        state.currentContext = state.currentContext.parentRef;
        return state;
      }
      function handleAttributeValue(state, token) {
        const attribute2 = getLastAttribute(state);
        if (attribute2.value !== void 0) {
          state.currentContext = state.currentContext.parentRef;
          return state;
        }
        attribute2.value = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeWrapperStart(state, token) {
        const attribute2 = getLastAttribute(state);
        if (attribute2.start !== void 0 || attribute2.value !== void 0) {
          state.currentContext = state.currentContext.parentRef;
          return state;
        }
        attribute2.startWrapper = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeWrapperEnd(state, token) {
        const attribute2 = getLastAttribute(state);
        attribute2.endWrapper = token;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      var doctypeAttribute$1 = function doctypeAttribute2(token, state) {
        if (token.type === TOKEN_DOCTYPE_END) {
          return handleDoctypeEnd(state);
        }
        if (token.type === TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_START) {
          return handleAttributeWrapperStart(state, token);
        }
        if (token.type === TOKEN_DOCTYPE_ATTRIBUTE_WRAPPER_END) {
          return handleAttributeWrapperEnd(state, token);
        }
        if (token.type === TOKEN_DOCTYPE_ATTRIBUTE) {
          return handleAttributeValue(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_OPEN_TAG_START_SCRIPT,
        TOKEN_OPEN_TAG_END_SCRIPT,
        TOKEN_CLOSE_TAG_SCRIPT,
        TOKEN_ATTRIBUTE_KEY: TOKEN_ATTRIBUTE_KEY$1,
        TOKEN_ATTRIBUTE_ASSIGNMENT: TOKEN_ATTRIBUTE_ASSIGNMENT$1,
        TOKEN_SCRIPT_TAG_CONTENT
      } = tokenTypes$2;
      const { ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$2 } = treeConstructorContexts;
      function handleOpenTagStartScript(state, token) {
        state.currentNode.content.openStart = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeStartScript(state) {
        state.currentContext = {
          parentRef: state.currentContext,
          type: ATTRIBUTES_CONTEXT$2
        };
        return state;
      }
      function handleOpenTagEndScript(state, token) {
        state.currentNode.content.openEnd = token;
        state.caretPosition++;
        return state;
      }
      function handleScriptContent(state, token) {
        state.currentNode.content.value = token;
        state.caretPosition++;
        return state;
      }
      function handleCloseTagScript(state, token) {
        state.currentNode.content.close = token;
        state.currentNode = state.currentNode.parentRef;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      var scriptTag$1 = function scriptTag2(token, state) {
        if (token.type === TOKEN_OPEN_TAG_START_SCRIPT) {
          return handleOpenTagStartScript(state, token);
        }
        const ATTRIBUTE_START_TOKENS = [
          TOKEN_ATTRIBUTE_KEY$1,
          TOKEN_ATTRIBUTE_ASSIGNMENT$1
        ];
        if (ATTRIBUTE_START_TOKENS.indexOf(token.type) !== -1) {
          return handleAttributeStartScript(state);
        }
        if (token.type === TOKEN_OPEN_TAG_END_SCRIPT) {
          return handleOpenTagEndScript(state, token);
        }
        if (token.type === TOKEN_SCRIPT_TAG_CONTENT) {
          return handleScriptContent(state, token);
        }
        if (token.type === TOKEN_CLOSE_TAG_SCRIPT) {
          return handleCloseTagScript(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const {
        TOKEN_OPEN_TAG_START_STYLE,
        TOKEN_OPEN_TAG_END_STYLE,
        TOKEN_CLOSE_TAG_STYLE,
        TOKEN_ATTRIBUTE_KEY,
        TOKEN_ATTRIBUTE_ASSIGNMENT,
        TOKEN_STYLE_TAG_CONTENT
      } = tokenTypes$2;
      const { ATTRIBUTES_CONTEXT: ATTRIBUTES_CONTEXT$1 } = treeConstructorContexts;
      function handleOpenTagStartStyle(state, token) {
        state.currentNode.content.openStart = token;
        state.caretPosition++;
        return state;
      }
      function handleAttributeStartStyle(state) {
        state.currentContext = {
          parentRef: state.currentContext,
          type: ATTRIBUTES_CONTEXT$1
        };
        return state;
      }
      function handleOpenTagEndStyle(state, token) {
        state.currentNode.content.openEnd = token;
        state.caretPosition++;
        return state;
      }
      function handleStyleContent(state, token) {
        state.currentNode.content.value = token;
        state.caretPosition++;
        return state;
      }
      function handleCloseTagStyle(state, token) {
        state.currentNode.content.close = token;
        state.currentNode = state.currentNode.parentRef;
        state.currentContext = state.currentContext.parentRef;
        state.caretPosition++;
        return state;
      }
      var styleTag$1 = function styleTag2(token, state) {
        if (token.type === TOKEN_OPEN_TAG_START_STYLE) {
          return handleOpenTagStartStyle(state, token);
        }
        const ATTRIBUTE_START_TOKENS = [
          TOKEN_ATTRIBUTE_KEY,
          TOKEN_ATTRIBUTE_ASSIGNMENT
        ];
        if (ATTRIBUTE_START_TOKENS.indexOf(token.type) !== -1) {
          return handleAttributeStartStyle(state);
        }
        if (token.type === TOKEN_OPEN_TAG_END_STYLE) {
          return handleOpenTagEndStyle(state, token);
        }
        if (token.type === TOKEN_STYLE_TAG_CONTENT) {
          return handleStyleContent(state, token);
        }
        if (token.type === TOKEN_CLOSE_TAG_STYLE) {
          return handleCloseTagStyle(state, token);
        }
        state.caretPosition++;
        return state;
      };
      const tag$4 = tag$5;
      const tagContent = tagContent$1;
      const tagName = tagName$1;
      const attributes = attributes$1;
      const attribute$4 = attribute$5;
      const attributeValue = attributeValue$1;
      const comment$7 = comment$8;
      const doctype = doctype$1;
      const doctypeAttributes = doctypeAttributes$1;
      const doctypeAttribute = doctypeAttribute$1;
      const scriptTag = scriptTag$1;
      const styleTag = styleTag$1;
      const {
        TAG_CONTENT_CONTEXT,
        TAG_CONTEXT,
        TAG_NAME_CONTEXT,
        ATTRIBUTES_CONTEXT,
        ATTRIBUTE_CONTEXT,
        ATTRIBUTE_VALUE_CONTEXT,
        COMMENT_CONTEXT,
        DOCTYPE_CONTEXT,
        DOCTYPE_ATTRIBUTES_CONTEXT,
        DOCTYPE_ATTRIBUTE_CONTEXT,
        SCRIPT_TAG_CONTEXT,
        STYLE_TAG_CONTEXT
      } = treeConstructorContexts;
      const { NODE_DOCUMENT: NODE_DOCUMENT$1 } = astNodes;
      const contextsMap = {
        [TAG_CONTENT_CONTEXT]: tagContent,
        [TAG_CONTEXT]: tag$4,
        [TAG_NAME_CONTEXT]: tagName,
        [ATTRIBUTES_CONTEXT]: attributes,
        [ATTRIBUTE_CONTEXT]: attribute$4,
        [ATTRIBUTE_VALUE_CONTEXT]: attributeValue,
        [COMMENT_CONTEXT]: comment$7,
        [DOCTYPE_CONTEXT]: doctype,
        [DOCTYPE_ATTRIBUTES_CONTEXT]: doctypeAttributes,
        [DOCTYPE_ATTRIBUTE_CONTEXT]: doctypeAttribute,
        [SCRIPT_TAG_CONTEXT]: scriptTag,
        [STYLE_TAG_CONTEXT]: styleTag
      };
      function processTokens(tokens, state, positionOffset) {
        let tokenIndex = state.caretPosition - positionOffset;
        while (tokenIndex < tokens.length) {
          const token = tokens[tokenIndex];
          const contextHandler = contextsMap[state.currentContext.type];
          state = contextHandler(token, state);
          tokenIndex = state.caretPosition - positionOffset;
        }
        return state;
      }
      var constructTree$3 = function constructTree2(tokens = [], existingState, parseOptions = {}) {
        let state = existingState;
        if (existingState === void 0) {
          const rootContext = {
            type: TAG_CONTENT_CONTEXT,
            parentRef: void 0,
            content: []
          };
          const rootNode = {
            nodeType: NODE_DOCUMENT$1,
            parentRef: void 0,
            content: {}
          };
          state = {
            caretPosition: 0,
            currentContext: rootContext,
            currentNode: rootNode,
            rootNode,
            parseOptions
          };
        }
        const positionOffset = state.caretPosition;
        processTokens(tokens, state, positionOffset);
        return { state, ast: state.rootNode };
      };
      var domain;
      function EventHandlers() {
      }
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active)
            ;
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
        if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n2;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            listeners[i2].call(self2);
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            listeners[i2].call(self2, arg1);
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            listeners[i2].call(self2, arg1, arg2);
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            listeners[i2].call(self2, arg1, arg2, arg3);
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            listeners[i2].apply(self2, args);
        }
      }
      EventEmitter.prototype.emit = function emit2(type2) {
        var er, handler, len, args, i2, events, domain2;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i2 = 1; i2 < len; i2++)
              args[i2 - 1] = arguments[i2];
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type2, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = new EventHandlers();
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit(
              "newListener",
              type2,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type2];
        }
        if (!existing) {
          existing = events[type2] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type2;
              w.count = existing.length;
              emitWarning(w);
            }
          }
        }
        return target;
      }
      function emitWarning(e) {
        typeof console.warn === "function" ? console.warn(e) : console.log(e);
      }
      EventEmitter.prototype.addListener = function addListener2(type2, listener) {
        return _addListener(this, type2, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener2(type2, listener) {
        return _addListener(this, type2, listener, true);
      };
      function _onceWrap(target, type2, listener) {
        var fired = false;
        function g() {
          target.removeListener(type2, g);
          if (!fired) {
            fired = true;
            listener.apply(target, arguments);
          }
        }
        g.listener = listener;
        return g;
      }
      EventEmitter.prototype.once = function once2(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
        var list2, events, position, i2, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list2 = events[type2];
        if (!list2)
          return this;
        if (list2 === listener || list2.listener && list2.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list2.listener || listener);
          }
        } else if (typeof list2 !== "function") {
          position = -1;
          for (i2 = list2.length; i2-- > 0; ) {
            if (list2[i2] === listener || list2[i2].listener && list2[i2].listener === listener) {
              originalListener = list2[i2].listener;
              position = i2;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list2.length === 1) {
            list2[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list2, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = function(type2, listener) {
        return this.removeListener(type2, listener);
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type2) {
        var listeners, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i2 = 0, key; i2 < keys2.length; ++i2) {
            key = keys2[i2];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type2];
        if (typeof listeners === "function") {
          this.removeListener(type2, listeners);
        } else if (listeners) {
          do {
            this.removeListener(type2, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount$1.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount$1;
      function listenerCount$1(type2) {
        var events = this._events;
        if (events) {
          var evlistener = events[type2];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list2, index) {
        for (var i2 = index, k = i2 + 1, n2 = list2.length; k < n2; i2 += 1, k += 1)
          list2[i2] = list2[k];
        list2.pop();
      }
      function arrayClone(arr, i2) {
        var copy = new Array(i2);
        while (i2--)
          copy[i2] = arr[i2];
        return copy;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i2 = 0; i2 < ret.length; ++i2) {
          ret[i2] = arr[i2].listener || arr[i2];
        }
        return ret;
      }
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n2) {
        if (this.length === 0)
          return Buffer$1.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer$1.allocUnsafe(n2 >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          p.data.copy(ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      };
      var _safeBuffer_5_2_1_safeBuffer = { exports: {} };
      var require$$0$3 = getAugmentedNamespace(_polyfillNode_buffer);
      (function(module2, exports2) {
        var buffer = require$$0$3;
        var Buffer2 = buffer.Buffer;
        function copyProps(src2, dst) {
          for (var key in src2) {
            dst[key] = src2[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module2.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer2.prototype);
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      })(_safeBuffer_5_2_1_safeBuffer, _safeBuffer_5_2_1_safeBuffer.exports);
      var Buffer = _safeBuffer_5_2_1_safeBuffer.exports.Buffer;
      var isEncoding = Buffer.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      var StringDecoder_1 = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i2;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i2 = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i2 = 0;
        }
        if (i2 < buf.length)
          return r ? r + this.text(buf, i2) : this.text(buf, i2);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i2) {
        var j = buf.length - 1;
        if (j < i2)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i2 || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i2 || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "�";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "�";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "�";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i2) {
        var total = utf8CheckIncomplete(this, buf, i2);
        if (!this.lastNeed)
          return buf.toString("utf8", i2);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i2, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "�";
        return r;
      }
      function utf16Text(buf, i2) {
        if ((buf.length - i2) % 2 === 0) {
          var r = buf.toString("utf16le", i2);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i2, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i2) {
        var n2 = (buf.length - i2) % 3;
        if (n2 === 0)
          return buf.toString("base64", i2);
        this.lastNeed = 3 - n2;
        this.lastTotal = 3;
        if (n2 === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i2, buf.length - n2);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
      Readable.ReadableState = ReadableState;
      var debug = debuglog("stream");
      inherits$1(Readable, EventEmitter);
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") {
          return emitter.prependListener(event, fn);
        } else {
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      function listenerCount(emitter, type2) {
        return emitter.listeners(type2).length;
      }
      function ReadableState(options2, stream) {
        options2 = options2 || {};
        this.objectMode = !!options2.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options2.readableObjectMode;
        var hwm = options2.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.defaultEncoding = options2.defaultEncoding || "utf8";
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options2.encoding) {
          this.decoder = new StringDecoder_1(options2.encoding);
          this.encoding = options2.encoding;
        }
      }
      function Readable(options2) {
        if (!(this instanceof Readable))
          return new Readable(options2);
        this._readableState = new ReadableState(options2, this);
        this.readable = true;
        if (options2 && typeof options2.read === "function")
          this._read = options2.read;
        EventEmitter.call(this);
      }
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer$1.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error("stream.push() after EOF");
            stream.emit("error", e);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error("stream.unshift() after end event");
            stream.emit("error", _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront)
              state.reading = false;
            if (!skipAdd) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
            }
            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder_1(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n2) {
        if (n2 >= MAX_HWM) {
          n2 = MAX_HWM;
        } else {
          n2--;
          n2 |= n2 >>> 1;
          n2 |= n2 >>> 2;
          n2 |= n2 >>> 4;
          n2 |= n2 >>> 8;
          n2 |= n2 >>> 16;
          n2++;
        }
        return n2;
      }
      function howMuchToRead(n2, state) {
        if (n2 <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n2 !== n2) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n2 > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n2);
        if (n2 <= state.length)
          return n2;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n2) {
        debug("read", n2);
        n2 = parseInt(n2, 10);
        var state = this._readableState;
        var nOrig = n2;
        if (n2 !== 0)
          state.emittedReadable = false;
        if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n2 = howMuchToRead(n2, state);
        if (n2 === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n2 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n2 = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n2 > 0)
          ret = fromList(n2, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n2 = 0;
        } else {
          state.length -= n2;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n2 && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            nextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n2) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src2 = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick(endFn);
        else
          src2.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src2) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src2);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src2.removeListener("end", onend2);
          src2.removeListener("end", cleanup);
          src2.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src2.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src2._readableState.awaitDrain);
              src2._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src2.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src2.unpipe(dest);
        }
        dest.emit("pipe", src2);
        if (!state.flowing) {
          debug("pipe resume");
          src2.resume();
        }
        return dest;
      };
      function pipeOnDrain(src2) {
        return function() {
          var state = src2._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && src2.listeners("data").length) {
            state.flowing = true;
            flow(src2);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i2 = indexOf(state.pipes, dest);
        if (i2 === -1)
          return this;
        state.pipes.splice(i2, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i2 in stream) {
          if (this[i2] === void 0 && typeof stream[i2] === "function") {
            this[i2] = /* @__PURE__ */ function(method2) {
              return function() {
                return stream[method2].apply(stream, arguments);
              };
            }(i2);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
      function fromList(n2, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n2 || n2 >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n2, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n2, list2, hasStrings) {
        var ret;
        if (n2 < list2.head.data.length) {
          ret = list2.head.data.slice(0, n2);
          list2.head.data = list2.head.data.slice(n2);
        } else if (n2 === list2.head.data.length) {
          ret = list2.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n2, list2) : copyFromBuffer(n2, list2);
        }
        return ret;
      }
      function copyFromBufferString(n2, list2) {
        var p = list2.head;
        var c = 1;
        var ret = p.data;
        n2 -= ret.length;
        while (p = p.next) {
          var str2 = p.data;
          var nb = n2 > str2.length ? str2.length : n2;
          if (nb === str2.length)
            ret += str2;
          else
            ret += str2.slice(0, n2);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === str2.length) {
              ++c;
              if (p.next)
                list2.head = p.next;
              else
                list2.head = list2.tail = null;
            } else {
              list2.head = p;
              p.data = str2.slice(nb);
            }
            break;
          }
          ++c;
        }
        list2.length -= c;
        return ret;
      }
      function copyFromBuffer(n2, list2) {
        var ret = Buffer$1.allocUnsafe(n2);
        var p = list2.head;
        var c = 1;
        p.data.copy(ret);
        n2 -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n2 > buf.length ? buf.length : n2;
          buf.copy(ret, ret.length - n2, 0, nb);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list2.head = p.next;
              else
                list2.head = list2.tail = null;
            } else {
              list2.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list2.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      function forEach(xs, f) {
        for (var i2 = 0, l = xs.length; i2 < l; i2++) {
          f(xs[i2], i2);
        }
      }
      function indexOf(xs, x) {
        for (var i2 = 0, l = xs.length; i2 < l; i2++) {
          if (xs[i2] === x)
            return i2;
        }
        return -1;
      }
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);
      function nop() {
      }
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      function WritableState(options2, stream) {
        Object.defineProperty(this, "buffer", {
          get: deprecate$2(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
        options2 = options2 || {};
        this.objectMode = !!options2.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options2.writableObjectMode;
        var hwm = options2.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options2.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options2.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      function Writable(options2) {
        if (!(this instanceof Writable) && !(this instanceof Duplex))
          return new Writable(options2);
        this._writableState = new WritableState(options2, this);
        this.writable = true;
        if (options2) {
          if (typeof options2.write === "function")
            this._write = options2.write;
          if (typeof options2.writev === "function")
            this._writev = options2.writev;
        }
        EventEmitter.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer$1.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer$1.from(chunk, encoding);
        }
        return chunk;
      }
      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer$1.isBuffer(chunk))
          encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last2 = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last2) {
            last2.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync)
          nextTick(cb, er);
        else
          cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
          }
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit("finish");
          } else {
            prefinish(stream, state);
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function(err) {
          var entry = _this.entry;
          _this.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }
      inherits$1(Duplex, Readable);
      var keys = Object.keys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
      function Duplex(options2) {
        if (!(this instanceof Duplex))
          return new Duplex(options2);
        Readable.call(this, options2);
        Writable.call(this, options2);
        if (options2 && options2.readable === false)
          this.readable = false;
        if (options2 && options2.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options2 && options2.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      inherits$1(Transform$2, Duplex);
      function TransformState(stream) {
        this.afterTransform = function(er, data2) {
          return afterTransform(stream, er, data2);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }
      function afterTransform(stream, er, data2) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb)
          return stream.emit("error", new Error("no writecb in Transform class"));
        ts.writechunk = null;
        ts.writecb = null;
        if (data2 !== null && data2 !== void 0)
          stream.push(data2);
        cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark);
        }
      }
      function Transform$2(options2) {
        if (!(this instanceof Transform$2))
          return new Transform$2(options2);
        Duplex.call(this, options2);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options2) {
          if (typeof options2.transform === "function")
            this._transform = options2.transform;
          if (typeof options2.flush === "function")
            this._flush = options2.flush;
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function")
            this._flush(function(er) {
              done(stream, er);
            });
          else
            done(stream);
        });
      }
      Transform$2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform$2.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform$2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform$2.prototype._read = function(n2) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      function done(stream, er) {
        if (er)
          return stream.emit("error", er);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (ts.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
      inherits$1(PassThrough, Transform$2);
      function PassThrough(options2) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options2);
        Transform$2.call(this, options2);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform$2;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      function Stream() {
        EventEmitter.call(this);
      }
      Stream.prototype.pipe = function(dest, options2) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options2 || options2.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      var _polyfillNode_stream = Object.freeze({
        __proto__: null,
        "default": Stream,
        Readable,
        Writable,
        Duplex,
        Transform: Transform$2,
        PassThrough,
        Stream
      });
      var require$$0$2 = getAugmentedNamespace(_polyfillNode_stream);
      const { Transform: Transform$1 } = require$$0$2;
      const tokenize$6 = tokenize_1;
      class StreamTokenizer$1 extends Transform$1 {
        constructor(options2) {
          super(Object.assign(
            {},
            options2,
            {
              decodeStrings: false,
              readableObjectMode: true
            }
          ));
          this.currentTokenizerState = void 0;
          this.setDefaultEncoding("utf8");
        }
        _transform(chunk, encoding, callback) {
          let chunkString = chunk;
          if (Buffer$1.isBuffer(chunk)) {
            chunkString = chunk.toString();
          }
          const { state, tokens } = tokenize$6(
            chunkString,
            this.currentTokenizerState,
            { isFinalChunk: false }
          );
          this.currentTokenizerState = state;
          callback(null, tokens);
        }
        _flush(callback) {
          const tokenizeResults = tokenize$6(
            "",
            this.currentTokenizerState,
            { isFinalChunk: true }
          );
          this.push(tokenizeResults.tokens);
          callback();
        }
      }
      var streamTokenizer = StreamTokenizer$1;
      const { Transform } = require$$0$2;
      const constructTree$2 = constructTree$3;
      class StreamTreeConstructor$1 extends Transform {
        constructor(options2) {
          super(Object.assign(
            {},
            options2,
            {
              objectMode: true,
              readableObjectMode: true
            }
          ));
          this.currentState = void 0;
        }
        _transform(tokensChunk, encoding, callback) {
          const { state, ast } = constructTree$2(
            tokensChunk,
            this.currentState
          );
          this.currentState = state;
          callback(null, ast);
        }
      }
      var streamTreeConstructor = StreamTreeConstructor$1;
      const tokenize$5 = tokenize_1;
      const constructTree$1 = constructTree$3;
      const StreamTokenizer = streamTokenizer;
      const StreamTreeConstructor = streamTreeConstructor;
      _hyntaxYx_1_0_9_hyntaxYx.tokenize = tokenize$5;
      _hyntaxYx_1_0_9_hyntaxYx.constructTree = constructTree$1;
      _hyntaxYx_1_0_9_hyntaxYx.StreamTokenizer = StreamTokenizer;
      _hyntaxYx_1_0_9_hyntaxYx.StreamTreeConstructor = StreamTreeConstructor;
      const { constructTree, tokenize: tokenize$4 } = _hyntaxYx_1_0_9_hyntaxYx;
      var parse$e = (code2) => {
        const { tokens } = tokenize$4(code2);
        const { ast } = constructTree(tokens);
        return ast;
      };
      const { isObject: isObject$4 } = util$2;
      const Props = [
        "startPosition",
        "endPosition",
        "parentRef",
        "openStart",
        "openEnd",
        "startWrapper",
        "endWrapper",
        "close"
      ];
      const filterProps$2 = function(node2, structure) {
        for (const key in node2) {
          if (Props.indexOf(key) == -1 && node2[key]) {
            if (isObject$4(node2[key])) {
              if (Array.isArray(node2[key])) {
                structure[key] = [];
                node2[key].forEach((n2, i2) => {
                  structure[key][i2] = {};
                  filterProps$2(n2, structure[key][i2]);
                });
              } else {
                structure[key] = {};
                filterProps$2(node2[key], structure[key]);
              }
            } else {
              structure[key] = node2[key];
            }
          }
        }
      };
      var filterProp$1 = filterProps$2;
      const parse$d = parse$e;
      const filterProps$1 = filterProp$1;
      function getSelector$1(selectorCode, parseOptions, expando = "g123o456g789o") {
        const selector2 = { nodeType: "", structure: {} };
        if (typeof selectorCode != "string") {
          selector2.nodeType = selectorCode.nodeType;
          filterProps$1(selectorCode, selector2.structure);
          selector2.type = selectorCode.nodeType;
          return selector2;
        } else {
          selectorCode = selectorCode.trim().replace(/\$_\$/g, expando).replace(/\$\$\$/g, expando.slice(0, -1) + "$3");
        }
        let selectorAst = parse$d(selectorCode);
        if (selectorAst.content && selectorAst.content.children && selectorAst.content.children[0]) {
          filterProps$1(selectorAst.content.children[0], selector2.structure);
          selector2.nodeType = selectorAst.content.children[0].nodeType;
        }
        return selector2;
      }
      var getSelector_1 = getSelector$1;
      const { escapeRegExp: escapeRegExp$1 } = util$2;
      var htmlTraverse = (ast, transformMap = {}, filePath, deleteComment) => {
        if (ast.nodeType) {
          handleNode(ast);
        } else if (ast.content && ast.content.children && ast.content.children.length > 0) {
          traversChildnode(ast.content.children);
        }
        if (Array.isArray(ast)) {
          ast.forEach((a) => {
            handleNode(a);
          });
        }
        function handleNode(node2) {
          const posIndex = node2.parentRef && node2.parentRef.content.children && Array.isArray(node2.parentRef.content.children) ? node2.parentRef.content.children.indexOf(node2) : void 0;
          const extra = {
            document: ast,
            nodeRef: node2,
            posIndex,
            parentRef: node2.parentRef,
            filePath
          };
          if (node2.nodeType == "tag" || node2.nodeType == "script") {
            const attrs = node2.content.attributes || [];
            const attrMap = {};
            attrs.forEach((attr) => {
              attrMap[attr.key.content] = attr;
            });
            const tagHandle = transformMap.tag || [];
            tagHandle.forEach((h) => {
              if (h.value) {
                if (h.value == node2.content.name) {
                  h.handle(node2.content, Object.assign({ attrs, attrMap }, extra));
                }
              } else {
                h.handle(node2.content, Object.assign({ attrs, attrMap }, extra));
              }
            });
            const attrHandle = transformMap.attr || [];
            attrHandle.forEach((h) => {
              const { key, value } = h;
              if (value) {
                if (attrMap[key] && attrMap[key].value && attrMap[key].value.content.replace(/\s/g, "") == value) {
                  h.handle(
                    node2.content,
                    Object.assign({ attrs, attrMap }, extra)
                  );
                }
              } else if (key) {
                if (attrMap[key]) {
                  h.handle(
                    node2.content,
                    Object.assign({ attrs, attrMap }, extra)
                  );
                }
              } else {
                h.handle(
                  node2.content,
                  Object.assign({ attrs, attrMap }, extra)
                );
              }
            });
            const eventHandle = transformMap.event || [];
            const attrKeys = Object.keys(attrMap);
            const eventAttr = attrKeys.filter((k) => k.match("mx-"))[0];
            if (eventAttr) {
              eventHandle.forEach((h) => {
                h.handle(
                  node2.content,
                  Object.assign({}, extra)
                );
              });
            }
            if (transformMap.abandonAttr) {
              for (let i2 = 0; i2 < attrs.length; i2++) {
                const attr = attrs[i2];
                if (attr && transformMap.abandonAttr.indexOf(attr.key.content) > -1) {
                  attrs.splice(i2, 1);
                  i2--;
                }
              }
            }
          } else if (node2.nodeType == "text") {
            const handle = transformMap.text || [];
            handle.forEach((h) => {
              let isContain = false;
              switch (h.type) {
                case "containOne":
                  isContain = h.value.some((v2) => node2.content.value.content.match(escapeRegExp$1(v2)));
                  if (isContain) {
                    h.handle(node2, extra);
                  }
                  break;
                case "containAll":
                  isContain = h.value.every((v2) => node2.content.value.content.match(escapeRegExp$1(v2)));
                  if (isContain) {
                    h.handle(node2, extra);
                  }
                  break;
                case "equal":
                  if (node2.content.value.content == h.value) {
                    h.handle(node2, extra);
                  }
                  break;
                default:
                  h.handle(node2, extra);
              }
            });
          } else {
            const handle = transformMap[node2.nodeType];
            handle && handle.forEach((h) => {
              h.handle(node2, extra);
            });
            if (deleteComment && node2.nodeType == "comment") {
              extra.parentRef.content.children.splice(extra.posIndex, 1);
            }
          }
          if (node2.content.children && node2.content.children.length) {
            traversChildnode(node2.content.children);
          }
        }
        function traversChildnode(list2) {
          let index = 0;
          while (list2[index]) {
            const node2 = list2[index];
            node2._index = index;
            node2.reached || handleNode(node2);
            node2.reached = true;
            index++;
          }
          list2.forEach((item) => item.reached = false);
        }
        return ast;
      };
      const recast = main$3;
      const visit = recast.types.visit;
      var NodePath_1 = class NodePath {
        constructor(node2, parent, parentPath) {
          if (!parent && !parentPath && node2.program) {
            const nodePath2 = this;
            visit(node2, {
              visitFile(path2) {
                ["node", "value", "parent", "get", "getValueProperty", "__childCache", "__proto__", "name"].forEach((key) => {
                  nodePath2[key] = path2[key];
                });
                this.abort();
              }
            });
          } else {
            this.node = node2;
            this.parent = parent || null;
            this.parentPath = parentPath || null;
            this.value = node2;
          }
        }
      };
      const {
        NODE_DOCUMENT,
        NODE_DOCTYPE,
        NODE_TAG,
        NODE_TEXT,
        NODE_COMMENT,
        NODE_SCRIPT,
        NODE_STYLE
      } = astNodes;
      function serializeDoctypeNode(node2) {
        let attributes2 = serializeDoctypeAttributes(node2.content.attributes);
        if (attributes2 !== "") {
          attributes2 = ` ${attributes2}`;
        }
        return `<!doctype${attributes2}>`;
      }
      function serializeCommentNode(node2) {
        return `<!--${node2.content.value.content}-->`;
      }
      function serializeTagNode(nodeName, attributes2, serializedChildren, selfClosing, node2) {
        let serializedAttributes = serializeTagAttributes(attributes2);
        if (serializedAttributes !== "") {
          serializedAttributes = ` ${serializedAttributes}`;
        }
        selfClosing = selfClosing === false ? false : node2.content.selfClosing;
        if (selfClosing) {
          return `<${nodeName}${serializedAttributes}/>`;
        }
        return `<${nodeName}${serializedAttributes}>` + serializedChildren + `</${nodeName}>`;
      }
      function serializeTagAttributes(attributes2 = []) {
        return attributes2.map((item) => {
          let serialized = "";
          if (item.key !== void 0) {
            serialized += item.key.content;
          }
          if (item.value !== void 0) {
            let quota = ['"', '"'];
            if (item.startWrapper && item.startWrapper.content) {
              quota[0] = item.startWrapper.content;
            } else {
              quota[0] = "";
            }
            if (item.endWrapper && item.endWrapper.content) {
              quota[1] = item.endWrapper.content;
            } else {
              quota[1] = "";
            }
            if (item.value.content && item.value.content.match && item.value.content.match(quota)) {
              quota = ["'", "'"];
            }
            if (item.value.content && item.value.content.trim && item.value.content.trim()[0] == "=") {
              quota = ["", ""];
            } else if (item.value.content && item.value.content.match && item.value.content.match(/\(/) && item.value.content.match(/\)/) && item.key.content.match(/\{\{/)) {
              quota = ["", ""];
            }
            serialized += `=${quota[0]}${item.value.content}${quota[1]}`;
          }
          return serialized;
        }).join(" ");
      }
      function serializeDoctypeAttributes(attributes2 = []) {
        return attributes2.map((item) => {
          let wrapper2 = "";
          if (item.startWrapper !== void 0) {
            wrapper2 = item.startWrapper;
          }
          return `${wrapper2}${item.value.content}${wrapper2}`;
        }).join(" ");
      }
      function serializeTextNode(node2) {
        return node2.content.value.content;
      }
      function serializeNode(node2, serializedChildren = "") {
        if (node2.content && node2.content.children && node2.content.children.length > 0) {
          serializedChildren = node2.content.children.map((child) => {
            return serializeNode(child, "");
          }).join("");
        }
        switch (node2.nodeType) {
          case NODE_DOCUMENT: {
            return serializedChildren;
          }
          case NODE_DOCTYPE: {
            return serializeDoctypeNode(node2);
          }
          case NODE_TAG: {
            return serializeTagNode(
              node2.content.name,
              node2.content.attributes,
              serializedChildren,
              void 0,
              node2
            );
          }
          case NODE_TEXT: {
            return serializeTextNode(node2);
          }
          case NODE_COMMENT: {
            return serializeCommentNode(node2);
          }
          case NODE_SCRIPT: {
            return serializeTagNode(
              "script",
              node2.content.attributes,
              node2.content.value ? node2.content.value.content : "",
              false,
              node2
            );
          }
          case NODE_STYLE: {
            return serializeTagNode(
              "style",
              node2.content.attributes,
              node2.content.value ? node2.content.value.content : "",
              false,
              node2
            );
          }
          default: {
            throw new Error(
              `generate failed! Unexpected node type for serialization: ${node2.nodeType}`
            );
          }
        }
      }
      var serializeNode_1 = serializeNode;
      const { isObject: isObject$3, hasOwn: hasOwn$1, escapeRegExp } = util$2;
      const filterProps = filterProp$1;
      const traverse = htmlTraverse;
      const NodePath$3 = NodePath_1;
      const generate$4 = serializeNode_1;
      let Expando = "g123o456g789o";
      function checkIsMatch(full, partial, extraData, strictSequence) {
        return Object.keys(partial).every((prop) => {
          if (prop == "children") {
            if (full.children && partial.children.length == 1 && partial.children[0].nodeType == "text" && partial.children[0].content.value.content.match) {
              if (partial.children[0].content.value.content.match(Expando)) {
                const expandoKey = partial.children[0].content.value.content.replace(Expando, "") || "0";
                extraData[expandoKey] = extraData[expandoKey] || [];
                extraData[expandoKey].push({ node: full.children, value: full.children.map((c) => generate$4(c)).join("\n") });
                return true;
              } else if (partial.children[0].content.value.content.match(new RegExp(Expando.slice(0, -1) + "\\$3"))) {
                find$$$(partial[prop], full[prop], extraData, strictSequence);
                return true;
              }
            }
          }
          if (!full || !partial) {
            return false;
          } else if (isObject$3(partial[prop])) {
            let res = false;
            let has$$$ = false;
            if (Array.isArray(partial[prop])) {
              has$$$ = find$$$(partial[prop], full[prop], extraData, strictSequence);
            }
            if (Array.isArray(partial[prop]) && !strictSequence) {
              if (hasOwn$1(full, prop)) {
                res = partial[prop].every((p) => {
                  let a = false;
                  if (!full[prop].length && partial[prop].length == 1 && has$$$) {
                    return true;
                  }
                  full[prop] && full[prop].forEach((f) => {
                    if (checkIsMatch(f, p, extraData, strictSequence)) {
                      a = true;
                    }
                  });
                  return a;
                });
              } else {
                if (partial[prop].length == 1 && has$$$) {
                  return true;
                }
                return false;
              }
            } else {
              try {
                if (partial[prop].type == "token:attribute-value" && !full[prop]) {
                  if (partial[prop].content.match && partial[prop].content.match(Expando)) {
                    const expandoKey = partial[prop].content.replace(Expando, "") || "0";
                    extraData[expandoKey] = extraData[expandoKey] || [];
                    extraData[expandoKey].push({ node: null, value: null });
                    return true;
                  }
                }
                res = hasOwn$1(full, prop) && checkIsMatch(full[prop], partial[prop], extraData, strictSequence);
              } catch (e) {
                console.log(e);
              }
            }
            return res;
          } else {
            if (partial[prop].match && partial[prop].match(new RegExp(Expando.slice(0, -1) + "\\$3"))) {
              return true;
            }
            if (partial[prop] == Expando || partial[prop].match && partial[prop].match(Expando)) {
              let extra = {
                node: full
              };
              const expandoKey = partial[prop].replace(Expando, "") || "0";
              extraData[expandoKey] = extraData[expandoKey] || [];
              if (!full)
                return;
              if (full[prop] !== void 0) {
                extra.value = full[prop] || "";
              } else {
                extra.value = {};
                filterProps(full, extra.value);
              }
              extraData[expandoKey].push(extra);
              return true;
            } else if (partial[prop])
              ;
            if (prop == "content") {
              if (partial[prop].trim().match(new RegExp(Expando))) {
                return true;
              } else {
                if (partial.type == "token:attribute-key") {
                  return full ? full[prop] == partial[prop].trim() : false;
                }
                return full ? !!full[prop].match(escapeRegExp(partial[prop].trim())) : false;
              }
            } else {
              return full ? full[prop] == partial[prop] : false;
            }
          }
        });
      }
      function find$$$(partial, full, extraData, strictSequence) {
        let key$$$;
        let index$$$ = -1;
        let i2 = 0;
        while (partial[i2]) {
          const p = partial[i2];
          for (const key in p) {
            let value = "";
            if (p[key] && p[key].value && p[key].value.content) {
              value = p[key].value.content;
            } else if (p[key] && p[key].content) {
              value = p[key].content;
            }
            if (p.nodeType == "text") {
              const start = value.indexOf(Expando.slice(0, -1) + "$3");
              if (start > -1 && value.slice(0, start).trim()) {
                p.content.value.content = value.slice(0, start);
                partial[i2 + 1] = {
                  nodeType: "text",
                  content: {
                    value: {
                      content: value.slice(start),
                      type: "token:text"
                    }
                  }
                };
                value = p.content.value.content;
              }
            }
            if (value && value.match && value.match(new RegExp(Expando.slice(0, -1) + "\\$3"))) {
              key$$$ = value.match(new RegExp(`(?<=${Expando.slice(0, -1)}\\$3)([0-9]|[a-z]|[A-Z])*`))[0] || "$";
              index$$$ = i2;
              break;
            }
          }
          i2++;
        }
        if (!key$$$) {
          return false;
        }
        const extraNodeList = full ? full.slice(0) : [];
        partial.forEach((p, i3) => {
          if (i3 == index$$$) {
            return;
          }
          let fi = 0;
          while (extraNodeList[fi]) {
            if (checkIsMatch(extraNodeList[fi], p, {}, strictSequence)) {
              extraNodeList.splice(fi, 1);
            } else {
              fi++;
            }
          }
        });
        extraData[`$$$${key$$$}`] = (extraData[`$$$${key$$$}`] || []).concat(extraNodeList);
        return true;
      }
      function find$1(nodeType, structure, strictSequence, deep, expando = "g123o456g789o") {
        const nodePathList = [];
        const matchWildCardList = [];
        let isMatch = false;
        Expando = expando;
        const traverseMap = {
          tag: nodeType == "tag" || nodeType == "script" ? [{
            value: (structure.content.name || "").match(Expando) ? "" : structure.content.name,
            handle(tagContent2, { attrMap, parentRef, nodeRef } = {}) {
              const matchWildCard = {};
              isMatch = checkIsMatch(nodeRef, structure, matchWildCard, strictSequence);
              if (isMatch) {
                nodePathList.push(linkParentPath(nodeRef));
                matchWildCardList.push(matchWildCard);
              }
            }
          }] : [],
          attr: [],
          text: nodeType == "text" ? [{
            value: [structure.content.trim && structure.content.trim() == Expando || structure.content.value.content.trim() == Expando ? "" : structure.content.value.content.trim()],
            type: "containOne",
            handle(node2) {
              nodePathList.push(linkParentPath(node2));
              matchWildCardList.push(node2.content.value.content);
            }
          }] : []
        };
        if (nodeType != "tag" && nodeType != "script" && nodeType != "text") {
          traverseMap[nodeType] = [{
            handle(node2) {
              nodePathList.push(linkParentPath(node2));
              if (node2.content.value) {
                matchWildCardList.push(node2.content.value.content);
              }
            }
          }];
        }
        traverse(this, traverseMap);
        return { nodePathList, matchWildCardList };
      }
      function linkParentPath(node2) {
        while (node2) {
          const pPath = node2.parentRef ? linkParentPath(node2.parentRef) : null;
          const path2 = new NodePath$3(node2, pPath, pPath);
          return path2;
        }
        return null;
      }
      var find_1 = { find: find$1 };
      const getSelector = getSelector_1;
      const { find } = find_1;
      const parse$c = parse$e;
      const generate$3 = serializeNode_1;
      const core$2 = {
        // 通过选择器获取，返回ast片段
        getAstsBySelector(ast, selector2, { strictSequence, deep, parseOptions, expando = "g123o456g789o" } = {}) {
          if (!Array.isArray(selector2)) {
            selector2 = [selector2];
          }
          let nodePathList = [];
          let matchWildCardList = [];
          const selectorAst = selector2.map((item) => {
            const sel = getSelector(
              item,
              this.parseOptions || parseOptions,
              expando
            );
            if (!sel.nodeType) {
              throw new Error(
                "语句类型缺失，请在 https://github.com/thx/gogocode/issues 上提供您的代码样例"
              );
            }
            return sel;
          });
          const reachedNodeList = [];
          selectorAst.forEach((item) => {
            const res = find.call(
              ast,
              item.nodeType,
              item.structure,
              strictSequence,
              deep,
              expando
            );
            res.nodePathList.forEach((p, i2) => {
              if (reachedNodeList.indexOf(p.node.content) == -1) {
                nodePathList.push(p);
                matchWildCardList.push(res.matchWildCardList[i2]);
                reachedNodeList.push(p.node.content);
              }
            });
          });
          return {
            nodePathList,
            matchWildCardList,
            pathList: nodePathList,
            extraDataList: matchWildCardList
          };
        },
        getParentListByAst(path2) {
          const list2 = [];
          while (path2 && path2.parentPath) {
            list2.push(path2.parentPath);
            path2 = path2.parentPath;
          }
          return list2;
        },
        buildAstByAstStr(str2, astPatialMap = {}, { isProgram = false, parseOptions } = {}) {
          try {
            const ast = parse$c(str2, parseOptions);
            const program = core$2.replaceStrByAst(ast, astPatialMap);
            if (program) {
              if (isProgram) {
                return program;
              } else {
                if (program.content.children && program.content.children[0]) {
                  if (program.content.children.length > 1) {
                    return program.content.children;
                  } else if (program.content.children.length == 1) {
                    return program.content.children[0];
                  } else {
                    return null;
                  }
                }
              }
            } else {
              return null;
            }
          } catch (e) {
            console.log("buildAstByAstStr failed:" + e);
          }
        },
        replaceStrByAst(ast, astPatialMap = {}) {
          for (let key in astPatialMap) {
            const valueAst = astPatialMap[key];
            const { nodePathList } = core$2.getAstsBySelector(
              ast,
              `'$_$${key}$_$'`
            );
            if (nodePathList.length > 0) {
              nodePathList[0].replace(valueAst);
            }
          }
          return ast;
        },
        replaceAstByAst(oldAst, newAst, _index) {
          if (oldAst.parent && oldAst.parent.node && oldAst.parent.node.content) {
            oldAst.parent.node.content.children.splice(
              _index,
              1,
              newAst
            );
          } else if (oldAst.node.nodeType == "document") {
            oldAst.node.content.children = [newAst];
          }
        },
        replaceSelBySel(ast, selector2, replacer2, strictSequence, parseOptions, expando = "g123o456g789o") {
          if (ast.node) {
            ast = ast.node;
          }
          const { nodePathList, matchWildCardList } = core$2.getAstsBySelector(
            ast,
            selector2,
            {
              strictSequence,
              deep: "nn",
              parseOptions: this.parseOptions || parseOptions,
              expando
            }
          );
          const originReplacer = replacer2;
          nodePathList.forEach((path2, i2) => {
            const extra = matchWildCardList[i2];
            replacer2 = originReplacer;
            if (typeof replacer2 == "function") {
              replacer2 = replacer2(extra, path2);
            }
            if (Object.keys(extra).length > 0 && typeof replacer2 == "string") {
              let newReplacer = replacer2;
              for (let key in extra) {
                if (key.match(/\$\$\$/)) {
                  let key$$$ = key.replace(/\$\$\$/, "");
                  key$$$ == "$" && (key$$$ = "");
                  let join2 = "\n";
                  let wildCardCode = extra[key].map((item) => {
                    let codeStr = "";
                    if (item.key) {
                      if (item.value) {
                        codeStr = `${item.key.content}="${item.value.content}"`;
                      } else {
                        codeStr = item.key.content;
                      }
                    } else if (item.nodeType == "text") {
                      codeStr = item.content.value.content;
                    } else if (item.nodeType == "tag") {
                      codeStr = generate$3(item);
                    }
                    try {
                      const childAst = core$2.buildAstByAstStr(
                        generate$3(item),
                        {},
                        { isProgram: true }
                      );
                      core$2.replaceSelBySel(
                        childAst,
                        selector2,
                        replacer2,
                        strictSequence,
                        parseOptions,
                        expando
                      );
                      codeStr = generate$3(childAst);
                    } catch (e) {
                    }
                    return codeStr;
                  }).join(join2);
                  newReplacer = newReplacer.replace(
                    "$$$" + key$$$,
                    wildCardCode
                  );
                } else {
                  let wildCardCode = extra[key][0].value;
                  key == "0" && (key = "");
                  newReplacer = newReplacer.replace(new RegExp(`\\$_\\$${key}`, "g"), wildCardCode);
                }
              }
              core$2.replace(path2, newReplacer);
            } else {
              core$2.replace(path2, replacer2);
            }
          });
        },
        replace(oldPath, newReplacer) {
          let parentContent, index, isDoc, newNodes;
          if (oldPath.node.nodeType == "document") {
            isDoc = true;
          } else {
            parentContent = oldPath.parent.node.content.children || [];
            index = parentContent.indexOf(oldPath.node);
          }
          if (!newReplacer) {
            if (index > -1) {
              if (isDoc) {
                oldPath.node.content.children = [];
              } else {
                parentContent.splice(index, 1);
              }
            }
            return;
          } else if (newReplacer.nodeType == "document") {
            newNodes = newReplacer.content.children || [];
          } else if (typeof newReplacer == "string") {
            if (index > -1) {
              newNodes = core$2.buildAstByAstStr(
                newReplacer,
                {},
                { isProgram: true }
              ).content.children;
            }
          } else if (newReplacer[0] && newReplacer[0].nodePath) {
            newNodes = [newReplacer.node];
          } else if (newReplacer.type) {
            newNodes = [newReplacer];
          }
          if (isDoc) {
            oldPath.node.content.children = newNodes;
          } else {
            newNodes.forEach((newNode) => {
              newNode.parentRef = oldPath.parent.node;
              parentContent.splice(index, 1, newNode);
            });
          }
        },
        removeAst(ast, selector2, { strictSequence, parseOptions, expando } = {}) {
          if (!ast || typeof ast !== "object") {
            throw new Error("remove failed! first argument mast be object");
          }
          if (!selector2 || typeof selector2 !== "object" && typeof selector2 !== "string" && !Array.isArray(selector2)) {
            throw new Error(
              "remove failed! first argument mast be object、string or string array"
            );
          }
          const { nodePathList } = core$2.getAstsBySelector(ast, selector2, {
            strictSequence,
            parseOptions,
            expando
          });
          nodePathList.forEach((path2) => {
            const parentChildList = path2.parent.node.content.children;
            const index = parentChildList.indexOf(path2.node);
            parentChildList.splice(index, 1);
          });
        },
        remove(ast) {
          try {
            ast.node.parentRef.content.children.forEach((item, index) => {
              if (item == ast.node) {
                ast.node.parentRef.content.children.splice(index, 1);
              }
            });
          } catch (e) {
            throw `remove failed! ${e}`;
          }
        }
      };
      var core_1$1 = core$2;
      var compilerSfc_cjs = {};
      function makeMap(str2, expectsLowerCase) {
        const map2 = /* @__PURE__ */ Object.create(null);
        const list2 = str2.split(",");
        for (let i2 = 0; i2 < list2.length; i2++) {
          map2[list2[i2]] = true;
        }
        return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
      }
      const PatchFlagNames = {
        [
          1
          /* TEXT */
        ]: `TEXT`,
        [
          2
          /* CLASS */
        ]: `CLASS`,
        [
          4
          /* STYLE */
        ]: `STYLE`,
        [
          8
          /* PROPS */
        ]: `PROPS`,
        [
          16
          /* FULL_PROPS */
        ]: `FULL_PROPS`,
        [
          32
          /* HYDRATE_EVENTS */
        ]: `HYDRATE_EVENTS`,
        [
          64
          /* STABLE_FRAGMENT */
        ]: `STABLE_FRAGMENT`,
        [
          128
          /* KEYED_FRAGMENT */
        ]: `KEYED_FRAGMENT`,
        [
          256
          /* UNKEYED_FRAGMENT */
        ]: `UNKEYED_FRAGMENT`,
        [
          512
          /* NEED_PATCH */
        ]: `NEED_PATCH`,
        [
          1024
          /* DYNAMIC_SLOTS */
        ]: `DYNAMIC_SLOTS`,
        [
          2048
          /* DEV_ROOT_FRAGMENT */
        ]: `DEV_ROOT_FRAGMENT`,
        [
          -1
          /* HOISTED */
        ]: `HOISTED`,
        [
          -2
          /* BAIL */
        ]: `BAIL`
      };
      const slotFlagsText = {
        [
          1
          /* STABLE */
        ]: "STABLE",
        [
          2
          /* DYNAMIC */
        ]: "DYNAMIC",
        [
          3
          /* FORWARDED */
        ]: "FORWARDED"
      };
      const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
      const isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED);
      const range = 2;
      function generateCodeFrame(source, start = 0, end = source.length) {
        const lines2 = source.split(/\r?\n/);
        let count = 0;
        const res = [];
        for (let i2 = 0; i2 < lines2.length; i2++) {
          count += lines2[i2].length + 1;
          if (count >= start) {
            for (let j = i2 - range; j <= i2 + range || end > count; j++) {
              if (j < 0 || j >= lines2.length)
                continue;
              const line = j + 1;
              res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines2[j]}`);
              const lineLength = lines2[j].length;
              if (j === i2) {
                const pad2 = start - (count - lineLength) + 1;
                const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
                res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
              } else if (j > i2) {
                if (end > count) {
                  const length = Math.max(Math.min(end - count, lineLength), 1);
                  res.push(`   |  ` + "^".repeat(length));
                }
                count += lineLength + 1;
              }
            }
            break;
          }
        }
        return res.join("\n");
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
      const isBooleanAttr = makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
      const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
      const attrValidationCache = {};
      function isSSRSafeAttrName(name2) {
        if (attrValidationCache.hasOwnProperty(name2)) {
          return attrValidationCache[name2];
        }
        const isUnsafe = unsafeAttrCharRE.test(name2);
        if (isUnsafe) {
          console.error(`unsafe attribute name: ${name2}`);
        }
        return attrValidationCache[name2] = !isUnsafe;
      }
      const propsToAttrMap = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv"
      };
      const isNoUnitNumericStyleProp = makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
      const isKnownAttr = makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
      function normalizeStyle(value) {
        if (isArray$1(value)) {
          const res = {};
          for (let i2 = 0; i2 < value.length; i2++) {
            const item = value[i2];
            const normalized = normalizeStyle(isString$2(item) ? parseStringStyle(item) : item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isObject$2(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:(.+)/;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function stringifyStyle(styles) {
        let ret = "";
        if (!styles) {
          return ret;
        }
        for (const key in styles) {
          const value = styles[key];
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          if (isString$2(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
            ret += `${normalizedKey}:${value};`;
          }
        }
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$2(value)) {
          res = value;
        } else if (isArray$1(value)) {
          for (let i2 = 0; i2 < value.length; i2++) {
            const normalized = normalizeClass(value[i2]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$2(value)) {
          for (const name2 in value) {
            if (value[name2]) {
              res += name2 + " ";
            }
          }
        }
        return res.trim();
      }
      const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
      const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
      const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
      const isHTMLTag = makeMap(HTML_TAGS);
      const isSVGTag = makeMap(SVG_TAGS);
      const isVoidTag = makeMap(VOID_TAGS);
      const escapeRE = /["'&<>]/;
      function escapeHtml(string2) {
        const str2 = "" + string2;
        const match = escapeRE.exec(str2);
        if (!match) {
          return str2;
        }
        let html = "";
        let escaped;
        let index;
        let lastIndex = 0;
        for (index = match.index; index < str2.length; index++) {
          switch (str2.charCodeAt(index)) {
            case 34:
              escaped = "&quot;";
              break;
            case 38:
              escaped = "&amp;";
              break;
            case 39:
              escaped = "&#39;";
              break;
            case 60:
              escaped = "&lt;";
              break;
            case 62:
              escaped = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str2.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escaped;
        }
        return lastIndex !== index ? html + str2.substring(lastIndex, index) : html;
      }
      const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
      function escapeHtmlComment(src2) {
        return src2.replace(commentStripRE, "");
      }
      function looseCompareArrays(a, b2) {
        if (a.length !== b2.length)
          return false;
        let equal2 = true;
        for (let i2 = 0; equal2 && i2 < a.length; i2++) {
          equal2 = looseEqual(a[i2], b2[i2]);
        }
        return equal2;
      }
      function looseEqual(a, b2) {
        if (a === b2)
          return true;
        let aValidType = isDate(a);
        let bValidType = isDate(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a.getTime() === b2.getTime() : false;
        }
        aValidType = isArray$1(a);
        bValidType = isArray$1(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a, b2) : false;
        }
        aValidType = isObject$2(a);
        bValidType = isObject$2(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const toDisplayString = (val) => {
        return val == null ? "" : isObject$2(val) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      const babelParserDefaultPlugins = [
        "bigInt",
        "optionalChaining",
        "nullishCoalescingOperator"
      ];
      const EMPTY_OBJ = browser$1$1.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
      const EMPTY_ARR = browser$1$1.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
      const NOOP = () => {
      };
      const NO = () => false;
      const onRE = /^on[^a-z]/;
      const isOn = (key) => onRE.test(key);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i2 = arr.indexOf(el);
        if (i2 > -1) {
          arr.splice(i2, 1);
        }
      };
      const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
      const isArray$1 = Array.isArray;
      const isMap = (val) => toTypeString(val) === "[object Map]";
      const isSet = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => val instanceof Date;
      const isFunction$1 = (val) => typeof val === "function";
      const isString$2 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$2 = (val) => val !== null && typeof val === "object";
      const isPromise$1 = (val) => {
        return isObject$2(val) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction$1 = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str2) => {
          const hit = cache[str2];
          return hit || (cache[str2] = fn(str2));
        };
      };
      const camelizeRE$1 = /-(\w)/g;
      const camelize$1 = cacheStringFunction$1((str2) => {
        return str2.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction$1((str2) => str2.replace(hyphenateRE, "-$1").toLowerCase());
      const capitalize$2 = cacheStringFunction$1((str2) => str2.charAt(0).toUpperCase() + str2.slice(1));
      const toHandlerKey = cacheStringFunction$1((str2) => str2 ? `on${capitalize$2(str2)}` : ``);
      const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i2 = 0; i2 < fns.length; i2++) {
          fns[i2](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const toNumber = (val) => {
        const n2 = parseFloat(val);
        return isNaN(n2) ? val : n2;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : {});
      };
      var shared_esmBundler = Object.freeze({
        __proto__: null,
        EMPTY_ARR,
        EMPTY_OBJ,
        NO,
        NOOP,
        PatchFlagNames,
        babelParserDefaultPlugins,
        camelize: camelize$1,
        capitalize: capitalize$2,
        def,
        escapeHtml,
        escapeHtmlComment,
        extend,
        generateCodeFrame,
        getGlobalThis,
        hasChanged,
        hasOwn,
        hyphenate,
        invokeArrayFns,
        isArray: isArray$1,
        isBooleanAttr,
        isDate,
        isFunction: isFunction$1,
        isGloballyWhitelisted,
        isHTMLTag,
        isIntegerKey,
        isKnownAttr,
        isMap,
        isModelListener,
        isNoUnitNumericStyleProp,
        isObject: isObject$2,
        isOn,
        isPlainObject,
        isPromise: isPromise$1,
        isReservedProp,
        isSSRSafeAttrName,
        isSVGTag,
        isSet,
        isSpecialBooleanAttr,
        isString: isString$2,
        isSymbol: isSymbol$1,
        isVoidTag,
        looseEqual,
        looseIndexOf,
        makeMap,
        normalizeClass,
        normalizeStyle,
        objectToString: objectToString$1,
        parseStringStyle,
        propsToAttrMap,
        remove,
        slotFlagsText,
        stringifyStyle,
        toDisplayString,
        toHandlerKey,
        toNumber,
        toRawType,
        toTypeString
      });
      function defaultOnError(error2) {
        throw error2;
      }
      function createCompilerError(code2, loc, messages, additionalMessage) {
        const msg = browser$1$1.env.NODE_ENV !== "production" || false ? (messages || errorMessages)[code2] + (additionalMessage || ``) : code2;
        const error2 = new SyntaxError(String(msg));
        error2.code = code2;
        error2.loc = loc;
        return error2;
      }
      const errorMessages = {
        // parse errors
        [
          0
          /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
        ]: "Illegal comment.",
        [
          1
          /* CDATA_IN_HTML_CONTENT */
        ]: "CDATA section is allowed only in XML context.",
        [
          2
          /* DUPLICATE_ATTRIBUTE */
        ]: "Duplicate attribute.",
        [
          3
          /* END_TAG_WITH_ATTRIBUTES */
        ]: "End tag cannot have attributes.",
        [
          4
          /* END_TAG_WITH_TRAILING_SOLIDUS */
        ]: "Illegal '/' in tags.",
        [
          5
          /* EOF_BEFORE_TAG_NAME */
        ]: "Unexpected EOF in tag.",
        [
          6
          /* EOF_IN_CDATA */
        ]: "Unexpected EOF in CDATA section.",
        [
          7
          /* EOF_IN_COMMENT */
        ]: "Unexpected EOF in comment.",
        [
          8
          /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        ]: "Unexpected EOF in script.",
        [
          9
          /* EOF_IN_TAG */
        ]: "Unexpected EOF in tag.",
        [
          10
          /* INCORRECTLY_CLOSED_COMMENT */
        ]: "Incorrectly closed comment.",
        [
          11
          /* INCORRECTLY_OPENED_COMMENT */
        ]: "Incorrectly opened comment.",
        [
          12
          /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
        ]: "Illegal tag name. Use '&lt;' to print '<'.",
        [
          13
          /* MISSING_ATTRIBUTE_VALUE */
        ]: "Attribute value was expected.",
        [
          14
          /* MISSING_END_TAG_NAME */
        ]: "End tag name was expected.",
        [
          15
          /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
        ]: "Whitespace was expected.",
        [
          16
          /* NESTED_COMMENT */
        ]: "Unexpected '<!--' in comment.",
        [
          17
          /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
        ]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [
          18
          /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
        ]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [
          19
          /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
        ]: "Attribute name cannot start with '='.",
        [
          21
          /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
        ]: "'<?' is allowed only in XML context.",
        [
          22
          /* UNEXPECTED_SOLIDUS_IN_TAG */
        ]: "Illegal '/' in tags.",
        // Vue-specific parse errors
        [
          23
          /* X_INVALID_END_TAG */
        ]: "Invalid end tag.",
        [
          24
          /* X_MISSING_END_TAG */
        ]: "Element is missing end tag.",
        [
          25
          /* X_MISSING_INTERPOLATION_END */
        ]: "Interpolation end sign was not found.",
        [
          26
          /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
        ]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        // transform errors
        [
          27
          /* X_V_IF_NO_EXPRESSION */
        ]: `v-if/v-else-if is missing expression.`,
        [
          28
          /* X_V_IF_SAME_KEY */
        ]: `v-if/else branches must use unique keys.`,
        [
          29
          /* X_V_ELSE_NO_ADJACENT_IF */
        ]: `v-else/v-else-if has no adjacent v-if.`,
        [
          30
          /* X_V_FOR_NO_EXPRESSION */
        ]: `v-for is missing expression.`,
        [
          31
          /* X_V_FOR_MALFORMED_EXPRESSION */
        ]: `v-for has invalid expression.`,
        [
          32
          /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
        ]: `<template v-for> key should be placed on the <template> tag.`,
        [
          33
          /* X_V_BIND_NO_EXPRESSION */
        ]: `v-bind is missing expression.`,
        [
          34
          /* X_V_ON_NO_EXPRESSION */
        ]: `v-on is missing expression.`,
        [
          35
          /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
        ]: `Unexpected custom directive on <slot> outlet.`,
        [
          36
          /* X_V_SLOT_MIXED_SLOT_USAGE */
        ]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
        [
          37
          /* X_V_SLOT_DUPLICATE_SLOT_NAMES */
        ]: `Duplicate slot names found. `,
        [
          38
          /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
        ]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
        [
          39
          /* X_V_SLOT_MISPLACED */
        ]: `v-slot can only be used on components or <template> tags.`,
        [
          40
          /* X_V_MODEL_NO_EXPRESSION */
        ]: `v-model is missing expression.`,
        [
          41
          /* X_V_MODEL_MALFORMED_EXPRESSION */
        ]: `v-model value must be a valid JavaScript member expression.`,
        [
          42
          /* X_V_MODEL_ON_SCOPE_VARIABLE */
        ]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
        [
          43
          /* X_INVALID_EXPRESSION */
        ]: `Error parsing JavaScript expression: `,
        [
          44
          /* X_KEEP_ALIVE_INVALID_CHILDREN */
        ]: `<KeepAlive> expects exactly one child component.`,
        // generic errors
        [
          45
          /* X_PREFIX_ID_NOT_SUPPORTED */
        ]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
        [
          46
          /* X_MODULE_MODE_NOT_SUPPORTED */
        ]: `ES module mode is not supported in this build of compiler.`,
        [
          47
          /* X_CACHE_HANDLER_NOT_SUPPORTED */
        ]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
        [
          48
          /* X_SCOPE_ID_NOT_SUPPORTED */
        ]: `"scopeId" option is only supported in module mode.`
      };
      const FRAGMENT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `Fragment` : ``);
      const TELEPORT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `Teleport` : ``);
      const SUSPENSE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `Suspense` : ``);
      const KEEP_ALIVE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `KeepAlive` : ``);
      const BASE_TRANSITION = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `BaseTransition` : ``);
      const OPEN_BLOCK = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `openBlock` : ``);
      const CREATE_BLOCK = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createBlock` : ``);
      const CREATE_VNODE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createVNode` : ``);
      const CREATE_COMMENT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createCommentVNode` : ``);
      const CREATE_TEXT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createTextVNode` : ``);
      const CREATE_STATIC = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createStaticVNode` : ``);
      const RESOLVE_COMPONENT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `resolveComponent` : ``);
      const RESOLVE_DYNAMIC_COMPONENT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `resolveDynamicComponent` : ``);
      const RESOLVE_DIRECTIVE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `resolveDirective` : ``);
      const WITH_DIRECTIVES = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `withDirectives` : ``);
      const RENDER_LIST = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `renderList` : ``);
      const RENDER_SLOT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `renderSlot` : ``);
      const CREATE_SLOTS = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `createSlots` : ``);
      const TO_DISPLAY_STRING = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `toDisplayString` : ``);
      const MERGE_PROPS = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `mergeProps` : ``);
      const TO_HANDLERS = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `toHandlers` : ``);
      const CAMELIZE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `camelize` : ``);
      const CAPITALIZE = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `capitalize` : ``);
      const TO_HANDLER_KEY = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `toHandlerKey` : ``);
      const SET_BLOCK_TRACKING = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `setBlockTracking` : ``);
      const PUSH_SCOPE_ID = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `pushScopeId` : ``);
      const POP_SCOPE_ID = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `popScopeId` : ``);
      const WITH_SCOPE_ID = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `withScopeId` : ``);
      const WITH_CTX = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `withCtx` : ``);
      const UNREF = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `unref` : ``);
      const IS_REF = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `isRef` : ``);
      const helperNameMap = {
        [FRAGMENT]: `Fragment`,
        [TELEPORT]: `Teleport`,
        [SUSPENSE]: `Suspense`,
        [KEEP_ALIVE]: `KeepAlive`,
        [BASE_TRANSITION]: `BaseTransition`,
        [OPEN_BLOCK]: `openBlock`,
        [CREATE_BLOCK]: `createBlock`,
        [CREATE_VNODE]: `createVNode`,
        [CREATE_COMMENT]: `createCommentVNode`,
        [CREATE_TEXT]: `createTextVNode`,
        [CREATE_STATIC]: `createStaticVNode`,
        [RESOLVE_COMPONENT]: `resolveComponent`,
        [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
        [RESOLVE_DIRECTIVE]: `resolveDirective`,
        [WITH_DIRECTIVES]: `withDirectives`,
        [RENDER_LIST]: `renderList`,
        [RENDER_SLOT]: `renderSlot`,
        [CREATE_SLOTS]: `createSlots`,
        [TO_DISPLAY_STRING]: `toDisplayString`,
        [MERGE_PROPS]: `mergeProps`,
        [TO_HANDLERS]: `toHandlers`,
        [CAMELIZE]: `camelize`,
        [CAPITALIZE]: `capitalize`,
        [TO_HANDLER_KEY]: `toHandlerKey`,
        [SET_BLOCK_TRACKING]: `setBlockTracking`,
        [PUSH_SCOPE_ID]: `pushScopeId`,
        [POP_SCOPE_ID]: `popScopeId`,
        [WITH_SCOPE_ID]: `withScopeId`,
        [WITH_CTX]: `withCtx`,
        [UNREF]: `unref`,
        [IS_REF]: `isRef`
      };
      function registerRuntimeHelpers(helpers2) {
        Object.getOwnPropertySymbols(helpers2).forEach((s) => {
          helperNameMap[s] = helpers2[s];
        });
      }
      const locStub = {
        source: "",
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 }
      };
      function createRoot(children, loc = locStub) {
        return {
          type: 0,
          children,
          helpers: [],
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: void 0,
          loc
        };
      }
      function createVNodeCall(context, tag2, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {
        if (context) {
          if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(CREATE_BLOCK);
          } else {
            context.helper(CREATE_VNODE);
          }
          if (directives) {
            context.helper(WITH_DIRECTIVES);
          }
        }
        return {
          type: 13,
          tag: tag2,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          loc
        };
      }
      function createArrayExpression(elements, loc = locStub) {
        return {
          type: 17,
          loc,
          elements
        };
      }
      function createObjectExpression(properties, loc = locStub) {
        return {
          type: 15,
          loc,
          properties
        };
      }
      function createObjectProperty(key, value) {
        return {
          type: 16,
          loc: locStub,
          key: isString$2(key) ? createSimpleExpression(key, true) : key,
          value
        };
      }
      function createSimpleExpression(content, isStatic, loc = locStub, constType = 0) {
        return {
          type: 4,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 : constType
        };
      }
      function createInterpolation(content, loc) {
        return {
          type: 5,
          loc,
          content: isString$2(content) ? createSimpleExpression(content, false, loc) : content
        };
      }
      function createCompoundExpression(children, loc = locStub) {
        return {
          type: 8,
          loc,
          children
        };
      }
      function createCallExpression(callee, args = [], loc = locStub) {
        return {
          type: 14,
          loc,
          callee,
          arguments: args
        };
      }
      function createFunctionExpression(params, returns = void 0, newline2 = false, isSlot = false, loc = locStub) {
        return {
          type: 18,
          params,
          returns,
          newline: newline2,
          isSlot,
          loc
        };
      }
      function createConditionalExpression(test, consequent, alternate, newline2 = true) {
        return {
          type: 19,
          test,
          consequent,
          alternate,
          newline: newline2,
          loc: locStub
        };
      }
      function createCacheExpression(index, value, isVNode = false) {
        return {
          type: 20,
          index,
          value,
          isVNode,
          loc: locStub
        };
      }
      function createBlockStatement(body) {
        return {
          type: 21,
          body,
          loc: locStub
        };
      }
      function createTemplateLiteral(elements) {
        return {
          type: 22,
          elements,
          loc: locStub
        };
      }
      function createIfStatement(test, consequent, alternate) {
        return {
          type: 23,
          test,
          consequent,
          alternate,
          loc: locStub
        };
      }
      function createAssignmentExpression(left, right) {
        return {
          type: 24,
          left,
          right,
          loc: locStub
        };
      }
      function createSequenceExpression(expressions) {
        return {
          type: 25,
          expressions,
          loc: locStub
        };
      }
      function createReturnStatement(returns) {
        return {
          type: 26,
          returns,
          loc: locStub
        };
      }
      const isStaticExp = (p) => p.type === 4 && p.isStatic;
      const isBuiltInType = (tag2, expected) => tag2 === expected || tag2 === hyphenate(expected);
      function isCoreComponent(tag2) {
        if (isBuiltInType(tag2, "Teleport")) {
          return TELEPORT;
        } else if (isBuiltInType(tag2, "Suspense")) {
          return SUSPENSE;
        } else if (isBuiltInType(tag2, "KeepAlive")) {
          return KEEP_ALIVE;
        } else if (isBuiltInType(tag2, "BaseTransition")) {
          return BASE_TRANSITION;
        }
      }
      const nonIdentifierRE = /^\d|[^\$\w]/;
      const isSimpleIdentifier = (name2) => !nonIdentifierRE.test(name2);
      const memberExpRE = /^[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*(?:\s*\.\s*[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*|\[[^\]]+\])*$/;
      const isMemberExpression = (path2) => {
        if (!path2)
          return false;
        return memberExpRE.test(path2.trim());
      };
      function getInnerRange(loc, offset, length) {
        const source = loc.source.substr(offset, length);
        const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
        };
        if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
        }
        return newLoc;
      }
      function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
        return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
      }
      function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
        let linesCount = 0;
        let lastNewLinePos = -1;
        for (let i2 = 0; i2 < numberOfCharacters; i2++) {
          if (source.charCodeAt(i2) === 10) {
            linesCount++;
            lastNewLinePos = i2;
          }
        }
        pos.offset += numberOfCharacters;
        pos.line += linesCount;
        pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
        return pos;
      }
      function assert(condition, msg) {
        if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
        }
      }
      function findDir(node2, name2, allowEmpty = false) {
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const p = node2.props[i2];
          if (p.type === 7 && (allowEmpty || p.exp) && (isString$2(name2) ? p.name === name2 : name2.test(p.name))) {
            return p;
          }
        }
      }
      function findProp(node2, name2, dynamicOnly = false, allowEmpty = false) {
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const p = node2.props[i2];
          if (p.type === 6) {
            if (dynamicOnly)
              continue;
            if (p.name === name2 && (p.value || allowEmpty)) {
              return p;
            }
          } else if (p.name === "bind" && (p.exp || allowEmpty) && isBindKey(p.arg, name2)) {
            return p;
          }
        }
      }
      function isBindKey(arg, name2) {
        return !!(arg && isStaticExp(arg) && arg.content === name2);
      }
      function hasDynamicKeyVBind(node2) {
        return node2.props.some(
          (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
          p.arg.type !== 4 || // v-bind:[_ctx.foo]
          !p.arg.isStatic)
          // v-bind:[foo]
        );
      }
      function isText(node2) {
        return node2.type === 5 || node2.type === 2;
      }
      function isVSlot(p) {
        return p.type === 7 && p.name === "slot";
      }
      function isTemplateNode(node2) {
        return node2.type === 1 && node2.tagType === 3;
      }
      function isSlotOutlet(node2) {
        return node2.type === 1 && node2.tagType === 2;
      }
      function injectProp(node2, prop, context) {
        let propsWithInjection;
        const props = node2.type === 13 ? node2.props : node2.arguments[2];
        if (props == null || isString$2(props)) {
          propsWithInjection = createObjectExpression([prop]);
        } else if (props.type === 14) {
          const first = props.arguments[0];
          if (!isString$2(first) && first.type === 15) {
            first.properties.unshift(prop);
          } else {
            if (props.callee === TO_HANDLERS) {
              propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                createObjectExpression([prop]),
                props
              ]);
            } else {
              props.arguments.unshift(createObjectExpression([prop]));
            }
          }
          !propsWithInjection && (propsWithInjection = props);
        } else if (props.type === 15) {
          let alreadyExists = false;
          if (prop.key.type === 4) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
          }
          if (!alreadyExists) {
            props.properties.unshift(prop);
          }
          propsWithInjection = props;
        } else {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        }
        if (node2.type === 13) {
          node2.props = propsWithInjection;
        } else {
          node2.arguments[2] = propsWithInjection;
        }
      }
      function toValidAssetId(name2, type2) {
        return `_${type2}_${name2.replace(/[^\w]/g, "_")}`;
      }
      function hasScopeRef(node2, ids) {
        if (!node2 || Object.keys(ids).length === 0) {
          return false;
        }
        switch (node2.type) {
          case 1:
            for (let i2 = 0; i2 < node2.props.length; i2++) {
              const p = node2.props[i2];
              if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                return true;
              }
            }
            return node2.children.some((c) => hasScopeRef(c, ids));
          case 11:
            if (hasScopeRef(node2.source, ids)) {
              return true;
            }
            return node2.children.some((c) => hasScopeRef(c, ids));
          case 9:
            return node2.branches.some((b2) => hasScopeRef(b2, ids));
          case 10:
            if (hasScopeRef(node2.condition, ids)) {
              return true;
            }
            return node2.children.some((c) => hasScopeRef(c, ids));
          case 4:
            return !node2.isStatic && isSimpleIdentifier(node2.content) && !!ids[node2.content];
          case 8:
            return node2.children.some((c) => isObject$2(c) && hasScopeRef(c, ids));
          case 5:
          case 12:
            return hasScopeRef(node2.content, ids);
          case 2:
          case 3:
            return false;
          default:
            return false;
        }
      }
      const decodeRE = /&(gt|lt|amp|apos|quot);/g;
      const decodeMap = {
        gt: ">",
        lt: "<",
        amp: "&",
        apos: "'",
        quot: '"'
      };
      const defaultParserOptions = {
        delimiters: [`{{`, `}}`],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: NO,
        isPreTag: NO,
        isCustomElement: NO,
        decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
        onError: defaultOnError,
        comments: false
      };
      function baseParse(content, options2 = {}) {
        const context = createParserContext(content, options2);
        const start = getCursor(context);
        return createRoot(parseChildren(context, 0, []), getSelection(context, start));
      }
      function createParserContext(content, rawOptions) {
        const options2 = extend({}, defaultParserOptions);
        for (const key in rawOptions) {
          options2[key] = rawOptions[key] || defaultParserOptions[key];
        }
        return {
          options: options2,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false
        };
      }
      function parseChildren(context, mode, ancestors) {
        const parent = last(ancestors);
        const ns = parent ? parent.ns : 0;
        const nodes = [];
        while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node2 = void 0;
          if (mode === 0 || mode === 1) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
              node2 = parseInterpolation(context, mode);
            } else if (mode === 0 && s[0] === "<") {
              if (s.length === 1) {
                emitError(context, 5, 1);
              } else if (s[1] === "!") {
                if (startsWith(s, "<!--")) {
                  node2 = parseComment(context);
                } else if (startsWith(s, "<!DOCTYPE")) {
                  node2 = parseBogusComment(context);
                } else if (startsWith(s, "<![CDATA[")) {
                  if (ns !== 0) {
                    node2 = parseCDATA(context, ancestors);
                  } else {
                    emitError(
                      context,
                      1
                      /* CDATA_IN_HTML_CONTENT */
                    );
                    node2 = parseBogusComment(context);
                  }
                } else {
                  emitError(
                    context,
                    11
                    /* INCORRECTLY_OPENED_COMMENT */
                  );
                  node2 = parseBogusComment(context);
                }
              } else if (s[1] === "/") {
                if (s.length === 2) {
                  emitError(context, 5, 2);
                } else if (s[2] === ">") {
                  emitError(context, 14, 2);
                  advanceBy(context, 3);
                  continue;
                } else if (/[a-z]/i.test(s[2])) {
                  emitError(
                    context,
                    23
                    /* X_INVALID_END_TAG */
                  );
                  parseTag(context, 1, parent);
                  continue;
                } else {
                  emitError(context, 12, 2);
                  node2 = parseBogusComment(context);
                }
              } else if (/[a-z]/i.test(s[1])) {
                node2 = parseElement(context, ancestors);
              } else if (s[1] === "?") {
                emitError(context, 21, 1);
                node2 = parseBogusComment(context);
              } else {
                emitError(context, 12, 1);
              }
            }
          }
          if (!node2) {
            node2 = parseText(context, mode);
          }
          if (isArray$1(node2)) {
            for (let i2 = 0; i2 < node2.length; i2++) {
              pushNode(nodes, node2[i2]);
            }
          } else {
            pushNode(nodes, node2);
          }
        }
        let removedWhitespace = false;
        if (mode !== 2 && mode !== 1) {
          for (let i2 = 0; i2 < nodes.length; i2++) {
            const node2 = nodes[i2];
            if (!context.inPre && node2.type === 2) {
              if (!/[^\t\r\n\f ]/.test(node2.content)) {
                const prev = nodes[i2 - 1];
                const next = nodes[i2 + 1];
                if (!prev || !next || prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node2.content)) {
                  removedWhitespace = true;
                  nodes[i2] = null;
                } else {
                  node2.content = " ";
                }
              } else {
                node2.content = node2.content.replace(/[\t\r\n\f ]+/g, " ");
              }
            }
            if (!(browser$1$1.env.NODE_ENV !== "production") && node2.type === 3 && !context.options.comments) {
              removedWhitespace = true;
              nodes[i2] = null;
            }
          }
          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            const first = nodes[0];
            if (first && first.type === 2) {
              first.content = first.content.replace(/^\r?\n/, "");
            }
          }
        }
        return removedWhitespace ? nodes.filter(Boolean) : nodes;
      }
      function pushNode(nodes, node2) {
        if (node2.type === 2) {
          const prev = last(nodes);
          if (prev && prev.type === 2 && prev.loc.end.offset === node2.loc.start.offset) {
            prev.content += node2.content;
            prev.loc.end = node2.loc.end;
            prev.loc.source += node2.loc.source;
            return;
          }
        }
        nodes.push(node2);
      }
      function parseCDATA(context, ancestors) {
        advanceBy(context, 9);
        const nodes = parseChildren(context, 3, ancestors);
        if (context.source.length === 0) {
          emitError(
            context,
            6
            /* EOF_IN_CDATA */
          );
        } else {
          advanceBy(context, 3);
        }
        return nodes;
      }
      function parseComment(context) {
        const start = getCursor(context);
        let content;
        const match = /--(\!)?>/.exec(context.source);
        if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(
            context,
            7
            /* EOF_IN_COMMENT */
          );
        } else {
          if (match.index <= 3) {
            emitError(
              context,
              0
              /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
            );
          }
          if (match[1]) {
            emitError(
              context,
              10
              /* INCORRECTLY_CLOSED_COMMENT */
            );
          }
          content = context.source.slice(4, match.index);
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
              emitError(
                context,
                16
                /* NESTED_COMMENT */
              );
            }
            prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseBogusComment(context) {
        const start = getCursor(context);
        const contentStart = context.source[1] === "?" ? 1 : 2;
        let content;
        const closeIndex = context.source.indexOf(">");
        if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
        } else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseElement(context, ancestors) {
        const wasInPre = context.inPre;
        const wasInVPre = context.inVPre;
        const parent = last(ancestors);
        const element = parseTag(context, 0, parent);
        const isPreBoundary = context.inPre && !wasInPre;
        const isVPreBoundary = context.inVPre && !wasInVPre;
        if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          return element;
        }
        ancestors.push(element);
        const mode = context.options.getTextMode(element, parent);
        const children = parseChildren(context, mode, ancestors);
        ancestors.pop();
        element.children = children;
        if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, 1, parent);
        } else {
          emitError(context, 24, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
            const first = children[0];
            if (first && startsWith(first.loc.source, "<!--")) {
              emitError(
                context,
                8
                /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
              );
            }
          }
        }
        element.loc = getSelection(context, element.loc.start);
        if (isPreBoundary) {
          context.inPre = false;
        }
        if (isVPreBoundary) {
          context.inVPre = false;
        }
        return element;
      }
      const isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
      function parseTag(context, type2, parent) {
        const start = getCursor(context);
        const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
        const tag2 = match[1];
        const ns = context.options.getNamespace(tag2, parent);
        advanceBy(context, match[0].length);
        advanceSpaces(context);
        const cursor = getCursor(context);
        const currentSource = context.source;
        let props = parseAttributes(context, type2);
        if (context.options.isPreTag(tag2)) {
          context.inPre = true;
        }
        if (!context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
          context.inVPre = true;
          extend(context, cursor);
          context.source = currentSource;
          props = parseAttributes(context, type2).filter((p) => p.name !== "v-pre");
        }
        let isSelfClosing = false;
        if (context.source.length === 0) {
          emitError(
            context,
            9
            /* EOF_IN_TAG */
          );
        } else {
          isSelfClosing = startsWith(context.source, "/>");
          if (type2 === 1 && isSelfClosing) {
            emitError(
              context,
              4
              /* END_TAG_WITH_TRAILING_SOLIDUS */
            );
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
        }
        let tagType = 0;
        const options2 = context.options;
        if (!context.inVPre && !options2.isCustomElement(tag2)) {
          const hasVIs = props.some((p) => p.type === 7 && p.name === "is");
          if (options2.isNativeTag && !hasVIs) {
            if (!options2.isNativeTag(tag2))
              tagType = 1;
          } else if (hasVIs || isCoreComponent(tag2) || options2.isBuiltInComponent && options2.isBuiltInComponent(tag2) || /^[A-Z]/.test(tag2) || tag2 === "component") {
            tagType = 1;
          }
          if (tag2 === "slot") {
            tagType = 2;
          } else if (tag2 === "template" && props.some((p) => {
            return p.type === 7 && isSpecialTemplateDirective(p.name);
          })) {
            tagType = 3;
          }
        }
        return {
          type: 1,
          ns,
          tag: tag2,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: void 0
          // to be created during transform phase
        };
      }
      function parseAttributes(context, type2) {
        const props = [];
        const attributeNames = /* @__PURE__ */ new Set();
        while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
          if (startsWith(context.source, "/")) {
            emitError(
              context,
              22
              /* UNEXPECTED_SOLIDUS_IN_TAG */
            );
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
          }
          if (type2 === 1) {
            emitError(
              context,
              3
              /* END_TAG_WITH_ATTRIBUTES */
            );
          }
          const attr = parseAttribute(context, attributeNames);
          if (type2 === 0) {
            props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(
              context,
              15
              /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
            );
          }
          advanceSpaces(context);
        }
        return props;
      }
      function parseAttribute(context, nameSet) {
        const start = getCursor(context);
        const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
        const name2 = match[0];
        if (nameSet.has(name2)) {
          emitError(
            context,
            2
            /* DUPLICATE_ATTRIBUTE */
          );
        }
        nameSet.add(name2);
        if (name2[0] === "=") {
          emitError(
            context,
            19
            /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
          );
        }
        {
          const pattern = /["'<]/g;
          let m;
          while (m = pattern.exec(name2)) {
            emitError(context, 17, m.index);
          }
        }
        advanceBy(context, name2.length);
        let value = void 0;
        if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
            emitError(
              context,
              13
              /* MISSING_ATTRIBUTE_VALUE */
            );
          }
        }
        const loc = getSelection(context, start);
        if (!context.inVPre && /^(v-|:|@|#)/.test(name2)) {
          const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name2);
          const dirName = match2[1] || (startsWith(name2, ":") ? "bind" : startsWith(name2, "@") ? "on" : "slot");
          let arg;
          if (match2[2]) {
            const isSlot = dirName === "slot";
            const startOffset = name2.lastIndexOf(match2[2]);
            const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
            let content = match2[2];
            let isStatic = true;
            if (content.startsWith("[")) {
              isStatic = false;
              if (!content.endsWith("]")) {
                emitError(
                  context,
                  26
                  /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
                );
              }
              content = content.substr(1, content.length - 2);
            } else if (isSlot) {
              content += match2[3] || "";
            }
            arg = {
              type: 4,
              content,
              isStatic,
              constType: isStatic ? 3 : 0,
              loc: loc2
            };
          }
          if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
          }
          return {
            type: 7,
            name: dirName,
            exp: value && {
              type: 4,
              content: value.content,
              isStatic: false,
              // Treat as non-constant by default. This can be potentially set to
              // other values by `transformExpression` to make it eligible for hoisting.
              constType: 0,
              loc: value.loc
            },
            arg,
            modifiers: match2[3] ? match2[3].substr(1).split(".") : [],
            loc
          };
        }
        return {
          type: 6,
          name: name2,
          value: value && {
            type: 2,
            content: value.content,
            loc: value.loc
          },
          loc
        };
      }
      function parseAttributeValue(context) {
        const start = getCursor(context);
        let content;
        const quote = context.source[0];
        const isQuoted = quote === `"` || quote === `'`;
        if (isQuoted) {
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
            content = parseTextData(
              context,
              context.source.length,
              4
              /* ATTRIBUTE_VALUE */
            );
          } else {
            content = parseTextData(
              context,
              endIndex,
              4
              /* ATTRIBUTE_VALUE */
            );
            advanceBy(context, 1);
          }
        } else {
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
            return void 0;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while (m = unexpectedChars.exec(match[0])) {
            emitError(context, 18, m.index);
          }
          content = parseTextData(
            context,
            match[0].length,
            4
            /* ATTRIBUTE_VALUE */
          );
        }
        return { content, isQuoted, loc: getSelection(context, start) };
      }
      function parseInterpolation(context, mode) {
        const [open, close] = context.options.delimiters;
        const closeIndex = context.source.indexOf(close, open.length);
        if (closeIndex === -1) {
          emitError(
            context,
            25
            /* X_MISSING_INTERPOLATION_END */
          );
          return void 0;
        }
        const start = getCursor(context);
        advanceBy(context, open.length);
        const innerStart = getCursor(context);
        const innerEnd = getCursor(context);
        const rawContentLength = closeIndex - open.length;
        const rawContent = context.source.slice(0, rawContentLength);
        const preTrimContent = parseTextData(context, rawContentLength, mode);
        const content = preTrimContent.trim();
        const startOffset = preTrimContent.indexOf(content);
        if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
        }
        const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
        advancePositionWithMutation(innerEnd, rawContent, endOffset);
        advanceBy(context, close.length);
        return {
          type: 5,
          content: {
            type: 4,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0,
            content,
            loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
        };
      }
      function parseText(context, mode) {
        const endTokens = ["<", context.options.delimiters[0]];
        if (mode === 3) {
          endTokens.push("]]>");
        }
        let endIndex = context.source.length;
        for (let i2 = 0; i2 < endTokens.length; i2++) {
          const index = context.source.indexOf(endTokens[i2], 1);
          if (index !== -1 && endIndex > index) {
            endIndex = index;
          }
        }
        const start = getCursor(context);
        const content = parseTextData(context, endIndex, mode);
        return {
          type: 2,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseTextData(context, length, mode) {
        const rawText = context.source.slice(0, length);
        advanceBy(context, length);
        if (mode === 2 || mode === 3 || rawText.indexOf("&") === -1) {
          return rawText;
        } else {
          return context.options.decodeEntities(
            rawText,
            mode === 4
            /* ATTRIBUTE_VALUE */
          );
        }
      }
      function getCursor(context) {
        const { column, line, offset } = context;
        return { column, line, offset };
      }
      function getSelection(context, start, end) {
        end = end || getCursor(context);
        return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
        };
      }
      function last(xs) {
        return xs[xs.length - 1];
      }
      function startsWith(source, searchString) {
        return source.startsWith(searchString);
      }
      function advanceBy(context, numberOfCharacters) {
        const { source } = context;
        advancePositionWithMutation(context, source, numberOfCharacters);
        context.source = source.slice(numberOfCharacters);
      }
      function advanceSpaces(context) {
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
          advanceBy(context, match[0].length);
        }
      }
      function getNewPosition(context, start, numberOfCharacters) {
        return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
      }
      function emitError(context, code2, offset, loc = getCursor(context)) {
        if (offset) {
          loc.offset += offset;
          loc.column += offset;
        }
        context.options.onError(createCompilerError(code2, {
          start: loc,
          end: loc,
          source: ""
        }));
      }
      function isEnd(context, mode, ancestors) {
        const s = context.source;
        switch (mode) {
          case 0:
            if (startsWith(s, "</")) {
              for (let i2 = ancestors.length - 1; i2 >= 0; --i2) {
                if (startsWithEndTagOpen(s, ancestors[i2].tag)) {
                  return true;
                }
              }
            }
            break;
          case 1:
          case 2: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
              return true;
            }
            break;
          }
          case 3:
            if (startsWith(s, "]]>")) {
              return true;
            }
            break;
        }
        return !s;
      }
      function startsWithEndTagOpen(source, tag2) {
        return startsWith(source, "</") && source.substr(2, tag2.length).toLowerCase() === tag2.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag2.length] || ">");
      }
      function hoistStatic(root2, context) {
        walk$2(
          root2,
          context,
          // Root node is unfortunately non-hoistable due to potential parent
          // fallthrough attributes.
          isSingleElementRoot(root2, root2.children[0])
        );
      }
      function isSingleElementRoot(root2, child) {
        const { children } = root2;
        return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
      }
      function walk$2(node2, context, doNotHoistNode = false) {
        let hasHoistedNode = false;
        let canStringify = true;
        const { children } = node2;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.type === 1 && child.tagType === 0) {
            const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
            if (constantType > 0) {
              if (constantType < 3) {
                canStringify = false;
              }
              if (constantType >= 2) {
                child.codegenNode.patchFlag = -1 + (browser$1$1.env.NODE_ENV !== "production" ? ` /* HOISTED */` : ``);
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
                continue;
              }
            } else {
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13) {
                const flag = getPatchFlag(codegenNode);
                if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                  const props = getNodeProps(child);
                  if (props) {
                    codegenNode.props = context.hoist(props);
                  }
                }
              }
            }
          } else if (child.type === 12) {
            const contentType = getConstantType(child.content, context);
            if (contentType > 0) {
              if (contentType < 3) {
                canStringify = false;
              }
              if (contentType >= 2) {
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
              }
            }
          }
          if (child.type === 1) {
            const isComponent = child.tagType === 1;
            if (isComponent) {
              context.scopes.vSlot++;
            }
            walk$2(child, context);
            if (isComponent) {
              context.scopes.vSlot--;
            }
          } else if (child.type === 11) {
            walk$2(child, context, child.children.length === 1);
          } else if (child.type === 9) {
            for (let i3 = 0; i3 < child.branches.length; i3++) {
              walk$2(child.branches[i3], context, child.branches[i3].children.length === 1);
            }
          }
        }
        if (canStringify && hasHoistedNode && context.transformHoist) {
          context.transformHoist(children, context, node2);
        }
      }
      function getConstantType(node2, context) {
        const { constantCache } = context;
        switch (node2.type) {
          case 1:
            if (node2.tagType !== 0) {
              return 0;
            }
            const cached = constantCache.get(node2);
            if (cached !== void 0) {
              return cached;
            }
            const codegenNode = node2.codegenNode;
            if (codegenNode.type !== 13) {
              return 0;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
              let returnType2 = 3;
              const generatedPropsType = getGeneratedPropsConstantType(node2, context);
              if (generatedPropsType === 0) {
                constantCache.set(
                  node2,
                  0
                  /* NOT_CONSTANT */
                );
                return 0;
              }
              if (generatedPropsType < returnType2) {
                returnType2 = generatedPropsType;
              }
              for (let i2 = 0; i2 < node2.children.length; i2++) {
                const childType = getConstantType(node2.children[i2], context);
                if (childType === 0) {
                  constantCache.set(
                    node2,
                    0
                    /* NOT_CONSTANT */
                  );
                  return 0;
                }
                if (childType < returnType2) {
                  returnType2 = childType;
                }
              }
              if (returnType2 > 1) {
                for (let i2 = 0; i2 < node2.props.length; i2++) {
                  const p = node2.props[i2];
                  if (p.type === 7 && p.name === "bind" && p.exp) {
                    const expType = getConstantType(p.exp, context);
                    if (expType === 0) {
                      constantCache.set(
                        node2,
                        0
                        /* NOT_CONSTANT */
                      );
                      return 0;
                    }
                    if (expType < returnType2) {
                      returnType2 = expType;
                    }
                  }
                }
              }
              if (codegenNode.isBlock) {
                context.removeHelper(OPEN_BLOCK);
                context.removeHelper(CREATE_BLOCK);
                codegenNode.isBlock = false;
                context.helper(CREATE_VNODE);
              }
              constantCache.set(node2, returnType2);
              return returnType2;
            } else {
              constantCache.set(
                node2,
                0
                /* NOT_CONSTANT */
              );
              return 0;
            }
          case 2:
          case 3:
            return 3;
          case 9:
          case 11:
          case 10:
            return 0;
          case 5:
          case 12:
            return getConstantType(node2.content, context);
          case 4:
            return node2.constType;
          case 8:
            let returnType = 3;
            for (let i2 = 0; i2 < node2.children.length; i2++) {
              const child = node2.children[i2];
              if (isString$2(child) || isSymbol$1(child)) {
                continue;
              }
              const childType = getConstantType(child, context);
              if (childType === 0) {
                return 0;
              } else if (childType < returnType) {
                returnType = childType;
              }
            }
            return returnType;
          default:
            return 0;
        }
      }
      function getGeneratedPropsConstantType(node2, context) {
        let returnType = 3;
        const props = getNodeProps(node2);
        if (props && props.type === 15) {
          const { properties } = props;
          for (let i2 = 0; i2 < properties.length; i2++) {
            const { key, value } = properties[i2];
            const keyType = getConstantType(key, context);
            if (keyType === 0) {
              return keyType;
            }
            if (keyType < returnType) {
              returnType = keyType;
            }
            if (value.type !== 4) {
              return 0;
            }
            const valueType = getConstantType(value, context);
            if (valueType === 0) {
              return valueType;
            }
            if (valueType < returnType) {
              returnType = valueType;
            }
          }
        }
        return returnType;
      }
      function getNodeProps(node2) {
        const codegenNode = node2.codegenNode;
        if (codegenNode.type === 13) {
          return codegenNode.props;
        }
      }
      function getPatchFlag(node2) {
        const flag = node2.patchFlag;
        return flag ? parseInt(flag, 10) : void 0;
      }
      function createTransformContext(root2, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError }) {
        const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
        const context = {
          // options
          selfName: nameMatch && capitalize$2(camelize$1(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic: hoistStatic2,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          // state
          root: root2,
          helpers: /* @__PURE__ */ new Map(),
          components: /* @__PURE__ */ new Set(),
          directives: /* @__PURE__ */ new Set(),
          hoists: [],
          imports: [],
          constantCache: /* @__PURE__ */ new Map(),
          temps: 0,
          cached: 0,
          identifiers: /* @__PURE__ */ Object.create(null),
          scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
          },
          parent: null,
          currentNode: root2,
          childIndex: 0,
          // methods
          helper(name2) {
            const count = context.helpers.get(name2) || 0;
            context.helpers.set(name2, count + 1);
            return name2;
          },
          removeHelper(name2) {
            const count = context.helpers.get(name2);
            if (count) {
              const currentCount = count - 1;
              if (!currentCount) {
                context.helpers.delete(name2);
              } else {
                context.helpers.set(name2, currentCount);
              }
            }
          },
          helperString(name2) {
            return `_${helperNameMap[context.helper(name2)]}`;
          },
          replaceNode(node2) {
            if (browser$1$1.env.NODE_ENV !== "production") {
              if (!context.currentNode) {
                throw new Error(`Node being replaced is already removed.`);
              }
              if (!context.parent) {
                throw new Error(`Cannot replace root node.`);
              }
            }
            context.parent.children[context.childIndex] = context.currentNode = node2;
          },
          removeNode(node2) {
            if (browser$1$1.env.NODE_ENV !== "production" && !context.parent) {
              throw new Error(`Cannot remove root node.`);
            }
            const list2 = context.parent.children;
            const removalIndex = node2 ? list2.indexOf(node2) : context.currentNode ? context.childIndex : -1;
            if (browser$1$1.env.NODE_ENV !== "production" && removalIndex < 0) {
              throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node2 || node2 === context.currentNode) {
              context.currentNode = null;
              context.onNodeRemoved();
            } else {
              if (context.childIndex > removalIndex) {
                context.childIndex--;
                context.onNodeRemoved();
              }
            }
            context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => {
          },
          addIdentifiers(exp2) {
          },
          removeIdentifiers(exp2) {
          },
          hoist(exp2) {
            context.hoists.push(exp2);
            const identifier = createSimpleExpression(
              `_hoisted_${context.hoists.length}`,
              false,
              exp2.loc,
              2
              /* CAN_HOIST */
            );
            identifier.hoisted = exp2;
            return identifier;
          },
          cache(exp2, isVNode = false) {
            return createCacheExpression(++context.cached, exp2, isVNode);
          }
        };
        return context;
      }
      function transform(root2, options2) {
        const context = createTransformContext(root2, options2);
        traverseNode(root2, context);
        if (options2.hoistStatic) {
          hoistStatic(root2, context);
        }
        if (!options2.ssr) {
          createRootCodegen(root2, context);
        }
        root2.helpers = [...context.helpers.keys()];
        root2.components = [...context.components];
        root2.directives = [...context.directives];
        root2.imports = context.imports;
        root2.hoists = context.hoists;
        root2.temps = context.temps;
        root2.cached = context.cached;
      }
      function createRootCodegen(root2, context) {
        const { helper, removeHelper } = context;
        const { children } = root2;
        if (children.length === 1) {
          const child = children[0];
          if (isSingleElementRoot(root2, child) && child.codegenNode) {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              if (!codegenNode.isBlock) {
                removeHelper(CREATE_VNODE);
                codegenNode.isBlock = true;
                helper(OPEN_BLOCK);
                helper(CREATE_BLOCK);
              }
            }
            root2.codegenNode = codegenNode;
          } else {
            root2.codegenNode = child;
          }
        } else if (children.length > 1) {
          let patchFlag = 64;
          let patchFlagText = PatchFlagNames[
            64
            /* STABLE_FRAGMENT */
          ];
          if (browser$1$1.env.NODE_ENV !== "production" && children.filter(
            (c) => c.type !== 3
            /* COMMENT */
          ).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${PatchFlagNames[
              2048
              /* DEV_ROOT_FRAGMENT */
            ]}`;
          }
          root2.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root2.children, patchFlag + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true);
        } else
          ;
      }
      function traverseChildren(parent, context) {
        let i2 = 0;
        const nodeRemoved = () => {
          i2--;
        };
        for (; i2 < parent.children.length; i2++) {
          const child = parent.children[i2];
          if (isString$2(child))
            continue;
          context.parent = parent;
          context.childIndex = i2;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
        }
      }
      function traverseNode(node2, context) {
        context.currentNode = node2;
        const { nodeTransforms } = context;
        const exitFns = [];
        for (let i3 = 0; i3 < nodeTransforms.length; i3++) {
          const onExit = nodeTransforms[i3](node2, context);
          if (onExit) {
            if (isArray$1(onExit)) {
              exitFns.push(...onExit);
            } else {
              exitFns.push(onExit);
            }
          }
          if (!context.currentNode) {
            return;
          } else {
            node2 = context.currentNode;
          }
        }
        switch (node2.type) {
          case 3:
            if (!context.ssr) {
              context.helper(CREATE_COMMENT);
            }
            break;
          case 5:
            if (!context.ssr) {
              context.helper(TO_DISPLAY_STRING);
            }
            break;
          case 9:
            for (let i3 = 0; i3 < node2.branches.length; i3++) {
              traverseNode(node2.branches[i3], context);
            }
            break;
          case 10:
          case 11:
          case 1:
          case 0:
            traverseChildren(node2, context);
            break;
        }
        context.currentNode = node2;
        let i2 = exitFns.length;
        while (i2--) {
          exitFns[i2]();
        }
      }
      function createStructuralDirectiveTransform(name2, fn) {
        const matches = isString$2(name2) ? (n2) => n2 === name2 : (n2) => name2.test(n2);
        return (node2, context) => {
          if (node2.type === 1) {
            const { props } = node2;
            if (node2.tagType === 3 && props.some(isVSlot)) {
              return;
            }
            const exitFns = [];
            for (let i2 = 0; i2 < props.length; i2++) {
              const prop = props[i2];
              if (prop.type === 7 && matches(prop.name)) {
                props.splice(i2, 1);
                i2--;
                const onExit = fn(node2, prop, context);
                if (onExit)
                  exitFns.push(onExit);
              }
            }
            return exitFns;
          }
        };
      }
      const PURE_ANNOTATION = `/*#__PURE__*/`;
      function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap: sourceMap2 = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {
        const context = {
          mode,
          prefixIdentifiers,
          sourceMap: sourceMap2,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssr,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: void 0,
          helper(key) {
            return `_${helperNameMap[key]}`;
          },
          push(code2, node2) {
            context.code += code2;
          },
          indent() {
            newline2(++context.indentLevel);
          },
          deindent(withoutNewLine = false) {
            if (withoutNewLine) {
              --context.indentLevel;
            } else {
              newline2(--context.indentLevel);
            }
          },
          newline() {
            newline2(context.indentLevel);
          }
        };
        function newline2(n2) {
          context.push("\n" + `  `.repeat(n2));
        }
        return context;
      }
      function generate$2(ast, options2 = {}) {
        const context = createCodegenContext(ast, options2);
        if (options2.onContextCreated)
          options2.onContextCreated(context);
        const { mode, push: push2, prefixIdentifiers, indent, deindent, newline: newline2, scopeId, ssr } = context;
        const hasHelpers = ast.helpers.length > 0;
        const useWithBlock = !prefixIdentifiers && mode !== "module";
        const preambleContext = context;
        {
          genFunctionPreamble(ast, preambleContext);
        }
        const functionName = ssr ? `ssrRender` : `render`;
        const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
        const signature = args.join(", ");
        {
          push2(`function ${functionName}(${signature}) {`);
        }
        indent();
        if (useWithBlock) {
          push2(`with (_ctx) {`);
          indent();
          if (hasHelpers) {
            push2(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
            push2(`
`);
            newline2();
          }
        }
        if (ast.components.length) {
          genAssets(ast.components, "component", context);
          if (ast.directives.length || ast.temps > 0) {
            newline2();
          }
        }
        if (ast.directives.length) {
          genAssets(ast.directives, "directive", context);
          if (ast.temps > 0) {
            newline2();
          }
        }
        if (ast.temps > 0) {
          push2(`let `);
          for (let i2 = 0; i2 < ast.temps; i2++) {
            push2(`${i2 > 0 ? `, ` : ``}_temp${i2}`);
          }
        }
        if (ast.components.length || ast.directives.length || ast.temps) {
          push2(`
`);
          newline2();
        }
        if (!ssr) {
          push2(`return `);
        }
        if (ast.codegenNode) {
          genNode(ast.codegenNode, context);
        } else {
          push2(`null`);
        }
        if (useWithBlock) {
          deindent();
          push2(`}`);
        }
        deindent();
        push2(`}`);
        return {
          ast,
          code: context.code,
          preamble: ``,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context.map ? context.map.toJSON() : void 0
        };
      }
      function genFunctionPreamble(ast, context) {
        const { ssr, prefixIdentifiers, push: push2, newline: newline2, runtimeModuleName, runtimeGlobalName } = context;
        const VueBinding = runtimeGlobalName;
        const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
        if (ast.helpers.length > 0) {
          {
            push2(`const _Vue = ${VueBinding}
`);
            if (ast.hoists.length) {
              const staticHelpers = [
                CREATE_VNODE,
                CREATE_COMMENT,
                CREATE_TEXT,
                CREATE_STATIC
              ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
              push2(`const { ${staticHelpers} } = _Vue
`);
            }
          }
        }
        genHoists(ast.hoists, context);
        newline2();
        push2(`return `);
      }
      function genAssets(assets, type2, { helper, push: push2, newline: newline2 }) {
        const resolver = helper(type2 === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
        for (let i2 = 0; i2 < assets.length; i2++) {
          let id2 = assets[i2];
          const maybeSelfReference = id2.endsWith("__self");
          if (maybeSelfReference) {
            id2 = id2.slice(0, -6);
          }
          push2(`const ${toValidAssetId(id2, type2)} = ${resolver}(${JSON.stringify(id2)}${maybeSelfReference ? `, true` : ``})`);
          if (i2 < assets.length - 1) {
            newline2();
          }
        }
      }
      function genHoists(hoists, context) {
        if (!hoists.length) {
          return;
        }
        context.pure = true;
        const { push: push2, newline: newline2, helper, scopeId, mode } = context;
        newline2();
        hoists.forEach((exp2, i2) => {
          if (exp2) {
            push2(`const _hoisted_${i2 + 1} = `);
            genNode(exp2, context);
            newline2();
          }
        });
        context.pure = false;
      }
      function isText$1(n2) {
        return isString$2(n2) || n2.type === 4 || n2.type === 2 || n2.type === 5 || n2.type === 8;
      }
      function genNodeListAsArray(nodes, context) {
        const multilines = nodes.length > 3 || browser$1$1.env.NODE_ENV !== "production" && nodes.some((n2) => isArray$1(n2) || !isText$1(n2));
        context.push(`[`);
        multilines && context.indent();
        genNodeList(nodes, context, multilines);
        multilines && context.deindent();
        context.push(`]`);
      }
      function genNodeList(nodes, context, multilines = false, comma2 = true) {
        const { push: push2, newline: newline2 } = context;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node2 = nodes[i2];
          if (isString$2(node2)) {
            push2(node2);
          } else if (isArray$1(node2)) {
            genNodeListAsArray(node2, context);
          } else {
            genNode(node2, context);
          }
          if (i2 < nodes.length - 1) {
            if (multilines) {
              comma2 && push2(",");
              newline2();
            } else {
              comma2 && push2(", ");
            }
          }
        }
      }
      function genNode(node2, context) {
        if (isString$2(node2)) {
          context.push(node2);
          return;
        }
        if (isSymbol$1(node2)) {
          context.push(context.helper(node2));
          return;
        }
        switch (node2.type) {
          case 1:
          case 9:
          case 11:
            browser$1$1.env.NODE_ENV !== "production" && assert(node2.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
            genNode(node2.codegenNode, context);
            break;
          case 2:
            genText(node2, context);
            break;
          case 4:
            genExpression(node2, context);
            break;
          case 5:
            genInterpolation(node2, context);
            break;
          case 12:
            genNode(node2.codegenNode, context);
            break;
          case 8:
            genCompoundExpression(node2, context);
            break;
          case 3:
            genComment(node2, context);
            break;
          case 13:
            genVNodeCall(node2, context);
            break;
          case 14:
            genCallExpression(node2, context);
            break;
          case 15:
            genObjectExpression(node2, context);
            break;
          case 17:
            genArrayExpression(node2, context);
            break;
          case 18:
            genFunctionExpression(node2, context);
            break;
          case 19:
            genConditionalExpression(node2, context);
            break;
          case 20:
            genCacheExpression(node2, context);
            break;
          case 21:
            break;
          case 22:
            break;
          case 23:
            break;
          case 24:
            break;
          case 25:
            break;
          case 26:
            break;
          case 10:
            break;
          default:
            if (browser$1$1.env.NODE_ENV !== "production") {
              assert(false, `unhandled codegen node type: ${node2.type}`);
              const exhaustiveCheck = node2;
              return exhaustiveCheck;
            }
        }
      }
      function genText(node2, context) {
        context.push(JSON.stringify(node2.content), node2);
      }
      function genExpression(node2, context) {
        const { content, isStatic } = node2;
        context.push(isStatic ? JSON.stringify(content) : content, node2);
      }
      function genInterpolation(node2, context) {
        const { push: push2, helper, pure } = context;
        if (pure)
          push2(PURE_ANNOTATION);
        push2(`${helper(TO_DISPLAY_STRING)}(`);
        genNode(node2.content, context);
        push2(`)`);
      }
      function genCompoundExpression(node2, context) {
        for (let i2 = 0; i2 < node2.children.length; i2++) {
          const child = node2.children[i2];
          if (isString$2(child)) {
            context.push(child);
          } else {
            genNode(child, context);
          }
        }
      }
      function genExpressionAsPropertyKey(node2, context) {
        const { push: push2 } = context;
        if (node2.type === 8) {
          push2(`[`);
          genCompoundExpression(node2, context);
          push2(`]`);
        } else if (node2.isStatic) {
          const text = isSimpleIdentifier(node2.content) ? node2.content : JSON.stringify(node2.content);
          push2(text, node2);
        } else {
          push2(`[${node2.content}]`, node2);
        }
      }
      function genComment(node2, context) {
        if (browser$1$1.env.NODE_ENV !== "production") {
          const { push: push2, helper, pure } = context;
          if (pure) {
            push2(PURE_ANNOTATION);
          }
          push2(`${helper(CREATE_COMMENT)}(${JSON.stringify(node2.content)})`, node2);
        }
      }
      function genVNodeCall(node2, context) {
        const { push: push2, helper, pure } = context;
        const { tag: tag2, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node2;
        if (directives) {
          push2(helper(WITH_DIRECTIVES) + `(`);
        }
        if (isBlock) {
          push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
        }
        if (pure) {
          push2(PURE_ANNOTATION);
        }
        push2(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node2);
        genNodeList(genNullableArgs([tag2, props, children, patchFlag, dynamicProps]), context);
        push2(`)`);
        if (isBlock) {
          push2(`)`);
        }
        if (directives) {
          push2(`, `);
          genNode(directives, context);
          push2(`)`);
        }
      }
      function genNullableArgs(args) {
        let i2 = args.length;
        while (i2--) {
          if (args[i2] != null)
            break;
        }
        return args.slice(0, i2 + 1).map((arg) => arg || `null`);
      }
      function genCallExpression(node2, context) {
        const { push: push2, helper, pure } = context;
        const callee = isString$2(node2.callee) ? node2.callee : helper(node2.callee);
        if (pure) {
          push2(PURE_ANNOTATION);
        }
        push2(callee + `(`, node2);
        genNodeList(node2.arguments, context);
        push2(`)`);
      }
      function genObjectExpression(node2, context) {
        const { push: push2, indent, deindent, newline: newline2 } = context;
        const { properties } = node2;
        if (!properties.length) {
          push2(`{}`, node2);
          return;
        }
        const multilines = properties.length > 1 || browser$1$1.env.NODE_ENV !== "production" && properties.some(
          (p) => p.value.type !== 4
          /* SIMPLE_EXPRESSION */
        );
        push2(multilines ? `{` : `{ `);
        multilines && indent();
        for (let i2 = 0; i2 < properties.length; i2++) {
          const { key, value } = properties[i2];
          genExpressionAsPropertyKey(key, context);
          push2(`: `);
          genNode(value, context);
          if (i2 < properties.length - 1) {
            push2(`,`);
            newline2();
          }
        }
        multilines && deindent();
        push2(multilines ? `}` : ` }`);
      }
      function genArrayExpression(node2, context) {
        genNodeListAsArray(node2.elements, context);
      }
      function genFunctionExpression(node2, context) {
        const { push: push2, indent, deindent, scopeId, mode } = context;
        const { params, returns, body, newline: newline2, isSlot } = node2;
        if (isSlot) {
          push2(`_${helperNameMap[WITH_CTX]}(`);
        }
        push2(`(`, node2);
        if (isArray$1(params)) {
          genNodeList(params, context);
        } else if (params) {
          genNode(params, context);
        }
        push2(`) => `);
        if (newline2 || body) {
          push2(`{`);
          indent();
        }
        if (returns) {
          if (newline2) {
            push2(`return `);
          }
          if (isArray$1(returns)) {
            genNodeListAsArray(returns, context);
          } else {
            genNode(returns, context);
          }
        } else if (body) {
          genNode(body, context);
        }
        if (newline2 || body) {
          deindent();
          push2(`}`);
        }
        if (isSlot) {
          push2(`)`);
        }
      }
      function genConditionalExpression(node2, context) {
        const { test, consequent, alternate, newline: needNewline } = node2;
        const { push: push2, indent, deindent, newline: newline2 } = context;
        if (test.type === 4) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push2(`(`);
          genExpression(test, context);
          needsParens && push2(`)`);
        } else {
          push2(`(`);
          genNode(test, context);
          push2(`)`);
        }
        needNewline && indent();
        context.indentLevel++;
        needNewline || push2(` `);
        push2(`? `);
        genNode(consequent, context);
        context.indentLevel--;
        needNewline && newline2();
        needNewline || push2(` `);
        push2(`: `);
        const isNested = alternate.type === 19;
        if (!isNested) {
          context.indentLevel++;
        }
        genNode(alternate, context);
        if (!isNested) {
          context.indentLevel--;
        }
        needNewline && deindent(
          true
          /* without newline */
        );
      }
      function genCacheExpression(node2, context) {
        const { push: push2, helper, indent, deindent, newline: newline2 } = context;
        push2(`_cache[${node2.index}] || (`);
        if (node2.isVNode) {
          indent();
          push2(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline2();
        }
        push2(`_cache[${node2.index}] = `);
        genNode(node2.value, context);
        if (node2.isVNode) {
          push2(`,`);
          newline2();
          push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline2();
          push2(`_cache[${node2.index}]`);
          deindent();
        }
        push2(`)`);
      }
      const prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
      const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
      function validateBrowserExpression(node2, context, asParams = false, asRawStatements = false) {
        const exp2 = node2.content;
        if (!exp2.trim()) {
          return;
        }
        try {
          new Function(asRawStatements ? ` ${exp2} ` : `return ${asParams ? `(${exp2}) => {}` : `(${exp2})`}`);
        } catch (e) {
          let message = e.message;
          const keywordMatch = exp2.replace(stripStringRE, "").match(prohibitedKeywordRE);
          if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
          }
          context.onError(createCompilerError(43, node2.loc, void 0, message));
        }
      }
      const transformExpression = (node2, context) => {
        if (node2.type === 5) {
          node2.content = processExpression(node2.content, context);
        } else if (node2.type === 1) {
          for (let i2 = 0; i2 < node2.props.length; i2++) {
            const dir = node2.props[i2];
            if (dir.type === 7 && dir.name !== "for") {
              const exp2 = dir.exp;
              const arg = dir.arg;
              if (exp2 && exp2.type === 4 && !(dir.name === "on" && arg)) {
                dir.exp = processExpression(
                  exp2,
                  context,
                  // slot args must be processed as function params
                  dir.name === "slot"
                );
              }
              if (arg && arg.type === 4 && !arg.isStatic) {
                dir.arg = processExpression(arg, context);
              }
            }
          }
        }
      };
      function processExpression(node2, context, asParams = false, asRawStatements = false) {
        {
          if (browser$1$1.env.NODE_ENV !== "production") {
            validateBrowserExpression(node2, context, asParams, asRawStatements);
          }
          return node2;
        }
      }
      const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node2, dir, context) => {
        return processIf(node2, dir, context, (ifNode, branch, isRoot2) => {
          const siblings = context.parent.children;
          let i2 = siblings.indexOf(ifNode);
          let key = 0;
          while (i2-- >= 0) {
            const sibling = siblings[i2];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot2) {
              ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
          };
        });
      });
      function processIf(node2, dir, context, processCodegen) {
        if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node2.loc;
          context.onError(createCompilerError(27, dir.loc));
          dir.exp = createSimpleExpression(`true`, false, loc);
        }
        if (browser$1$1.env.NODE_ENV !== "production" && true && dir.exp) {
          validateBrowserExpression(dir.exp, context);
        }
        if (dir.name === "if") {
          const branch = createIfBranch(node2, dir);
          const ifNode = {
            type: 9,
            loc: node2.loc,
            branches: [branch]
          };
          context.replaceNode(ifNode);
          if (processCodegen) {
            return processCodegen(ifNode, branch, true);
          }
        } else {
          const siblings = context.parent.children;
          const comments2 = [];
          let i2 = siblings.indexOf(node2);
          while (i2-- >= -1) {
            const sibling = siblings[i2];
            if (browser$1$1.env.NODE_ENV !== "production" && sibling && sibling.type === 3) {
              context.removeNode(sibling);
              comments2.unshift(sibling);
              continue;
            }
            if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
              context.removeNode(sibling);
              continue;
            }
            if (sibling && sibling.type === 9) {
              context.removeNode();
              const branch = createIfBranch(node2, dir);
              if (browser$1$1.env.NODE_ENV !== "production" && comments2.length) {
                branch.children = [...comments2, ...branch.children];
              }
              if (browser$1$1.env.NODE_ENV !== "production" || false) {
                const key = branch.userKey;
                if (key) {
                  sibling.branches.forEach(({ userKey }) => {
                    if (isSameKey(userKey, key)) {
                      context.onError(createCompilerError(28, branch.userKey.loc));
                    }
                  });
                }
              }
              sibling.branches.push(branch);
              const onExit = processCodegen && processCodegen(sibling, branch, false);
              traverseNode(branch, context);
              if (onExit)
                onExit();
              context.currentNode = null;
            } else {
              context.onError(createCompilerError(29, node2.loc));
            }
            break;
          }
        }
      }
      function createIfBranch(node2, dir) {
        return {
          type: 10,
          loc: node2.loc,
          condition: dir.name === "else" ? void 0 : dir.exp,
          children: node2.tagType === 3 && !findDir(node2, "for") ? node2.children : [node2],
          userKey: findProp(node2, `key`)
        };
      }
      function createCodegenNodeForBranch(branch, keyIndex, context) {
        if (branch.condition) {
          return createConditionalExpression(
            branch.condition,
            createChildrenCodegenNode(branch, keyIndex, context),
            // make sure to pass in asBlock: true so that the comment node call
            // closes the current block.
            createCallExpression(context.helper(CREATE_COMMENT), [
              browser$1$1.env.NODE_ENV !== "production" ? '"v-if"' : '""',
              "true"
            ])
          );
        } else {
          return createChildrenCodegenNode(branch, keyIndex, context);
        }
      }
      function createChildrenCodegenNode(branch, keyIndex, context) {
        const { helper, removeHelper } = context;
        const keyProperty = createObjectProperty(`key`, createSimpleExpression(
          `${keyIndex}`,
          false,
          locStub,
          2
          /* CAN_HOIST */
        ));
        const { children } = branch;
        const firstChild = children[0];
        const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
        if (needFragmentWrapper) {
          if (children.length === 1 && firstChild.type === 11) {
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
          } else {
            let patchFlag = 64;
            let patchFlagText = PatchFlagNames[
              64
              /* STABLE_FRAGMENT */
            ];
            if (browser$1$1.env.NODE_ENV !== "production" && children.filter(
              (c) => c.type !== 3
              /* COMMENT */
            ).length === 1) {
              patchFlag |= 2048;
              patchFlagText += `, ${PatchFlagNames[
                2048
                /* DEV_ROOT_FRAGMENT */
              ]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, branch.loc);
          }
        } else {
          const vnodeCall = firstChild.codegenNode;
          if (vnodeCall.type === 13 && !vnodeCall.isBlock) {
            removeHelper(CREATE_VNODE);
            vnodeCall.isBlock = true;
            helper(OPEN_BLOCK);
            helper(CREATE_BLOCK);
          }
          injectProp(vnodeCall, keyProperty, context);
          return vnodeCall;
        }
      }
      function isSameKey(a, b2) {
        if (!a || a.type !== b2.type) {
          return false;
        }
        if (a.type === 6) {
          if (a.value.content !== b2.value.content) {
            return false;
          }
        } else {
          const exp2 = a.exp;
          const branchExp = b2.exp;
          if (exp2.type !== branchExp.type) {
            return false;
          }
          if (exp2.type !== 4 || (exp2.isStatic !== branchExp.isStatic || exp2.content !== branchExp.content)) {
            return false;
          }
        }
        return true;
      }
      function getParentCondition(node2) {
        while (true) {
          if (node2.type === 19) {
            if (node2.alternate.type === 19) {
              node2 = node2.alternate;
            } else {
              return node2;
            }
          } else if (node2.type === 20) {
            node2 = node2.value;
          }
        }
      }
      const transformFor = createStructuralDirectiveTransform("for", (node2, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node2, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const keyProp = findProp(node2, `key`);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, node2.loc);
          return () => {
            let childBlock;
            const isTemplate = isTemplateNode(node2);
            const { children } = forNode;
            if ((browser$1$1.env.NODE_ENV !== "production" || false) && isTemplate) {
              node2.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(createCompilerError(32, key.loc));
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node2) ? node2 : isTemplate && node2.children.length === 1 && isSlotOutlet(node2.children[0]) ? node2.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node2.children, 64 + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[
                64
                /* STABLE_FRAGMENT */
              ]} */` : ``), void 0, void 0, true);
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(CREATE_BLOCK);
                } else {
                  removeHelper(CREATE_VNODE);
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(CREATE_BLOCK);
              } else {
                helper(CREATE_VNODE);
              }
            }
            renderExp.arguments.push(createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
              /* force newline */
            ));
          };
        });
      });
      function processFor(node2, dir, context, processCodegen) {
        if (!dir.exp) {
          context.onError(createCompilerError(30, dir.loc));
          return;
        }
        const parseResult = parseForExpression(
          // can only be simple expression because vFor transform is applied
          // before expression transform.
          dir.exp,
          context
        );
        if (!parseResult) {
          context.onError(createCompilerError(31, dir.loc));
          return;
        }
        const { addIdentifiers, removeIdentifiers, scopes } = context;
        const { source, value, key, index } = parseResult;
        const forNode = {
          type: 11,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index,
          parseResult,
          children: isTemplateNode(node2) ? node2.children : [node2]
        };
        context.replaceNode(forNode);
        scopes.vFor++;
        const onExit = processCodegen && processCodegen(forNode);
        return () => {
          scopes.vFor--;
          if (onExit)
            onExit();
        };
      }
      const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
      const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      const stripParensRE = /^\(|\)$/g;
      function parseForExpression(input2, context) {
        const loc = input2.loc;
        const exp2 = input2.content;
        const inMatch = exp2.match(forAliasRE);
        if (!inMatch)
          return;
        const [, LHS, RHS] = inMatch;
        const result2 = {
          source: createAliasExpression(loc, RHS.trim(), exp2.indexOf(RHS, LHS.length)),
          value: void 0,
          key: void 0,
          index: void 0
        };
        if (browser$1$1.env.NODE_ENV !== "production" && true) {
          validateBrowserExpression(result2.source, context);
        }
        let valueContent = LHS.trim().replace(stripParensRE, "").trim();
        const trimmedOffset = LHS.indexOf(valueContent);
        const iteratorMatch = valueContent.match(forIteratorRE);
        if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, "").trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
            keyOffset = exp2.indexOf(keyContent, trimmedOffset + valueContent.length);
            result2.key = createAliasExpression(loc, keyContent, keyOffset);
            if (browser$1$1.env.NODE_ENV !== "production" && true) {
              validateBrowserExpression(result2.key, context, true);
            }
          }
          if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
              result2.index = createAliasExpression(loc, indexContent, exp2.indexOf(indexContent, result2.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
              if (browser$1$1.env.NODE_ENV !== "production" && true) {
                validateBrowserExpression(result2.index, context, true);
              }
            }
          }
        }
        if (valueContent) {
          result2.value = createAliasExpression(loc, valueContent, trimmedOffset);
          if (browser$1$1.env.NODE_ENV !== "production" && true) {
            validateBrowserExpression(result2.value, context, true);
          }
        }
        return result2;
      }
      function createAliasExpression(range2, content, offset) {
        return createSimpleExpression(content, false, getInnerRange(range2, offset, content.length));
      }
      function createForLoopParams({ value, key, index }) {
        const params = [];
        if (value) {
          params.push(value);
        }
        if (key) {
          if (!value) {
            params.push(createSimpleExpression(`_`, false));
          }
          params.push(key);
        }
        if (index) {
          if (!key) {
            if (!value) {
              params.push(createSimpleExpression(`_`, false));
            }
            params.push(createSimpleExpression(`__`, false));
          }
          params.push(index);
        }
        return params;
      }
      const defaultFallback = createSimpleExpression(`undefined`, false);
      const trackSlotScopes = (node2, context) => {
        if (node2.type === 1 && (node2.tagType === 1 || node2.tagType === 3)) {
          const vSlot = findDir(node2, "slot");
          if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
              context.scopes.vSlot--;
            };
          }
        }
      };
      const trackVForSlotScopes = (node2, context) => {
        let vFor;
        if (isTemplateNode(node2) && node2.props.some(isVSlot) && (vFor = findDir(node2, "for"))) {
          const result2 = vFor.parseResult = parseForExpression(vFor.exp, context);
          if (result2) {
            const { value, key, index } = result2;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
              value && removeIdentifiers(value);
              key && removeIdentifiers(key);
              index && removeIdentifiers(index);
            };
          }
        }
      };
      const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
      function buildSlots(node2, context, buildSlotFn = buildClientSlotFn) {
        context.helper(WITH_CTX);
        const { children, loc } = node2;
        const slotsProperties = [];
        const dynamicSlots = [];
        const buildDefaultSlotProperty = (props, children2) => createObjectProperty(`default`, buildSlotFn(props, children2, loc));
        let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
        const onComponentSlot = findDir(node2, "slot", true);
        if (onComponentSlot) {
          const { arg, exp: exp2 } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
          }
          slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp2, children, loc)));
        }
        let hasTemplateSlots = false;
        let hasNamedDefaultSlot = false;
        const implicitDefaultChildren = [];
        const seenSlotNames = /* @__PURE__ */ new Set();
        for (let i2 = 0; i2 < children.length; i2++) {
          const slotElement = children[i2];
          let slotDir;
          if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
            if (slotElement.type !== 3) {
              implicitDefaultChildren.push(slotElement);
            }
            continue;
          }
          if (onComponentSlot) {
            context.onError(createCompilerError(36, slotDir.loc));
            break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
          let staticSlotName;
          if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
          } else {
            hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          let vIf;
          let vElse;
          let vFor;
          if (vIf = findDir(slotElement, "if")) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
          } else if (vElse = findDir(
            slotElement,
            /^else(-if)?$/,
            true
            /* allowEmpty */
          )) {
            let j = i2;
            let prev;
            while (j--) {
              prev = children[j];
              if (prev.type !== 3) {
                break;
              }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
              children.splice(i2, 1);
              i2--;
              let conditional = dynamicSlots[dynamicSlots.length - 1];
              while (conditional.alternate.type === 19) {
                conditional = conditional.alternate;
              }
              conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
            } else {
              context.onError(createCompilerError(29, vElse.loc));
            }
          } else if (vFor = findDir(slotElement, "for")) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
            if (parseResult) {
              dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                parseResult.source,
                createFunctionExpression(
                  createForLoopParams(parseResult),
                  buildDynamicSlot(slotName, slotFunction),
                  true
                  /* force newline */
                )
              ]));
            } else {
              context.onError(createCompilerError(31, vFor.loc));
            }
          } else {
            if (staticSlotName) {
              if (seenSlotNames.has(staticSlotName)) {
                context.onError(createCompilerError(37, dirLoc));
                continue;
              }
              seenSlotNames.add(staticSlotName);
              if (staticSlotName === "default") {
                hasNamedDefaultSlot = true;
              }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
        }
        if (!onComponentSlot) {
          if (!hasTemplateSlots) {
            slotsProperties.push(buildDefaultSlotProperty(void 0, children));
          } else if (implicitDefaultChildren.length) {
            if (hasNamedDefaultSlot) {
              context.onError(createCompilerError(38, implicitDefaultChildren[0].loc));
            } else {
              slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
            }
          }
        }
        const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node2.children) ? 3 : 1;
        let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(
          `_`,
          // 2 = compiled but dynamic = can skip normalization, but must run diff
          // 1 = compiled and static = can skip normalization AND diff as optimized
          createSimpleExpression(slotFlag + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false)
        )), loc);
        if (dynamicSlots.length) {
          slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
          ]);
        }
        return {
          slots,
          hasDynamicSlots
        };
      }
      function buildDynamicSlot(name2, fn) {
        return createObjectExpression([
          createObjectProperty(`name`, name2),
          createObjectProperty(`fn`, fn)
        ]);
      }
      function hasForwardedSlots(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          switch (child.type) {
            case 1:
              if (child.tagType === 2 || child.tagType === 0 && hasForwardedSlots(child.children)) {
                return true;
              }
              break;
            case 9:
              if (hasForwardedSlots(child.branches))
                return true;
              break;
            case 10:
            case 11:
              if (hasForwardedSlots(child.children))
                return true;
              break;
          }
        }
        return false;
      }
      const directiveImportMap = /* @__PURE__ */ new WeakMap();
      const transformElement = (node2, context) => {
        return function postTransformElement() {
          node2 = context.currentNode;
          if (!(node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1))) {
            return;
          }
          const { tag: tag2, props } = node2;
          const isComponent = node2.tagType === 1;
          const vnodeTag = isComponent ? resolveComponentType(node2, context) : `"${tag2}"`;
          const isDynamicComponent = isObject$2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = (
            // dynamic component may resolve to plain elements
            isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
            // updates inside get proper isSVG flag at runtime. (#639, #643)
            // This is technically web-specific, but splitting the logic out of core
            // leads to too much unnecessary complexity.
            (tag2 === "svg" || tag2 === "foreignObject" || // #938: elements with dynamic keys should be forced into blocks
            findProp(node2, "key", true))
          );
          if (props.length > 0) {
            const propsBuildResult = buildProps(node2, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          }
          if (node2.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
              shouldUseBlock = true;
              patchFlag |= 1024;
              if (browser$1$1.env.NODE_ENV !== "production" && node2.children.length > 1) {
                context.onError(createCompilerError(44, {
                  start: node2.children[0].loc.start,
                  end: node2.children[node2.children.length - 1].loc.end,
                  source: ""
                }));
              }
            }
            const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
            vnodeTag !== TELEPORT && // explained above.
            vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
              const { slots, hasDynamicSlots } = buildSlots(node2, context);
              vnodeChildren = slots;
              if (hasDynamicSlots) {
                patchFlag |= 1024;
              }
            } else if (node2.children.length === 1 && vnodeTag !== TELEPORT) {
              const child = node2.children[0];
              const type2 = child.type;
              const hasDynamicTextChild = type2 === 5 || type2 === 8;
              if (hasDynamicTextChild && getConstantType(child, context) === 0) {
                patchFlag |= 1;
              }
              if (hasDynamicTextChild || type2 === 2) {
                vnodeChildren = child;
              } else {
                vnodeChildren = node2.children;
              }
            } else {
              vnodeChildren = node2.children;
            }
          }
          if (patchFlag !== 0) {
            if (browser$1$1.env.NODE_ENV !== "production") {
              if (patchFlag < 0) {
                vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
              } else {
                const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n2) => n2 > 0 && patchFlag & n2).map((n2) => PatchFlagNames[n2]).join(`, `);
                vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
              }
            } else {
              vnodePatchFlag = String(patchFlag);
            }
            if (dynamicPropNames && dynamicPropNames.length) {
              vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
          }
          node2.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, node2.loc);
        };
      };
      function resolveComponentType(node2, context, ssr = false) {
        const { tag: tag2 } = node2;
        const isProp = isComponentTag(tag2) ? findProp(node2, "is") : findDir(node2, "is");
        if (isProp) {
          const exp2 = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
          if (exp2) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp2
            ]);
          }
        }
        const builtIn = isCoreComponent(tag2) || context.isBuiltInComponent(tag2);
        if (builtIn) {
          if (!ssr)
            context.helper(builtIn);
          return builtIn;
        }
        context.helper(RESOLVE_COMPONENT);
        context.components.add(tag2);
        return toValidAssetId(tag2, `component`);
      }
      function buildProps(node2, context, props = node2.props, ssr = false) {
        const { tag: tag2, loc: elementLoc } = node2;
        const isComponent = node2.tagType === 1;
        let properties = [];
        const mergeArgs = [];
        const runtimeDirectives = [];
        let patchFlag = 0;
        let hasRef = false;
        let hasClassBinding = false;
        let hasStyleBinding = false;
        let hasHydrationEventBinding = false;
        let hasDynamicKeys = false;
        let hasVnodeHook = false;
        const dynamicPropNames = [];
        const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
            const name2 = key.content;
            const isEventHandler = isOn(name2);
            if (!isComponent && isEventHandler && // omit the flag for click handlers because hydration gives click
            // dedicated fast path.
            name2.toLowerCase() !== "onclick" && // omit v-model handlers
            name2 !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
            !isReservedProp(name2)) {
              hasHydrationEventBinding = true;
            }
            if (isEventHandler && isReservedProp(name2)) {
              hasVnodeHook = true;
            }
            if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
              return;
            }
            if (name2 === "ref") {
              hasRef = true;
            } else if (name2 === "class" && !isComponent) {
              hasClassBinding = true;
            } else if (name2 === "style" && !isComponent) {
              hasStyleBinding = true;
            } else if (name2 !== "key" && !dynamicPropNames.includes(name2)) {
              dynamicPropNames.push(name2);
            }
          } else {
            hasDynamicKeys = true;
          }
        };
        for (let i2 = 0; i2 < props.length; i2++) {
          const prop = props[i2];
          if (prop.type === 6) {
            const { loc, name: name2, value } = prop;
            let isStatic = true;
            if (name2 === "ref") {
              hasRef = true;
            }
            if (name2 === "is" && isComponentTag(tag2)) {
              continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name2, true, getInnerRange(loc, 0, name2.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
          } else {
            const { name: name2, arg, exp: exp2, loc } = prop;
            const isBind = name2 === "bind";
            const isOn2 = name2 === "on";
            if (name2 === "slot") {
              if (!isComponent) {
                context.onError(createCompilerError(39, loc));
              }
              continue;
            }
            if (name2 === "once") {
              continue;
            }
            if (name2 === "is" || isBind && isComponentTag(tag2) && isBindKey(arg, "is")) {
              continue;
            }
            if (isOn2 && ssr) {
              continue;
            }
            if (!arg && (isBind || isOn2)) {
              hasDynamicKeys = true;
              if (exp2) {
                if (properties.length) {
                  mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                  properties = [];
                }
                if (isBind) {
                  mergeArgs.push(exp2);
                } else {
                  mergeArgs.push({
                    type: 14,
                    loc,
                    callee: context.helper(TO_HANDLERS),
                    arguments: [exp2]
                  });
                }
              } else {
                context.onError(createCompilerError(isBind ? 33 : 34, loc));
              }
              continue;
            }
            const directiveTransform = context.directiveTransforms[name2];
            if (directiveTransform) {
              const { props: props2, needRuntime } = directiveTransform(prop, node2, context);
              !ssr && props2.forEach(analyzePatchFlag);
              properties.push(...props2);
              if (needRuntime) {
                runtimeDirectives.push(prop);
                if (isSymbol$1(needRuntime)) {
                  directiveImportMap.set(prop, needRuntime);
                }
              }
            } else {
              runtimeDirectives.push(prop);
            }
          }
        }
        let propsExpression = void 0;
        if (mergeArgs.length) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
          }
          if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
          } else {
            propsExpression = mergeArgs[0];
          }
        } else if (properties.length) {
          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
        }
        if (hasDynamicKeys) {
          patchFlag |= 16;
        } else {
          if (hasClassBinding) {
            patchFlag |= 2;
          }
          if (hasStyleBinding) {
            patchFlag |= 4;
          }
          if (dynamicPropNames.length) {
            patchFlag |= 8;
          }
          if (hasHydrationEventBinding) {
            patchFlag |= 32;
          }
        }
        if ((patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512;
        }
        return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames
        };
      }
      function dedupeProperties(properties) {
        const knownProps = /* @__PURE__ */ new Map();
        const deduped = [];
        for (let i2 = 0; i2 < properties.length; i2++) {
          const prop = properties[i2];
          if (prop.key.type === 8 || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
          }
          const name2 = prop.key.content;
          const existing = knownProps.get(name2);
          if (existing) {
            if (name2 === "style" || name2 === "class" || name2.startsWith("on")) {
              mergeAsArray(existing, prop);
            }
          } else {
            knownProps.set(name2, prop);
            deduped.push(prop);
          }
        }
        return deduped;
      }
      function mergeAsArray(existing, incoming) {
        if (existing.value.type === 17) {
          existing.value.elements.push(incoming.value);
        } else {
          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
        }
      }
      function buildDirectiveArgs(dir, context) {
        const dirArgs = [];
        const runtime = directiveImportMap.get(dir);
        if (runtime) {
          dirArgs.push(context.helperString(runtime));
        } else {
          {
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
          }
        }
        const { loc } = dir;
        if (dir.exp)
          dirArgs.push(dir.exp);
        if (dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
        }
        if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
            if (!dir.exp) {
              dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
        }
        return createArrayExpression(dirArgs, dir.loc);
      }
      function stringifyDynamicPropNames(props) {
        let propsNamesString = `[`;
        for (let i2 = 0, l = props.length; i2 < l; i2++) {
          propsNamesString += JSON.stringify(props[i2]);
          if (i2 < l - 1)
            propsNamesString += ", ";
        }
        return propsNamesString + `]`;
      }
      function isComponentTag(tag2) {
        return tag2[0].toLowerCase() + tag2.slice(1) === "component";
      }
      browser$1$1.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
      browser$1$1.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
      const cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str2) => {
          const hit = cache[str2];
          return hit || (cache[str2] = fn(str2));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str2) => {
        return str2.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      });
      const transformSlotOutlet = (node2, context) => {
        if (isSlotOutlet(node2)) {
          const { children, loc } = node2;
          const { slotName, slotProps } = processSlotOutlet(node2, context);
          const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName
          ];
          if (slotProps) {
            slotArgs.push(slotProps);
          }
          if (children.length) {
            if (!slotProps) {
              slotArgs.push(`{}`);
            }
            slotArgs.push(createFunctionExpression([], children, false, false, loc));
          }
          if (context.scopeId && !context.slotted) {
            if (!slotProps) {
              slotArgs.push(`{}`);
            }
            if (!children.length) {
              slotArgs.push(`undefined`);
            }
            slotArgs.push(`true`);
          }
          node2.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
        }
      };
      function processSlotOutlet(node2, context) {
        let slotName = `"default"`;
        let slotProps = void 0;
        const nonNameProps = [];
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const p = node2.props[i2];
          if (p.type === 6) {
            if (p.value) {
              if (p.name === "name") {
                slotName = JSON.stringify(p.value.content);
              } else {
                p.name = camelize(p.name);
                nonNameProps.push(p);
              }
            }
          } else {
            if (p.name === "bind" && isBindKey(p.arg, "name")) {
              if (p.exp)
                slotName = p.exp;
            } else {
              if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
                p.arg.content = camelize(p.arg.content);
              }
              nonNameProps.push(p);
            }
          }
        }
        if (nonNameProps.length > 0) {
          const { props, directives } = buildProps(node2, context, nonNameProps);
          slotProps = props;
          if (directives.length) {
            context.onError(createCompilerError(35, directives[0].loc));
          }
        }
        return {
          slotName,
          slotProps
        };
      }
      const fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
      const transformOn$1 = (dir, node2, context, augmentor) => {
        const { loc, modifiers, arg } = dir;
        if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(34, loc));
        }
        let eventName;
        if (arg.type === 4) {
          if (arg.isStatic) {
            const rawName = arg.content;
            eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);
          } else {
            eventName = createCompoundExpression([
              `${context.helperString(TO_HANDLER_KEY)}(`,
              arg,
              `)`
            ]);
          }
        } else {
          eventName = arg;
          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
        }
        let exp2 = dir.exp;
        if (exp2 && !exp2.content.trim()) {
          exp2 = void 0;
        }
        let shouldCache = context.cacheHandlers && !exp2;
        if (exp2) {
          const isMemberExp = isMemberExpression(exp2.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp2.content));
          const hasMultipleStatements = exp2.content.includes(`;`);
          if (browser$1$1.env.NODE_ENV !== "production" && true) {
            validateBrowserExpression(exp2, context, false, hasMultipleStatements);
          }
          if (isInlineStatement || shouldCache && isMemberExp) {
            exp2 = createCompoundExpression([
              `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
              exp2,
              hasMultipleStatements ? `}` : `)`
            ]);
          }
        }
        let ret = {
          props: [
            createObjectProperty(eventName, exp2 || createSimpleExpression(`() => {}`, false, loc))
          ]
        };
        if (augmentor) {
          ret = augmentor(ret);
        }
        if (shouldCache) {
          ret.props[0].value = context.cache(ret.props[0].value);
        }
        return ret;
      };
      const transformBind = (dir, node2, context) => {
        const { exp: exp2, modifiers, loc } = dir;
        const arg = dir.arg;
        if (arg.type !== 4) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
        } else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
        }
        if (modifiers.includes("camel")) {
          if (arg.type === 4) {
            if (arg.isStatic) {
              arg.content = camelize$1(arg.content);
            } else {
              arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
          } else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
          }
        }
        if (!exp2 || exp2.type === 4 && !exp2.content.trim()) {
          context.onError(createCompilerError(33, loc));
          return {
            props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
          };
        }
        return {
          props: [createObjectProperty(arg, exp2)]
        };
      };
      const transformText = (node2, context) => {
        if (node2.type === 0 || node2.type === 1 || node2.type === 11 || node2.type === 10) {
          return () => {
            const children = node2.children;
            let currentContainer = void 0;
            let hasText = false;
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (isText(child)) {
                hasText = true;
                for (let j = i2 + 1; j < children.length; j++) {
                  const next = children[j];
                  if (isText(next)) {
                    if (!currentContainer) {
                      currentContainer = children[i2] = {
                        type: 8,
                        loc: child.loc,
                        children: [child]
                      };
                    }
                    currentContainer.children.push(` + `, next);
                    children.splice(j, 1);
                    j--;
                  } else {
                    currentContainer = void 0;
                    break;
                  }
                }
              }
            }
            if (!hasText || // if this is a plain element with a single text child, leave it
            // as-is since the runtime has dedicated fast path for this by directly
            // setting textContent of the element.
            // for component root it's always normalized anyway.
            children.length === 1 && (node2.type === 0 || node2.type === 1 && node2.tagType === 0)) {
              return;
            }
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (isText(child) || child.type === 8) {
                const callArgs = [];
                if (child.type !== 2 || child.content !== " ") {
                  callArgs.push(child);
                }
                if (!context.ssr && getConstantType(child, context) === 0) {
                  callArgs.push(1 + (browser$1$1.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[
                    1
                    /* TEXT */
                  ]} */` : ``));
                }
                children[i2] = {
                  type: 12,
                  content: child,
                  loc: child.loc,
                  codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                };
              }
            }
          };
        }
      };
      const seen = /* @__PURE__ */ new WeakSet();
      const transformOnce = (node2, context) => {
        if (node2.type === 1 && findDir(node2, "once", true)) {
          if (seen.has(node2)) {
            return;
          }
          seen.add(node2);
          context.helper(SET_BLOCK_TRACKING);
          return () => {
            const cur = context.currentNode;
            if (cur.codegenNode) {
              cur.codegenNode = context.cache(
                cur.codegenNode,
                true
                /* isVNode */
              );
            }
          };
        }
      };
      const transformModel$1 = (dir, node2, context) => {
        const { exp: exp2, arg } = dir;
        if (!exp2) {
          context.onError(createCompilerError(40, dir.loc));
          return createTransformProps();
        }
        const rawExp = exp2.loc.source;
        const expString = exp2.type === 4 ? exp2.content : rawExp;
        context.bindingMetadata[rawExp];
        const maybeRef = false;
        if (!isMemberExpression(expString) && !maybeRef) {
          context.onError(createCompilerError(41, exp2.loc));
          return createTransformProps();
        }
        const propName = arg ? arg : createSimpleExpression("modelValue", true);
        const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
        let assignmentExp;
        const eventArg = context.isTS ? `($event: any)` : `$event`;
        {
          assignmentExp = createCompoundExpression([
            `${eventArg} => (`,
            exp2,
            ` = $event)`
          ]);
        }
        const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, assignmentExp)
        ];
        if (dir.modifiers.length && node2.tagType === 1) {
          const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
          const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(
            `{ ${modifiers} }`,
            false,
            dir.loc,
            2
            /* CAN_HOIST */
          )));
        }
        return createTransformProps(props);
      };
      function createTransformProps(props = []) {
        return { props };
      }
      function getBaseTransformPreset(prefixIdentifiers) {
        return [
          [
            transformOnce,
            transformIf,
            transformFor,
            ...browser$1$1.env.NODE_ENV !== "production" ? [transformExpression] : [],
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
          ],
          {
            on: transformOn$1,
            bind: transformBind,
            model: transformModel$1
          }
        ];
      }
      function baseCompile(template, options2 = {}) {
        const onError = options2.onError || defaultOnError;
        const isModuleMode = options2.mode === "module";
        {
          if (options2.prefixIdentifiers === true) {
            onError(createCompilerError(
              45
              /* X_PREFIX_ID_NOT_SUPPORTED */
            ));
          } else if (isModuleMode) {
            onError(createCompilerError(
              46
              /* X_MODULE_MODE_NOT_SUPPORTED */
            ));
          }
        }
        const prefixIdentifiers = false;
        if (options2.cacheHandlers) {
          onError(createCompilerError(
            47
            /* X_CACHE_HANDLER_NOT_SUPPORTED */
          ));
        }
        if (options2.scopeId && !isModuleMode) {
          onError(createCompilerError(
            48
            /* X_SCOPE_ID_NOT_SUPPORTED */
          ));
        }
        const ast = isString$2(template) ? baseParse(template, options2) : template;
        const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
        transform(ast, extend({}, options2, {
          prefixIdentifiers,
          nodeTransforms: [
            ...nodeTransforms,
            ...options2.nodeTransforms || []
            // user transforms
          ],
          directiveTransforms: extend(
            {},
            directiveTransforms,
            options2.directiveTransforms || {}
            // user transforms
          )
        }));
        return generate$2(ast, extend({}, options2, {
          prefixIdentifiers
        }));
      }
      const noopDirectiveTransform = () => ({ props: [] });
      var compilerCore_esmBundler = Object.freeze({
        __proto__: null,
        BASE_TRANSITION,
        CAMELIZE,
        CAPITALIZE,
        CREATE_BLOCK,
        CREATE_COMMENT,
        CREATE_SLOTS,
        CREATE_STATIC,
        CREATE_TEXT,
        CREATE_VNODE,
        FRAGMENT,
        IS_REF,
        KEEP_ALIVE,
        MERGE_PROPS,
        OPEN_BLOCK,
        POP_SCOPE_ID,
        PUSH_SCOPE_ID,
        RENDER_LIST,
        RENDER_SLOT,
        RESOLVE_COMPONENT,
        RESOLVE_DIRECTIVE,
        RESOLVE_DYNAMIC_COMPONENT,
        SET_BLOCK_TRACKING,
        SUSPENSE,
        TELEPORT,
        TO_DISPLAY_STRING,
        TO_HANDLERS,
        TO_HANDLER_KEY,
        UNREF,
        WITH_CTX,
        WITH_DIRECTIVES,
        WITH_SCOPE_ID,
        advancePositionWithClone,
        advancePositionWithMutation,
        assert,
        baseCompile,
        baseParse,
        buildProps,
        buildSlots,
        createArrayExpression,
        createAssignmentExpression,
        createBlockStatement,
        createCacheExpression,
        createCallExpression,
        createCompilerError,
        createCompoundExpression,
        createConditionalExpression,
        createForLoopParams,
        createFunctionExpression,
        createIfStatement,
        createInterpolation,
        createObjectExpression,
        createObjectProperty,
        createReturnStatement,
        createRoot,
        createSequenceExpression,
        createSimpleExpression,
        createStructuralDirectiveTransform,
        createTemplateLiteral,
        createTransformContext,
        createVNodeCall,
        findDir,
        findProp,
        generate: generate$2,
        getBaseTransformPreset,
        getInnerRange,
        hasDynamicKeyVBind,
        hasScopeRef,
        helperNameMap,
        injectProp,
        isBindKey,
        isBuiltInType,
        isCoreComponent,
        isMemberExpression,
        isSimpleIdentifier,
        isSlotOutlet,
        isStaticExp,
        isTemplateNode,
        isText,
        isVSlot,
        locStub,
        noopDirectiveTransform,
        processExpression,
        processFor,
        processIf,
        processSlotOutlet,
        registerRuntimeHelpers,
        resolveComponentType,
        toValidAssetId,
        trackSlotScopes,
        trackVForSlotScopes,
        transform,
        transformBind,
        transformElement,
        transformExpression,
        transformModel: transformModel$1,
        transformOn: transformOn$1,
        traverseNode,
        generateCodeFrame
      });
      const V_MODEL_RADIO = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vModelRadio` : ``);
      const V_MODEL_CHECKBOX = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vModelCheckbox` : ``);
      const V_MODEL_TEXT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vModelText` : ``);
      const V_MODEL_SELECT = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vModelSelect` : ``);
      const V_MODEL_DYNAMIC = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vModelDynamic` : ``);
      const V_ON_WITH_MODIFIERS = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vOnModifiersGuard` : ``);
      const V_ON_WITH_KEYS = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vOnKeysGuard` : ``);
      const V_SHOW = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `vShow` : ``);
      const TRANSITION = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `Transition` : ``);
      const TRANSITION_GROUP = Symbol(browser$1$1.env.NODE_ENV !== "production" ? `TransitionGroup` : ``);
      registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      let decoder;
      function decodeHtmlBrowser(raw) {
        (decoder || (decoder = document.createElement("div"))).innerHTML = raw;
        return decoder.textContent;
      }
      const isRawTextContainer = makeMap("style,iframe,script,noscript", true);
      const parserOptions = {
        isVoidTag,
        isNativeTag: (tag2) => isHTMLTag(tag2) || isSVGTag(tag2),
        isPreTag: (tag2) => tag2 === "pre",
        decodeEntities: decodeHtmlBrowser,
        isBuiltInComponent: (tag2) => {
          if (isBuiltInType(tag2, `Transition`)) {
            return TRANSITION;
          } else if (isBuiltInType(tag2, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
        getNamespace(tag2, parent) {
          let ns = parent ? parent.ns : 0;
          if (parent && ns === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag2 === "svg") {
                return 1;
              }
              if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
                ns = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag2 !== "mglyph" && tag2 !== "malignmark") {
              ns = 0;
            }
          } else if (parent && ns === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns = 0;
            }
          }
          if (ns === 0) {
            if (tag2 === "svg") {
              return 1;
            }
            if (tag2 === "math") {
              return 2;
            }
          }
          return ns;
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        getTextMode({ tag: tag2, ns }) {
          if (ns === 0) {
            if (tag2 === "textarea" || tag2 === "title") {
              return 1;
            }
            if (isRawTextContainer(tag2)) {
              return 2;
            }
          }
          return 0;
        }
      };
      const transformStyle = (node2) => {
        if (node2.type === 1) {
          node2.props.forEach((p, i2) => {
            if (p.type === 6 && p.name === "style" && p.value) {
              node2.props[i2] = {
                type: 7,
                name: `bind`,
                arg: createSimpleExpression(`style`, true, p.loc),
                exp: parseInlineCSS(p.value.content, p.loc),
                modifiers: [],
                loc: p.loc
              };
            }
          });
        }
      };
      const parseInlineCSS = (cssText, loc) => {
        const normalized = parseStringStyle(cssText);
        return createSimpleExpression(
          JSON.stringify(normalized),
          false,
          loc,
          3
          /* CAN_STRINGIFY */
        );
      };
      function createDOMCompilerError(code2, loc) {
        return createCompilerError(code2, loc, browser$1$1.env.NODE_ENV !== "production" || false ? DOMErrorMessages : void 0);
      }
      const DOMErrorMessages = {
        [
          49
          /* X_V_HTML_NO_EXPRESSION */
        ]: `v-html is missing expression.`,
        [
          50
          /* X_V_HTML_WITH_CHILDREN */
        ]: `v-html will override element children.`,
        [
          51
          /* X_V_TEXT_NO_EXPRESSION */
        ]: `v-text is missing expression.`,
        [
          52
          /* X_V_TEXT_WITH_CHILDREN */
        ]: `v-text will override element children.`,
        [
          53
          /* X_V_MODEL_ON_INVALID_ELEMENT */
        ]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [
          54
          /* X_V_MODEL_ARG_ON_ELEMENT */
        ]: `v-model argument is not supported on plain elements.`,
        [
          55
          /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
        ]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [
          56
          /* X_V_MODEL_UNNECESSARY_VALUE */
        ]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [
          57
          /* X_V_SHOW_NO_EXPRESSION */
        ]: `v-show is missing expression.`,
        [
          58
          /* X_TRANSITION_INVALID_CHILDREN */
        ]: `<Transition> expects exactly one child element or component.`,
        [
          59
          /* X_IGNORED_SIDE_EFFECT_TAG */
        ]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      const transformVHtml = (dir, node2, context) => {
        const { exp: exp2, loc } = dir;
        if (!exp2) {
          context.onError(createDOMCompilerError(49, loc));
        }
        if (node2.children.length) {
          context.onError(createDOMCompilerError(50, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp2 || createSimpleExpression("", true))
          ]
        };
      };
      const transformVText = (dir, node2, context) => {
        const { exp: exp2, loc } = dir;
        if (!exp2) {
          context.onError(createDOMCompilerError(51, loc));
        }
        if (node2.children.length) {
          context.onError(createDOMCompilerError(52, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`textContent`, true), exp2 ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp2], loc) : createSimpleExpression("", true))
          ]
        };
      };
      const transformModel = (dir, node2, context) => {
        const baseResult = transformModel$1(dir, node2, context);
        if (!baseResult.props.length || node2.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context.onError(createDOMCompilerError(54, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value = findProp(node2, "value");
          if (value) {
            context.onError(createDOMCompilerError(56, value.loc));
          }
        }
        const { tag: tag2 } = node2;
        const isCustomElement = context.isCustomElement(tag2);
        if (tag2 === "input" || tag2 === "textarea" || tag2 === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag2 === "input" || isCustomElement) {
            const type2 = findProp(node2, `type`);
            if (type2) {
              if (type2.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type2.value) {
                switch (type2.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context.onError(createDOMCompilerError(55, dir.loc));
                    break;
                  default:
                    browser$1$1.env.NODE_ENV !== "production" && checkDuplicatedValue();
                    break;
                }
              }
            } else if (hasDynamicKeyVBind(node2)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              browser$1$1.env.NODE_ENV !== "production" && checkDuplicatedValue();
            }
          } else if (tag2 === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            browser$1$1.env.NODE_ENV !== "production" && checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
          }
        } else {
          context.onError(createDOMCompilerError(53, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
        return baseResult;
      };
      const isEventOptionModifier = makeMap(`passive,once,capture`);
      const isNonKeyModifier = makeMap(
        // event propagation management
        `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
      );
      const maybeKeyModifier = makeMap("left,right");
      const isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`, true);
      const resolveModifiers = (key, modifiers) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const modifier = modifiers[i2];
          if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (isStaticExp(key)) {
                if (isKeyboardEvent(key.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      const transformClick = (key, event) => {
        const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
        return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
          `(`,
          key,
          `) === "onClick" ? "${event}" : (`,
          key,
          `)`
        ]) : key;
      };
      const transformOn = (dir, node2, context) => {
        return transformOn$1(dir, node2, context, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);
          if (nonKeyModifiers.includes("right")) {
            key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
          (!isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(capitalize$2).join("");
            key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [createObjectProperty(key, handlerExp)]
          };
        });
      };
      const transformShow = (dir, node2, context) => {
        const { exp: exp2, loc } = dir;
        if (!exp2) {
          context.onError(createDOMCompilerError(57, loc));
        }
        return {
          props: [],
          needRuntime: context.helper(V_SHOW)
        };
      };
      const warnTransitionChildren = (node2, context) => {
        if (node2.type === 1 && node2.tagType === 1) {
          const component = context.isBuiltInComponent(node2.tag);
          if (component === TRANSITION) {
            return () => {
              if (node2.children.length && hasMultipleChildren(node2)) {
                context.onError(createDOMCompilerError(58, {
                  start: node2.children[0].loc.start,
                  end: node2.children[node2.children.length - 1].loc.end,
                  source: ""
                }));
              }
            };
          }
        }
      };
      function hasMultipleChildren(node2) {
        const children = node2.children = node2.children.filter(
          (c) => c.type !== 3
          /* COMMENT */
        );
        const child = children[0];
        return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
      }
      const ignoreSideEffectTags = (node2, context) => {
        if (node2.type === 1 && node2.tagType === 0 && (node2.tag === "script" || node2.tag === "style")) {
          context.onError(createDOMCompilerError(59, node2.loc));
          context.removeNode();
        }
      };
      const DOMNodeTransforms = [
        transformStyle,
        ...browser$1$1.env.NODE_ENV !== "production" ? [warnTransitionChildren] : []
      ];
      const DOMDirectiveTransforms = {
        cloak: noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel,
        on: transformOn,
        show: transformShow
      };
      function compile$1(template, options2 = {}) {
        return baseCompile(template, extend({}, parserOptions, options2, {
          nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...options2.nodeTransforms || []
          ],
          directiveTransforms: extend({}, DOMDirectiveTransforms, options2.directiveTransforms || {}),
          transformHoist: null
        }));
      }
      function parse$b(template, options2 = {}) {
        return baseParse(template, extend({}, parserOptions, options2));
      }
      var compilerDom_esmBundler = Object.freeze({
        __proto__: null,
        DOMDirectiveTransforms,
        DOMNodeTransforms,
        TRANSITION,
        TRANSITION_GROUP,
        V_MODEL_CHECKBOX,
        V_MODEL_DYNAMIC,
        V_MODEL_RADIO,
        V_MODEL_SELECT,
        V_MODEL_TEXT,
        V_ON_WITH_KEYS,
        V_ON_WITH_MODIFIERS,
        V_SHOW,
        compile: compile$1,
        createDOMCompilerError,
        parse: parse$b,
        parserOptions,
        transformStyle,
        generateCodeFrame,
        BASE_TRANSITION,
        CAMELIZE,
        CAPITALIZE,
        CREATE_BLOCK,
        CREATE_COMMENT,
        CREATE_SLOTS,
        CREATE_STATIC,
        CREATE_TEXT,
        CREATE_VNODE,
        FRAGMENT,
        IS_REF,
        KEEP_ALIVE,
        MERGE_PROPS,
        OPEN_BLOCK,
        POP_SCOPE_ID,
        PUSH_SCOPE_ID,
        RENDER_LIST,
        RENDER_SLOT,
        RESOLVE_COMPONENT,
        RESOLVE_DIRECTIVE,
        RESOLVE_DYNAMIC_COMPONENT,
        SET_BLOCK_TRACKING,
        SUSPENSE,
        TELEPORT,
        TO_DISPLAY_STRING,
        TO_HANDLERS,
        TO_HANDLER_KEY,
        UNREF,
        WITH_CTX,
        WITH_DIRECTIVES,
        WITH_SCOPE_ID,
        advancePositionWithClone,
        advancePositionWithMutation,
        assert,
        baseCompile,
        baseParse,
        buildProps,
        buildSlots,
        createArrayExpression,
        createAssignmentExpression,
        createBlockStatement,
        createCacheExpression,
        createCallExpression,
        createCompilerError,
        createCompoundExpression,
        createConditionalExpression,
        createForLoopParams,
        createFunctionExpression,
        createIfStatement,
        createInterpolation,
        createObjectExpression,
        createObjectProperty,
        createReturnStatement,
        createRoot,
        createSequenceExpression,
        createSimpleExpression,
        createStructuralDirectiveTransform,
        createTemplateLiteral,
        createTransformContext,
        createVNodeCall,
        findDir,
        findProp,
        generate: generate$2,
        getBaseTransformPreset,
        getInnerRange,
        hasDynamicKeyVBind,
        hasScopeRef,
        helperNameMap,
        injectProp,
        isBindKey,
        isBuiltInType,
        isCoreComponent,
        isMemberExpression,
        isSimpleIdentifier,
        isSlotOutlet,
        isStaticExp,
        isTemplateNode,
        isText,
        isVSlot,
        locStub,
        noopDirectiveTransform,
        processExpression,
        processFor,
        processIf,
        processSlotOutlet,
        registerRuntimeHelpers,
        resolveComponentType,
        toValidAssetId,
        trackSlotScopes,
        trackVForSlotScopes,
        transform,
        transformBind,
        transformElement,
        transformExpression,
        transformModel: transformModel$1,
        transformOn: transformOn$1,
        traverseNode
      });
      var require$$0$1 = getAugmentedNamespace(compilerDom_esmBundler);
      function pad(hash2, len) {
        while (hash2.length < len) {
          hash2 = "0" + hash2;
        }
        return hash2;
      }
      function fold(hash2, text) {
        var i2;
        var chr;
        var len;
        if (text.length === 0) {
          return hash2;
        }
        for (i2 = 0, len = text.length; i2 < len; i2++) {
          chr = text.charCodeAt(i2);
          hash2 = (hash2 << 5) - hash2 + chr;
          hash2 |= 0;
        }
        return hash2 < 0 ? hash2 * -2 : hash2;
      }
      function foldObject(hash2, o, seen2) {
        return Object.keys(o).sort().reduce(foldKey, hash2);
        function foldKey(hash3, key) {
          return foldValue(hash3, o[key], key, seen2);
        }
      }
      function foldValue(input2, value, key, seen2) {
        var hash2 = fold(fold(fold(input2, key), toString$2(value)), typeof value);
        if (value === null) {
          return fold(hash2, "null");
        }
        if (value === void 0) {
          return fold(hash2, "undefined");
        }
        if (typeof value === "object" || typeof value === "function") {
          if (seen2.indexOf(value) !== -1) {
            return fold(hash2, "[Circular]" + key);
          }
          seen2.push(value);
          var objHash = foldObject(hash2, value, seen2);
          if (!("valueOf" in value) || typeof value.valueOf !== "function") {
            return objHash;
          }
          try {
            return fold(objHash, String(value.valueOf()));
          } catch (err) {
            return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
          }
        }
        return fold(hash2, value.toString());
      }
      function toString$2(o) {
        return Object.prototype.toString.call(o);
      }
      function sum(o) {
        return pad(foldValue(0, o, "", []).toString(16), 8);
      }
      var hashSum = sum;
      function normalizeArray(parts, allowAboveRoot) {
        var up = 0;
        for (var i2 = parts.length - 1; i2 >= 0; i2--) {
          var last2 = parts[i2];
          if (last2 === ".") {
            parts.splice(i2, 1);
          } else if (last2 === "..") {
            parts.splice(i2, 1);
            up++;
          } else if (up) {
            parts.splice(i2, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift("..");
          }
        }
        return parts;
      }
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      var splitPath = function(filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      function resolve$2() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
          var path2 = i2 >= 0 ? arguments[i2] : "/";
          if (typeof path2 !== "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path2) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charAt(0) === "/";
        }
        resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
          return !!p;
        }), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      }
      function normalize(path2) {
        var isPathAbsolute = isAbsolute$1(path2), trailingSlash = substr(path2, -1) === "/";
        path2 = normalizeArray(filter(path2.split("/"), function(p) {
          return !!p;
        }), !isPathAbsolute).join("/");
        if (!path2 && !isPathAbsolute) {
          path2 = ".";
        }
        if (path2 && trailingSlash) {
          path2 += "/";
        }
        return (isPathAbsolute ? "/" : "") + path2;
      }
      function isAbsolute$1(path2) {
        return path2.charAt(0) === "/";
      }
      function join$1() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return normalize(filter(paths, function(p, index) {
          if (typeof p !== "string") {
            throw new TypeError("Arguments to path.join must be strings");
          }
          return p;
        }).join("/"));
      }
      function relative$1(from2, to) {
        from2 = resolve$2(from2).substr(1);
        to = resolve$2(to).substr(1);
        function trim2(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim2(from2.split("/"));
        var toParts = trim2(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i2 = 0; i2 < length; i2++) {
          if (fromParts[i2] !== toParts[i2]) {
            samePartsLength = i2;
            break;
          }
        }
        var outputParts = [];
        for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
      var sep$1 = "/";
      var delimiter$1 = ":";
      function dirname$2(path2) {
        var result2 = splitPath(path2), root2 = result2[0], dir = result2[1];
        if (!root2 && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root2 + dir;
      }
      function basename(path2, ext) {
        var f = splitPath(path2)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
          f = f.substr(0, f.length - ext.length);
        }
        return f;
      }
      function extname(path2) {
        return splitPath(path2)[3];
      }
      var _polyfillNode_path = {
        extname,
        basename,
        dirname: dirname$2,
        sep: sep$1,
        delimiter: delimiter$1,
        relative: relative$1,
        join: join$1,
        isAbsolute: isAbsolute$1,
        normalize,
        resolve: resolve$2
      };
      function filter(xs, f) {
        if (xs.filter)
          return xs.filter(f);
        var res = [];
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (f(xs[i2], i2, xs))
            res.push(xs[i2]);
        }
        return res;
      }
      var substr = "ab".substr(-1) === "b" ? function(str2, start, len) {
        return str2.substr(start, len);
      } : function(str2, start, len) {
        if (start < 0)
          start = str2.length + start;
        return str2.substr(start, len);
      };
      var _polyfillNode_path$1 = Object.freeze({
        __proto__: null,
        resolve: resolve$2,
        normalize,
        isAbsolute: isAbsolute$1,
        join: join$1,
        relative: relative$1,
        sep: sep$1,
        delimiter: delimiter$1,
        dirname: dirname$2,
        basename,
        extname,
        "default": _polyfillNode_path
      });
      var require$$3 = getAugmentedNamespace(_polyfillNode_path$1);
      var require$$4 = getAugmentedNamespace(compilerCore_esmBundler);
      const maxInt = 2147483647;
      const base = 36;
      const tMin = 1;
      const tMax = 26;
      const skew = 38;
      const damp = 700;
      const initialBias = 72;
      const initialN = 128;
      const delimiter = "-";
      const regexNonASCII = /[^\0-\x7E]/;
      const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      const errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      const baseMinusTMin = base - tMin;
      const floor = Math.floor;
      const stringFromCharCode = String.fromCharCode;
      function error(type2) {
        throw new RangeError(errors[type2]);
      }
      function map$1(array, fn) {
        const result2 = [];
        let length = array.length;
        while (length--) {
          result2[length] = fn(array[length]);
        }
        return result2;
      }
      function mapDomain(string2, fn) {
        const parts = string2.split("@");
        let result2 = "";
        if (parts.length > 1) {
          result2 = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        const labels = string2.split(".");
        const encoded = map$1(labels, fn).join(".");
        return result2 + encoded;
      }
      function ucs2decode(string2) {
        const output = [];
        let counter = 0;
        const length = string2.length;
        while (counter < length) {
          const value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            const extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      const digitToBasic = function(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      const adapt = function(delta, numPoints, firstTime) {
        let k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      const encode$1 = function(input2) {
        const output = [];
        input2 = ucs2decode(input2);
        let inputLength = input2.length;
        let n2 = initialN;
        let delta = 0;
        let bias = initialBias;
        for (const currentValue of input2) {
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        let basicLength = output.length;
        let handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          let m = maxInt;
          for (const currentValue of input2) {
            if (currentValue >= n2 && currentValue < m) {
              m = currentValue;
            }
          }
          const handledCPCountPlusOne = handledCPCount + 1;
          if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n2) * handledCPCountPlusOne;
          n2 = m;
          for (const currentValue of input2) {
            if (currentValue < n2 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n2) {
              let q = delta;
              for (let k = base; ; k += base) {
                const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                const qMinusT = q - t2;
                const baseMinusT = base - t2;
                output.push(
                  stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      };
      const toASCII = function(input2) {
        return mapDomain(input2, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode$1(string2) : string2;
        });
      };
      function hasOwnProperty$2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
      function stringifyPrimitive(v2) {
        switch (typeof v2) {
          case "string":
            return v2;
          case "boolean":
            return v2 ? "true" : "false";
          case "number":
            return isFinite(v2) ? v2 : "";
          default:
            return "";
        }
      }
      function stringify$6(obj, sep2, eq, name2) {
        sep2 = sep2 || "&";
        eq = eq || "=";
        if (obj === null) {
          obj = void 0;
        }
        if (typeof obj === "object") {
          return map(objectKeys(obj), function(k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (isArray(obj[k])) {
              return map(obj[k], function(v2) {
                return ks + encodeURIComponent(stringifyPrimitive(v2));
              }).join(sep2);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep2);
        }
        if (!name2)
          return "";
        return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      }
      function map(xs, f) {
        if (xs.map)
          return xs.map(f);
        var res = [];
        for (var i2 = 0; i2 < xs.length; i2++) {
          res.push(f(xs[i2], i2));
        }
        return res;
      }
      var objectKeys = Object.keys || function(obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            res.push(key);
        }
        return res;
      };
      function parse$a(qs, sep2, eq, options2) {
        sep2 = sep2 || "&";
        eq = eq || "=";
        var obj = {};
        if (typeof qs !== "string" || qs.length === 0) {
          return obj;
        }
        var regexp = /\+/g;
        qs = qs.split(sep2);
        var maxKeys = 1e3;
        if (options2 && typeof options2.maxKeys === "number") {
          maxKeys = options2.maxKeys;
        }
        var len = qs.length;
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }
        for (var i2 = 0; i2 < len; ++i2) {
          var x = qs[i2].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v2;
          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = "";
          }
          k = decodeURIComponent(kstr);
          v2 = decodeURIComponent(vstr);
          if (!hasOwnProperty$2(obj, k)) {
            obj[k] = v2;
          } else if (isArray(obj[k])) {
            obj[k].push(v2);
          } else {
            obj[k] = [obj[k], v2];
          }
        }
        return obj;
      }
      var _polyfillNode_url = {
        parse: urlParse,
        resolve: urlResolve,
        resolveObject: urlResolveObject,
        format: urlFormat,
        Url
      };
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
        "javascript": true,
        "javascript:": true
      }, hostlessProtocol = {
        "javascript": true,
        "javascript:": true
      }, slashedProtocol = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      function urlParse(url2, parseQueryString, slashesDenoteHost) {
        if (url2 && isObject$c(url2) && url2 instanceof Url)
          return url2;
        var u = new Url();
        u.parse(url2, parseQueryString, slashesDenoteHost);
        return u;
      }
      Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
        return parse$9(this, url2, parseQueryString, slashesDenoteHost);
      };
      function parse$9(self2, url2, parseQueryString, slashesDenoteHost) {
        if (!isString$5(url2)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
        }
        var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url2 = uSplit.join(splitter);
        var rest = url2;
        rest = rest.trim();
        if (!slashesDenoteHost && url2.split("#").length === 1) {
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            self2.path = rest;
            self2.href = rest;
            self2.pathname = simplePath[1];
            if (simplePath[2]) {
              self2.search = simplePath[2];
              if (parseQueryString) {
                self2.query = parse$a(self2.search.substr(1));
              } else {
                self2.query = self2.search.substr(1);
              }
            } else if (parseQueryString) {
              self2.search = "";
              self2.query = {};
            }
            return self2;
          }
        }
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          self2.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            self2.slashes = true;
          }
        }
        var i2, hec, l, p;
        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
          var hostEnd = -1;
          for (i2 = 0; i2 < hostEndingChars.length; i2++) {
            hec = rest.indexOf(hostEndingChars[i2]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            self2.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (i2 = 0; i2 < nonHostChars.length; i2++) {
            hec = rest.indexOf(nonHostChars[i2]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          if (hostEnd === -1)
            hostEnd = rest.length;
          self2.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          parseHost(self2);
          self2.hostname = self2.hostname || "";
          var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = self2.hostname.split(/\./);
            for (i2 = 0, l = hostparts.length; i2 < l; i2++) {
              var part = hostparts[i2];
              if (!part)
                continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = "";
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i2);
                  var notHost = hostparts.slice(i2 + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  self2.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (self2.hostname.length > hostnameMaxLen) {
            self2.hostname = "";
          } else {
            self2.hostname = self2.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            self2.hostname = toASCII(self2.hostname);
          }
          p = self2.port ? ":" + self2.port : "";
          var h = self2.hostname || "";
          self2.host = h + p;
          self2.href += self2.host;
          if (ipv6Hostname) {
            self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol[lowerProto]) {
          for (i2 = 0, l = autoEscape.length; i2 < l; i2++) {
            var ae = autoEscape[i2];
            if (rest.indexOf(ae) === -1)
              continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash2 = rest.indexOf("#");
        if (hash2 !== -1) {
          self2.hash = rest.substr(hash2);
          rest = rest.slice(0, hash2);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          self2.search = rest.substr(qm);
          self2.query = rest.substr(qm + 1);
          if (parseQueryString) {
            self2.query = parse$a(self2.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          self2.search = "";
          self2.query = {};
        }
        if (rest)
          self2.pathname = rest;
        if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
          self2.pathname = "/";
        }
        if (self2.pathname || self2.search) {
          p = self2.pathname || "";
          var s = self2.search || "";
          self2.path = p + s;
        }
        self2.href = format(self2);
        return self2;
      }
      function urlFormat(obj) {
        if (isString$5(obj))
          obj = parse$9({}, obj);
        return format(obj);
      }
      function format(self2) {
        var auth = self2.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }
        var protocol = self2.protocol || "", pathname = self2.pathname || "", hash2 = self2.hash || "", host = false, query = "";
        if (self2.host) {
          host = auth + self2.host;
        } else if (self2.hostname) {
          host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
          if (self2.port) {
            host += ":" + self2.port;
          }
        }
        if (self2.query && isObject$c(self2.query) && Object.keys(self2.query).length) {
          query = stringify$6(self2.query);
        }
        var search = self2.search || query && "?" + query || "";
        if (protocol && protocol.substr(-1) !== ":")
          protocol += ":";
        if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/")
            pathname = "/" + pathname;
        } else if (!host) {
          host = "";
        }
        if (hash2 && hash2.charAt(0) !== "#")
          hash2 = "#" + hash2;
        if (search && search.charAt(0) !== "?")
          search = "?" + search;
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");
        return protocol + host + pathname + search + hash2;
      }
      Url.prototype.format = function() {
        return format(this);
      };
      function urlResolve(source, relative2) {
        return urlParse(source, false, true).resolve(relative2);
      }
      Url.prototype.resolve = function(relative2) {
        return this.resolveObject(urlParse(relative2, false, true)).format();
      };
      function urlResolveObject(source, relative2) {
        if (!source)
          return relative2;
        return urlParse(source, false, true).resolveObject(relative2);
      }
      Url.prototype.resolveObject = function(relative2) {
        if (isString$5(relative2)) {
          var rel = new Url();
          rel.parse(relative2, false, true);
          relative2 = rel;
        }
        var result2 = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result2[tkey] = this[tkey];
        }
        result2.hash = relative2.hash;
        if (relative2.href === "") {
          result2.href = result2.format();
          return result2;
        }
        if (relative2.slashes && !relative2.protocol) {
          var rkeys = Object.keys(relative2);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result2[rkey] = relative2[rkey];
          }
          if (slashedProtocol[result2.protocol] && result2.hostname && !result2.pathname) {
            result2.path = result2.pathname = "/";
          }
          result2.href = result2.format();
          return result2;
        }
        var relPath;
        if (relative2.protocol && relative2.protocol !== result2.protocol) {
          if (!slashedProtocol[relative2.protocol]) {
            var keys2 = Object.keys(relative2);
            for (var v2 = 0; v2 < keys2.length; v2++) {
              var k = keys2[v2];
              result2[k] = relative2[k];
            }
            result2.href = result2.format();
            return result2;
          }
          result2.protocol = relative2.protocol;
          if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
            relPath = (relative2.pathname || "").split("/");
            while (relPath.length && !(relative2.host = relPath.shift()))
              ;
            if (!relative2.host)
              relative2.host = "";
            if (!relative2.hostname)
              relative2.hostname = "";
            if (relPath[0] !== "")
              relPath.unshift("");
            if (relPath.length < 2)
              relPath.unshift("");
            result2.pathname = relPath.join("/");
          } else {
            result2.pathname = relative2.pathname;
          }
          result2.search = relative2.search;
          result2.query = relative2.query;
          result2.host = relative2.host || "";
          result2.auth = relative2.auth;
          result2.hostname = relative2.hostname || relative2.host;
          result2.port = relative2.port;
          if (result2.pathname || result2.search) {
            var p = result2.pathname || "";
            var s = result2.search || "";
            result2.path = p + s;
          }
          result2.slashes = result2.slashes || relative2.slashes;
          result2.href = result2.format();
          return result2;
        }
        var isSourceAbs = result2.pathname && result2.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result2.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result2.pathname && result2.pathname.split("/") || [], psychotic = result2.protocol && !slashedProtocol[result2.protocol];
        relPath = relative2.pathname && relative2.pathname.split("/") || [];
        if (psychotic) {
          result2.hostname = "";
          result2.port = null;
          if (result2.host) {
            if (srcPath[0] === "")
              srcPath[0] = result2.host;
            else
              srcPath.unshift(result2.host);
          }
          result2.host = "";
          if (relative2.protocol) {
            relative2.hostname = null;
            relative2.port = null;
            if (relative2.host) {
              if (relPath[0] === "")
                relPath[0] = relative2.host;
              else
                relPath.unshift(relative2.host);
            }
            relative2.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        var authInHost;
        if (isRelAbs) {
          result2.host = relative2.host || relative2.host === "" ? relative2.host : result2.host;
          result2.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result2.hostname;
          result2.search = relative2.search;
          result2.query = relative2.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result2.search = relative2.search;
          result2.query = relative2.query;
        } else if (!isNullOrUndefined(relative2.search)) {
          if (psychotic) {
            result2.hostname = result2.host = srcPath.shift();
            authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
            if (authInHost) {
              result2.auth = authInHost.shift();
              result2.host = result2.hostname = authInHost.shift();
            }
          }
          result2.search = relative2.search;
          result2.query = relative2.query;
          if (!isNull(result2.pathname) || !isNull(result2.search)) {
            result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
          }
          result2.href = result2.format();
          return result2;
        }
        if (!srcPath.length) {
          result2.pathname = null;
          if (result2.search) {
            result2.path = "/" + result2.search;
          } else {
            result2.path = null;
          }
          result2.href = result2.format();
          return result2;
        }
        var last2 = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result2.host || relative2.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
        var up = 0;
        for (var i2 = srcPath.length; i2 >= 0; i2--) {
          last2 = srcPath[i2];
          if (last2 === ".") {
            srcPath.splice(i2, 1);
          } else if (last2 === "..") {
            srcPath.splice(i2, 1);
            up++;
          } else if (up) {
            srcPath.splice(i2, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result2.hostname = result2.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
          authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
          if (authInHost) {
            result2.auth = authInHost.shift();
            result2.host = result2.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result2.host && srcPath.length;
        if (mustEndAbs && !isAbsolute2) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result2.pathname = null;
          result2.path = null;
        } else {
          result2.pathname = srcPath.join("/");
        }
        if (!isNull(result2.pathname) || !isNull(result2.search)) {
          result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
        }
        result2.auth = relative2.auth || result2.auth;
        result2.slashes = result2.slashes || relative2.slashes;
        result2.href = result2.format();
        return result2;
      };
      Url.prototype.parseHost = function() {
        return parseHost(this);
      };
      function parseHost(self2) {
        var host = self2.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            self2.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host)
          self2.hostname = host;
      }
      var _polyfillNode_url$1 = Object.freeze({
        __proto__: null,
        parse: urlParse,
        resolve: urlResolve,
        resolveObject: urlResolveObject,
        format: urlFormat,
        "default": _polyfillNode_url,
        Url
      });
      var require$$5 = getAugmentedNamespace(_polyfillNode_url$1);
      var require$$6 = getAugmentedNamespace(shared_esmBundler);
      var compilerSsr_cjs = {};
      Object.defineProperty(compilerSsr_cjs, "__esModule", { value: true });
      var compilerDom = require$$0$1;
      var shared$1 = require$$6;
      const SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
      const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
      const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
      const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
      const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
      const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
      const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
      const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
      const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
      const SSR_RENDER_LIST = Symbol(`ssrRenderList`);
      const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
      const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
      const SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
      const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
      const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
      const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
      const ssrHelpers = {
        [SSR_INTERPOLATE]: `ssrInterpolate`,
        [SSR_RENDER_VNODE]: `ssrRenderVNode`,
        [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
        [SSR_RENDER_SLOT]: `ssrRenderSlot`,
        [SSR_RENDER_CLASS]: `ssrRenderClass`,
        [SSR_RENDER_STYLE]: `ssrRenderStyle`,
        [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
        [SSR_RENDER_ATTR]: `ssrRenderAttr`,
        [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
        [SSR_RENDER_LIST]: `ssrRenderList`,
        [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
        [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
        [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
        [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
        [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
        [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`
      };
      compilerDom.registerRuntimeHelpers(ssrHelpers);
      const ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);
      function ssrProcessIf(node2, context, disableNestedFragments = false) {
        const [rootBranch] = node2.branches;
        const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));
        context.pushStatement(ifStatement);
        let currentIf = ifStatement;
        for (let i2 = 1; i2 < node2.branches.length; i2++) {
          const branch = node2.branches[i2];
          const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);
          if (branch.condition) {
            currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);
          } else {
            currentIf.alternate = branchBlockStatement;
          }
        }
        if (!currentIf.alternate) {
          currentIf.alternate = compilerDom.createBlockStatement([
            compilerDom.createCallExpression(`_push`, ["`<!---->`"])
          ]);
        }
      }
      function processIfBranch(branch, context, disableNestedFragments = false) {
        const { children } = branch;
        const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode
        !(children.length === 1 && children[0].type === 11);
        return processChildrenAsStatement(children, context, needFragmentWrapper);
      }
      const ssrTransformFor = compilerDom.createStructuralDirectiveTransform("for", compilerDom.processFor);
      function ssrProcessFor(node2, context, disableNestedFragments = false) {
        const needFragmentWrapper = !disableNestedFragments && (node2.children.length !== 1 || node2.children[0].type !== 1);
        const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node2.parseResult));
        renderLoop.body = processChildrenAsStatement(node2.children, context, needFragmentWrapper);
        if (!disableNestedFragments) {
          context.pushStringPart(`<!--[-->`);
        }
        context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [
          node2.source,
          renderLoop
        ]));
        if (!disableNestedFragments) {
          context.pushStringPart(`<!--]-->`);
        }
      }
      const ssrTransformSlotOutlet = (node2, context) => {
        if (compilerDom.isSlotOutlet(node2)) {
          const { slotName, slotProps } = compilerDom.processSlotOutlet(node2, context);
          const args = [
            `_ctx.$slots`,
            slotName,
            slotProps || `{}`,
            // fallback content placeholder. will be replaced in the process phase
            `null`,
            `_push`,
            `_parent`
          ];
          if (context.scopeId && context.slotted !== false) {
            args.push(`"${context.scopeId}-s"`);
          }
          node2.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_SLOT), args);
        }
      };
      function ssrProcessSlotOutlet(node2, context) {
        const renderCall = node2.ssrCodegenNode;
        if (node2.children.length) {
          const fallbackRenderFn = compilerDom.createFunctionExpression([]);
          fallbackRenderFn.body = processChildrenAsStatement(node2.children, context);
          renderCall.arguments[3] = fallbackRenderFn;
        }
        if (context.withSlotScopeId) {
          const slotScopeId = renderCall.arguments[6];
          renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
        }
        context.pushStatement(node2.ssrCodegenNode);
      }
      function createSSRCompilerError(code2, loc) {
        return compilerDom.createCompilerError(code2, loc, SSRErrorMessages);
      }
      const SSRErrorMessages = {
        [
          60
          /* X_SSR_CUSTOM_DIRECTIVE_NO_TRANSFORM */
        ]: `Custom directive is missing corresponding SSR transform and will be ignored.`,
        [
          61
          /* X_SSR_UNSAFE_ATTR_NAME */
        ]: `Unsafe attribute name for SSR.`,
        [
          62
          /* X_SSR_NO_TELEPORT_TARGET */
        ]: `Missing the 'to' prop on teleport element.`,
        [
          63
          /* X_SSR_INVALID_AST_NODE */
        ]: `Invalid AST node during SSR transform.`
      };
      function ssrProcessTeleport(node2, context) {
        const targetProp = compilerDom.findProp(node2, "to");
        if (!targetProp) {
          context.onError(createSSRCompilerError(62, node2.loc));
          return;
        }
        let target;
        if (targetProp.type === 6) {
          target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);
        } else {
          target = targetProp.exp;
        }
        if (!target) {
          context.onError(createSSRCompilerError(62, targetProp.loc));
          return;
        }
        const disabledProp = compilerDom.findProp(
          node2,
          "disabled",
          false,
          true
          /* allow empty */
        );
        const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
        const contentRenderFn = compilerDom.createFunctionExpression(
          [`_push`],
          void 0,
          // Body is added later
          true,
          // newline
          false,
          // isSlot
          node2.loc
        );
        contentRenderFn.body = processChildrenAsStatement(node2.children, context);
        context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
          `_push`,
          contentRenderFn,
          target,
          disabled,
          `_parent`
        ]));
      }
      const wipMap = /* @__PURE__ */ new WeakMap();
      function ssrTransformSuspense(node2, context) {
        return () => {
          if (node2.children.length) {
            const wipEntry = {
              slotsExp: null,
              wipSlots: []
            };
            wipMap.set(node2, wipEntry);
            wipEntry.slotsExp = compilerDom.buildSlots(node2, context, (_props, children, loc) => {
              const fn = compilerDom.createFunctionExpression(
                [],
                void 0,
                // no return, assign body later
                true,
                // newline
                false,
                // suspense slots are not treated as normal slots
                loc
              );
              wipEntry.wipSlots.push({
                fn,
                children
              });
              return fn;
            }).slots;
          }
        };
      }
      function ssrProcessSuspense(node2, context) {
        const wipEntry = wipMap.get(node2);
        if (!wipEntry) {
          return;
        }
        const { slotsExp, wipSlots } = wipEntry;
        for (let i2 = 0; i2 < wipSlots.length; i2++) {
          const { fn, children } = wipSlots[i2];
          fn.body = processChildrenAsStatement(children, context);
        }
        context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
          `_push`,
          slotsExp
        ]));
      }
      function ssrProcessTransitionGroup(node2, context) {
        const tag2 = compilerDom.findProp(node2, "tag");
        if (tag2) {
          if (tag2.type === 7) {
            context.pushStringPart(`<`);
            context.pushStringPart(tag2.exp);
            context.pushStringPart(`>`);
            processChildren(
              node2.children,
              context,
              false,
              /**
               * TransitionGroup has the special runtime behavior of flattening and
               * concatenating all children into a single fragment (in order for them to
               * be pathced using the same key map) so we need to account for that here
               * by disabling nested fragment wrappers from being generated.
               */
              true
            );
            context.pushStringPart(`</`);
            context.pushStringPart(tag2.exp);
            context.pushStringPart(`>`);
          } else {
            context.pushStringPart(`<${tag2.value.content}>`);
            processChildren(node2.children, context, false, true);
            context.pushStringPart(`</${tag2.value.content}>`);
          }
        } else {
          processChildren(node2.children, context, true, true);
        }
      }
      const wipMap$1 = /* @__PURE__ */ new WeakMap();
      const componentTypeMap = /* @__PURE__ */ new WeakMap();
      const ssrTransformComponent = (node2, context) => {
        if (node2.type !== 1 || node2.tagType !== 1) {
          return;
        }
        const component = compilerDom.resolveComponentType(
          node2,
          context,
          true
          /* ssr */
        );
        componentTypeMap.set(node2, component);
        if (shared$1.isSymbol(component)) {
          if (component === compilerDom.SUSPENSE) {
            return ssrTransformSuspense(node2, context);
          }
          return;
        }
        const vnodeBranches = [];
        const clonedNode = clone(node2);
        return function ssrPostTransformComponent() {
          if (clonedNode.children.length) {
            compilerDom.buildSlots(clonedNode, context, (props2, children) => {
              vnodeBranches.push(createVNodeSlotBranch(props2, children, context));
              return compilerDom.createFunctionExpression(void 0);
            });
          }
          const props = node2.props.length > 0 ? (
            // note we are not passing ssr: true here because for components, v-on
            // handlers should still be passed
            compilerDom.buildProps(node2, context).props || `null`
          ) : `null`;
          const wipEntries = [];
          wipMap$1.set(node2, wipEntries);
          const buildSSRSlotFn = (props2, children, loc) => {
            const fn = compilerDom.createFunctionExpression(
              [props2 || `_`, `_push`, `_parent`, `_scopeId`],
              void 0,
              // no return, assign body later
              true,
              // newline
              true,
              // isSlot
              loc
            );
            wipEntries.push({
              fn,
              children,
              // also collect the corresponding vnode branch built earlier
              vnodeBranch: vnodeBranches[wipEntries.length]
            });
            return fn;
          };
          const slots = node2.children.length ? compilerDom.buildSlots(node2, context, buildSSRSlotFn).slots : `null`;
          if (typeof component !== "string") {
            node2.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [
              `_push`,
              compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [
                component,
                props,
                slots
              ]),
              `_parent`
            ]);
          } else {
            node2.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, props, slots, `_parent`]);
          }
        };
      };
      function ssrProcessComponent(node2, context) {
        const component = componentTypeMap.get(node2);
        if (!node2.ssrCodegenNode) {
          if (component === compilerDom.TELEPORT) {
            return ssrProcessTeleport(node2, context);
          } else if (component === compilerDom.SUSPENSE) {
            return ssrProcessSuspense(node2, context);
          } else if (component === compilerDom.TRANSITION_GROUP) {
            return ssrProcessTransitionGroup(node2, context);
          } else {
            processChildren(node2.children, context);
          }
        } else {
          const wipEntries = wipMap$1.get(node2) || [];
          for (let i2 = 0; i2 < wipEntries.length; i2++) {
            const { fn, children, vnodeBranch } = wipEntries[i2];
            fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(
              children,
              context,
              false,
              true
              /* withSlotScopeId */
            ), vnodeBranch);
          }
          if (context.withSlotScopeId) {
            node2.ssrCodegenNode.arguments.push(`_scopeId`);
          }
          if (typeof component === "string") {
            context.pushStatement(compilerDom.createCallExpression(`_push`, [node2.ssrCodegenNode]));
          } else {
            context.pushStatement(node2.ssrCodegenNode);
          }
        }
      }
      const rawOptionsMap = /* @__PURE__ */ new WeakMap();
      const [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);
      const vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];
      const vnodeDirectiveTransforms = {
        ...baseDirectiveTransforms,
        ...compilerDom.DOMDirectiveTransforms
      };
      function createVNodeSlotBranch(props, children, parentContext) {
        const rawOptions = rawOptionsMap.get(parentContext.root);
        const subOptions = {
          ...rawOptions,
          // overwrite with vnode-based transforms
          nodeTransforms: [
            ...vnodeNodeTransforms,
            ...rawOptions.nodeTransforms || []
          ],
          directiveTransforms: {
            ...vnodeDirectiveTransforms,
            ...rawOptions.directiveTransforms || {}
          }
        };
        const wrapperNode = {
          type: 1,
          ns: 0,
          tag: "template",
          tagType: 3,
          isSelfClosing: false,
          // important: provide v-slot="props" on the wrapper for proper
          // scope analysis
          props: [
            {
              type: 7,
              name: "slot",
              exp: props,
              arg: void 0,
              modifiers: [],
              loc: compilerDom.locStub
            }
          ],
          children,
          loc: compilerDom.locStub,
          codegenNode: void 0
        };
        subTransform(wrapperNode, subOptions, parentContext);
        return compilerDom.createReturnStatement(children);
      }
      function subTransform(node2, options2, parentContext) {
        const childRoot = compilerDom.createRoot([node2]);
        const childContext = compilerDom.createTransformContext(childRoot, options2);
        childContext.ssr = false;
        childContext.scopes = { ...parentContext.scopes };
        childContext.identifiers = { ...parentContext.identifiers };
        childContext.imports = parentContext.imports;
        compilerDom.traverseNode(childRoot, childContext);
        ["helpers", "components", "directives"].forEach((key) => {
          childContext[key].forEach((value, helperKey) => {
            if (key === "helpers") {
              const parentCount = parentContext.helpers.get(helperKey);
              if (parentCount === void 0) {
                parentContext.helpers.set(helperKey, value);
              } else {
                parentContext.helpers.set(helperKey, value + parentCount);
              }
            } else {
              parentContext[key].add(value);
            }
          });
        });
      }
      function clone(v2) {
        if (shared$1.isArray(v2)) {
          return v2.map(clone);
        } else if (shared$1.isObject(v2)) {
          const res = {};
          for (const key in v2) {
            res[key] = clone(v2[key]);
          }
          return res;
        } else {
          return v2;
        }
      }
      const rawChildrenMap = /* @__PURE__ */ new WeakMap();
      const ssrTransformElement = (node2, context) => {
        if (node2.type !== 1 || node2.tagType !== 0) {
          return;
        }
        return function ssrPostTransformElement() {
          const openTag = [`<${node2.tag}`];
          const needTagForRuntime = node2.tag === "textarea" || node2.tag.indexOf("-") > 0;
          const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node2);
          if (hasDynamicVBind) {
            const { props } = compilerDom.buildProps(
              node2,
              context,
              node2.props,
              true
              /* ssr */
            );
            if (props) {
              const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [props]);
              if (node2.tag === "textarea") {
                const existingText = node2.children[0];
                if (!existingText || existingText.type !== 5) {
                  const tempId = `_temp${context.temps++}`;
                  propsExp.arguments = [
                    compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), props)
                  ];
                  rawChildrenMap.set(node2, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
                    compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`"value" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)
                  ]));
                }
              } else if (node2.tag === "input") {
                const vModel = findVModel(node2);
                if (vModel) {
                  const tempId = `_temp${context.temps++}`;
                  const tempExp = compilerDom.createSimpleExpression(tempId, false);
                  propsExp.arguments = [
                    compilerDom.createSequenceExpression([
                      compilerDom.createAssignmentExpression(tempExp, props),
                      compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [
                        tempExp,
                        compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                          tempExp,
                          vModel.exp
                          // model
                        ])
                      ])
                    ])
                  ];
                }
              }
              if (needTagForRuntime) {
                propsExp.arguments.push(`"${node2.tag}"`);
              }
              openTag.push(propsExp);
            }
          }
          let dynamicClassBinding = void 0;
          let staticClassBinding = void 0;
          let dynamicStyleBinding = void 0;
          for (let i2 = 0; i2 < node2.props.length; i2++) {
            const prop = node2.props[i2];
            if (node2.tag === "input" && isTrueFalseValue(prop)) {
              continue;
            }
            if (prop.type === 7) {
              if (prop.name === "html" && prop.exp) {
                rawChildrenMap.set(node2, prop.exp);
              } else if (prop.name === "text" && prop.exp) {
                node2.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
              } else if (prop.name === "slot") {
                context.onError(compilerDom.createCompilerError(39, prop.loc));
              } else if (isTextareaWithValue(node2, prop) && prop.exp) {
                if (!hasDynamicVBind) {
                  node2.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
                }
              } else {
                const directiveTransform = context.directiveTransforms[prop.name];
                if (!directiveTransform) {
                  context.onError(createSSRCompilerError(60, prop.loc));
                } else if (!hasDynamicVBind) {
                  const { props, ssrTagParts } = directiveTransform(prop, node2, context);
                  if (ssrTagParts) {
                    openTag.push(...ssrTagParts);
                  }
                  for (let j = 0; j < props.length; j++) {
                    const { key, value } = props[j];
                    if (compilerDom.isStaticExp(key)) {
                      let attrName = key.content;
                      if (attrName === "key" || attrName === "ref") {
                        continue;
                      }
                      if (attrName === "class") {
                        openTag.push(` class="`, dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `"`);
                      } else if (attrName === "style") {
                        if (dynamicStyleBinding) {
                          mergeCall(dynamicStyleBinding, value);
                        } else {
                          openTag.push(` style="`, dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `"`);
                        }
                      } else {
                        attrName = node2.tag.indexOf("-") > 0 ? attrName : shared$1.propsToAttrMap[attrName] || attrName.toLowerCase();
                        if (shared$1.isBooleanAttr(attrName)) {
                          openTag.push(compilerDom.createConditionalExpression(
                            value,
                            compilerDom.createSimpleExpression(" " + attrName, true),
                            compilerDom.createSimpleExpression("", true),
                            false
                            /* no newline */
                          ));
                        } else if (shared$1.isSSRSafeAttrName(attrName)) {
                          openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [
                            key,
                            value
                          ]));
                        } else {
                          context.onError(createSSRCompilerError(61, key.loc));
                        }
                      }
                    } else {
                      const args = [key, value];
                      if (needTagForRuntime) {
                        args.push(`"${node2.tag}"`);
                      }
                      openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
                    }
                  }
                }
              }
            } else {
              if (node2.tag === "textarea" && prop.name === "value" && prop.value) {
                rawChildrenMap.set(node2, shared$1.escapeHtml(prop.value.content));
              } else if (!hasDynamicVBind) {
                if (prop.name === "key" || prop.name === "ref") {
                  continue;
                }
                if (prop.name === "class" && prop.value) {
                  staticClassBinding = JSON.stringify(prop.value.content);
                }
                openTag.push(` ${prop.name}` + (prop.value ? `="${shared$1.escapeHtml(prop.value.content)}"` : ``));
              }
            }
          }
          if (dynamicClassBinding && staticClassBinding) {
            mergeCall(dynamicClassBinding, staticClassBinding);
            removeStaticBinding(openTag, "class");
          }
          if (context.scopeId) {
            openTag.push(` ${context.scopeId}`);
          }
          node2.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);
        };
      };
      function isTrueFalseValue(prop) {
        if (prop.type === 7) {
          return prop.name === "bind" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
        } else {
          return prop.name === "true-value" || prop.name === "false-value";
        }
      }
      function isTextareaWithValue(node2, prop) {
        return !!(node2.tag === "textarea" && prop.name === "bind" && compilerDom.isBindKey(prop.arg, "value"));
      }
      function mergeCall(call, arg) {
        const existing = call.arguments[0];
        if (existing.type === 17) {
          existing.elements.push(arg);
        } else {
          call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);
        }
      }
      function removeStaticBinding(tag2, binding2) {
        const regExp = new RegExp(`^ ${binding2}=".+"$`);
        const i2 = tag2.findIndex((e) => typeof e === "string" && regExp.test(e));
        if (i2 > -1) {
          tag2.splice(i2, 1);
        }
      }
      function findVModel(node2) {
        return node2.props.find((p) => p.type === 7 && p.name === "model" && p.exp);
      }
      function ssrProcessElement(node2, context) {
        const isVoidTag2 = context.options.isVoidTag || shared$1.NO;
        const elementsToAdd = node2.ssrCodegenNode.elements;
        for (let j = 0; j < elementsToAdd.length; j++) {
          context.pushStringPart(elementsToAdd[j]);
        }
        if (context.withSlotScopeId) {
          context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));
        }
        context.pushStringPart(`>`);
        const rawChildren = rawChildrenMap.get(node2);
        if (rawChildren) {
          context.pushStringPart(rawChildren);
        } else if (node2.children.length) {
          processChildren(node2.children, context);
        }
        if (!isVoidTag2(node2.tag)) {
          context.pushStringPart(`</${node2.tag}>`);
        }
      }
      function ssrCodegenTransform(ast, options2) {
        const context = createSSRTransformContext(ast, options2);
        if (options2.ssrCssVars) {
          const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options2.ssrCssVars, false), compilerDom.createTransformContext(compilerDom.createRoot([]), options2));
          context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));
        }
        const isFragment2 = ast.children.length > 1 && ast.children.some((c) => !compilerDom.isText(c));
        processChildren(ast.children, context, isFragment2);
        ast.codegenNode = compilerDom.createBlockStatement(context.body);
        ast.ssrHelpers = Array.from(/* @__PURE__ */ new Set([
          ...ast.helpers.filter((h) => h in ssrHelpers),
          ...context.helpers
        ]));
        ast.helpers = ast.helpers.filter((h) => !(h in ssrHelpers));
      }
      function createSSRTransformContext(root2, options2, helpers2 = /* @__PURE__ */ new Set(), withSlotScopeId = false) {
        const body = [];
        let currentString = null;
        return {
          root: root2,
          options: options2,
          body,
          helpers: helpers2,
          withSlotScopeId,
          onError: options2.onError || ((e) => {
            throw e;
          }),
          helper(name2) {
            helpers2.add(name2);
            return name2;
          },
          pushStringPart(part) {
            if (!currentString) {
              const currentCall = compilerDom.createCallExpression(`_push`);
              body.push(currentCall);
              currentString = compilerDom.createTemplateLiteral([]);
              currentCall.arguments.push(currentString);
            }
            const bufferedElements = currentString.elements;
            const lastItem = bufferedElements[bufferedElements.length - 1];
            if (shared$1.isString(part) && shared$1.isString(lastItem)) {
              bufferedElements[bufferedElements.length - 1] += part;
            } else {
              bufferedElements.push(part);
            }
          },
          pushStatement(statement) {
            currentString = null;
            body.push(statement);
          }
        };
      }
      function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
        return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
      }
      function processChildren(children, context, asFragment = false, disableNestedFragments = false) {
        if (asFragment) {
          context.pushStringPart(`<!--[-->`);
        }
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          switch (child.type) {
            case 1:
              switch (child.tagType) {
                case 0:
                  ssrProcessElement(child, context);
                  break;
                case 1:
                  ssrProcessComponent(child, context);
                  break;
                case 2:
                  ssrProcessSlotOutlet(child, context);
                  break;
                case 3:
                  break;
                default:
                  context.onError(createSSRCompilerError(63, child.loc));
                  const exhaustiveCheck2 = child;
                  return exhaustiveCheck2;
              }
              break;
            case 2:
              context.pushStringPart(shared$1.escapeHtml(child.content));
              break;
            case 3:
              context.pushStringPart(`<!--${child.content}-->`);
              break;
            case 5:
              context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));
              break;
            case 9:
              ssrProcessIf(child, context, disableNestedFragments);
              break;
            case 11:
              ssrProcessFor(child, context, disableNestedFragments);
              break;
            case 10:
              break;
            case 12:
            case 8:
              break;
            default:
              context.onError(createSSRCompilerError(63, child.loc));
              const exhaustiveCheck = child;
              return exhaustiveCheck;
          }
        }
        if (asFragment) {
          context.pushStringPart(`<!--]-->`);
        }
      }
      function processChildrenAsStatement(children, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
        const childContext = createChildContext(parentContext, withSlotScopeId);
        processChildren(children, childContext, asFragment);
        return compilerDom.createBlockStatement(childContext.body);
      }
      const ssrTransformModel = (dir, node2, context) => {
        const model = dir.exp;
        function checkDuplicatedValue() {
          const value = compilerDom.findProp(node2, "value");
          if (value) {
            context.onError(compilerDom.createDOMCompilerError(56, value.loc));
          }
        }
        if (node2.tagType === 0) {
          const res = { props: [] };
          const defaultProps = [
            // default value binding for text type inputs
            compilerDom.createObjectProperty(`value`, model)
          ];
          if (node2.tag === "input") {
            const type2 = compilerDom.findProp(node2, "type");
            if (type2) {
              const value = findValueBinding(node2);
              if (type2.type === 7) {
                res.ssrTagParts = [
                  compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
                    type2.exp,
                    model,
                    value
                  ])
                ];
              } else if (type2.value) {
                switch (type2.value.content) {
                  case "radio":
                    res.props = [
                      compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                        model,
                        value
                      ]))
                    ];
                    break;
                  case "checkbox":
                    const trueValueBinding = compilerDom.findProp(node2, "true-value");
                    if (trueValueBinding) {
                      const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                      res.props = [
                        compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                          model,
                          trueValue
                        ]))
                      ];
                    } else {
                      res.props = [
                        compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                          model,
                          value
                        ]), model))
                      ];
                    }
                    break;
                  case "file":
                    context.onError(compilerDom.createDOMCompilerError(55, dir.loc));
                    break;
                  default:
                    checkDuplicatedValue();
                    res.props = defaultProps;
                    break;
                }
              }
            } else if (compilerDom.hasDynamicKeyVBind(node2))
              ;
            else {
              checkDuplicatedValue();
              res.props = defaultProps;
            }
          } else if (node2.tag === "textarea") {
            checkDuplicatedValue();
            node2.children = [compilerDom.createInterpolation(model, model.loc)];
          } else if (node2.tag === "select")
            ;
          else {
            context.onError(compilerDom.createDOMCompilerError(53, dir.loc));
          }
          return res;
        } else {
          return compilerDom.transformModel(dir, node2, context);
        }
      };
      function findValueBinding(node2) {
        const valueBinding = compilerDom.findProp(node2, "value");
        return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);
      }
      const ssrTransformShow = (dir, node2, context) => {
        if (!dir.exp) {
          context.onError(compilerDom.createDOMCompilerError(
            57
            /* X_V_SHOW_NO_EXPRESSION */
          ));
        }
        return {
          props: [
            compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(
              dir.exp,
              compilerDom.createSimpleExpression(`null`, false),
              compilerDom.createObjectExpression([
                compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))
              ]),
              false
              /* no newline */
            ))
          ]
        };
      };
      const hasSingleChild = (node2) => node2.children.filter(
        (n2) => n2.type !== 3
        /* COMMENT */
      ).length === 1;
      const ssrInjectFallthroughAttrs = (node2, context) => {
        if (node2.type === 0) {
          context.identifiers._attrs = 1;
        }
        const parent = context.parent;
        if (!parent || parent.type !== 0) {
          return;
        }
        if (node2.type === 10 && hasSingleChild(node2)) {
          injectFallthroughAttrs(node2.children[0]);
        } else if (hasSingleChild(parent)) {
          injectFallthroughAttrs(node2);
        }
      };
      function injectFallthroughAttrs(node2) {
        if (node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1) && !compilerDom.findDir(node2, "for")) {
          node2.props.push({
            type: 7,
            name: "bind",
            arg: void 0,
            exp: compilerDom.createSimpleExpression(`_attrs`, false),
            modifiers: [],
            loc: compilerDom.locStub
          });
        }
      }
      const ssrInjectCssVars = (node2, context) => {
        if (!context.ssrCssVars) {
          return;
        }
        if (node2.type === 0) {
          context.identifiers._cssVars = 1;
        }
        const parent = context.parent;
        if (!parent || parent.type !== 0) {
          return;
        }
        if (node2.type === 10) {
          for (const child of node2.children) {
            injectCssVars(child);
          }
        } else {
          injectCssVars(node2);
        }
      };
      function injectCssVars(node2) {
        if (node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1) && !compilerDom.findDir(node2, "for")) {
          if (compilerDom.isBuiltInType(node2.tag, "Suspense")) {
            for (const child of node2.children) {
              if (child.type === 1 && child.tagType === 3) {
                child.children.forEach(injectCssVars);
              } else {
                injectCssVars(child);
              }
            }
          } else {
            node2.props.push({
              type: 7,
              name: "bind",
              arg: void 0,
              exp: compilerDom.createSimpleExpression(`_cssVars`, false),
              modifiers: [],
              loc: compilerDom.locStub
            });
          }
        }
      }
      function compile(template, options2 = {}) {
        options2 = {
          ...options2,
          // apply DOM-specific parsing options
          ...compilerDom.parserOptions,
          ssr: true,
          scopeId: options2.mode === "function" ? null : options2.scopeId,
          // always prefix since compiler-ssr doesn't have size concern
          prefixIdentifiers: true,
          // disable optimizations that are unnecessary for ssr
          cacheHandlers: false,
          hoistStatic: false
        };
        const ast = compilerDom.baseParse(template, options2);
        rawOptionsMap.set(ast, options2);
        compilerDom.transform(ast, {
          ...options2,
          nodeTransforms: [
            ssrTransformIf,
            ssrTransformFor,
            compilerDom.trackVForSlotScopes,
            compilerDom.transformExpression,
            ssrTransformSlotOutlet,
            ssrInjectFallthroughAttrs,
            ssrInjectCssVars,
            ssrTransformElement,
            ssrTransformComponent,
            compilerDom.trackSlotScopes,
            compilerDom.transformStyle,
            ...options2.nodeTransforms || []
            // user transforms
          ],
          directiveTransforms: {
            // reusing core v-bind
            bind: compilerDom.transformBind,
            // model and show has dedicated SSR handling
            model: ssrTransformModel,
            show: ssrTransformShow,
            // the following are ignored during SSR
            on: compilerDom.noopDirectiveTransform,
            cloak: compilerDom.noopDirectiveTransform,
            once: compilerDom.noopDirectiveTransform,
            ...options2.directiveTransforms || {}
            // user transforms
          }
        });
        ssrCodegenTransform(ast, options2);
        return compilerDom.generate(ast, options2);
      }
      compilerSsr_cjs.compile = compile;
      let { red, bold, gray, options: colorette } = require$$4$1;
      let terminalHighlight$1 = require$$4$1;
      class CssSyntaxError$3 extends Error {
        constructor(message, line, column, source, file, plugin2) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin2) {
            this.plugin = plugin2;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            this.line = line;
            this.column = column;
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CssSyntaxError$3);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color) {
          if (!this.source)
            return "";
          let css = this.source;
          if (color == null)
            color = colorette.enabled;
          if (terminalHighlight$1) {
            if (color)
              css = terminalHighlight$1(css);
          }
          let lines2 = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines2.length);
          let maxWidth = String(end).length;
          let mark, aside;
          if (color) {
            mark = (text) => bold(red(text));
            aside = (text) => gray(text);
          } else {
            mark = aside = (str2) => str2;
          }
          return lines2.slice(start, end).map((line, index) => {
            let number = start + 1 + index;
            let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
            if (number === this.line) {
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + line;
          }).join("\n");
        }
        toString() {
          let code2 = this.showSourceCode();
          if (code2) {
            code2 = "\n\n" + code2 + "\n";
          }
          return this.name + ": " + this.message + code2;
        }
      }
      var cssSyntaxError = CssSyntaxError$3;
      CssSyntaxError$3.default = CssSyntaxError$3;
      const DEFAULT_RAW = {
        colon: ": ",
        indent: "    ",
        beforeDecl: "\n",
        beforeRule: "\n",
        beforeOpen: " ",
        beforeClose: "\n",
        beforeComment: "\n",
        after: "\n",
        emptyBody: "",
        commentLeft: " ",
        commentRight: " ",
        semicolon: false
      };
      function capitalize$1(str2) {
        return str2[0].toUpperCase() + str2.slice(1);
      }
      class Stringifier$2 {
        constructor(builder) {
          this.builder = builder;
        }
        stringify(node2, semicolon2) {
          this[node2.type](node2, semicolon2);
        }
        root(node2) {
          this.root = node2;
          this.body(node2);
          if (node2.raws.after)
            this.builder(node2.raws.after);
        }
        comment(node2) {
          let left = this.raw(node2, "left", "commentLeft");
          let right = this.raw(node2, "right", "commentRight");
          this.builder("/*" + left + node2.text + right + "*/", node2);
        }
        decl(node2, semicolon2) {
          let between = this.raw(node2, "between", "colon");
          let string2 = node2.prop + between + this.rawValue(node2, "value");
          if (node2.important) {
            string2 += node2.raws.important || " !important";
          }
          if (semicolon2)
            string2 += ";";
          this.builder(string2, node2);
        }
        rule(node2) {
          this.block(node2, this.rawValue(node2, "selector"));
          if (node2.raws.ownSemicolon) {
            this.builder(node2.raws.ownSemicolon, node2, "end");
          }
        }
        atrule(node2, semicolon2) {
          let name2 = "@" + node2.name;
          let params = node2.params ? this.rawValue(node2, "params") : "";
          if (typeof node2.raws.afterName !== "undefined") {
            name2 += node2.raws.afterName;
          } else if (params) {
            name2 += " ";
          }
          if (node2.nodes) {
            this.block(node2, name2 + params);
          } else {
            let end = (node2.raws.between || "") + (semicolon2 ? ";" : "");
            this.builder(name2 + params + end, node2);
          }
        }
        body(node2) {
          let last2 = node2.nodes.length - 1;
          while (last2 > 0) {
            if (node2.nodes[last2].type !== "comment")
              break;
            last2 -= 1;
          }
          let semicolon2 = this.raw(node2, "semicolon");
          for (let i2 = 0; i2 < node2.nodes.length; i2++) {
            let child = node2.nodes[i2];
            let before = this.raw(child, "before");
            if (before)
              this.builder(before);
            this.stringify(child, last2 !== i2 || semicolon2);
          }
        }
        block(node2, start) {
          let between = this.raw(node2, "between", "beforeOpen");
          this.builder(start + between + "{", node2, "start");
          let after;
          if (node2.nodes && node2.nodes.length) {
            this.body(node2);
            after = this.raw(node2, "after");
          } else {
            after = this.raw(node2, "after", "emptyBody");
          }
          if (after)
            this.builder(after);
          this.builder("}", node2, "end");
        }
        raw(node2, own, detect) {
          let value;
          if (!detect)
            detect = own;
          if (own) {
            value = node2.raws[own];
            if (typeof value !== "undefined")
              return value;
          }
          let parent = node2.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node2) {
              return "";
            }
          }
          if (!parent)
            return DEFAULT_RAW[detect];
          let root2 = node2.root();
          if (!root2.rawCache)
            root2.rawCache = {};
          if (typeof root2.rawCache[detect] !== "undefined") {
            return root2.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node2, detect);
          } else {
            let method2 = "raw" + capitalize$1(detect);
            if (this[method2]) {
              value = this[method2](root2, node2);
            } else {
              root2.walk((i2) => {
                value = i2.raws[own];
                if (typeof value !== "undefined")
                  return false;
              });
            }
          }
          if (typeof value === "undefined")
            value = DEFAULT_RAW[detect];
          root2.rawCache[detect] = value;
          return value;
        }
        rawSemicolon(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
              value = i2.raws.semicolon;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawEmptyBody(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length === 0) {
              value = i2.raws.after;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawIndent(root2) {
          if (root2.raws.indent)
            return root2.raws.indent;
          let value;
          root2.walk((i2) => {
            let p = i2.parent;
            if (p && p !== root2 && p.parent && p.parent === root2) {
              if (typeof i2.raws.before !== "undefined") {
                let parts = i2.raws.before.split("\n");
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value;
        }
        rawBeforeComment(root2, node2) {
          let value;
          root2.walkComments((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node2, null, "beforeDecl");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeDecl(root2, node2) {
          let value;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node2, null, "beforeRule");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeRule(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
              if (typeof i2.raws.before !== "undefined") {
                value = i2.raws.before;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawBeforeClose(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length > 0) {
              if (typeof i2.raws.after !== "undefined") {
                value = i2.raws.after;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawBeforeOpen(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.type !== "decl") {
              value = i2.raws.between;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawColon(root2) {
          let value;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.between !== "undefined") {
              value = i2.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value;
        }
        beforeAfter(node2, detect) {
          let value;
          if (node2.type === "decl") {
            value = this.raw(node2, null, "beforeDecl");
          } else if (node2.type === "comment") {
            value = this.raw(node2, null, "beforeComment");
          } else if (detect === "before") {
            value = this.raw(node2, null, "beforeRule");
          } else {
            value = this.raw(node2, null, "beforeClose");
          }
          let buf = node2.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value.includes("\n")) {
            let indent = this.raw(node2, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++)
                value += indent;
            }
          }
          return value;
        }
        rawValue(node2, prop) {
          let value = node2[prop];
          let raw = node2.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }
          return value;
        }
      }
      var stringifier = Stringifier$2;
      var symbols = {};
      symbols.isClean = Symbol("isClean");
      let Stringifier$1 = stringifier;
      function stringify$5(node2, builder) {
        let str2 = new Stringifier$1(builder);
        str2.stringify(node2);
      }
      var stringify_1$1 = stringify$5;
      stringify$5.default = stringify$5;
      let CssSyntaxError$2 = cssSyntaxError;
      let Stringifier = stringifier;
      let { isClean: isClean$2 } = symbols;
      let stringify$4 = stringify_1$1;
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
            continue;
          }
          if (i2 === "proxyCache")
            continue;
          let value = obj[i2];
          let type2 = typeof value;
          if (i2 === "parent" && type2 === "object") {
            if (parent)
              cloned[i2] = parent;
          } else if (i2 === "source") {
            cloned[i2] = value;
          } else if (Array.isArray(value)) {
            cloned[i2] = value.map((j) => cloneNode(j, cloned));
          } else {
            if (type2 === "object" && value !== null)
              value = cloneNode(value);
            cloned[i2] = value;
          }
        }
        return cloned;
      }
      class Node$5 {
        constructor(defaults2 = {}) {
          this.raws = {};
          this[isClean$2] = false;
          for (let name2 in defaults2) {
            if (name2 === "nodes") {
              this.nodes = [];
              for (let node2 of defaults2[name2]) {
                if (typeof node2.clone === "function") {
                  this.append(node2.clone());
                } else {
                  this.append(node2);
                }
              }
            } else {
              this[name2] = defaults2[name2];
            }
          }
        }
        error(message, opts = {}) {
          if (this.source) {
            let pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
          }
          return new CssSyntaxError$2(message);
        }
        warn(result2, text, opts) {
          let data2 = { node: this };
          for (let i2 in opts)
            data2[i2] = opts[i2];
          return result2.warn(text, data2);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        toString(stringifier2 = stringify$4) {
          if (stringifier2.stringify)
            stringifier2 = stringifier2.stringify;
          let result2 = "";
          stringifier2(this, (i2) => {
            result2 += i2;
          });
          return result2;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name2 in overrides) {
            cloned[name2] = overrides[name2];
          }
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node2 of nodes) {
              if (node2 === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node2);
                bookmark = node2;
              } else {
                this.parent.insertBefore(bookmark, node2);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        next() {
          if (!this.parent)
            return void 0;
          let index = this.parent.index(this);
          return this.parent.nodes[index + 1];
        }
        prev() {
          if (!this.parent)
            return void 0;
          let index = this.parent.index(this);
          return this.parent.nodes[index - 1];
        }
        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }
        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }
        root() {
          let result2 = this;
          while (result2.parent)
            result2 = result2.parent;
          return result2;
        }
        raw(prop, defaultType) {
          let str2 = new Stringifier();
          return str2.raw(this, prop, defaultType);
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween)
            delete this.raws.between;
        }
        toJSON() {
          let fixed = {};
          for (let name2 in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name2)) {
              continue;
            }
            if (name2 === "parent")
              continue;
            let value = this[name2];
            if (Array.isArray(value)) {
              fixed[name2] = value.map((i2) => {
                if (typeof i2 === "object" && i2.toJSON) {
                  return i2.toJSON();
                } else {
                  return i2;
                }
              });
            } else if (typeof value === "object" && value.toJSON) {
              fixed[name2] = value.toJSON();
            } else {
              fixed[name2] = value;
            }
          }
          return fixed;
        }
        positionInside(index) {
          let string2 = this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;
          for (let i2 = 0; i2 < index; i2++) {
            if (string2[i2] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { line, column };
        }
        positionBy(opts) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index);
          } else if (opts.word) {
            let index = this.toString().indexOf(opts.word);
            if (index !== -1)
              pos = this.positionInside(index);
          }
          return pos;
        }
        getProxyProcessor() {
          return {
            set(node2, prop, value) {
              if (node2[prop] === value)
                return true;
              node2[prop] = value;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
                node2.markDirty();
              }
              return true;
            },
            get(node2, prop) {
              if (prop === "proxyOf") {
                return node2;
              } else if (prop === "root") {
                return () => node2.root().toProxy();
              } else {
                return node2[prop];
              }
            }
          };
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        addToError(error2) {
          error2.postcssNode = this;
          if (error2.stack && this.source && /\n\s{4}at /.test(error2.stack)) {
            let s = this.source;
            error2.stack = error2.stack.replace(
              /\n\s{4}at /,
              `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
            );
          }
          return error2;
        }
        markDirty() {
          if (this[isClean$2]) {
            this[isClean$2] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean$2] = false;
            }
          }
        }
        get proxyOf() {
          return this;
        }
      }
      var node_1 = Node$5;
      Node$5.default = Node$5;
      let Node$4 = node_1;
      class Declaration$3 extends Node$4 {
        constructor(defaults2) {
          if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
            defaults2 = { ...defaults2, value: String(defaults2.value) };
          }
          super(defaults2);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      }
      var declaration = Declaration$3;
      Declaration$3.default = Declaration$3;
      let { dirname: dirname$1, resolve: resolve$1, relative, sep } = require$$3;
      let { pathToFileURL: pathToFileURL$1 } = require$$5;
      let mozilla$1 = sourceMap$2;
      class MapGenerator$1 {
        constructor(stringify2, root2, opts) {
          this.stringify = stringify2;
          this.mapOpts = opts.map || {};
          this.root = root2;
          this.opts = opts;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk((node2) => {
              if (node2.source && node2.source.input.map) {
                let map2 = node2.source.input.map;
                if (!this.previousMaps.includes(map2)) {
                  this.previousMaps.push(map2);
                }
              }
            });
          }
          return this.previousMaps;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.inline);
          }
          return true;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.withContent());
          }
          return true;
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false)
            return;
          let node2;
          for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
            node2 = this.root.nodes[i2];
            if (node2.type !== "comment")
              continue;
            if (node2.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i2);
            }
          }
        }
        setSourcesContent() {
          let already = {};
          this.root.walk((node2) => {
            if (node2.source) {
              let from2 = node2.source.input.from;
              if (from2 && !already[from2]) {
                already[from2] = true;
                this.map.setSourceContent(
                  this.toUrl(this.path(from2)),
                  node2.source.input.css
                );
              }
            }
          });
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from2 = this.toUrl(this.path(prev.file));
            let root2 = prev.root || dirname$1(prev.file);
            let map2;
            if (this.mapOpts.sourcesContent === false) {
              map2 = new mozilla$1.SourceMapConsumer(prev.text);
              if (map2.sourcesContent) {
                map2.sourcesContent = map2.sourcesContent.map(() => null);
              }
            } else {
              map2 = prev.consumer();
            }
            this.map.applySourceMap(map2, from2, this.toUrl(this.path(root2)));
          }
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.annotation);
          }
          return true;
        }
        toBase64(str2) {
          if (Buffer$1) {
            return Buffer$1.from(str2).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str2)));
          }
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n"))
            eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          }
          if (this.opts.from) {
            return this.path(this.opts.from);
          }
          return "to.css";
        }
        generateMap() {
          this.generateString();
          if (this.isSourcesContent())
            this.setSourcesContent();
          if (this.previous().length > 0)
            this.applyPrevMaps();
          if (this.isAnnotation())
            this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          }
          return [this.css, this.map];
        }
        path(file) {
          if (file.indexOf("<") === 0)
            return file;
          if (/^\w+:\/\//.test(file))
            return file;
          if (this.mapOpts.absolute)
            return file;
          let from2 = this.opts.to ? dirname$1(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from2 = dirname$1(resolve$1(from2, this.mapOpts.annotation));
          }
          file = relative(from2, file);
          return file;
        }
        toUrl(path2) {
          if (sep === "\\") {
            path2 = path2.replace(/\\/g, "/");
          }
          return encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
        }
        sourcePath(node2) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.mapOpts.absolute) {
            return pathToFileURL$1(node2.source.input.from).toString();
          } else {
            return this.toUrl(this.path(node2.source.input.from));
          }
        }
        generateString() {
          this.css = "";
          this.map = new mozilla$1.SourceMapGenerator({ file: this.outputFile() });
          let line = 1;
          let column = 1;
          let lines2, last2;
          this.stringify(this.root, (str2, node2, type2) => {
            this.css += str2;
            if (node2 && type2 !== "end") {
              if (node2.source && node2.source.start) {
                this.map.addMapping({
                  source: this.sourcePath(node2),
                  generated: { line, column: column - 1 },
                  original: {
                    line: node2.source.start.line,
                    column: node2.source.start.column - 1
                  }
                });
              } else {
                this.map.addMapping({
                  source: "<no source>",
                  original: { line: 1, column: 0 },
                  generated: { line, column: column - 1 }
                });
              }
            }
            lines2 = str2.match(/\n/g);
            if (lines2) {
              line += lines2.length;
              last2 = str2.lastIndexOf("\n");
              column = str2.length - last2;
            } else {
              column += str2.length;
            }
            if (node2 && type2 !== "start") {
              let p = node2.parent || { raws: {} };
              if (node2.type !== "decl" || node2 !== p.last || p.raws.semicolon) {
                if (node2.source && node2.source.end) {
                  this.map.addMapping({
                    source: this.sourcePath(node2),
                    generated: { line, column: column - 2 },
                    original: {
                      line: node2.source.end.line,
                      column: node2.source.end.column - 1
                    }
                  });
                } else {
                  this.map.addMapping({
                    source: "<no source>",
                    original: { line: 1, column: 0 },
                    generated: { line, column: column - 1 }
                  });
                }
              }
            }
          });
        }
        generate() {
          this.clearAnnotation();
          if (this.isMap()) {
            return this.generateMap();
          }
          let result2 = "";
          this.stringify(this.root, (i2) => {
            result2 += i2;
          });
          return [result2];
        }
      }
      var mapGenerator = MapGenerator$1;
      let printed = {};
      var warnOnce$2 = function warnOnce2(message) {
        if (printed[message])
          return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
      class Warning$2 {
        constructor(text, opts = {}) {
          this.type = "warning";
          this.text = text;
          if (opts.node && opts.node.source) {
            let pos = opts.node.positionBy(opts);
            this.line = pos.line;
            this.column = pos.column;
          }
          for (let opt in opts)
            this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              plugin: this.plugin,
              index: this.index,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      }
      var warning = Warning$2;
      Warning$2.default = Warning$2;
      let Warning$1 = warning;
      class Result$2 {
        constructor(processor2, root2, opts) {
          this.processor = processor2;
          this.messages = [];
          this.root = root2;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning2 = new Warning$1(text, opts);
          this.messages.push(warning2);
          return warning2;
        }
        warnings() {
          return this.messages.filter((i2) => i2.type === "warning");
        }
        get content() {
          return this.css;
        }
      }
      var result = Result$2;
      Result$2.default = Result$2;
      let Node$3 = node_1;
      class Comment$3 extends Node$3 {
        constructor(defaults2) {
          super(defaults2);
          this.type = "comment";
        }
      }
      var comment$6 = Comment$3;
      Comment$3.default = Comment$3;
      let Declaration$2 = declaration;
      let { isClean: isClean$1 } = symbols;
      let Comment$2 = comment$6;
      let Node$2 = node_1;
      let parse$8, Rule$3, AtRule$3;
      function cleanSource(nodes) {
        return nodes.map((i2) => {
          if (i2.nodes)
            i2.nodes = cleanSource(i2.nodes);
          delete i2.source;
          return i2;
        });
      }
      function markDirtyUp(node2) {
        node2[isClean$1] = false;
        if (node2.proxyOf.nodes) {
          for (let i2 of node2.proxyOf.nodes) {
            markDirtyUp(i2);
          }
        }
      }
      function rebuild(node2) {
        if (node2.type === "atrule") {
          Object.setPrototypeOf(node2, AtRule$3.prototype);
        } else if (node2.type === "rule") {
          Object.setPrototypeOf(node2, Rule$3.prototype);
        } else if (node2.type === "decl") {
          Object.setPrototypeOf(node2, Declaration$2.prototype);
        } else if (node2.type === "comment") {
          Object.setPrototypeOf(node2, Comment$2.prototype);
        }
        if (node2.nodes) {
          node2.nodes.forEach((child) => {
            rebuild(child);
          });
        }
      }
      class Container$5 extends Node$2 {
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        each(callback) {
          if (!this.proxyOf.nodes)
            return void 0;
          let iterator = this.getIterator();
          let index, result2;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index = this.indexes[iterator];
            result2 = callback(this.proxyOf.nodes[index], index);
            if (result2 === false)
              break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result2;
        }
        walk(callback) {
          return this.each((child, i2) => {
            let result2;
            try {
              result2 = callback(child, i2);
            } catch (e) {
              throw child.addToError(e);
            }
            if (result2 !== false && child.walk) {
              result2 = child.walk(callback);
            }
            return result2;
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i2) => {
              if (child.type === "decl") {
                return callback(child, i2);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i2);
            }
          });
        }
        walkRules(selector2, callback) {
          if (!callback) {
            callback = selector2;
            return this.walk((child, i2) => {
              if (child.type === "rule") {
                return callback(child, i2);
              }
            });
          }
          if (selector2 instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "rule" && selector2.test(child.selector)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "rule" && child.selector === selector2) {
              return callback(child, i2);
            }
          });
        }
        walkAtRules(name2, callback) {
          if (!callback) {
            callback = name2;
            return this.walk((child, i2) => {
              if (child.type === "atrule") {
                return callback(child, i2);
              }
            });
          }
          if (name2 instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "atrule" && name2.test(child.name)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "atrule" && child.name === name2) {
              return callback(child, i2);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i2) => {
            if (child.type === "comment") {
              return callback(child, i2);
            }
          });
        }
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node2 of nodes)
              this.proxyOf.nodes.push(node2);
          }
          this.markDirty();
          return this;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node2 of nodes)
              this.proxyOf.nodes.unshift(node2);
            for (let id2 in this.indexes) {
              this.indexes[id2] = this.indexes[id2] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node2 of this.nodes)
              node2.cleanRaws(keepBetween);
          }
        }
        insertBefore(exist, add) {
          exist = this.index(exist);
          let type2 = exist === 0 ? "prepend" : false;
          let nodes = this.normalize(add, this.proxyOf.nodes[exist], type2).reverse();
          for (let node2 of nodes)
            this.proxyOf.nodes.splice(exist, 0, node2);
          let index;
          for (let id2 in this.indexes) {
            index = this.indexes[id2];
            if (exist <= index) {
              this.indexes[id2] = index + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertAfter(exist, add) {
          exist = this.index(exist);
          let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
          for (let node2 of nodes)
            this.proxyOf.nodes.splice(exist + 1, 0, node2);
          let index;
          for (let id2 in this.indexes) {
            index = this.indexes[id2];
            if (exist < index) {
              this.indexes[id2] = index + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index;
          for (let id2 in this.indexes) {
            index = this.indexes[id2];
            if (index >= child) {
              this.indexes[id2] = index - 1;
            }
          }
          this.markDirty();
          return this;
        }
        removeAll() {
          for (let node2 of this.proxyOf.nodes)
            node2.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl) => {
            if (opts.props && !opts.props.includes(decl.prop))
              return;
            if (opts.fast && !decl.value.includes(opts.fast))
              return;
            decl.value = decl.value.replace(pattern, callback);
          });
          this.markDirty();
          return this;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        index(child) {
          if (typeof child === "number")
            return child;
          if (child.proxyOf)
            child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        get first() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse$8(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent)
                i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type === "root") {
            nodes = nodes.nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent)
                i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration$2(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule$3(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule$3(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment$2(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i2) => {
            if (typeof i2.markDirty !== "function")
              rebuild(i2);
            if (i2.parent)
              i2.parent.removeChild(i2);
            if (i2[isClean$1])
              markDirtyUp(i2);
            if (typeof i2.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i2.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i2.parent = this;
            return i2;
          });
          return processed;
        }
        getProxyProcessor() {
          return {
            set(node2, prop, value) {
              if (node2[prop] === value)
                return true;
              node2[prop] = value;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node2.markDirty();
              }
              return true;
            },
            get(node2, prop) {
              if (prop === "proxyOf") {
                return node2;
              } else if (!node2[prop]) {
                return node2[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node2[prop](
                    ...args.map((i2) => {
                      if (typeof i2 === "function") {
                        return (child, index) => i2(child.toProxy(), index);
                      } else {
                        return i2;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node2[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node2.root().toProxy();
              } else if (prop === "nodes") {
                return node2.nodes.map((i2) => i2.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node2[prop].toProxy();
              } else {
                return node2[prop];
              }
            }
          };
        }
        getIterator() {
          if (!this.lastEach)
            this.lastEach = 0;
          if (!this.indexes)
            this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
      }
      Container$5.registerParse = (dependant) => {
        parse$8 = dependant;
      };
      Container$5.registerRule = (dependant) => {
        Rule$3 = dependant;
      };
      Container$5.registerAtRule = (dependant) => {
        AtRule$3 = dependant;
      };
      var container$2 = Container$5;
      Container$5.default = Container$5;
      const SINGLE_QUOTE = "'".charCodeAt(0);
      const DOUBLE_QUOTE = '"'.charCodeAt(0);
      const BACKSLASH = "\\".charCodeAt(0);
      const SLASH = "/".charCodeAt(0);
      const NEWLINE = "\n".charCodeAt(0);
      const SPACE = " ".charCodeAt(0);
      const FEED = "\f".charCodeAt(0);
      const TAB = "	".charCodeAt(0);
      const CR = "\r".charCodeAt(0);
      const OPEN_SQUARE = "[".charCodeAt(0);
      const CLOSE_SQUARE = "]".charCodeAt(0);
      const OPEN_PARENTHESES = "(".charCodeAt(0);
      const CLOSE_PARENTHESES = ")".charCodeAt(0);
      const OPEN_CURLY = "{".charCodeAt(0);
      const CLOSE_CURLY = "}".charCodeAt(0);
      const SEMICOLON = ";".charCodeAt(0);
      const ASTERISK = "*".charCodeAt(0);
      const COLON = ":".charCodeAt(0);
      const AT = "@".charCodeAt(0);
      const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      const RE_BAD_BRACKET = /.[\n"'(/\\]/;
      const RE_HEX_ESCAPE = /[\da-f]/i;
      var tokenize$3 = function tokenizer2(input2, options2 = {}) {
        let css = input2.css.valueOf();
        let ignore = options2.ignoreErrors;
        let code2, next, quote, content, escape2;
        let escaped, escapePos, prev, n2, currentToken;
        let length = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position() {
          return pos;
        }
        function unclosed(what) {
          throw input2.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }
        function nextToken(opts) {
          if (returned.length)
            return returned.pop();
          if (pos >= length)
            return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code2 = css.charCodeAt(pos);
          switch (code2) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED: {
              next = pos;
              do {
                next += 1;
                code2 = css.charCodeAt(next);
              } while (code2 === SPACE || code2 === NEWLINE || code2 === TAB || code2 === CR || code2 === FEED);
              currentToken = ["space", css.slice(pos, next)];
              pos = next - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code2);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n2 = css.charCodeAt(pos + 1);
              if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(")", next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                next = css.indexOf(")", pos + 1);
                content = css.slice(pos, next + 1);
                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next];
                  pos = next;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code2 === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case BACKSLASH: {
              next = pos;
              escape2 = true;
              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape2 = !escape2;
              }
              code2 = css.charCodeAt(next + 1);
              if (escape2 && code2 !== SLASH && code2 !== SPACE && code2 !== NEWLINE && code2 !== TAB && code2 !== CR && code2 !== FEED) {
                next += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                    next += 1;
                  }
                  if (css.charCodeAt(next + 1) === SPACE) {
                    next += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            default: {
              if (code2 === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next = css.indexOf("*/", pos + 2) + 1;
                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next + 1), pos, next];
                buffer.push(currentToken);
                pos = next;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          nextToken,
          endOfFile,
          position
        };
      };
      let Container$4 = container$2;
      class AtRule$2 extends Container$4 {
        constructor(defaults2) {
          super(defaults2);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.prepend(...children);
        }
      }
      var atRule = AtRule$2;
      AtRule$2.default = AtRule$2;
      Container$4.registerAtRule(AtRule$2);
      let Container$3 = container$2;
      let LazyResult$3, Processor$2;
      class Root$4 extends Container$3 {
        constructor(defaults2) {
          super(defaults2);
          this.type = "root";
          if (!this.nodes)
            this.nodes = [];
        }
        removeChild(child, ignore) {
          let index = this.index(child);
          if (!ignore && index === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index].raws.before;
          }
          return super.removeChild(child);
        }
        normalize(child, sample, type2) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type2 === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node2 of nodes) {
                node2.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        toResult(opts = {}) {
          let lazy = new LazyResult$3(new Processor$2(), this, opts);
          return lazy.stringify();
        }
      }
      Root$4.registerLazyResult = (dependant) => {
        LazyResult$3 = dependant;
      };
      Root$4.registerProcessor = (dependant) => {
        Processor$2 = dependant;
      };
      var root$5 = Root$4;
      Root$4.default = Root$4;
      let list$2 = {
        split(string2, separators, last2) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let quote = false;
          let escape2 = false;
          for (let letter of string2) {
            if (quote) {
              if (escape2) {
                escape2 = false;
              } else if (letter === "\\") {
                escape2 = true;
              } else if (letter === quote) {
                quote = false;
              }
            } else if (letter === '"' || letter === "'") {
              quote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0)
                func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter))
                split = true;
            }
            if (split) {
              if (current !== "")
                array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last2 || current !== "")
            array.push(current.trim());
          return array;
        },
        space(string2) {
          let spaces = [" ", "\n", "	"];
          return list$2.split(string2, spaces);
        },
        comma(string2) {
          return list$2.split(string2, [","], true);
        }
      };
      var list_1 = list$2;
      list$2.default = list$2;
      let Container$2 = container$2;
      let list$1 = list_1;
      class Rule$2 extends Container$2 {
        constructor(defaults2) {
          super(defaults2);
          this.type = "rule";
          if (!this.nodes)
            this.nodes = [];
        }
        get selectors() {
          return list$1.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep2);
        }
      }
      var rule = Rule$2;
      Rule$2.default = Rule$2;
      Container$2.registerRule(Rule$2);
      let Declaration$1 = declaration;
      let tokenizer = tokenize$3;
      let Comment$1 = comment$6;
      let AtRule$1 = atRule;
      let Root$3 = root$5;
      let Rule$1 = rule;
      class Parser$2 {
        constructor(input2) {
          this.input = input2;
          this.root = new Root$3();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.customProperty = false;
          this.createTokenizer();
          this.root.source = { input: input2, start: { offset: 0, line: 1, column: 1 } };
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        comment(token) {
          let node2 = new Comment$1();
          this.init(node2, token[2]);
          node2.source.end = this.getPosition(token[3] || token[2]);
          let text = token[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node2.text = "";
            node2.raws.left = text;
            node2.raws.right = "";
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node2.text = match[2];
            node2.raws.left = match[1];
            node2.raws.right = match[3];
          }
        }
        emptyRule(token) {
          let node2 = new Rule$1();
          this.init(node2, token[2]);
          node2.selector = "";
          node2.raws.between = "";
          this.current = node2;
        }
        other(start) {
          let end = false;
          let type2 = null;
          let colon2 = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type2 = token[0];
            tokens.push(token);
            if (type2 === "(" || type2 === "[") {
              if (!bracket)
                bracket = token;
              brackets.push(type2 === "(" ? ")" : "]");
            } else if (customProperty && colon2 && type2 === "{") {
              if (!bracket)
                bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type2 === ";") {
                if (colon2) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type2 === "{") {
                this.rule(tokens);
                return;
              } else if (type2 === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type2 === ":") {
                colon2 = true;
              }
            } else if (type2 === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0)
                bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile())
            end = true;
          if (brackets.length > 0)
            this.unclosedBracket(bracket);
          if (end && colon2) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        rule(tokens) {
          tokens.pop();
          let node2 = new Rule$1();
          this.init(node2, tokens[0][2]);
          node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node2, "selector", tokens);
          this.current = node2;
        }
        decl(tokens, customProperty) {
          let node2 = new Declaration$1();
          this.init(node2, tokens[0][2]);
          let last2 = tokens[tokens.length - 1];
          if (last2[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node2.source.end = this.getPosition(last2[3] || last2[2]);
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1)
              this.unknownWord(tokens);
            node2.raws.before += tokens.shift()[1];
          }
          node2.source.start = this.getPosition(tokens[0][2]);
          node2.prop = "";
          while (tokens.length) {
            let type2 = tokens[0][0];
            if (type2 === ":" || type2 === "space" || type2 === "comment") {
              break;
            }
            node2.prop += tokens.shift()[1];
          }
          node2.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node2.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node2.raws.between += token[1];
            }
          }
          if (node2.prop[0] === "_" || node2.prop[0] === "*") {
            node2.raws.before += node2.prop[0];
            node2.prop = node2.prop.slice(1);
          }
          let firstSpaces = this.spacesAndCommentsFromStart(tokens);
          this.precheckMissedSemicolon(tokens);
          for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
            token = tokens[i2];
            if (token[1].toLowerCase() === "!important") {
              node2.important = true;
              let string2 = this.stringFrom(tokens, i2);
              string2 = this.spacesFromEnd(tokens) + string2;
              if (string2 !== " !important")
                node2.raws.important = string2;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache = tokens.slice(0);
              let str2 = "";
              for (let j = i2; j > 0; j--) {
                let type2 = cache[j][0];
                if (str2.trim().indexOf("!") === 0 && type2 !== "space") {
                  break;
                }
                str2 = cache.pop()[1] + str2;
              }
              if (str2.trim().indexOf("!") === 0) {
                node2.important = true;
                node2.raws.important = str2;
                tokens = cache;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
          this.raw(node2, "value", tokens);
          if (hasWord) {
            node2.raws.between += firstSpaces;
          } else {
            node2.value = firstSpaces + node2.value;
          }
          if (node2.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        atrule(token) {
          let node2 = new AtRule$1();
          node2.name = token[1].slice(1);
          if (node2.name === "") {
            this.unnamedAtrule(node2, token);
          }
          this.init(node2, token[2]);
          let type2;
          let prev;
          let shift;
          let last2 = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type2 = token[0];
            if (type2 === "(" || type2 === "[") {
              brackets.push(type2 === "(" ? ")" : "]");
            } else if (type2 === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type2 === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type2 === ";") {
                node2.source.end = this.getPosition(token[2]);
                this.semicolon = true;
                break;
              } else if (type2 === "{") {
                open = true;
                break;
              } else if (type2 === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node2.source.end = this.getPosition(prev[3] || prev[2]);
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last2 = true;
              break;
            }
          }
          node2.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node2.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node2, "params", params);
            if (last2) {
              token = params[params.length - 1];
              node2.source.end = this.getPosition(token[3] || token[2]);
              this.spaces = node2.raws.between;
              node2.raws.between = "";
            }
          } else {
            node2.raws.afterName = "";
            node2.params = "";
          }
          if (open) {
            node2.nodes = [];
            this.current = node2;
          }
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent)
            this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            offset,
            line: pos.line,
            column: pos.col
          };
        }
        init(node2, offset) {
          this.current.push(node2);
          node2.source = {
            start: this.getPosition(offset),
            input: this.input
          };
          node2.raws.before = this.spaces;
          this.spaces = "";
          if (node2.type !== "comment")
            this.semicolon = false;
        }
        raw(node2, prop, tokens) {
          let token, type2;
          let length = tokens.length;
          let value = "";
          let clean = true;
          let next, prev;
          let pattern = /^([#.|])?(\w)+/i;
          for (let i2 = 0; i2 < length; i2 += 1) {
            token = tokens[i2];
            type2 = token[0];
            if (type2 === "comment" && node2.type === "rule") {
              prev = tokens[i2 - 1];
              next = tokens[i2 + 1];
              if (prev[0] !== "space" && next[0] !== "space" && pattern.test(prev[1]) && pattern.test(next[1])) {
                value += token[1];
              } else {
                clean = false;
              }
              continue;
            }
            if (type2 === "comment" || type2 === "space" && i2 === length - 1) {
              clean = false;
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i2) => all + i2[1], "");
            node2.raws[prop] = { value, raw };
          }
          node2[prop] = value;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = "";
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from2) {
          let result2 = "";
          for (let i2 = from2; i2 < tokens.length; i2++) {
            result2 += tokens[i2][1];
          }
          tokens.splice(from2, tokens.length - from2);
          return result2;
        }
        colon(tokens) {
          let brackets = 0;
          let token, type2, prev;
          for (let [i2, element] of tokens.entries()) {
            token = element;
            type2 = token[0];
            if (type2 === "(") {
              brackets += 1;
            }
            if (type2 === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type2 === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i2;
              }
            }
            prev = token;
          }
          return false;
        }
        // Errors
        unclosedBracket(bracket) {
          throw this.input.error("Unclosed bracket", bracket[2]);
        }
        unknownWord(tokens) {
          throw this.input.error("Unknown word", tokens[0][2]);
        }
        unexpectedClose(token) {
          throw this.input.error("Unexpected }", token[2]);
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        doubleColon(token) {
          throw this.input.error("Double colon", token[2]);
        }
        unnamedAtrule(node2, token) {
          throw this.input.error("At-rule without name", token[2]);
        }
        precheckMissedSemicolon() {
        }
        checkMissedSemicolon(tokens) {
          let colon2 = this.colon(tokens);
          if (colon2 === false)
            return;
          let founded = 0;
          let token;
          for (let j = colon2 - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2)
                break;
            }
          }
          throw this.input.error("Missed semicolon", token[2]);
        }
      }
      var parser$4 = Parser$2;
      let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id2 = "";
          let i2 = size;
          while (i2--) {
            id2 += alphabet[Math.random() * alphabet.length | 0];
          }
          return id2;
        };
      };
      let nanoid$1 = (size = 21) => {
        let id2 = "";
        let i2 = size;
        while (i2--) {
          id2 += urlAlphabet[Math.random() * 64 | 0];
        }
        return id2;
      };
      var nonSecure = { nanoid: nanoid$1, customAlphabet };
      var _vfileLocation_3_2_0_vfileLocation = factory;
      function factory(file) {
        var value = String(file);
        var indices = [];
        var search = /\r?\n|\r/g;
        while (search.exec(value)) {
          indices.push(search.lastIndex);
        }
        indices.push(value.length + 1);
        return {
          toPoint: offsetToPoint,
          toPosition: offsetToPoint,
          toOffset: pointToOffset
        };
        function offsetToPoint(offset) {
          var index = -1;
          if (offset > -1 && offset < indices[indices.length - 1]) {
            while (++index < indices.length) {
              if (indices[index] > offset) {
                return {
                  line: index + 1,
                  column: offset - (indices[index - 1] || 0) + 1,
                  offset
                };
              }
            }
          }
          return {};
        }
        function pointToOffset(point) {
          var line = point && point.line;
          var column = point && point.column;
          var offset;
          if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
            offset = (indices[line - 2] || 0) + column - 1 || 0;
          }
          return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
        }
      }
      let { existsSync, readFileSync } = require$$4$1;
      let { dirname, join } = require$$3;
      let mozilla = sourceMap$2;
      function fromBase64(str2) {
        if (Buffer$1) {
          return Buffer$1.from(str2, "base64").toString();
        } else {
          return window.atob(str2);
        }
      }
      class PreviousMap$1 {
        constructor(css, opts) {
          if (opts.map === false)
            return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile)
            this.root = dirname(this.mapFile);
          if (text)
            this.text = text;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new mozilla.SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
        startWith(string2, start) {
          if (!string2)
            return false;
          return string2.substr(0, start.length) === start;
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1].trim();
        }
        loadAnnotation(css) {
          let annotations = css.match(/\/\*\s*# sourceMappingURL=.*\s*\*\//gm);
          if (annotations && annotations.length > 0) {
            let lastAnnotation = annotations[annotations.length - 1];
            if (lastAnnotation) {
              this.annotation = this.getAnnotationURL(lastAnnotation);
            }
          }
        }
        decodeInline(text) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          if (charsetUri.test(text) || uri.test(text)) {
            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
          }
          if (baseCharsetUri.test(text) || baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
          }
          let encoding = text.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        loadFile(path2) {
          this.root = dirname(path2);
          if (existsSync(path2)) {
            this.mapFile = path2;
            return readFileSync(path2, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false)
            return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map2 = this.loadFile(prevPath);
                if (!map2) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map2;
              }
            } else if (prev instanceof mozilla.SourceMapConsumer) {
              return mozilla.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof mozilla.SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map2 = this.annotation;
            if (file)
              map2 = join(dirname(file), map2);
            return this.loadFile(map2);
          }
        }
        isMap(map2) {
          if (typeof map2 !== "object")
            return false;
          return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
        }
      }
      var previousMap = PreviousMap$1;
      PreviousMap$1.default = PreviousMap$1;
      let { fileURLToPath, pathToFileURL } = require$$5;
      let { resolve, isAbsolute } = require$$3;
      let { nanoid } = nonSecure;
      let vfileLocation = _vfileLocation_3_2_0_vfileLocation;
      let terminalHighlight = require$$4$1;
      let CssSyntaxError$1 = cssSyntaxError;
      let PreviousMap = previousMap;
      class Input$2 {
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "￾") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (/^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }
          let map2 = new PreviousMap(this.css, opts);
          if (map2.text) {
            this.map = map2;
            let file = map2.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map)
            this.map.file = this.from;
        }
        fromOffset(offset) {
          let finder = vfileLocation(this.css);
          this.fromOffset = (i2) => {
            let position = finder.toPoint(i2);
            return {
              line: position.line,
              col: position.column
            };
          };
          return this.fromOffset(offset);
        }
        error(message, line, column, opts = {}) {
          let result2;
          if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column);
          if (origin) {
            result2 = new CssSyntaxError$1(
              message,
              origin.line,
              origin.column,
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result2 = new CssSyntaxError$1(
              message,
              line,
              column,
              this.css,
              this.file,
              opts.plugin
            );
          }
          result2.input = { line, column, source: this.css };
          if (this.file) {
            result2.input.url = pathToFileURL(this.file).toString();
            result2.input.file = this.file;
          }
          return result2;
        }
        origin(line, column) {
          if (!this.map)
            return false;
          let consumer = this.map.consumer();
          let from2 = consumer.originalPositionFor({ line, column });
          if (!from2.source)
            return false;
          let fromUrl;
          if (isAbsolute(from2.source)) {
            fromUrl = pathToFileURL(from2.source);
          } else {
            fromUrl = new URL(
              from2.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result2 = {
            url: fromUrl.toString(),
            line: from2.line,
            column: from2.column
          };
          if (fromUrl.protocol === "file:") {
            result2.file = fileURLToPath(fromUrl);
          }
          let source = consumer.sourceContentFor(from2.source);
          if (source)
            result2.source = source;
          return result2;
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        get from() {
          return this.file || this.id;
        }
      }
      var input = Input$2;
      Input$2.default = Input$2;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input$2);
      }
      let Container$1 = container$2;
      let Parser$1 = parser$4;
      let Input$1 = input;
      function parse$7(css, opts) {
        let input2 = new Input$1(css, opts);
        let parser2 = new Parser$1(input2);
        try {
          parser2.parse();
        } catch (e) {
          if (browser$1$1.env.NODE_ENV !== "production") {
            if (e.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e;
        }
        return parser2.root;
      }
      var parse_1$1 = parse$7;
      parse$7.default = parse$7;
      Container$1.registerParse(parse$7);
      let MapGenerator = mapGenerator;
      let { isClean } = symbols;
      let stringify$3 = stringify_1$1;
      let warnOnce$1 = warnOnce$2;
      let Result$1 = result;
      let parse$6 = parse_1$1;
      let Root$2 = root$5;
      const TYPE_TO_CLASS_NAME = {
        root: "Root",
        atrule: "AtRule",
        rule: "Rule",
        decl: "Declaration",
        comment: "Comment"
      };
      const CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node2) {
        let key = false;
        let type2 = TYPE_TO_CLASS_NAME[node2.type];
        if (node2.type === "decl") {
          key = node2.prop.toLowerCase();
        } else if (node2.type === "atrule") {
          key = node2.name.toLowerCase();
        }
        if (key && node2.append) {
          return [
            type2,
            type2 + "-" + key,
            CHILDREN,
            type2 + "Exit",
            type2 + "Exit-" + key
          ];
        } else if (key) {
          return [type2, type2 + "-" + key, type2 + "Exit", type2 + "Exit-" + key];
        } else if (node2.append) {
          return [type2, CHILDREN, type2 + "Exit"];
        } else {
          return [type2, type2 + "Exit"];
        }
      }
      function toStack(node2) {
        let events;
        if (node2.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node2);
        }
        return {
          node: node2,
          events,
          eventIndex: 0,
          visitors: [],
          visitorIndex: 0,
          iterator: 0
        };
      }
      function cleanMarks(node2) {
        node2[isClean] = false;
        if (node2.nodes)
          node2.nodes.forEach((i2) => cleanMarks(i2));
        return node2;
      }
      let postcss$2 = {};
      class LazyResult$2 {
        constructor(processor2, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root2;
          if (typeof css === "object" && css !== null && css.type === "root") {
            root2 = cleanMarks(css);
          } else if (css instanceof LazyResult$2 || css instanceof Result$1) {
            root2 = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined")
                opts.map = {};
              if (!opts.map.inline)
                opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser2 = parse$6;
            if (opts.syntax)
              parser2 = opts.syntax.parse;
            if (opts.parser)
              parser2 = opts.parser;
            if (parser2.parse)
              parser2 = parser2.parse;
            try {
              root2 = parser2(css, opts);
            } catch (error2) {
              this.processed = true;
              this.error = error2;
            }
          }
          this.result = new Result$1(processor2, root2, opts);
          this.helpers = { ...postcss$2, result: this.result, postcss: postcss$2 };
          this.plugins = this.processor.plugins.map((plugin2) => {
            if (typeof plugin2 === "object" && plugin2.prepare) {
              return { ...plugin2, ...plugin2.prepare(this.result) };
            } else {
              return plugin2;
            }
          });
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
        get processor() {
          return this.result.processor;
        }
        get opts() {
          return this.result.opts;
        }
        get css() {
          return this.stringify().css;
        }
        get content() {
          return this.stringify().content;
        }
        get map() {
          return this.stringify().map;
        }
        get root() {
          return this.sync().root;
        }
        get messages() {
          return this.sync().messages;
        }
        warnings() {
          return this.sync().warnings();
        }
        toString() {
          return this.css;
        }
        then(onFulfilled, onRejected) {
          if (browser$1$1.env.NODE_ENV !== "production") {
            if (!("from" in this.opts)) {
              warnOnce$1(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          if (this.processed)
            return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        sync() {
          if (this.error)
            throw this.error;
          if (this.processed)
            return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin2 of this.plugins) {
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              this.walkSync(root2);
            }
            if (this.listeners.OnceExit) {
              this.visitSync(this.listeners.OnceExit, root2);
            }
          }
          return this.result;
        }
        stringify() {
          if (this.error)
            throw this.error;
          if (this.stringified)
            return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str2 = stringify$3;
          if (opts.syntax)
            str2 = opts.syntax.stringify;
          if (opts.stringifier)
            str2 = opts.stringifier;
          if (str2.stringify)
            str2 = str2.stringify;
          let map2 = new MapGenerator(str2, this.result.root, this.result.opts);
          let data2 = map2.generate();
          this.result.css = data2[0];
          this.result.map = data2[1];
          return this.result;
        }
        walkSync(node2) {
          node2[isClean] = true;
          let events = getEvents(node2);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node2.nodes) {
                node2.each((child) => {
                  if (!child[isClean])
                    this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node2.toProxy()))
                  return;
              }
            }
          }
        }
        visitSync(visitors, node2) {
          for (let [plugin2, visitor] of visitors) {
            this.result.lastPlugin = plugin2;
            let promise;
            try {
              promise = visitor(node2, this.helpers);
            } catch (e) {
              throw this.handleError(e, node2.proxyOf);
            }
            if (node2.type !== "root" && !node2.parent)
              return true;
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        runOnRoot(plugin2) {
          this.result.lastPlugin = plugin2;
          try {
            if (typeof plugin2 === "object" && plugin2.Once) {
              return plugin2.Once(this.result.root, this.helpers);
            } else if (typeof plugin2 === "function") {
              return plugin2(this.result.root, this.result);
            }
          } catch (error2) {
            throw this.handleError(error2);
          }
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error2, node2) {
          let plugin2 = this.result.lastPlugin;
          try {
            if (node2)
              node2.addToError(error2);
            this.error = error2;
            if (error2.name === "CssSyntaxError" && !error2.plugin) {
              error2.plugin = plugin2.postcssPlugin;
              error2.setMessage();
            } else if (plugin2.postcssVersion) {
              if (browser$1$1.env.NODE_ENV !== "production") {
                let pluginName = plugin2.postcssPlugin;
                let pluginVer = plugin2.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a = pluginVer.split(".");
                let b2 = runtimeVer.split(".");
                if (a[0] !== b2[0] || parseInt(a[1]) > parseInt(b2[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error)
              console.error(err);
          }
          return error2;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i2 = 0; i2 < this.plugins.length; i2++) {
            let plugin2 = this.plugins[i2];
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error2) {
                throw this.handleError(error2);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              let stack = [toStack(root2)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e) {
                    let node2 = stack[stack.length - 1].node;
                    throw this.handleError(e, node2);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin2, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin2;
                try {
                  await visitor(root2, this.helpers);
                } catch (e) {
                  throw this.handleError(e);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        prepareVisitors() {
          this.listeners = {};
          let add = (plugin2, type2, cb) => {
            if (!this.listeners[type2])
              this.listeners[type2] = [];
            this.listeners[type2].push([plugin2, cb]);
          };
          for (let plugin2 of this.plugins) {
            if (typeof plugin2 === "object") {
              for (let type2 of [
                "Root",
                "Declaration",
                "Rule",
                "AtRule",
                "Comment",
                "DeclarationExit",
                "RuleExit",
                "AtRuleExit",
                "CommentExit",
                "RootExit",
                "OnceExit"
              ]) {
                if (typeof plugin2[type2] === "object") {
                  for (let filter2 in plugin2[type2]) {
                    if (filter2 === "*") {
                      add(plugin2, type2, plugin2[type2][filter2]);
                    } else {
                      add(
                        plugin2,
                        type2 + "-" + filter2.toLowerCase(),
                        plugin2[type2][filter2]
                      );
                    }
                  }
                } else if (typeof plugin2[type2] === "function") {
                  add(plugin2, type2, plugin2[type2]);
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        visitTick(stack) {
          let visit2 = stack[stack.length - 1];
          let { node: node2, visitors } = visit2;
          if (node2.type !== "root" && !node2.parent) {
            stack.pop();
            return;
          }
          if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
            let [plugin2, visitor] = visitors[visit2.visitorIndex];
            visit2.visitorIndex += 1;
            if (visit2.visitorIndex === visitors.length) {
              visit2.visitors = [];
              visit2.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin2;
            try {
              return visitor(node2.toProxy(), this.helpers);
            } catch (e) {
              throw this.handleError(e, node2);
            }
          }
          if (visit2.iterator !== 0) {
            let iterator = visit2.iterator;
            let child;
            while (child = node2.nodes[node2.indexes[iterator]]) {
              node2.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit2.iterator = 0;
            delete node2.indexes[iterator];
          }
          let events = visit2.events;
          while (visit2.eventIndex < events.length) {
            let event = events[visit2.eventIndex];
            visit2.eventIndex += 1;
            if (event === CHILDREN) {
              if (node2.nodes && node2.nodes.length) {
                node2[isClean] = true;
                visit2.iterator = node2.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit2.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
      }
      LazyResult$2.registerPostcss = (dependant) => {
        postcss$2 = dependant;
      };
      var lazyResult = LazyResult$2;
      LazyResult$2.default = LazyResult$2;
      Root$2.registerLazyResult(LazyResult$2);
      let LazyResult$1 = lazyResult;
      let Root$1 = root$5;
      class Processor$1 {
        constructor(plugins = []) {
          this.version = "8.1.10";
          this.plugins = this.normalize(plugins);
        }
        use(plugin2) {
          this.plugins = this.plugins.concat(this.normalize([plugin2]));
          return this;
        }
        process(css, opts = {}) {
          if (this.plugins.length === 0 && opts.parser === opts.stringifier && !opts.hideNothingWarning) {
            if (browser$1$1.env.NODE_ENV !== "production") {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on https://www.postcss.parts/ and use them in postcss.config.js."
                );
              }
            }
          }
          return new LazyResult$1(this, css, opts);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i2 of plugins) {
            if (i2.postcss === true) {
              i2 = i2();
            } else if (i2.postcss) {
              i2 = i2.postcss;
            }
            if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
              normalized = normalized.concat(i2.plugins);
            } else if (typeof i2 === "object" && i2.postcssPlugin) {
              normalized.push(i2);
            } else if (typeof i2 === "function") {
              normalized.push(i2);
            } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
              if (browser$1$1.env.NODE_ENV !== "production") {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i2 + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
      }
      var processor$2 = Processor$1;
      Processor$1.default = Processor$1;
      Root$1.registerProcessor(Processor$1);
      let CssSyntaxError = cssSyntaxError;
      let Declaration = declaration;
      let LazyResult = lazyResult;
      let Container = container$2;
      let Processor = processor$2;
      let stringify$2 = stringify_1$1;
      let Warning = warning;
      let Comment = comment$6;
      let AtRule = atRule;
      let Result = result;
      let Input = input;
      let parse$5 = parse_1$1;
      let list = list_1;
      let Rule = rule;
      let Root = root$5;
      let Node$1 = node_1;
      function postcss$1(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor(plugins, postcss$1);
      }
      postcss$1.plugin = function plugin2(name2, initializer) {
        if (console && console.warn) {
          console.warn(
            "postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (browser$1$1.env.LANG && browser$1$1.env.LANG.startsWith("cn")) {
            console.warn(
              "postcss.plugin 被弃用. 迁移指南:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        function creator(...args) {
          let transformer = initializer(...args);
          transformer.postcssPlugin = name2;
          transformer.postcssVersion = new Processor().version;
          return transformer;
        }
        let cache;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache)
              cache = creator();
            return cache;
          }
        });
        creator.process = function(css, processOpts, pluginOpts) {
          return postcss$1([creator(pluginOpts)]).process(css, processOpts);
        };
        return creator;
      };
      postcss$1.stringify = stringify$2;
      postcss$1.parse = parse$5;
      postcss$1.list = list;
      postcss$1.comment = (defaults2) => new Comment(defaults2);
      postcss$1.atRule = (defaults2) => new AtRule(defaults2);
      postcss$1.decl = (defaults2) => new Declaration(defaults2);
      postcss$1.rule = (defaults2) => new Rule(defaults2);
      postcss$1.root = (defaults2) => new Root(defaults2);
      postcss$1.CssSyntaxError = CssSyntaxError;
      postcss$1.Declaration = Declaration;
      postcss$1.Container = Container;
      postcss$1.Comment = Comment;
      postcss$1.Warning = Warning;
      postcss$1.AtRule = AtRule;
      postcss$1.Result = Result;
      postcss$1.Input = Input;
      postcss$1.Rule = Rule;
      postcss$1.Root = Root;
      postcss$1.Node = Node$1;
      LazyResult.registerPostcss(postcss$1);
      var postcss_1 = postcss$1;
      postcss$1.default = postcss$1;
      var dist$2 = { exports: {} };
      var processor$1 = { exports: {} };
      var parser$3 = { exports: {} };
      var _indexesOf_1_0_1_indexesOf = function(ary, item) {
        var i2 = -1, indexes = [];
        while ((i2 = ary.indexOf(item, i2 + 1)) !== -1)
          indexes.push(i2);
        return indexes;
      };
      function unique_pred(list2, compare2) {
        var ptr = 1, len = list2.length, a = list2[0], b2 = list2[0];
        for (var i2 = 1; i2 < len; ++i2) {
          b2 = a;
          a = list2[i2];
          if (compare2(a, b2)) {
            if (i2 === ptr) {
              ptr++;
              continue;
            }
            list2[ptr++] = a;
          }
        }
        list2.length = ptr;
        return list2;
      }
      function unique_eq(list2) {
        var ptr = 1, len = list2.length, a = list2[0], b2 = list2[0];
        for (var i2 = 1; i2 < len; ++i2, b2 = a) {
          b2 = a;
          a = list2[i2];
          if (a !== b2) {
            if (i2 === ptr) {
              ptr++;
              continue;
            }
            list2[ptr++] = a;
          }
        }
        list2.length = ptr;
        return list2;
      }
      function unique(list2, compare2, sorted) {
        if (list2.length === 0) {
          return list2;
        }
        if (compare2) {
          if (!sorted) {
            list2.sort(compare2);
          }
          return unique_pred(list2, compare2);
        }
        if (!sorted) {
          list2.sort();
        }
        return unique_eq(list2);
      }
      var uniq = unique;
      var root$4 = { exports: {} };
      var container$1 = { exports: {} };
      var node$1 = { exports: {} };
      var util$1 = {};
      var unesc$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = unesc2;
        var whitespace2 = "[\\x20\\t\\r\\n\\f]";
        var unescapeRegExp2 = new RegExp("\\\\([\\da-f]{1,6}" + whitespace2 + "?|(" + whitespace2 + ")|.)", "ig");
        function unesc2(str2) {
          return str2.replace(unescapeRegExp2, function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? (
              // BMP codepoint
              String.fromCharCode(high + 65536)
            ) : (
              // Supplemental Plane codepoint (surrogate pair)
              String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
            );
          });
        }
        module2.exports = exports2.default;
      })(unesc$1, unesc$1.exports);
      var getProp$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = getProp2;
        function getProp2(obj) {
          for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            props[_key - 1] = arguments[_key];
          }
          while (props.length > 0) {
            var prop = props.shift();
            if (!obj[prop]) {
              return void 0;
            }
            obj = obj[prop];
          }
          return obj;
        }
        module2.exports = exports2.default;
      })(getProp$1, getProp$1.exports);
      var ensureObject$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = ensureObject2;
        function ensureObject2(obj) {
          for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            props[_key - 1] = arguments[_key];
          }
          while (props.length > 0) {
            var prop = props.shift();
            if (!obj[prop]) {
              obj[prop] = {};
            }
            obj = obj[prop];
          }
        }
        module2.exports = exports2.default;
      })(ensureObject$1, ensureObject$1.exports);
      var stripComments$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = stripComments2;
        function stripComments2(str2) {
          var s = "";
          var commentStart2 = str2.indexOf("/*");
          var lastEnd = 0;
          while (commentStart2 >= 0) {
            s = s + str2.slice(lastEnd, commentStart2);
            var commentEnd2 = str2.indexOf("*/", commentStart2 + 2);
            if (commentEnd2 < 0) {
              return s;
            }
            lastEnd = commentEnd2 + 2;
            commentStart2 = str2.indexOf("/*", lastEnd);
          }
          s = s + str2.slice(lastEnd);
          return s;
        }
        module2.exports = exports2.default;
      })(stripComments$1, stripComments$1.exports);
      util$1.__esModule = true;
      util$1.stripComments = util$1.ensureObject = util$1.getProp = util$1.unesc = void 0;
      var _unesc$2 = _interopRequireDefault$9(unesc$1.exports);
      util$1.unesc = _unesc$2.default;
      var _getProp$1 = _interopRequireDefault$9(getProp$1.exports);
      util$1.getProp = _getProp$1.default;
      var _ensureObject$1 = _interopRequireDefault$9(ensureObject$1.exports);
      util$1.ensureObject = _ensureObject$1.default;
      var _stripComments$1 = _interopRequireDefault$9(stripComments$1.exports);
      util$1.stripComments = _stripComments$1.default;
      function _interopRequireDefault$9(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _util = util$1;
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var cloneNode2 = function cloneNode3(obj, parent) {
          if (typeof obj !== "object" || obj === null) {
            return obj;
          }
          var cloned = new obj.constructor();
          for (var i2 in obj) {
            if (!obj.hasOwnProperty(i2)) {
              continue;
            }
            var value = obj[i2];
            var type2 = typeof value;
            if (i2 === "parent" && type2 === "object") {
              if (parent) {
                cloned[i2] = parent;
              }
            } else if (value instanceof Array) {
              cloned[i2] = value.map(function(j) {
                return cloneNode3(j, cloned);
              });
            } else {
              cloned[i2] = cloneNode3(value, cloned);
            }
          }
          return cloned;
        };
        var Node2 = function() {
          function Node3(opts) {
            if (opts === void 0) {
              opts = {};
            }
            Object.assign(this, opts);
            this.spaces = this.spaces || {};
            this.spaces.before = this.spaces.before || "";
            this.spaces.after = this.spaces.after || "";
          }
          var _proto = Node3.prototype;
          _proto.remove = function remove2() {
            if (this.parent) {
              this.parent.removeChild(this);
            }
            this.parent = void 0;
            return this;
          };
          _proto.replaceWith = function replaceWith() {
            if (this.parent) {
              for (var index in arguments) {
                this.parent.insertBefore(this, arguments[index]);
              }
              this.remove();
            }
            return this;
          };
          _proto.next = function next() {
            return this.parent.at(this.parent.index(this) + 1);
          };
          _proto.prev = function prev() {
            return this.parent.at(this.parent.index(this) - 1);
          };
          _proto.clone = function clone2(overrides) {
            if (overrides === void 0) {
              overrides = {};
            }
            var cloned = cloneNode2(this);
            for (var name2 in overrides) {
              cloned[name2] = overrides[name2];
            }
            return cloned;
          };
          _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name2, value, valueEscaped) {
            if (!this.raws) {
              this.raws = {};
            }
            var originalValue = this[name2];
            var originalEscaped = this.raws[name2];
            this[name2] = originalValue + value;
            if (originalEscaped || valueEscaped !== value) {
              this.raws[name2] = (originalEscaped || originalValue) + valueEscaped;
            } else {
              delete this.raws[name2];
            }
          };
          _proto.setPropertyAndEscape = function setPropertyAndEscape(name2, value, valueEscaped) {
            if (!this.raws) {
              this.raws = {};
            }
            this[name2] = value;
            this.raws[name2] = valueEscaped;
          };
          _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name2, value) {
            this[name2] = value;
            if (this.raws) {
              delete this.raws[name2];
            }
          };
          _proto.isAtPosition = function isAtPosition(line, column) {
            if (this.source && this.source.start && this.source.end) {
              if (this.source.start.line > line) {
                return false;
              }
              if (this.source.end.line < line) {
                return false;
              }
              if (this.source.start.line === line && this.source.start.column > column) {
                return false;
              }
              if (this.source.end.line === line && this.source.end.column < column) {
                return false;
              }
              return true;
            }
            return void 0;
          };
          _proto.stringifyProperty = function stringifyProperty(name2) {
            return this.raws && this.raws[name2] || this[name2];
          };
          _proto.valueToString = function valueToString() {
            return String(this.stringifyProperty("value"));
          };
          _proto.toString = function toString2() {
            return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
          };
          _createClass2(Node3, [{
            key: "rawSpaceBefore",
            get: function get2() {
              var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
              if (rawSpace === void 0) {
                rawSpace = this.spaces && this.spaces.before;
              }
              return rawSpace || "";
            },
            set: function set(raw) {
              (0, _util.ensureObject)(this, "raws", "spaces");
              this.raws.spaces.before = raw;
            }
          }, {
            key: "rawSpaceAfter",
            get: function get2() {
              var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
              if (rawSpace === void 0) {
                rawSpace = this.spaces.after;
              }
              return rawSpace || "";
            },
            set: function set(raw) {
              (0, _util.ensureObject)(this, "raws", "spaces");
              this.raws.spaces.after = raw;
            }
          }]);
          return Node3;
        }();
        exports2.default = Node2;
        module2.exports = exports2.default;
      })(node$1, node$1.exports);
      var types$2 = {};
      types$2.__esModule = true;
      types$2.UNIVERSAL = types$2.ATTRIBUTE = types$2.CLASS = types$2.COMBINATOR = types$2.COMMENT = types$2.ID = types$2.NESTING = types$2.PSEUDO = types$2.ROOT = types$2.SELECTOR = types$2.STRING = types$2.TAG = void 0;
      var TAG$1 = "tag";
      types$2.TAG = TAG$1;
      var STRING$1 = "string";
      types$2.STRING = STRING$1;
      var SELECTOR$1 = "selector";
      types$2.SELECTOR = SELECTOR$1;
      var ROOT$1 = "root";
      types$2.ROOT = ROOT$1;
      var PSEUDO$1 = "pseudo";
      types$2.PSEUDO = PSEUDO$1;
      var NESTING$1 = "nesting";
      types$2.NESTING = NESTING$1;
      var ID$1 = "id";
      types$2.ID = ID$1;
      var COMMENT$1 = "comment";
      types$2.COMMENT = COMMENT$1;
      var COMBINATOR$1 = "combinator";
      types$2.COMBINATOR = COMBINATOR$1;
      var CLASS$1 = "class";
      types$2.CLASS = CLASS$1;
      var ATTRIBUTE$1 = "attribute";
      types$2.ATTRIBUTE = ATTRIBUTE$1;
      var UNIVERSAL$1 = "universal";
      types$2.UNIVERSAL = UNIVERSAL$1;
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var types2 = _interopRequireWildcard2(types$2);
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                  if (desc.get || desc.set) {
                    Object.defineProperty(newObj, key, desc);
                  } else {
                    newObj[key] = obj[key];
                  }
                }
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Container2 = function(_Node) {
          _inheritsLoose2(Container3, _Node);
          function Container3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            if (!_this.nodes) {
              _this.nodes = [];
            }
            return _this;
          }
          var _proto = Container3.prototype;
          _proto.append = function append(selector2) {
            selector2.parent = this;
            this.nodes.push(selector2);
            return this;
          };
          _proto.prepend = function prepend(selector2) {
            selector2.parent = this;
            this.nodes.unshift(selector2);
            return this;
          };
          _proto.at = function at2(index) {
            return this.nodes[index];
          };
          _proto.index = function index(child) {
            if (typeof child === "number") {
              return child;
            }
            return this.nodes.indexOf(child);
          };
          _proto.removeChild = function removeChild(child) {
            child = this.index(child);
            this.at(child).parent = void 0;
            this.nodes.splice(child, 1);
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (index >= child) {
                this.indexes[id2] = index - 1;
              }
            }
            return this;
          };
          _proto.removeAll = function removeAll() {
            for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref = _i.value;
              }
              var node2 = _ref;
              node2.parent = void 0;
            }
            this.nodes = [];
            return this;
          };
          _proto.empty = function empty() {
            return this.removeAll();
          };
          _proto.insertAfter = function insertAfter(oldNode, newNode) {
            newNode.parent = this;
            var oldIndex = this.index(oldNode);
            this.nodes.splice(oldIndex + 1, 0, newNode);
            newNode.parent = this;
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (oldIndex <= index) {
                this.indexes[id2] = index + 1;
              }
            }
            return this;
          };
          _proto.insertBefore = function insertBefore(oldNode, newNode) {
            newNode.parent = this;
            var oldIndex = this.index(oldNode);
            this.nodes.splice(oldIndex, 0, newNode);
            newNode.parent = this;
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (index <= oldIndex) {
                this.indexes[id2] = index + 1;
              }
            }
            return this;
          };
          _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
            var found = void 0;
            this.each(function(node2) {
              if (node2.atPosition) {
                var foundChild = node2.atPosition(line, col);
                if (foundChild) {
                  found = foundChild;
                  return false;
                }
              } else if (node2.isAtPosition(line, col)) {
                found = node2;
                return false;
              }
            });
            return found;
          };
          _proto.atPosition = function atPosition(line, col) {
            if (this.isAtPosition(line, col)) {
              return this._findChildAtPosition(line, col) || this;
            } else {
              return void 0;
            }
          };
          _proto._inferEndPosition = function _inferEndPosition() {
            if (this.last && this.last.source && this.last.source.end) {
              this.source = this.source || {};
              this.source.end = this.source.end || {};
              Object.assign(this.source.end, this.last.source.end);
            }
          };
          _proto.each = function each(callback) {
            if (!this.lastEach) {
              this.lastEach = 0;
            }
            if (!this.indexes) {
              this.indexes = {};
            }
            this.lastEach++;
            var id2 = this.lastEach;
            this.indexes[id2] = 0;
            if (!this.length) {
              return void 0;
            }
            var index, result2;
            while (this.indexes[id2] < this.length) {
              index = this.indexes[id2];
              result2 = callback(this.at(index), index);
              if (result2 === false) {
                break;
              }
              this.indexes[id2] += 1;
            }
            delete this.indexes[id2];
            if (result2 === false) {
              return false;
            }
          };
          _proto.walk = function walk2(callback) {
            return this.each(function(node2, i2) {
              var result2 = callback(node2, i2);
              if (result2 !== false && node2.length) {
                result2 = node2.walk(callback);
              }
              if (result2 === false) {
                return false;
              }
            });
          };
          _proto.walkAttributes = function walkAttributes(callback) {
            var _this2 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.ATTRIBUTE) {
                return callback.call(_this2, selector2);
              }
            });
          };
          _proto.walkClasses = function walkClasses(callback) {
            var _this3 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.CLASS) {
                return callback.call(_this3, selector2);
              }
            });
          };
          _proto.walkCombinators = function walkCombinators(callback) {
            var _this4 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.COMBINATOR) {
                return callback.call(_this4, selector2);
              }
            });
          };
          _proto.walkComments = function walkComments(callback) {
            var _this5 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.COMMENT) {
                return callback.call(_this5, selector2);
              }
            });
          };
          _proto.walkIds = function walkIds(callback) {
            var _this6 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.ID) {
                return callback.call(_this6, selector2);
              }
            });
          };
          _proto.walkNesting = function walkNesting(callback) {
            var _this7 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.NESTING) {
                return callback.call(_this7, selector2);
              }
            });
          };
          _proto.walkPseudos = function walkPseudos(callback) {
            var _this8 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.PSEUDO) {
                return callback.call(_this8, selector2);
              }
            });
          };
          _proto.walkTags = function walkTags(callback) {
            var _this9 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.TAG) {
                return callback.call(_this9, selector2);
              }
            });
          };
          _proto.walkUniversals = function walkUniversals(callback) {
            var _this10 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.UNIVERSAL) {
                return callback.call(_this10, selector2);
              }
            });
          };
          _proto.split = function split(callback) {
            var _this11 = this;
            var current = [];
            return this.reduce(function(memo, node2, index) {
              var split2 = callback.call(_this11, node2);
              current.push(node2);
              if (split2) {
                memo.push(current);
                current = [];
              } else if (index === _this11.length - 1) {
                memo.push(current);
              }
              return memo;
            }, []);
          };
          _proto.map = function map2(callback) {
            return this.nodes.map(callback);
          };
          _proto.reduce = function reduce(callback, memo) {
            return this.nodes.reduce(callback, memo);
          };
          _proto.every = function every(callback) {
            return this.nodes.every(callback);
          };
          _proto.some = function some(callback) {
            return this.nodes.some(callback);
          };
          _proto.filter = function filter2(callback) {
            return this.nodes.filter(callback);
          };
          _proto.sort = function sort(callback) {
            return this.nodes.sort(callback);
          };
          _proto.toString = function toString2() {
            return this.map(String).join("");
          };
          _createClass2(Container3, [{
            key: "first",
            get: function get2() {
              return this.at(0);
            }
          }, {
            key: "last",
            get: function get2() {
              return this.at(this.length - 1);
            }
          }, {
            key: "length",
            get: function get2() {
              return this.nodes.length;
            }
          }]);
          return Container3;
        }(_node.default);
        exports2.default = Container2;
        module2.exports = exports2.default;
      })(container$1, container$1.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _container = _interopRequireDefault2(container$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Root2 = function(_Container) {
          _inheritsLoose2(Root3, _Container);
          function Root3(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.ROOT;
            return _this;
          }
          var _proto = Root3.prototype;
          _proto.toString = function toString2() {
            var str2 = this.reduce(function(memo, selector2) {
              memo.push(String(selector2));
              return memo;
            }, []).join(",");
            return this.trailingComma ? str2 + "," : str2;
          };
          _proto.error = function error2(message, options2) {
            if (this._error) {
              return this._error(message, options2);
            } else {
              return new Error(message);
            }
          };
          _createClass2(Root3, [{
            key: "errorGenerator",
            set: function set(handler) {
              this._error = handler;
            }
          }]);
          return Root3;
        }(_container.default);
        exports2.default = Root2;
        module2.exports = exports2.default;
      })(root$4, root$4.exports);
      var selector$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _container = _interopRequireDefault2(container$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Selector = function(_Container) {
          _inheritsLoose2(Selector2, _Container);
          function Selector2(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.SELECTOR;
            return _this;
          }
          return Selector2;
        }(_container.default);
        exports2.default = Selector;
        module2.exports = exports2.default;
      })(selector$3, selector$3.exports);
      var className$3 = { exports: {} };
      var object = {};
      var hasOwnProperty$1 = object.hasOwnProperty;
      var merge$2 = function merge2(options2, defaults2) {
        if (!options2) {
          return defaults2;
        }
        var result2 = {};
        for (var key in defaults2) {
          result2[key] = hasOwnProperty$1.call(options2, key) ? options2[key] : defaults2[key];
        }
        return result2;
      };
      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
      var cssesc = function cssesc2(string2, options2) {
        options2 = merge$2(options2, cssesc2.options);
        if (options2.quotes != "single" && options2.quotes != "double") {
          options2.quotes = "single";
        }
        var quote = options2.quotes == "double" ? '"' : "'";
        var isIdentifier2 = options2.isIdentifier;
        var firstChar = string2.charAt(0);
        var output = "";
        var counter = 0;
        var length = string2.length;
        while (counter < length) {
          var character = string2.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
              var extra = string2.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
              } else {
                counter--;
              }
            }
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else {
            if (options2.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value = "\\" + character;
              } else {
                value = "\\" + codePoint.toString(16).toUpperCase() + " ";
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = character;
            }
          }
          output += value;
        }
        if (isIdentifier2) {
          if (/^-[-\d]/.test(output)) {
            output = "\\-" + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = "\\3" + firstChar + " " + output.slice(1);
          }
        }
        output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
          if ($1 && $1.length % 2) {
            return $0;
          }
          return ($1 || "") + $2;
        });
        if (!isIdentifier2 && options2.wrap) {
          return quote + output + quote;
        }
        return output;
      };
      cssesc.options = {
        "escapeEverything": false,
        "isIdentifier": false,
        "quotes": "single",
        "wrap": false
      };
      cssesc.version = "3.0.0";
      var cssesc_1 = cssesc;
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _cssesc2 = _interopRequireDefault2(cssesc_1);
        var _util = util$1;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ClassName = function(_Node) {
          _inheritsLoose2(ClassName2, _Node);
          function ClassName2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.CLASS;
            _this._constructed = true;
            return _this;
          }
          var _proto = ClassName2.prototype;
          _proto.valueToString = function valueToString() {
            return "." + _Node.prototype.valueToString.call(this);
          };
          _createClass2(ClassName2, [{
            key: "value",
            set: function set(v2) {
              if (this._constructed) {
                var escaped = (0, _cssesc2.default)(v2, {
                  isIdentifier: true
                });
                if (escaped !== v2) {
                  (0, _util.ensureObject)(this, "raws");
                  this.raws.value = escaped;
                } else if (this.raws) {
                  delete this.raws.value;
                }
              }
              this._value = v2;
            },
            get: function get2() {
              return this._value;
            }
          }]);
          return ClassName2;
        }(_node.default);
        exports2.default = ClassName;
        module2.exports = exports2.default;
      })(className$3, className$3.exports);
      var comment$5 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Comment2 = function(_Node) {
          _inheritsLoose2(Comment3, _Node);
          function Comment3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.COMMENT;
            return _this;
          }
          return Comment3;
        }(_node.default);
        exports2.default = Comment2;
        module2.exports = exports2.default;
      })(comment$5, comment$5.exports);
      var id$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ID2 = function(_Node) {
          _inheritsLoose2(ID3, _Node);
          function ID3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.ID;
            return _this;
          }
          var _proto = ID3.prototype;
          _proto.valueToString = function valueToString() {
            return "#" + _Node.prototype.valueToString.call(this);
          };
          return ID3;
        }(_node.default);
        exports2.default = ID2;
        module2.exports = exports2.default;
      })(id$3, id$3.exports);
      var tag$3 = { exports: {} };
      var namespace$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _cssesc2 = _interopRequireDefault2(cssesc_1);
        var _util = util$1;
        var _node = _interopRequireDefault2(node$1.exports);
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Namespace = function(_Node) {
          _inheritsLoose2(Namespace2, _Node);
          function Namespace2() {
            return _Node.apply(this, arguments) || this;
          }
          var _proto = Namespace2.prototype;
          _proto.qualifiedName = function qualifiedName(value) {
            if (this.namespace) {
              return this.namespaceString + "|" + value;
            } else {
              return value;
            }
          };
          _proto.valueToString = function valueToString() {
            return this.qualifiedName(_Node.prototype.valueToString.call(this));
          };
          _createClass2(Namespace2, [{
            key: "namespace",
            get: function get2() {
              return this._namespace;
            },
            set: function set(namespace2) {
              if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
                this._namespace = namespace2;
                if (this.raws) {
                  delete this.raws.namespace;
                }
                return;
              }
              var escaped = (0, _cssesc2.default)(namespace2, {
                isIdentifier: true
              });
              this._namespace = namespace2;
              if (escaped !== namespace2) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.namespace = escaped;
              } else if (this.raws) {
                delete this.raws.namespace;
              }
            }
          }, {
            key: "ns",
            get: function get2() {
              return this._namespace;
            },
            set: function set(namespace2) {
              this.namespace = namespace2;
            }
          }, {
            key: "namespaceString",
            get: function get2() {
              if (this.namespace) {
                var ns = this.stringifyProperty("namespace");
                if (ns === true) {
                  return "";
                } else {
                  return ns;
                }
              } else {
                return "";
              }
            }
          }]);
          return Namespace2;
        }(_node.default);
        exports2.default = Namespace;
        module2.exports = exports2.default;
      })(namespace$1, namespace$1.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _namespace2 = _interopRequireDefault2(namespace$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Tag = function(_Namespace) {
          _inheritsLoose2(Tag2, _Namespace);
          function Tag2(opts) {
            var _this;
            _this = _Namespace.call(this, opts) || this;
            _this.type = _types2.TAG;
            return _this;
          }
          return Tag2;
        }(_namespace2.default);
        exports2.default = Tag;
        module2.exports = exports2.default;
      })(tag$3, tag$3.exports);
      var string$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var String2 = function(_Node) {
          _inheritsLoose2(String3, _Node);
          function String3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.STRING;
            return _this;
          }
          return String3;
        }(_node.default);
        exports2.default = String2;
        module2.exports = exports2.default;
      })(string$3, string$3.exports);
      var pseudo$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _container = _interopRequireDefault2(container$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Pseudo = function(_Container) {
          _inheritsLoose2(Pseudo2, _Container);
          function Pseudo2(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.PSEUDO;
            return _this;
          }
          var _proto = Pseudo2.prototype;
          _proto.toString = function toString2() {
            var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
          };
          return Pseudo2;
        }(_container.default);
        exports2.default = Pseudo;
        module2.exports = exports2.default;
      })(pseudo$3, pseudo$3.exports);
      var attribute$3 = {};
      var browser$1 = deprecate$1;
      function deprecate$1(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned2 = false;
        function deprecated() {
          if (!warned2) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned2 = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name2) {
        try {
          if (!commonjsGlobal.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = commonjsGlobal.localStorage[name2];
        if (null == val)
          return false;
        return String(val).toLowerCase() === "true";
      }
      attribute$3.__esModule = true;
      attribute$3.unescapeValue = unescapeValue;
      attribute$3.default = void 0;
      var _cssesc = _interopRequireDefault$8(cssesc_1);
      var _unesc$1 = _interopRequireDefault$8(unesc$1.exports);
      var _namespace = _interopRequireDefault$8(namespace$1.exports);
      var _types$2 = types$2;
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault$8(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var deprecate = browser$1;
      var WRAPPED_IN_QUOTES = /^('|")(.*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m = unescaped.match(WRAPPED_IN_QUOTES);
        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }
        unescaped = (0, _unesc$1.default)(unescaped);
        if (unescaped !== value) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types$2.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var quoteMark = this._determineQuoteMark(options2);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc.default)(this._value, cssescopts);
          return escaped;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options2) {
          return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
        };
        _proto.setValue = function setValue(value, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this._value = value;
          this._quoteMark = this._determineQuoteMark(options2);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options2) {
          var v2 = this.value;
          var numSingleQuotes = v2.replace(/[^']/g, "").length;
          var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc.default)(v2, {
              isIdentifier: true
            });
            if (escaped === v2) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options2);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options2.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc.default)(v2, opts);
                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options2);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
          var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped = (0, _cssesc.default)(value, {
              isIdentifier: true
            });
            if (escaped !== value) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name2) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name2] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name2] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name2, spaceName, concat2) {
          if (spaceName === void 0) {
            spaceName = name2;
          }
          if (concat2 === void 0) {
            concat2 = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat2(this.stringifyProperty(name2), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name2) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name2 === "namespace" || name2 === "ns") {
            return this.namespace ? count : -1;
          }
          if (name2 === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name2 === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name2 === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");
          if (name2 === "value") {
            return value ? count : -1;
          }
          count += value.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name2 === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString2() {
          var _this2 = this;
          var selector2 = [this.rawSpaceBefore, "["];
          selector2.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector2.push(this._stringFor("operator"));
            selector2.push(this._stringFor("value"));
            selector2.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector2.push("]");
          selector2.push(this.rawSpaceAfter);
          return selector2.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get2() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get2() {
            return this._quoteMark;
          },
          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get2() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get2() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get2() {
            return this._value;
          },
          set: function set(v2) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v2;
            }
          }
        }, {
          key: "attribute",
          get: function get2() {
            return this._attribute;
          },
          set: function set(name2) {
            this._handleEscapes("attribute", name2);
            this._attribute = name2;
          }
        }]);
        return Attribute2;
      }(_namespace.default);
      attribute$3.default = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
      var universal$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _namespace2 = _interopRequireDefault2(namespace$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Universal = function(_Namespace) {
          _inheritsLoose2(Universal2, _Namespace);
          function Universal2(opts) {
            var _this;
            _this = _Namespace.call(this, opts) || this;
            _this.type = _types2.UNIVERSAL;
            _this.value = "*";
            return _this;
          }
          return Universal2;
        }(_namespace2.default);
        exports2.default = Universal;
        module2.exports = exports2.default;
      })(universal$3, universal$3.exports);
      var combinator$5 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Combinator = function(_Node) {
          _inheritsLoose2(Combinator2, _Node);
          function Combinator2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.COMBINATOR;
            return _this;
          }
          return Combinator2;
        }(_node.default);
        exports2.default = Combinator;
        module2.exports = exports2.default;
      })(combinator$5, combinator$5.exports);
      var nesting$3 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _node = _interopRequireDefault2(node$1.exports);
        var _types2 = types$2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Nesting = function(_Node) {
          _inheritsLoose2(Nesting2, _Node);
          function Nesting2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.NESTING;
            _this.value = "&";
            return _this;
          }
          return Nesting2;
        }(_node.default);
        exports2.default = Nesting;
        module2.exports = exports2.default;
      })(nesting$3, nesting$3.exports);
      var sortAscending$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = sortAscending2;
        function sortAscending2(list2) {
          return list2.sort(function(a, b2) {
            return a - b2;
          });
        }
        module2.exports = exports2.default;
      })(sortAscending$1, sortAscending$1.exports);
      var tokenize$2 = {};
      var tokenTypes$1 = {};
      tokenTypes$1.__esModule = true;
      tokenTypes$1.combinator = tokenTypes$1.word = tokenTypes$1.comment = tokenTypes$1.str = tokenTypes$1.tab = tokenTypes$1.newline = tokenTypes$1.feed = tokenTypes$1.cr = tokenTypes$1.backslash = tokenTypes$1.bang = tokenTypes$1.slash = tokenTypes$1.doubleQuote = tokenTypes$1.singleQuote = tokenTypes$1.space = tokenTypes$1.greaterThan = tokenTypes$1.pipe = tokenTypes$1.equals = tokenTypes$1.plus = tokenTypes$1.caret = tokenTypes$1.tilde = tokenTypes$1.dollar = tokenTypes$1.closeSquare = tokenTypes$1.openSquare = tokenTypes$1.closeParenthesis = tokenTypes$1.openParenthesis = tokenTypes$1.semicolon = tokenTypes$1.colon = tokenTypes$1.comma = tokenTypes$1.at = tokenTypes$1.asterisk = tokenTypes$1.ampersand = void 0;
      var ampersand$1 = 38;
      tokenTypes$1.ampersand = ampersand$1;
      var asterisk$1 = 42;
      tokenTypes$1.asterisk = asterisk$1;
      var at$1 = 64;
      tokenTypes$1.at = at$1;
      var comma$2 = 44;
      tokenTypes$1.comma = comma$2;
      var colon$2 = 58;
      tokenTypes$1.colon = colon$2;
      var semicolon$1 = 59;
      tokenTypes$1.semicolon = semicolon$1;
      var openParenthesis$1 = 40;
      tokenTypes$1.openParenthesis = openParenthesis$1;
      var closeParenthesis$1 = 41;
      tokenTypes$1.closeParenthesis = closeParenthesis$1;
      var openSquare$1 = 91;
      tokenTypes$1.openSquare = openSquare$1;
      var closeSquare$1 = 93;
      tokenTypes$1.closeSquare = closeSquare$1;
      var dollar$1 = 36;
      tokenTypes$1.dollar = dollar$1;
      var tilde$1 = 126;
      tokenTypes$1.tilde = tilde$1;
      var caret$1 = 94;
      tokenTypes$1.caret = caret$1;
      var plus$3 = 43;
      tokenTypes$1.plus = plus$3;
      var equals$1 = 61;
      tokenTypes$1.equals = equals$1;
      var pipe$1 = 124;
      tokenTypes$1.pipe = pipe$1;
      var greaterThan$1 = 62;
      tokenTypes$1.greaterThan = greaterThan$1;
      var space$1 = 32;
      tokenTypes$1.space = space$1;
      var singleQuote$2 = 39;
      tokenTypes$1.singleQuote = singleQuote$2;
      var doubleQuote$2 = 34;
      tokenTypes$1.doubleQuote = doubleQuote$2;
      var slash$2 = 47;
      tokenTypes$1.slash = slash$2;
      var bang$1 = 33;
      tokenTypes$1.bang = bang$1;
      var backslash$2 = 92;
      tokenTypes$1.backslash = backslash$2;
      var cr$1 = 13;
      tokenTypes$1.cr = cr$1;
      var feed$1 = 12;
      tokenTypes$1.feed = feed$1;
      var newline$1 = 10;
      tokenTypes$1.newline = newline$1;
      var tab$1 = 9;
      tokenTypes$1.tab = tab$1;
      var str$1 = singleQuote$2;
      tokenTypes$1.str = str$1;
      var comment$4 = -1;
      tokenTypes$1.comment = comment$4;
      var word$1 = -2;
      tokenTypes$1.word = word$1;
      var combinator$4 = -3;
      tokenTypes$1.combinator = combinator$4;
      tokenize$2.__esModule = true;
      tokenize$2.default = tokenize$1;
      tokenize$2.FIELDS = void 0;
      var t = _interopRequireWildcard(tokenTypes$1);
      var _unescapable, _wordDelimiters;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                if (desc.get || desc.set) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (var i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      function consumeWord(css, start) {
        var next = start;
        var code2;
        do {
          code2 = css.charCodeAt(next);
          if (wordDelimiters[code2]) {
            return next - 1;
          } else if (code2 === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code2 = css.charCodeAt(next + 1);
        if (unescapable[code2])
          ;
        else if (hex[code2]) {
          var hexDigits = 0;
          do {
            next++;
            hexDigits++;
            code2 = css.charCodeAt(next + 1);
          } while (hex[code2] && hexDigits < 6);
          if (hexDigits < 6 && code2 === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      tokenize$2.FIELDS = FIELDS;
      function tokenize$1(input2) {
        var tokens = [];
        var css = input2.css.valueOf();
        var _css = css, length = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code2, content, endColumn, endLine, escaped, escapePos, last2, lines2, next, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input2.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input2.error("Unclosed " + what, line, start - offset, start);
          }
        }
        while (start < length) {
          code2 = css.charCodeAt(start);
          if (code2 === t.newline) {
            offset = start;
            line += 1;
          }
          switch (code2) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;
              do {
                next += 1;
                code2 = css.charCodeAt(next);
                if (code2 === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code2 === t.space || code2 === t.newline || code2 === t.tab || code2 === t.cr || code2 === t.feed);
              tokenType = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;
              do {
                next += 1;
                code2 = css.charCodeAt(next);
              } while (code2 === t.plus || code2 === t.greaterThan || code2 === t.tilde || code2 === t.pipe);
              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code2;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote = code2 === t.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            default:
              if (code2 === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start, next + 1);
                lines2 = content.split("\n");
                last2 = lines2.length - 1;
                if (last2 > 0) {
                  nextLine = line + last2;
                  nextOffset = next - lines2[last2].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code2 === t.slash) {
                next = start;
                tokenType = code2;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType,
            // [0] Token type
            line,
            // [1] Starting line
            start - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start,
            // [5] Start position / Source index
            end
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _indexesOf = _interopRequireDefault2(_indexesOf_1_0_1_indexesOf);
        var _uniq = _interopRequireDefault2(uniq);
        var _root2 = _interopRequireDefault2(root$4.exports);
        var _selector2 = _interopRequireDefault2(selector$3.exports);
        var _className2 = _interopRequireDefault2(className$3.exports);
        var _comment2 = _interopRequireDefault2(comment$5.exports);
        var _id2 = _interopRequireDefault2(id$3.exports);
        var _tag2 = _interopRequireDefault2(tag$3.exports);
        var _string2 = _interopRequireDefault2(string$3.exports);
        var _pseudo2 = _interopRequireDefault2(pseudo$3.exports);
        var _attribute2 = _interopRequireWildcard2(attribute$3);
        var _universal2 = _interopRequireDefault2(universal$3.exports);
        var _combinator2 = _interopRequireDefault2(combinator$5.exports);
        var _nesting2 = _interopRequireDefault2(nesting$3.exports);
        var _sortAscending = _interopRequireDefault2(sortAscending$1.exports);
        var _tokenize = _interopRequireWildcard2(tokenize$2);
        var tokens = _interopRequireWildcard2(tokenTypes$1);
        var types2 = _interopRequireWildcard2(types$2);
        var _util = util$1;
        var _WHITESPACE_TOKENS, _Object$assign;
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                  if (desc.get || desc.set) {
                    Object.defineProperty(newObj, key, desc);
                  } else {
                    newObj[key] = obj[key];
                  }
                }
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
        var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
        function tokenStart(token) {
          return {
            line: token[_tokenize.FIELDS.START_LINE],
            column: token[_tokenize.FIELDS.START_COL]
          };
        }
        function tokenEnd(token) {
          return {
            line: token[_tokenize.FIELDS.END_LINE],
            column: token[_tokenize.FIELDS.END_COL]
          };
        }
        function getSource2(startLine, startColumn, endLine, endColumn) {
          return {
            start: {
              line: startLine,
              column: startColumn
            },
            end: {
              line: endLine,
              column: endColumn
            }
          };
        }
        function getTokenSource(token) {
          return getSource2(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
        }
        function getTokenSourceSpan(startToken, endToken) {
          if (!startToken) {
            return void 0;
          }
          return getSource2(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
        }
        function unescapeProp(node2, prop) {
          var value = node2[prop];
          if (typeof value !== "string") {
            return;
          }
          if (value.indexOf("\\") !== -1) {
            (0, _util.ensureObject)(node2, "raws");
            node2[prop] = (0, _util.unesc)(value);
            if (node2.raws[prop] === void 0) {
              node2.raws[prop] = value;
            }
          }
          return node2;
        }
        var Parser2 = function() {
          function Parser3(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            this.rule = rule2;
            this.options = Object.assign({
              lossy: false,
              safe: false
            }, options2);
            this.position = 0;
            this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
            this.tokens = (0, _tokenize.default)({
              css: this.css,
              error: this._errorGenerator(),
              safe: this.options.safe
            });
            var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
            this.root = new _root2.default({
              source: rootSource
            });
            this.root.errorGenerator = this._errorGenerator();
            var selector2 = new _selector2.default({
              source: {
                start: {
                  line: 1,
                  column: 1
                }
              }
            });
            this.root.append(selector2);
            this.current = selector2;
            this.loop();
          }
          var _proto = Parser3.prototype;
          _proto._errorGenerator = function _errorGenerator() {
            var _this = this;
            return function(message, errorOptions) {
              if (typeof _this.rule === "string") {
                return new Error(message);
              }
              return _this.rule.error(message, errorOptions);
            };
          };
          _proto.attribute = function attribute2() {
            var attr = [];
            var startingToken = this.currToken;
            this.position++;
            while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
              attr.push(this.currToken);
              this.position++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
              return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
            }
            var len = attr.length;
            var node2 = {
              source: getSource2(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            };
            if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
              return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
            }
            var pos = 0;
            var spaceBefore = "";
            var commentBefore = "";
            var lastAdded = null;
            var spaceAfterMeaningfulToken = false;
            while (pos < len) {
              var token = attr[pos];
              var content = this.content(token);
              var next = attr[pos + 1];
              switch (token[_tokenize.FIELDS.TYPE]) {
                case tokens.space:
                  spaceAfterMeaningfulToken = true;
                  if (this.options.lossy) {
                    break;
                  }
                  if (lastAdded) {
                    (0, _util.ensureObject)(node2, "spaces", lastAdded);
                    var prevContent = node2.spaces[lastAdded].after || "";
                    node2.spaces[lastAdded].after = prevContent + content;
                    var existingComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || null;
                    if (existingComment) {
                      node2.raws.spaces[lastAdded].after = existingComment + content;
                    }
                  } else {
                    spaceBefore = spaceBefore + content;
                    commentBefore = commentBefore + content;
                  }
                  break;
                case tokens.asterisk:
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  } else if ((!node2.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node2, "spaces", "attribute");
                      node2.spaces.attribute.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                      node2.raws.spaces.attribute.before = spaceBefore;
                      commentBefore = "";
                    }
                    node2.namespace = (node2.namespace || "") + content;
                    var rawValue = (0, _util.getProp)(node2, "raws", "namespace") || null;
                    if (rawValue) {
                      node2.raws.namespace += content;
                    }
                    lastAdded = "namespace";
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.dollar:
                  if (lastAdded === "value") {
                    var oldRawValue = (0, _util.getProp)(node2, "raws", "value");
                    node2.value += "$";
                    if (oldRawValue) {
                      node2.raws.value = oldRawValue + "$";
                    }
                    break;
                  }
                case tokens.caret:
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.combinator:
                  if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  }
                  if (content !== "|") {
                    spaceAfterMeaningfulToken = false;
                    break;
                  }
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  } else if (!node2.namespace && !node2.attribute) {
                    node2.namespace = true;
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.word:
                  if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                  !node2.operator && !node2.namespace) {
                    node2.namespace = content;
                    lastAdded = "namespace";
                  } else if (!node2.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node2, "spaces", "attribute");
                      node2.spaces.attribute.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                      node2.raws.spaces.attribute.before = commentBefore;
                      commentBefore = "";
                    }
                    node2.attribute = (node2.attribute || "") + content;
                    var _rawValue = (0, _util.getProp)(node2, "raws", "attribute") || null;
                    if (_rawValue) {
                      node2.raws.attribute += content;
                    }
                    lastAdded = "attribute";
                  } else if (!node2.value && node2.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                    var _unescaped = (0, _util.unesc)(content);
                    var _oldRawValue = (0, _util.getProp)(node2, "raws", "value") || "";
                    var oldValue = node2.value || "";
                    node2.value = oldValue + _unescaped;
                    node2.quoteMark = null;
                    if (_unescaped !== content || _oldRawValue) {
                      (0, _util.ensureObject)(node2, "raws");
                      node2.raws.value = (_oldRawValue || oldValue) + content;
                    }
                    lastAdded = "value";
                  } else {
                    var insensitive = content === "i" || content === "I";
                    if ((node2.value || node2.value === "") && (node2.quoteMark || spaceAfterMeaningfulToken)) {
                      node2.insensitive = insensitive;
                      if (!insensitive || content === "I") {
                        (0, _util.ensureObject)(node2, "raws");
                        node2.raws.insensitiveFlag = content;
                      }
                      lastAdded = "insensitive";
                      if (spaceBefore) {
                        (0, _util.ensureObject)(node2, "spaces", "insensitive");
                        node2.spaces.insensitive.before = spaceBefore;
                        spaceBefore = "";
                      }
                      if (commentBefore) {
                        (0, _util.ensureObject)(node2, "raws", "spaces", "insensitive");
                        node2.raws.spaces.insensitive.before = commentBefore;
                        commentBefore = "";
                      }
                    } else if (node2.value || node2.value === "") {
                      lastAdded = "value";
                      node2.value += content;
                      if (node2.raws.value) {
                        node2.raws.value += content;
                      }
                    }
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.str:
                  if (!node2.attribute || !node2.operator) {
                    return this.error("Expected an attribute followed by an operator preceding the string.", {
                      index: token[_tokenize.FIELDS.START_POS]
                    });
                  }
                  var _unescapeValue = (0, _attribute2.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                  node2.value = unescaped;
                  node2.quoteMark = quoteMark;
                  lastAdded = "value";
                  (0, _util.ensureObject)(node2, "raws");
                  node2.raws.value = content;
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.equals:
                  if (!node2.attribute) {
                    return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                  }
                  if (node2.value) {
                    return this.error('Unexpected "=" found; an operator was already defined.', {
                      index: token[_tokenize.FIELDS.START_POS]
                    });
                  }
                  node2.operator = node2.operator ? node2.operator + content : content;
                  lastAdded = "operator";
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.comment:
                  if (lastAdded) {
                    if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                      var lastComment = (0, _util.getProp)(node2, "spaces", lastAdded, "after") || "";
                      var rawLastComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || lastComment;
                      (0, _util.ensureObject)(node2, "raws", "spaces", lastAdded);
                      node2.raws.spaces[lastAdded].after = rawLastComment + content;
                    } else {
                      var lastValue = node2[lastAdded] || "";
                      var rawLastValue = (0, _util.getProp)(node2, "raws", lastAdded) || lastValue;
                      (0, _util.ensureObject)(node2, "raws");
                      node2.raws[lastAdded] = rawLastValue + content;
                    }
                  } else {
                    commentBefore = commentBefore + content;
                  }
                  break;
                default:
                  return this.error('Unexpected "' + content + '" found.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
              }
              pos++;
            }
            unescapeProp(node2, "attribute");
            unescapeProp(node2, "namespace");
            this.newNode(new _attribute2.default(node2));
            this.position++;
          };
          _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
            if (stopPosition < 0) {
              stopPosition = this.tokens.length;
            }
            var startPosition = this.position;
            var nodes = [];
            var space2 = "";
            var lastComment = void 0;
            do {
              if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
                if (!this.options.lossy) {
                  space2 += this.content();
                }
              } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
                var spaces = {};
                if (space2) {
                  spaces.before = space2;
                  space2 = "";
                }
                lastComment = new _comment2.default({
                  value: this.content(),
                  source: getTokenSource(this.currToken),
                  sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                  spaces
                });
                nodes.push(lastComment);
              }
            } while (++this.position < stopPosition);
            if (space2) {
              if (lastComment) {
                lastComment.spaces.after = space2;
              } else if (!this.options.lossy) {
                var firstToken = this.tokens[startPosition];
                var lastToken = this.tokens[this.position - 1];
                nodes.push(new _string2.default({
                  value: "",
                  source: getSource2(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                  sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                  spaces: {
                    before: space2,
                    after: ""
                  }
                }));
              }
            }
            return nodes;
          };
          _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
            var _this2 = this;
            if (requiredSpace === void 0) {
              requiredSpace = false;
            }
            var space2 = "";
            var rawSpace = "";
            nodes.forEach(function(n2) {
              var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
              var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
              space2 += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
              rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
            });
            if (rawSpace === space2) {
              rawSpace = void 0;
            }
            var result2 = {
              space: space2,
              rawSpace
            };
            return result2;
          };
          _proto.isNamedCombinator = function isNamedCombinator(position) {
            if (position === void 0) {
              position = this.position;
            }
            return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
          };
          _proto.namedCombinator = function namedCombinator() {
            if (this.isNamedCombinator()) {
              var nameRaw = this.content(this.tokens[this.position + 1]);
              var name2 = (0, _util.unesc)(nameRaw).toLowerCase();
              var raws = {};
              if (name2 !== nameRaw) {
                raws.value = "/" + nameRaw + "/";
              }
              var node2 = new _combinator2.default({
                value: "/" + name2 + "/",
                source: getSource2(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                raws
              });
              this.position = this.position + 3;
              return node2;
            } else {
              this.unexpected();
            }
          };
          _proto.combinator = function combinator2() {
            var _this3 = this;
            if (this.content() === "|") {
              return this.namespace();
            }
            var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
            if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
              var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
              if (nodes.length > 0) {
                var last2 = this.current.last;
                if (last2) {
                  var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                  if (rawSpace !== void 0) {
                    last2.rawSpaceAfter += rawSpace;
                  }
                  last2.spaces.after += space2;
                } else {
                  nodes.forEach(function(n2) {
                    return _this3.newNode(n2);
                  });
                }
              }
              return;
            }
            var firstToken = this.currToken;
            var spaceOrDescendantSelectorNodes = void 0;
            if (nextSigTokenPos > this.position) {
              spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            }
            var node2;
            if (this.isNamedCombinator()) {
              node2 = this.namedCombinator();
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
              node2 = new _combinator2.default({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
              });
              this.position++;
            } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]])
              ;
            else if (!spaceOrDescendantSelectorNodes) {
              this.unexpected();
            }
            if (node2) {
              if (spaceOrDescendantSelectorNodes) {
                var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
                node2.spaces.before = _space;
                node2.rawSpaceBefore = _rawSpace;
              }
            } else {
              var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
              if (!_rawSpace2) {
                _rawSpace2 = _space2;
              }
              var spaces = {};
              var raws = {
                spaces: {}
              };
              if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
                spaces.before = _space2.slice(0, _space2.length - 1);
                raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
              } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
                spaces.after = _space2.slice(1);
                raws.spaces.after = _rawSpace2.slice(1);
              } else {
                raws.value = _rawSpace2;
              }
              node2 = new _combinator2.default({
                value: " ",
                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces,
                raws
              });
            }
            if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
              node2.spaces.after = this.optionalSpace(this.content());
              this.position++;
            }
            return this.newNode(node2);
          };
          _proto.comma = function comma2() {
            if (this.position === this.tokens.length - 1) {
              this.root.trailingComma = true;
              this.position++;
              return;
            }
            this.current._inferEndPosition();
            var selector2 = new _selector2.default({
              source: {
                start: tokenStart(this.tokens[this.position + 1])
              }
            });
            this.current.parent.append(selector2);
            this.current = selector2;
            this.position++;
          };
          _proto.comment = function comment2() {
            var current = this.currToken;
            this.newNode(new _comment2.default({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.error = function error2(message, opts) {
            throw this.root.error(message, opts);
          };
          _proto.missingBackslash = function missingBackslash() {
            return this.error("Expected a backslash preceding the semicolon.", {
              index: this.currToken[_tokenize.FIELDS.START_POS]
            });
          };
          _proto.missingParenthesis = function missingParenthesis() {
            return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.missingSquareBracket = function missingSquareBracket() {
            return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.unexpected = function unexpected() {
            return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.namespace = function namespace2() {
            var before = this.prevToken && this.content(this.prevToken) || true;
            if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
              this.position++;
              return this.word(before);
            } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
              this.position++;
              return this.universal(before);
            }
          };
          _proto.nesting = function nesting2() {
            if (this.nextToken) {
              var nextContent = this.content(this.nextToken);
              if (nextContent === "|") {
                this.position++;
                return;
              }
            }
            var current = this.currToken;
            this.newNode(new _nesting2.default({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.parentheses = function parentheses() {
            var last2 = this.current.last;
            var unbalanced = 1;
            this.position++;
            if (last2 && last2.type === types2.PSEUDO) {
              var selector2 = new _selector2.default({
                source: {
                  start: tokenStart(this.tokens[this.position - 1])
                }
              });
              var cache = this.current;
              last2.append(selector2);
              this.current = selector2;
              while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                  unbalanced--;
                }
                if (unbalanced) {
                  this.parse();
                } else {
                  this.current.source.end = tokenEnd(this.currToken);
                  this.current.parent.source.end = tokenEnd(this.currToken);
                  this.position++;
                }
              }
              this.current = cache;
            } else {
              var parenStart = this.currToken;
              var parenValue = "(";
              var parenEnd;
              while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                  unbalanced--;
                }
                parenEnd = this.currToken;
                parenValue += this.parseParenthesisToken(this.currToken);
                this.position++;
              }
              if (last2) {
                last2.appendToPropertyAndEscape("value", parenValue, parenValue);
              } else {
                this.newNode(new _string2.default({
                  value: parenValue,
                  source: getSource2(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                  sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
                }));
              }
            }
            if (unbalanced) {
              return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
            }
          };
          _proto.pseudo = function pseudo2() {
            var _this4 = this;
            var pseudoStr = "";
            var startingToken = this.currToken;
            while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
              pseudoStr += this.content();
              this.position++;
            }
            if (!this.currToken) {
              return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
              this.splitWord(false, function(first, length) {
                pseudoStr += first;
                _this4.newNode(new _pseudo2.default({
                  value: pseudoStr,
                  source: getTokenSourceSpan(startingToken, _this4.currToken),
                  sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
                }));
                if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  _this4.error("Misplaced parenthesis.", {
                    index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                  });
                }
              });
            } else {
              return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
            }
          };
          _proto.space = function space2() {
            var content = this.content();
            if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node2) {
              return node2.type === "comment";
            })) {
              this.spaces = this.optionalSpace(content);
              this.position++;
            } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              this.current.last.spaces.after = this.optionalSpace(content);
              this.position++;
            } else {
              this.combinator();
            }
          };
          _proto.string = function string2() {
            var current = this.currToken;
            this.newNode(new _string2.default({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.universal = function universal2(namespace2) {
            var nextToken = this.nextToken;
            if (nextToken && this.content(nextToken) === "|") {
              this.position++;
              return this.namespace();
            }
            var current = this.currToken;
            this.newNode(new _universal2.default({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }), namespace2);
            this.position++;
          };
          _proto.splitWord = function splitWord(namespace2, firstCallback) {
            var _this5 = this;
            var nextToken = this.nextToken;
            var word2 = this.content();
            while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
              this.position++;
              var current = this.content();
              word2 += current;
              if (current.lastIndexOf("\\") === current.length - 1) {
                var next = this.nextToken;
                if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                  word2 += this.requiredSpace(this.content(next));
                  this.position++;
                }
              }
              nextToken = this.nextToken;
            }
            var hasClass = (0, _indexesOf.default)(word2, ".").filter(function(i2) {
              return word2[i2 - 1] !== "\\";
            });
            var hasId = (0, _indexesOf.default)(word2, "#").filter(function(i2) {
              return word2[i2 - 1] !== "\\";
            });
            var interpolations = (0, _indexesOf.default)(word2, "#{");
            if (interpolations.length) {
              hasId = hasId.filter(function(hashIndex) {
                return !~interpolations.indexOf(hashIndex);
              });
            }
            var indices = (0, _sortAscending.default)((0, _uniq.default)([0].concat(hasClass, hasId)));
            indices.forEach(function(ind, i2) {
              var index = indices[i2 + 1] || word2.length;
              var value = word2.slice(ind, index);
              if (i2 === 0 && firstCallback) {
                return firstCallback.call(_this5, value, indices.length);
              }
              var node2;
              var current2 = _this5.currToken;
              var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
              var source = getSource2(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
              if (~hasClass.indexOf(ind)) {
                var classNameOpts = {
                  value: value.slice(1),
                  source,
                  sourceIndex
                };
                node2 = new _className2.default(unescapeProp(classNameOpts, "value"));
              } else if (~hasId.indexOf(ind)) {
                var idOpts = {
                  value: value.slice(1),
                  source,
                  sourceIndex
                };
                node2 = new _id2.default(unescapeProp(idOpts, "value"));
              } else {
                var tagOpts = {
                  value,
                  source,
                  sourceIndex
                };
                unescapeProp(tagOpts, "value");
                node2 = new _tag2.default(tagOpts);
              }
              _this5.newNode(node2, namespace2);
              namespace2 = null;
            });
            this.position++;
          };
          _proto.word = function word2(namespace2) {
            var nextToken = this.nextToken;
            if (nextToken && this.content(nextToken) === "|") {
              this.position++;
              return this.namespace();
            }
            return this.splitWord(namespace2);
          };
          _proto.loop = function loop() {
            while (this.position < this.tokens.length) {
              this.parse(true);
            }
            this.current._inferEndPosition();
            return this.root;
          };
          _proto.parse = function parse2(throwOnParenthesis) {
            switch (this.currToken[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                this.space();
                break;
              case tokens.comment:
                this.comment();
                break;
              case tokens.openParenthesis:
                this.parentheses();
                break;
              case tokens.closeParenthesis:
                if (throwOnParenthesis) {
                  this.missingParenthesis();
                }
                break;
              case tokens.openSquare:
                this.attribute();
                break;
              case tokens.dollar:
              case tokens.caret:
              case tokens.equals:
              case tokens.word:
                this.word();
                break;
              case tokens.colon:
                this.pseudo();
                break;
              case tokens.comma:
                this.comma();
                break;
              case tokens.asterisk:
                this.universal();
                break;
              case tokens.ampersand:
                this.nesting();
                break;
              case tokens.slash:
              case tokens.combinator:
                this.combinator();
                break;
              case tokens.str:
                this.string();
                break;
              case tokens.closeSquare:
                this.missingSquareBracket();
              case tokens.semicolon:
                this.missingBackslash();
              default:
                this.unexpected();
            }
          };
          _proto.expected = function expected(description2, index, found) {
            if (Array.isArray(description2)) {
              var last2 = description2.pop();
              description2 = description2.join(", ") + " or " + last2;
            }
            var an = /^[aeiou]/.test(description2[0]) ? "an" : "a";
            if (!found) {
              return this.error("Expected " + an + " " + description2 + ".", {
                index
              });
            }
            return this.error("Expected " + an + " " + description2 + ', found "' + found + '" instead.', {
              index
            });
          };
          _proto.requiredSpace = function requiredSpace(space2) {
            return this.options.lossy ? " " : space2;
          };
          _proto.optionalSpace = function optionalSpace(space2) {
            return this.options.lossy ? "" : space2;
          };
          _proto.lossySpace = function lossySpace(space2, required) {
            if (this.options.lossy) {
              return required ? " " : "";
            } else {
              return space2;
            }
          };
          _proto.parseParenthesisToken = function parseParenthesisToken(token) {
            var content = this.content(token);
            if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
              return this.requiredSpace(content);
            } else {
              return content;
            }
          };
          _proto.newNode = function newNode(node2, namespace2) {
            if (namespace2) {
              if (/^ +$/.test(namespace2)) {
                if (!this.options.lossy) {
                  this.spaces = (this.spaces || "") + namespace2;
                }
                namespace2 = true;
              }
              node2.namespace = namespace2;
              unescapeProp(node2, "namespace");
            }
            if (this.spaces) {
              node2.spaces.before = this.spaces;
              this.spaces = "";
            }
            return this.current.append(node2);
          };
          _proto.content = function content(token) {
            if (token === void 0) {
              token = this.currToken;
            }
            return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
          };
          _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
            if (startPosition === void 0) {
              startPosition = this.position + 1;
            }
            var searchPosition = startPosition;
            while (searchPosition < this.tokens.length) {
              if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
                searchPosition++;
                continue;
              } else {
                return searchPosition;
              }
            }
            return -1;
          };
          _createClass2(Parser3, [{
            key: "currToken",
            get: function get2() {
              return this.tokens[this.position];
            }
          }, {
            key: "nextToken",
            get: function get2() {
              return this.tokens[this.position + 1];
            }
          }, {
            key: "prevToken",
            get: function get2() {
              return this.tokens[this.position - 1];
            }
          }]);
          return Parser3;
        }();
        exports2.default = Parser2;
        module2.exports = exports2.default;
      })(parser$3, parser$3.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _parser3 = _interopRequireDefault2(parser$3.exports);
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var Processor2 = function() {
          function Processor3(func, options2) {
            this.func = func || function noop2() {
            };
            this.funcRes = null;
            this.options = options2;
          }
          var _proto = Processor3.prototype;
          _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var merged = Object.assign({}, this.options, options2);
            if (merged.updateSelector === false) {
              return false;
            } else {
              return typeof rule2 !== "string";
            }
          };
          _proto._isLossy = function _isLossy(options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var merged = Object.assign({}, this.options, options2);
            if (merged.lossless === false) {
              return true;
            } else {
              return false;
            }
          };
          _proto._root = function _root2(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var parser2 = new _parser3.default(rule2, this._parseOptions(options2));
            return parser2.root;
          };
          _proto._parseOptions = function _parseOptions(options2) {
            return {
              lossy: this._isLossy(options2)
            };
          };
          _proto._run = function _run(rule2, options2) {
            var _this = this;
            if (options2 === void 0) {
              options2 = {};
            }
            return new Promise(function(resolve2, reject) {
              try {
                var root2 = _this._root(rule2, options2);
                Promise.resolve(_this.func(root2)).then(function(transform2) {
                  var string2 = void 0;
                  if (_this._shouldUpdateSelector(rule2, options2)) {
                    string2 = root2.toString();
                    rule2.selector = string2;
                  }
                  return {
                    transform: transform2,
                    root: root2,
                    string: string2
                  };
                }).then(resolve2, reject);
              } catch (e) {
                reject(e);
                return;
              }
            });
          };
          _proto._runSync = function _runSync(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var root2 = this._root(rule2, options2);
            var transform2 = this.func(root2);
            if (transform2 && typeof transform2.then === "function") {
              throw new Error("Selector processor returned a promise to a synchronous call.");
            }
            var string2 = void 0;
            if (options2.updateSelector && typeof rule2 !== "string") {
              string2 = root2.toString();
              rule2.selector = string2;
            }
            return {
              transform: transform2,
              root: root2,
              string: string2
            };
          };
          _proto.ast = function ast(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.root;
            });
          };
          _proto.astSync = function astSync(rule2, options2) {
            return this._runSync(rule2, options2).root;
          };
          _proto.transform = function transform2(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.transform;
            });
          };
          _proto.transformSync = function transformSync(rule2, options2) {
            return this._runSync(rule2, options2).transform;
          };
          _proto.process = function process(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.string || result2.root.toString();
            });
          };
          _proto.processSync = function processSync(rule2, options2) {
            var result2 = this._runSync(rule2, options2);
            return result2.string || result2.root.toString();
          };
          return Processor3;
        }();
        exports2.default = Processor2;
        module2.exports = exports2.default;
      })(processor$1, processor$1.exports);
      var selectors$1 = {};
      var constructors$1 = {};
      constructors$1.__esModule = true;
      constructors$1.universal = constructors$1.tag = constructors$1.string = constructors$1.selector = constructors$1.root = constructors$1.pseudo = constructors$1.nesting = constructors$1.id = constructors$1.comment = constructors$1.combinator = constructors$1.className = constructors$1.attribute = void 0;
      var _attribute$1 = _interopRequireDefault$7(attribute$3);
      var _className$1 = _interopRequireDefault$7(className$3.exports);
      var _combinator$1 = _interopRequireDefault$7(combinator$5.exports);
      var _comment$1 = _interopRequireDefault$7(comment$5.exports);
      var _id$1 = _interopRequireDefault$7(id$3.exports);
      var _nesting$1 = _interopRequireDefault$7(nesting$3.exports);
      var _pseudo$1 = _interopRequireDefault$7(pseudo$3.exports);
      var _root$1 = _interopRequireDefault$7(root$4.exports);
      var _selector$1 = _interopRequireDefault$7(selector$3.exports);
      var _string$1 = _interopRequireDefault$7(string$3.exports);
      var _tag$1 = _interopRequireDefault$7(tag$3.exports);
      var _universal$1 = _interopRequireDefault$7(universal$3.exports);
      function _interopRequireDefault$7(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var attribute$2 = function attribute2(opts) {
        return new _attribute$1.default(opts);
      };
      constructors$1.attribute = attribute$2;
      var className$2 = function className2(opts) {
        return new _className$1.default(opts);
      };
      constructors$1.className = className$2;
      var combinator$3 = function combinator2(opts) {
        return new _combinator$1.default(opts);
      };
      constructors$1.combinator = combinator$3;
      var comment$3 = function comment2(opts) {
        return new _comment$1.default(opts);
      };
      constructors$1.comment = comment$3;
      var id$2 = function id2(opts) {
        return new _id$1.default(opts);
      };
      constructors$1.id = id$2;
      var nesting$2 = function nesting2(opts) {
        return new _nesting$1.default(opts);
      };
      constructors$1.nesting = nesting$2;
      var pseudo$2 = function pseudo2(opts) {
        return new _pseudo$1.default(opts);
      };
      constructors$1.pseudo = pseudo$2;
      var root$3 = function root2(opts) {
        return new _root$1.default(opts);
      };
      constructors$1.root = root$3;
      var selector$2 = function selector2(opts) {
        return new _selector$1.default(opts);
      };
      constructors$1.selector = selector$2;
      var string$2 = function string2(opts) {
        return new _string$1.default(opts);
      };
      constructors$1.string = string$2;
      var tag$2 = function tag2(opts) {
        return new _tag$1.default(opts);
      };
      constructors$1.tag = tag$2;
      var universal$2 = function universal2(opts) {
        return new _universal$1.default(opts);
      };
      constructors$1.universal = universal$2;
      var guards$1 = {};
      guards$1.__esModule = true;
      guards$1.isNode = isNode$1;
      guards$1.isPseudoElement = isPseudoElement$1;
      guards$1.isPseudoClass = isPseudoClass$1;
      guards$1.isContainer = isContainer$1;
      guards$1.isNamespace = isNamespace$1;
      guards$1.isUniversal = guards$1.isTag = guards$1.isString = guards$1.isSelector = guards$1.isRoot = guards$1.isPseudo = guards$1.isNesting = guards$1.isIdentifier = guards$1.isComment = guards$1.isCombinator = guards$1.isClassName = guards$1.isAttribute = void 0;
      var _types$1 = types$2;
      var _IS_TYPE$1;
      var IS_TYPE$1 = (_IS_TYPE$1 = {}, _IS_TYPE$1[_types$1.ATTRIBUTE] = true, _IS_TYPE$1[_types$1.CLASS] = true, _IS_TYPE$1[_types$1.COMBINATOR] = true, _IS_TYPE$1[_types$1.COMMENT] = true, _IS_TYPE$1[_types$1.ID] = true, _IS_TYPE$1[_types$1.NESTING] = true, _IS_TYPE$1[_types$1.PSEUDO] = true, _IS_TYPE$1[_types$1.ROOT] = true, _IS_TYPE$1[_types$1.SELECTOR] = true, _IS_TYPE$1[_types$1.STRING] = true, _IS_TYPE$1[_types$1.TAG] = true, _IS_TYPE$1[_types$1.UNIVERSAL] = true, _IS_TYPE$1);
      function isNode$1(node2) {
        return typeof node2 === "object" && IS_TYPE$1[node2.type];
      }
      function isNodeType$1(type2, node2) {
        return isNode$1(node2) && node2.type === type2;
      }
      var isAttribute$1 = isNodeType$1.bind(null, _types$1.ATTRIBUTE);
      guards$1.isAttribute = isAttribute$1;
      var isClassName$1 = isNodeType$1.bind(null, _types$1.CLASS);
      guards$1.isClassName = isClassName$1;
      var isCombinator$1 = isNodeType$1.bind(null, _types$1.COMBINATOR);
      guards$1.isCombinator = isCombinator$1;
      var isComment$1 = isNodeType$1.bind(null, _types$1.COMMENT);
      guards$1.isComment = isComment$1;
      var isIdentifier$1 = isNodeType$1.bind(null, _types$1.ID);
      guards$1.isIdentifier = isIdentifier$1;
      var isNesting$1 = isNodeType$1.bind(null, _types$1.NESTING);
      guards$1.isNesting = isNesting$1;
      var isPseudo$1 = isNodeType$1.bind(null, _types$1.PSEUDO);
      guards$1.isPseudo = isPseudo$1;
      var isRoot$1 = isNodeType$1.bind(null, _types$1.ROOT);
      guards$1.isRoot = isRoot$1;
      var isSelector$1 = isNodeType$1.bind(null, _types$1.SELECTOR);
      guards$1.isSelector = isSelector$1;
      var isString$1 = isNodeType$1.bind(null, _types$1.STRING);
      guards$1.isString = isString$1;
      var isTag$1 = isNodeType$1.bind(null, _types$1.TAG);
      guards$1.isTag = isTag$1;
      var isUniversal$1 = isNodeType$1.bind(null, _types$1.UNIVERSAL);
      guards$1.isUniversal = isUniversal$1;
      function isPseudoElement$1(node2) {
        return isPseudo$1(node2) && node2.value && (node2.value.startsWith("::") || node2.value.toLowerCase() === ":before" || node2.value.toLowerCase() === ":after");
      }
      function isPseudoClass$1(node2) {
        return isPseudo$1(node2) && !isPseudoElement$1(node2);
      }
      function isContainer$1(node2) {
        return !!(isNode$1(node2) && node2.walk);
      }
      function isNamespace$1(node2) {
        return isAttribute$1(node2) || isTag$1(node2);
      }
      (function(exports2) {
        exports2.__esModule = true;
        var _types2 = types$2;
        Object.keys(_types2).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          exports2[key] = _types2[key];
        });
        var _constructors = constructors$1;
        Object.keys(_constructors).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          exports2[key] = _constructors[key];
        });
        var _guards = guards$1;
        Object.keys(_guards).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          exports2[key] = _guards[key];
        });
      })(selectors$1);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2.default = void 0;
        var _processor = _interopRequireDefault2(processor$1.exports);
        var selectors2 = _interopRequireWildcard2(selectors$1);
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                  if (desc.get || desc.set) {
                    Object.defineProperty(newObj, key, desc);
                  } else {
                    newObj[key] = obj[key];
                  }
                }
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var parser2 = function parser3(processor2) {
          return new _processor.default(processor2);
        };
        Object.assign(parser2, selectors2);
        delete parser2.__esModule;
        var _default = parser2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(dist$2, dist$2.exports);
      var sourceMap$1 = sourceMap$2;
      var SourceMapConsumer = sourceMap$1.SourceMapConsumer;
      var SourceMapGenerator = sourceMap$1.SourceMapGenerator;
      var _mergeSourceMap_1_1_0_mergeSourceMap = merge$1;
      function merge$1(oldMap, newMap) {
        if (!oldMap)
          return newMap;
        if (!newMap)
          return oldMap;
        var oldMapConsumer = new SourceMapConsumer(oldMap);
        var newMapConsumer = new SourceMapConsumer(newMap);
        var mergedMapGenerator = new SourceMapGenerator();
        newMapConsumer.eachMapping(function(m) {
          if (m.originalLine == null)
            return;
          var origPosInOldMap = oldMapConsumer.originalPositionFor({
            line: m.originalLine,
            column: m.originalColumn
          });
          if (origPosInOldMap.source == null)
            return;
          mergedMapGenerator.addMapping({
            original: {
              line: origPosInOldMap.line,
              column: origPosInOldMap.column
            },
            generated: {
              line: m.generatedLine,
              column: m.generatedColumn
            },
            source: origPosInOldMap.source,
            name: origPosInOldMap.name
          });
        });
        var consumers = [oldMapConsumer, newMapConsumer];
        consumers.forEach(function(consumer) {
          consumer.sources.forEach(function(sourceFile) {
            mergedMapGenerator._sources.add(sourceFile);
            var sourceContent = consumer.sourceContentFor(sourceFile);
            if (sourceContent != null) {
              mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
            }
          });
        });
        mergedMapGenerator._sourceRoot = oldMap.sourceRoot;
        mergedMapGenerator._file = oldMap.file;
        return JSON.parse(mergedMapGenerator.toString());
      }
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      function encode(decoded) {
        var sourceFileIndex = 0;
        var sourceCodeLine = 0;
        var sourceCodeColumn = 0;
        var nameIndex = 0;
        var mappings = "";
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          if (i2 > 0)
            mappings += ";";
          if (line.length === 0)
            continue;
          var generatedCodeColumn = 0;
          var lineMappings = [];
          for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
              segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
              sourceFileIndex = segment[1];
              sourceCodeLine = segment[2];
              sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
              segmentMappings += encodeInteger(segment[4] - nameIndex);
              nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
          }
          mappings += lineMappings.join(",");
        }
        return mappings;
      }
      function encodeInteger(num) {
        var result2 = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          var clamped = num & 31;
          num >>>= 5;
          if (num > 0) {
            clamped |= 32;
          }
          result2 += chars[clamped];
        } while (num > 0);
        return result2;
      }
      var BitSet = function BitSet2(arg) {
        this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
      };
      BitSet.prototype.add = function add(n2) {
        this.bits[n2 >> 5] |= 1 << (n2 & 31);
      };
      BitSet.prototype.has = function has2(n2) {
        return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
      };
      var Chunk = function Chunk2(start, end, content) {
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = "";
        this.outro = "";
        this.content = content;
        this.storeName = false;
        this.edited = false;
        Object.defineProperties(this, {
          previous: { writable: true, value: null },
          next: { writable: true, value: null }
        });
      };
      Chunk.prototype.appendLeft = function appendLeft(content) {
        this.outro += content;
      };
      Chunk.prototype.appendRight = function appendRight(content) {
        this.intro = this.intro + content;
      };
      Chunk.prototype.clone = function clone2() {
        var chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
      };
      Chunk.prototype.contains = function contains(index) {
        return this.start < index && index < this.end;
      };
      Chunk.prototype.eachNext = function eachNext(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.next;
        }
      };
      Chunk.prototype.eachPrevious = function eachPrevious(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.previous;
        }
      };
      Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
          this.intro = "";
          this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
      };
      Chunk.prototype.prependLeft = function prependLeft(content) {
        this.outro = content + this.outro;
      };
      Chunk.prototype.prependRight = function prependRight(content) {
        this.intro = content + this.intro;
      };
      Chunk.prototype.split = function split(index) {
        var sliceIndex = index - this.start;
        var originalBefore = this.original.slice(0, sliceIndex);
        var originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        var newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index;
        if (this.edited) {
          newChunk.edit("", false);
          this.content = "";
        } else {
          this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) {
          newChunk.next.previous = newChunk;
        }
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
      };
      Chunk.prototype.toString = function toString2() {
        return this.intro + this.content + this.outro;
      };
      Chunk.prototype.trimEnd = function trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.intro = this.intro.replace(rx, "");
          if (this.intro.length) {
            return true;
          }
        }
      };
      Chunk.prototype.trimStart = function trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.outro = this.outro.replace(rx, "");
          if (this.outro.length) {
            return true;
          }
        }
      };
      var btoa = function() {
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
      };
      if (typeof window !== "undefined" && typeof window.btoa === "function") {
        btoa = function(str2) {
          return window.btoa(unescape(encodeURIComponent(str2)));
        };
      } else if (typeof Buffer$1 === "function") {
        btoa = function(str2) {
          return Buffer$1.from(str2, "utf-8").toString("base64");
        };
      }
      var SourceMap = function SourceMap2(properties) {
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = encode(properties.mappings);
      };
      SourceMap.prototype.toString = function toString2() {
        return JSON.stringify(this);
      };
      SourceMap.prototype.toUrl = function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
      };
      function guessIndent(code2) {
        var lines2 = code2.split("\n");
        var tabbed = lines2.filter(function(line) {
          return /^\t+/.test(line);
        });
        var spaced = lines2.filter(function(line) {
          return /^ {2,}/.test(line);
        });
        if (tabbed.length === 0 && spaced.length === 0) {
          return null;
        }
        if (tabbed.length >= spaced.length) {
          return "	";
        }
        var min = spaced.reduce(function(previous, current) {
          var numSpaces = /^ +/.exec(current)[0].length;
          return Math.min(numSpaces, previous);
        }, Infinity);
        return new Array(min + 1).join(" ");
      }
      function getRelativePath(from2, to) {
        var fromParts = from2.split(/[/\\]/);
        var toParts = to.split(/[/\\]/);
        fromParts.pop();
        while (fromParts[0] === toParts[0]) {
          fromParts.shift();
          toParts.shift();
        }
        if (fromParts.length) {
          var i2 = fromParts.length;
          while (i2--) {
            fromParts[i2] = "..";
          }
        }
        return fromParts.concat(toParts).join("/");
      }
      var toString$1 = Object.prototype.toString;
      function isObject$1(thing) {
        return toString$1.call(thing) === "[object Object]";
      }
      function getLocator(source) {
        var originalLines = source.split("\n");
        var lineOffsets = [];
        for (var i2 = 0, pos = 0; i2 < originalLines.length; i2++) {
          lineOffsets.push(pos);
          pos += originalLines[i2].length + 1;
        }
        return function locate(index) {
          var i3 = 0;
          var j = lineOffsets.length;
          while (i3 < j) {
            var m = i3 + j >> 1;
            if (index < lineOffsets[m]) {
              j = m;
            } else {
              i3 = m + 1;
            }
          }
          var line = i3 - 1;
          var column = index - lineOffsets[line];
          return { line, column };
        };
      }
      var Mappings = function Mappings2(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
      };
      Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
          var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (nameIndex >= 0) {
            segment.push(nameIndex);
          }
          this.rawSegments.push(segment);
        } else if (this.pending) {
          this.rawSegments.push(this.pending);
        }
        this.advance(content);
        this.pending = null;
      };
      Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        var originalCharIndex = chunk.start;
        var first = true;
        while (originalCharIndex < chunk.end) {
          if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
          }
          if (original[originalCharIndex] === "\n") {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
            first = true;
          } else {
            loc.column += 1;
            this.generatedCodeColumn += 1;
            first = false;
          }
          originalCharIndex += 1;
        }
        this.pending = null;
      };
      Mappings.prototype.advance = function advance(str2) {
        if (!str2) {
          return;
        }
        var lines2 = str2.split("\n");
        if (lines2.length > 1) {
          for (var i2 = 0; i2 < lines2.length - 1; i2++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
          }
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines2[lines2.length - 1].length;
      };
      var n = "\n";
      var warned = {
        insertLeft: false,
        insertRight: false,
        storeName: false
      };
      var MagicString$1 = function MagicString2(string2, options2) {
        if (options2 === void 0)
          options2 = {};
        var chunk = new Chunk(0, string2.length, string2);
        Object.defineProperties(this, {
          original: { writable: true, value: string2 },
          outro: { writable: true, value: "" },
          intro: { writable: true, value: "" },
          firstChunk: { writable: true, value: chunk },
          lastChunk: { writable: true, value: chunk },
          lastSearchedChunk: { writable: true, value: chunk },
          byStart: { writable: true, value: {} },
          byEnd: { writable: true, value: {} },
          filename: { writable: true, value: options2.filename },
          indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
          sourcemapLocations: { writable: true, value: new BitSet() },
          storedNames: { writable: true, value: {} },
          indentStr: { writable: true, value: guessIndent(string2) }
        });
        this.byStart[0] = chunk;
        this.byEnd[string2.length] = chunk;
      };
      MagicString$1.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
      };
      MagicString$1.prototype.append = function append(content) {
        if (typeof content !== "string") {
          throw new TypeError("outro content must be a string");
        }
        this.outro += content;
        return this;
      };
      MagicString$1.prototype.appendLeft = function appendLeft(index, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index);
        var chunk = this.byEnd[index];
        if (chunk) {
          chunk.appendLeft(content);
        } else {
          this.intro += content;
        }
        return this;
      };
      MagicString$1.prototype.appendRight = function appendRight(index, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index);
        var chunk = this.byStart[index];
        if (chunk) {
          chunk.appendRight(content);
        } else {
          this.outro += content;
        }
        return this;
      };
      MagicString$1.prototype.clone = function clone2() {
        var cloned = new MagicString$1(this.original, { filename: this.filename });
        var originalChunk = this.firstChunk;
        var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;
          var nextOriginalChunk = originalChunk.next;
          var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
          }
          originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
      };
      MagicString$1.prototype.generateDecodedMap = function generateDecodedMap(options2) {
        var this$1$1 = this;
        options2 = options2 || {};
        var sourceIndex = 0;
        var names = Object.keys(this.storedNames);
        var mappings = new Mappings(options2.hires);
        var locate = getLocator(this.original);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.firstChunk.eachNext(function(chunk) {
          var loc = locate(chunk.start);
          if (chunk.intro.length) {
            mappings.advance(chunk.intro);
          }
          if (chunk.edited) {
            mappings.addEdit(
              sourceIndex,
              chunk.content,
              loc,
              chunk.storeName ? names.indexOf(chunk.original) : -1
            );
          } else {
            mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
          }
          if (chunk.outro.length) {
            mappings.advance(chunk.outro);
          }
        });
        return {
          file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
          sources: [options2.source ? getRelativePath(options2.file || "", options2.source) : null],
          sourcesContent: options2.includeContent ? [this.original] : [null],
          names,
          mappings: mappings.raw
        };
      };
      MagicString$1.prototype.generateMap = function generateMap(options2) {
        return new SourceMap(this.generateDecodedMap(options2));
      };
      MagicString$1.prototype.getIndentString = function getIndentString() {
        return this.indentStr === null ? "	" : this.indentStr;
      };
      MagicString$1.prototype.indent = function indent(indentStr, options2) {
        var pattern = /^[^\r\n]/gm;
        if (isObject$1(indentStr)) {
          options2 = indentStr;
          indentStr = void 0;
        }
        indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
        if (indentStr === "") {
          return this;
        }
        options2 = options2 || {};
        var isExcluded = {};
        if (options2.exclude) {
          var exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
          exclusions.forEach(function(exclusion) {
            for (var i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
              isExcluded[i2] = true;
            }
          });
        }
        var shouldIndentNextCharacter = options2.indentStart !== false;
        var replacer2 = function(match) {
          if (shouldIndentNextCharacter) {
            return "" + indentStr + match;
          }
          shouldIndentNextCharacter = true;
          return match;
        };
        this.intro = this.intro.replace(pattern, replacer2);
        var charIndex = 0;
        var chunk = this.firstChunk;
        while (chunk) {
          var end = chunk.end;
          if (chunk.edited) {
            if (!isExcluded[charIndex]) {
              chunk.content = chunk.content.replace(pattern, replacer2);
              if (chunk.content.length) {
                shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
              }
            }
          } else {
            charIndex = chunk.start;
            while (charIndex < end) {
              if (!isExcluded[charIndex]) {
                var char = this.original[charIndex];
                if (char === "\n") {
                  shouldIndentNextCharacter = true;
                } else if (char !== "\r" && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;
                  if (charIndex === chunk.start) {
                    chunk.prependRight(indentStr);
                  } else {
                    this._splitChunk(chunk, charIndex);
                    chunk = chunk.next;
                    chunk.prependRight(indentStr);
                  }
                }
              }
              charIndex += 1;
            }
          }
          charIndex = chunk.end;
          chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern, replacer2);
        return this;
      };
      MagicString$1.prototype.insert = function insert2() {
        throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
      };
      MagicString$1.prototype.insertLeft = function insertLeft(index, content) {
        if (!warned.insertLeft) {
          console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
          warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
      };
      MagicString$1.prototype.insertRight = function insertRight(index, content) {
        if (!warned.insertRight) {
          console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
          warned.insertRight = true;
        }
        return this.prependRight(index, content);
      };
      MagicString$1.prototype.move = function move(start, end, index) {
        if (index >= start && index <= end) {
          throw new Error("Cannot move a selection inside itself");
        }
        this._split(start);
        this._split(end);
        this._split(index);
        var first = this.byStart[start];
        var last2 = this.byEnd[end];
        var oldLeft = first.previous;
        var oldRight = last2.next;
        var newRight = this.byStart[index];
        if (!newRight && last2 === this.lastChunk) {
          return this;
        }
        var newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) {
          oldLeft.next = oldRight;
        }
        if (oldRight) {
          oldRight.previous = oldLeft;
        }
        if (newLeft) {
          newLeft.next = first;
        }
        if (newRight) {
          newRight.previous = last2;
        }
        if (!first.previous) {
          this.firstChunk = last2.next;
        }
        if (!last2.next) {
          this.lastChunk = first.previous;
          this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last2.next = newRight || null;
        if (!newLeft) {
          this.firstChunk = first;
        }
        if (!newRight) {
          this.lastChunk = last2;
        }
        return this;
      };
      MagicString$1.prototype.overwrite = function overwrite(start, end, content, options2) {
        if (typeof content !== "string") {
          throw new TypeError("replacement content must be a string");
        }
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        if (end > this.original.length) {
          throw new Error("end is out of bounds");
        }
        if (start === end) {
          throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
        }
        this._split(start);
        this._split(end);
        if (options2 === true) {
          if (!warned.storeName) {
            console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
            warned.storeName = true;
          }
          options2 = { storeName: true };
        }
        var storeName = options2 !== void 0 ? options2.storeName : false;
        var contentOnly = options2 !== void 0 ? options2.contentOnly : false;
        if (storeName) {
          var original = this.original.slice(start, end);
          this.storedNames[original] = true;
        }
        var first = this.byStart[start];
        var last2 = this.byEnd[end];
        if (first) {
          if (end > first.end && first.next !== this.byStart[first.end]) {
            throw new Error("Cannot overwrite across a split point");
          }
          first.edit(content, storeName, contentOnly);
          if (first !== last2) {
            var chunk = first.next;
            while (chunk !== last2) {
              chunk.edit("", false);
              chunk = chunk.next;
            }
            chunk.edit("", false);
          }
        } else {
          var newChunk = new Chunk(start, end, "").edit(content, storeName);
          last2.next = newChunk;
          newChunk.previous = last2;
        }
        return this;
      };
      MagicString$1.prototype.prepend = function prepend(content) {
        if (typeof content !== "string") {
          throw new TypeError("outro content must be a string");
        }
        this.intro = content + this.intro;
        return this;
      };
      MagicString$1.prototype.prependLeft = function prependLeft(index, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index);
        var chunk = this.byEnd[index];
        if (chunk) {
          chunk.prependLeft(content);
        } else {
          this.intro = content + this.intro;
        }
        return this;
      };
      MagicString$1.prototype.prependRight = function prependRight(index, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index);
        var chunk = this.byStart[index];
        if (chunk) {
          chunk.prependRight(content);
        } else {
          this.outro = content + this.outro;
        }
        return this;
      };
      MagicString$1.prototype.remove = function remove2(start, end) {
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        if (start === end) {
          return this;
        }
        if (start < 0 || end > this.original.length) {
          throw new Error("Character is out of bounds");
        }
        if (start > end) {
          throw new Error("end must be greater than start");
        }
        this._split(start);
        this._split(end);
        var chunk = this.byStart[start];
        while (chunk) {
          chunk.intro = "";
          chunk.outro = "";
          chunk.edit("");
          chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
      };
      MagicString$1.prototype.lastChar = function lastChar() {
        if (this.outro.length) {
          return this.outro[this.outro.length - 1];
        }
        var chunk = this.lastChunk;
        do {
          if (chunk.outro.length) {
            return chunk.outro[chunk.outro.length - 1];
          }
          if (chunk.content.length) {
            return chunk.content[chunk.content.length - 1];
          }
          if (chunk.intro.length) {
            return chunk.intro[chunk.intro.length - 1];
          }
        } while (chunk = chunk.previous);
        if (this.intro.length) {
          return this.intro[this.intro.length - 1];
        }
        return "";
      };
      MagicString$1.prototype.lastLine = function lastLine() {
        var lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return this.outro.substr(lineIndex + 1);
        }
        var lineStr = this.outro;
        var chunk = this.lastChunk;
        do {
          if (chunk.outro.length > 0) {
            lineIndex = chunk.outro.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.outro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.outro + lineStr;
          }
          if (chunk.content.length > 0) {
            lineIndex = chunk.content.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.content.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.content + lineStr;
          }
          if (chunk.intro.length > 0) {
            lineIndex = chunk.intro.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.intro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.intro + lineStr;
          }
        } while (chunk = chunk.previous);
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return this.intro.substr(lineIndex + 1) + lineStr;
        }
        return this.intro + lineStr;
      };
      MagicString$1.prototype.slice = function slice(start, end) {
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = this.original.length;
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        var result2 = "";
        var chunk = this.firstChunk;
        while (chunk && (chunk.start > start || chunk.end <= start)) {
          if (chunk.start < end && chunk.end >= end) {
            return result2;
          }
          chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) {
          throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
        }
        var startChunk = chunk;
        while (chunk) {
          if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result2 += chunk.intro;
          }
          var containsEnd = chunk.start < end && chunk.end >= end;
          if (containsEnd && chunk.edited && chunk.end !== end) {
            throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
          }
          var sliceStart = startChunk === chunk ? start - chunk.start : 0;
          var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
          result2 += chunk.content.slice(sliceStart, sliceEnd);
          if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result2 += chunk.outro;
          }
          if (containsEnd) {
            break;
          }
          chunk = chunk.next;
        }
        return result2;
      };
      MagicString$1.prototype.snip = function snip(start, end) {
        var clone2 = this.clone();
        clone2.remove(0, start);
        clone2.remove(end, clone2.original.length);
        return clone2;
      };
      MagicString$1.prototype._split = function _split(index) {
        if (this.byStart[index] || this.byEnd[index]) {
          return;
        }
        var chunk = this.lastSearchedChunk;
        var searchForward = index > chunk.end;
        while (chunk) {
          if (chunk.contains(index)) {
            return this._splitChunk(chunk, index);
          }
          chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
      };
      MagicString$1.prototype._splitChunk = function _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
          var loc = getLocator(this.original)(index);
          throw new Error(
            "Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' – "' + chunk.original + '")'
          );
        }
        var newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) {
          this.lastChunk = newChunk;
        }
        this.lastSearchedChunk = chunk;
        return true;
      };
      MagicString$1.prototype.toString = function toString2() {
        var str2 = this.intro;
        var chunk = this.firstChunk;
        while (chunk) {
          str2 += chunk.toString();
          chunk = chunk.next;
        }
        return str2 + this.outro;
      };
      MagicString$1.prototype.isEmpty = function isEmpty() {
        var chunk = this.firstChunk;
        do {
          if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
            return false;
          }
        } while (chunk = chunk.next);
        return true;
      };
      MagicString$1.prototype.length = function length() {
        var chunk = this.firstChunk;
        var length2 = 0;
        do {
          length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
        } while (chunk = chunk.next);
        return length2;
      };
      MagicString$1.prototype.trimLines = function trimLines() {
        return this.trim("[\\r\\n]");
      };
      MagicString$1.prototype.trim = function trim2(charType) {
        return this.trimStart(charType).trimEnd(charType);
      };
      MagicString$1.prototype.trimEndAborted = function trimEndAborted(charType) {
        var rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
        var chunk = this.lastChunk;
        do {
          var end = chunk.end;
          var aborted = chunk.trimEnd(rx);
          if (chunk.end !== end) {
            if (this.lastChunk === chunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted) {
            return true;
          }
          chunk = chunk.previous;
        } while (chunk);
        return false;
      };
      MagicString$1.prototype.trimEnd = function trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
      };
      MagicString$1.prototype.trimStartAborted = function trimStartAborted(charType) {
        var rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
        var chunk = this.firstChunk;
        do {
          var end = chunk.end;
          var aborted = chunk.trimStart(rx);
          if (chunk.end !== end) {
            if (chunk === this.lastChunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted) {
            return true;
          }
          chunk = chunk.next;
        } while (chunk);
        return false;
      };
      MagicString$1.prototype.trimStart = function trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
      };
      var hasOwnProp = Object.prototype.hasOwnProperty;
      var Bundle = function Bundle2(options2) {
        if (options2 === void 0)
          options2 = {};
        this.intro = options2.intro || "";
        this.separator = options2.separator !== void 0 ? options2.separator : "\n";
        this.sources = [];
        this.uniqueSources = [];
        this.uniqueSourceIndexByFilename = {};
      };
      Bundle.prototype.addSource = function addSource(source) {
        if (source instanceof MagicString$1) {
          return this.addSource({
            content: source,
            filename: source.filename,
            separator: this.separator
          });
        }
        if (!isObject$1(source) || !source.content) {
          throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
        }
        ["filename", "indentExclusionRanges", "separator"].forEach(function(option) {
          if (!hasOwnProp.call(source, option)) {
            source[option] = source.content[option];
          }
        });
        if (source.separator === void 0) {
          source.separator = this.separator;
        }
        if (source.filename) {
          if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
            this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
            this.uniqueSources.push({ filename: source.filename, content: source.content.original });
          } else {
            var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
            if (source.content.original !== uniqueSource.content) {
              throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
            }
          }
        }
        this.sources.push(source);
        return this;
      };
      Bundle.prototype.append = function append(str2, options2) {
        this.addSource({
          content: new MagicString$1(str2),
          separator: options2 && options2.separator || ""
        });
        return this;
      };
      Bundle.prototype.clone = function clone2() {
        var bundle = new Bundle({
          intro: this.intro,
          separator: this.separator
        });
        this.sources.forEach(function(source) {
          bundle.addSource({
            filename: source.filename,
            content: source.content.clone(),
            separator: source.separator
          });
        });
        return bundle;
      };
      Bundle.prototype.generateDecodedMap = function generateDecodedMap(options2) {
        var this$1$1 = this;
        if (options2 === void 0)
          options2 = {};
        var names = [];
        this.sources.forEach(function(source) {
          Object.keys(source.content.storedNames).forEach(function(name2) {
            if (!~names.indexOf(name2)) {
              names.push(name2);
            }
          });
        });
        var mappings = new Mappings(options2.hires);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.sources.forEach(function(source, i2) {
          if (i2 > 0) {
            mappings.advance(this$1$1.separator);
          }
          var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
          var magicString = source.content;
          var locate = getLocator(magicString.original);
          if (magicString.intro) {
            mappings.advance(magicString.intro);
          }
          magicString.firstChunk.eachNext(function(chunk) {
            var loc = locate(chunk.start);
            if (chunk.intro.length) {
              mappings.advance(chunk.intro);
            }
            if (source.filename) {
              if (chunk.edited) {
                mappings.addEdit(
                  sourceIndex,
                  chunk.content,
                  loc,
                  chunk.storeName ? names.indexOf(chunk.original) : -1
                );
              } else {
                mappings.addUneditedChunk(
                  sourceIndex,
                  chunk,
                  magicString.original,
                  loc,
                  magicString.sourcemapLocations
                );
              }
            } else {
              mappings.advance(chunk.content);
            }
            if (chunk.outro.length) {
              mappings.advance(chunk.outro);
            }
          });
          if (magicString.outro) {
            mappings.advance(magicString.outro);
          }
        });
        return {
          file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
          sources: this.uniqueSources.map(function(source) {
            return options2.file ? getRelativePath(options2.file, source.filename) : source.filename;
          }),
          sourcesContent: this.uniqueSources.map(function(source) {
            return options2.includeContent ? source.content : null;
          }),
          names,
          mappings: mappings.raw
        };
      };
      Bundle.prototype.generateMap = function generateMap(options2) {
        return new SourceMap(this.generateDecodedMap(options2));
      };
      Bundle.prototype.getIndentString = function getIndentString() {
        var indentStringCounts = {};
        this.sources.forEach(function(source) {
          var indentStr = source.content.indentStr;
          if (indentStr === null) {
            return;
          }
          if (!indentStringCounts[indentStr]) {
            indentStringCounts[indentStr] = 0;
          }
          indentStringCounts[indentStr] += 1;
        });
        return Object.keys(indentStringCounts).sort(function(a, b2) {
          return indentStringCounts[a] - indentStringCounts[b2];
        })[0] || "	";
      };
      Bundle.prototype.indent = function indent(indentStr) {
        var this$1$1 = this;
        if (!arguments.length) {
          indentStr = this.getIndentString();
        }
        if (indentStr === "") {
          return this;
        }
        var trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
        this.sources.forEach(function(source, i2) {
          var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
          var indentStart = trailingNewline || i2 > 0 && /\r?\n$/.test(separator);
          source.content.indent(indentStr, {
            exclude: source.indentExclusionRanges,
            indentStart
            //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
          });
          trailingNewline = source.content.lastChar() === "\n";
        });
        if (this.intro) {
          this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function(match, index) {
            return index > 0 ? indentStr + match : match;
          });
        }
        return this;
      };
      Bundle.prototype.prepend = function prepend(str2) {
        this.intro = str2 + this.intro;
        return this;
      };
      Bundle.prototype.toString = function toString2() {
        var this$1$1 = this;
        var body = this.sources.map(function(source, i2) {
          var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
          var str2 = (i2 > 0 ? separator : "") + source.content.toString();
          return str2;
        }).join("");
        return this.intro + body;
      };
      Bundle.prototype.isEmpty = function isEmpty() {
        if (this.intro.length && this.intro.trim()) {
          return false;
        }
        if (this.sources.some(function(source) {
          return !source.content.isEmpty();
        })) {
          return false;
        }
        return true;
      };
      Bundle.prototype.length = function length() {
        return this.sources.reduce(function(length2, source) {
          return length2 + source.content.length();
        }, this.intro.length);
      };
      Bundle.prototype.trimLines = function trimLines() {
        return this.trim("[\\r\\n]");
      };
      Bundle.prototype.trim = function trim2(charType) {
        return this.trimStart(charType).trimEnd(charType);
      };
      Bundle.prototype.trimStart = function trimStart(charType) {
        var rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (!this.intro) {
          var source;
          var i2 = 0;
          do {
            source = this.sources[i2++];
            if (!source) {
              break;
            }
          } while (!source.content.trimStartAborted(charType));
        }
        return this;
      };
      Bundle.prototype.trimEnd = function trimEnd(charType) {
        var rx = new RegExp((charType || "\\s") + "+$");
        var source;
        var i2 = this.sources.length - 1;
        do {
          source = this.sources[i2--];
          if (!source) {
            this.intro = this.intro.replace(rx, "");
            break;
          }
        } while (!source.content.trimEndAborted(charType));
        return this;
      };
      var magicString_es = Object.freeze({
        __proto__: null,
        "default": MagicString$1,
        Bundle,
        SourceMap
      });
      var require$$11 = getAugmentedNamespace(magicString_es);
      var estreeWalker$1 = { exports: {} };
      (function(module2, exports2) {
        (function(global2, factory2) {
          factory2(exports2);
        })(commonjsGlobal, function(exports3) {
          class WalkerBase {
            constructor() {
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              this.context = {
                skip: () => this.should_skip = true,
                remove: () => this.should_remove = true,
                replace: (node2) => this.replacement = node2
              };
            }
            /**
             *
             * @param {any} parent
             * @param {string} prop
             * @param {number} index
             * @param {BaseNode} node
             */
            replace(parent, prop, index, node2) {
              if (parent) {
                if (index !== null) {
                  parent[prop][index] = node2;
                } else {
                  parent[prop] = node2;
                }
              }
            }
            /**
             *
             * @param {any} parent
             * @param {string} prop
             * @param {number} index
             */
            remove(parent, prop, index) {
              if (parent) {
                if (index !== null) {
                  parent[prop].splice(index, 1);
                } else {
                  delete parent[prop];
                }
              }
            }
          }
          class SyncWalker extends WalkerBase {
            /**
             *
             * @param {SyncHandler} enter
             * @param {SyncHandler} leave
             */
            constructor(enter, leave) {
              super();
              this.enter = enter;
              this.leave = leave;
            }
            /**
             *
             * @param {BaseNode} node
             * @param {BaseNode} parent
             * @param {string} [prop]
             * @param {number} [index]
             * @returns {BaseNode}
             */
            visit(node2, parent, prop, index) {
              if (node2) {
                if (this.enter) {
                  const _should_skip = this.should_skip;
                  const _should_remove = this.should_remove;
                  const _replacement = this.replacement;
                  this.should_skip = false;
                  this.should_remove = false;
                  this.replacement = null;
                  this.enter.call(this.context, node2, parent, prop, index);
                  if (this.replacement) {
                    node2 = this.replacement;
                    this.replace(parent, prop, index, node2);
                  }
                  if (this.should_remove) {
                    this.remove(parent, prop, index);
                  }
                  const skipped = this.should_skip;
                  const removed = this.should_remove;
                  this.should_skip = _should_skip;
                  this.should_remove = _should_remove;
                  this.replacement = _replacement;
                  if (skipped)
                    return node2;
                  if (removed)
                    return null;
                }
                for (const key in node2) {
                  const value = node2[key];
                  if (typeof value !== "object") {
                    continue;
                  } else if (Array.isArray(value)) {
                    for (let i2 = 0; i2 < value.length; i2 += 1) {
                      if (value[i2] !== null && typeof value[i2].type === "string") {
                        if (!this.visit(value[i2], node2, key, i2)) {
                          i2--;
                        }
                      }
                    }
                  } else if (value !== null && typeof value.type === "string") {
                    this.visit(value, node2, key, null);
                  }
                }
                if (this.leave) {
                  const _replacement = this.replacement;
                  const _should_remove = this.should_remove;
                  this.replacement = null;
                  this.should_remove = false;
                  this.leave.call(this.context, node2, parent, prop, index);
                  if (this.replacement) {
                    node2 = this.replacement;
                    this.replace(parent, prop, index, node2);
                  }
                  if (this.should_remove) {
                    this.remove(parent, prop, index);
                  }
                  const removed = this.should_remove;
                  this.replacement = _replacement;
                  this.should_remove = _should_remove;
                  if (removed)
                    return null;
                }
              }
              return node2;
            }
          }
          class AsyncWalker extends WalkerBase {
            /**
             *
             * @param {AsyncHandler} enter
             * @param {AsyncHandler} leave
             */
            constructor(enter, leave) {
              super();
              this.enter = enter;
              this.leave = leave;
            }
            /**
             *
             * @param {BaseNode} node
             * @param {BaseNode} parent
             * @param {string} [prop]
             * @param {number} [index]
             * @returns {Promise<BaseNode>}
             */
            async visit(node2, parent, prop, index) {
              if (node2) {
                if (this.enter) {
                  const _should_skip = this.should_skip;
                  const _should_remove = this.should_remove;
                  const _replacement = this.replacement;
                  this.should_skip = false;
                  this.should_remove = false;
                  this.replacement = null;
                  await this.enter.call(this.context, node2, parent, prop, index);
                  if (this.replacement) {
                    node2 = this.replacement;
                    this.replace(parent, prop, index, node2);
                  }
                  if (this.should_remove) {
                    this.remove(parent, prop, index);
                  }
                  const skipped = this.should_skip;
                  const removed = this.should_remove;
                  this.should_skip = _should_skip;
                  this.should_remove = _should_remove;
                  this.replacement = _replacement;
                  if (skipped)
                    return node2;
                  if (removed)
                    return null;
                }
                for (const key in node2) {
                  const value = node2[key];
                  if (typeof value !== "object") {
                    continue;
                  } else if (Array.isArray(value)) {
                    for (let i2 = 0; i2 < value.length; i2 += 1) {
                      if (value[i2] !== null && typeof value[i2].type === "string") {
                        if (!await this.visit(value[i2], node2, key, i2)) {
                          i2--;
                        }
                      }
                    }
                  } else if (value !== null && typeof value.type === "string") {
                    await this.visit(value, node2, key, null);
                  }
                }
                if (this.leave) {
                  const _replacement = this.replacement;
                  const _should_remove = this.should_remove;
                  this.replacement = null;
                  this.should_remove = false;
                  await this.leave.call(this.context, node2, parent, prop, index);
                  if (this.replacement) {
                    node2 = this.replacement;
                    this.replace(parent, prop, index, node2);
                  }
                  if (this.should_remove) {
                    this.remove(parent, prop, index);
                  }
                  const removed = this.should_remove;
                  this.replacement = _replacement;
                  this.should_remove = _should_remove;
                  if (removed)
                    return null;
                }
              }
              return node2;
            }
          }
          function walk2(ast, { enter, leave }) {
            const instance = new SyncWalker(enter, leave);
            return instance.visit(ast, null);
          }
          async function asyncWalk(ast, { enter, leave }) {
            const instance = new AsyncWalker(enter, leave);
            return await instance.visit(ast, null);
          }
          exports3.asyncWalk = asyncWalk;
          exports3.walk = walk2;
          Object.defineProperty(exports3, "__esModule", { value: true });
        });
      })(estreeWalker$1, estreeWalker$1.exports);
      var yallist = Yallist$1;
      Yallist$1.Node = Node;
      Yallist$1.create = Yallist$1;
      function Yallist$1(list2) {
        var self2 = this;
        if (!(self2 instanceof Yallist$1)) {
          self2 = new Yallist$1();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list2 && typeof list2.forEach === "function") {
          list2.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
            self2.push(arguments[i2]);
          }
        }
        return self2;
      }
      Yallist$1.prototype.removeNode = function(node2) {
        if (node2.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node2.next;
        var prev = node2.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node2 === this.head) {
          this.head = next;
        }
        if (node2 === this.tail) {
          this.tail = prev;
        }
        node2.list.length--;
        node2.next = null;
        node2.prev = null;
        node2.list = null;
        return next;
      };
      Yallist$1.prototype.unshiftNode = function(node2) {
        if (node2 === this.head) {
          return;
        }
        if (node2.list) {
          node2.list.removeNode(node2);
        }
        var head = this.head;
        node2.list = this;
        node2.next = head;
        if (head) {
          head.prev = node2;
        }
        this.head = node2;
        if (!this.tail) {
          this.tail = node2;
        }
        this.length++;
      };
      Yallist$1.prototype.pushNode = function(node2) {
        if (node2 === this.tail) {
          return;
        }
        if (node2.list) {
          node2.list.removeNode(node2);
        }
        var tail = this.tail;
        node2.list = this;
        node2.prev = tail;
        if (tail) {
          tail.next = node2;
        }
        this.tail = node2;
        if (!this.head) {
          this.head = node2;
        }
        this.length++;
      };
      Yallist$1.prototype.push = function() {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          push(this, arguments[i2]);
        }
        return this.length;
      };
      Yallist$1.prototype.unshift = function() {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          unshift(this, arguments[i2]);
        }
        return this.length;
      };
      Yallist$1.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist$1.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist$1.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i2 = 0; walker !== null; i2++) {
          fn.call(thisp, walker.value, i2, this);
          walker = walker.next;
        }
      };
      Yallist$1.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
          fn.call(thisp, walker.value, i2, this);
          walker = walker.prev;
        }
      };
      Yallist$1.prototype.get = function(n2) {
        for (var i2 = 0, walker = this.head; walker !== null && i2 < n2; i2++) {
          walker = walker.next;
        }
        if (i2 === n2 && walker !== null) {
          return walker.value;
        }
      };
      Yallist$1.prototype.getReverse = function(n2) {
        for (var i2 = 0, walker = this.tail; walker !== null && i2 < n2; i2++) {
          walker = walker.prev;
        }
        if (i2 === n2 && walker !== null) {
          return walker.value;
        }
      };
      Yallist$1.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist$1();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist$1.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist$1();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist$1.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i2 = 0; walker !== null; i2++) {
          acc = fn(acc, walker.value, i2);
          walker = walker.next;
        }
        return acc;
      };
      Yallist$1.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i2 = this.length - 1; walker !== null; i2--) {
          acc = fn(acc, walker.value, i2);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist$1.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i2 = 0, walker = this.head; walker !== null; i2++) {
          arr[i2] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist$1.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
          arr[i2] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist$1.prototype.slice = function(from2, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from2 = from2 || 0;
        if (from2 < 0) {
          from2 += this.length;
        }
        var ret = new Yallist$1();
        if (to < from2 || to < 0) {
          return ret;
        }
        if (from2 < 0) {
          from2 = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i2 = 0, walker = this.head; walker !== null && i2 < from2; i2++) {
          walker = walker.next;
        }
        for (; walker !== null && i2 < to; i2++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist$1.prototype.sliceReverse = function(from2, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from2 = from2 || 0;
        if (from2 < 0) {
          from2 += this.length;
        }
        var ret = new Yallist$1();
        if (to < from2 || to < 0) {
          return ret;
        }
        if (from2 < 0) {
          from2 = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
          walker = walker.prev;
        }
        for (; walker !== null && i2 > from2; i2--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist$1.prototype.splice = function(start, deleteCount) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i2 = 0; walker && i2 < deleteCount; i2++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i2 = 2; i2 < arguments.length; i2++) {
          walker = insert(this, walker, arguments[i2]);
        }
        return ret;
      };
      Yallist$1.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node2, value) {
        var inserted = node2 === self2.head ? new Node(value, null, node2, self2) : new Node(value, node2, node2.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node(value, prev, next, list2) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list2);
        }
        this.list = list2;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        __require("./iterator.js")(Yallist$1);
      } catch (er) {
      }
      const Yallist = yallist;
      const MAX = Symbol("max");
      const LENGTH = Symbol("length");
      const LENGTH_CALCULATOR = Symbol("lengthCalculator");
      const ALLOW_STALE = Symbol("allowStale");
      const MAX_AGE = Symbol("maxAge");
      const DISPOSE = Symbol("dispose");
      const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      const LRU_LIST = Symbol("lruList");
      const CACHE = Symbol("cache");
      const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      const naiveLength = () => 1;
      class LRUCache {
        constructor(options2) {
          if (typeof options2 === "number")
            options2 = { max: options2 };
          if (!options2)
            options2 = {};
          if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
            throw new TypeError("max must be a non-negative number");
          this[MAX] = options2.max || Infinity;
          const lc = options2.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options2.stale || false;
          if (options2.maxAge && typeof options2.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options2.maxAge || 0;
          this[DISPOSE] = options2.dispose;
          this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
          this.reset();
        }
        // resize the cache when the max changes.
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        // resize the cache when the lengthCalculator changes.
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node2 = this[CACHE].get(key);
            const item = node2.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node2 = this[LRU_LIST].tail;
          if (!node2)
            return null;
          del(this, node2);
          return node2.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      }
      const get = (self2, key, doUse) => {
        const node2 = self2[CACHE].get(key);
        if (node2) {
          const hit = node2.value;
          if (isStale(self2, hit)) {
            del(self2, node2);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node2.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node2);
            }
          }
          return hit.value;
        }
      };
      const isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      const trim = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      const del = (self2, node2) => {
        if (node2) {
          const hit = node2.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node2);
        }
      };
      class Entry {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      }
      const forEachStep = (self2, fn, node2, thisp) => {
        let hit = node2.value;
        if (isStale(self2, hit)) {
          del(self2, node2);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      var _lruCache_5_1_1_lruCache = LRUCache;
      var build = { exports: {} };
      var INFINITY = 1 / 0;
      var symbolTag = "[object Symbol]";
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
        rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
        rsUpper + "+" + rsOptUpperContr,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "ss"
      };
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root$2 = freeGlobal || freeSelf || Function("return this")();
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var Symbol$1 = root$2.Symbol;
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var camelCase = createCompounder(function(result2, word2, index) {
        word2 = word2.toLowerCase();
        return result2 + (index ? capitalize(word2) : word2);
      });
      function capitalize(string2) {
        return upperFirst(toString(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var _lodash_camelcase_4_3_0_lodash_camelcase = camelCase;
      var lib$2 = {};
      var dist$1 = { exports: {} };
      (function(module2, exports2) {
        !function(u, D) {
          module2.exports = D();
        }(commonjsGlobal, function() {
          var u, D, F = (function(u2, D2) {
            Object.defineProperty(D2, "__esModule", { value: true });
            D2.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, D2.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, D2.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
          }(u = { exports: {} }, u.exports), u.exports);
          (D = F) && D.__esModule && Object.prototype.hasOwnProperty.call(D, "default") && D.default;
          var e = F.Space_Separator, C = F.ID_Start, A = F.ID_Continue;
          function r(u2) {
            return u2 >= "a" && u2 <= "z" || u2 >= "A" && u2 <= "Z" || "$" === u2 || "_" === u2 || C.test(u2);
          }
          function t2(u2) {
            return u2 >= "a" && u2 <= "z" || u2 >= "A" && u2 <= "Z" || u2 >= "0" && u2 <= "9" || "$" === u2 || "_" === u2 || "‌" === u2 || "‍" === u2 || A.test(u2);
          }
          function E(u2) {
            return /[0-9]/.test(u2);
          }
          function n2(u2) {
            return /[0-9A-Fa-f]/.test(u2);
          }
          var i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(u2) {
            return typeof u2;
          } : function(u2) {
            return u2 && "function" == typeof Symbol && u2.constructor === Symbol && u2 !== Symbol.prototype ? "symbol" : typeof u2;
          }, o = void 0, a = void 0, B = void 0, c = void 0, s = void 0, f = void 0, d = void 0, l = void 0, v2 = void 0;
          var m = void 0, p = void 0, h = void 0, y = void 0, w = void 0;
          function b2() {
            for (m = "default", p = "", h = false, y = 1; ; ) {
              w = g();
              var u2 = x[m]();
              if (u2)
                return u2;
            }
          }
          function g() {
            if (o[c])
              return String.fromCodePoint(o.codePointAt(c));
          }
          function S() {
            var u2 = g();
            return "\n" === u2 ? (s++, f = 0) : u2 ? f += u2.length : f++, u2 && (c += u2.length), u2;
          }
          var x = { default: function() {
            switch (w) {
              case "	":
              case "\v":
              case "\f":
              case " ":
              case " ":
              case "\uFEFF":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return void S();
              case "/":
                return S(), void (m = "comment");
              case void 0:
                return S(), N("eof");
            }
            if (!function(u2) {
              return e.test(u2);
            }(w))
              return x[a]();
            S();
          }, comment: function() {
            switch (w) {
              case "*":
                return S(), void (m = "multiLineComment");
              case "/":
                return S(), void (m = "singleLineComment");
            }
            throw j(S());
          }, multiLineComment: function() {
            switch (w) {
              case "*":
                return S(), void (m = "multiLineCommentAsterisk");
              case void 0:
                throw j(S());
            }
            S();
          }, multiLineCommentAsterisk: function() {
            switch (w) {
              case "*":
                return void S();
              case "/":
                return S(), void (m = "default");
              case void 0:
                throw j(S());
            }
            S(), m = "multiLineComment";
          }, singleLineComment: function() {
            switch (w) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return S(), void (m = "default");
              case void 0:
                return S(), N("eof");
            }
            S();
          }, value: function() {
            switch (w) {
              case "{":
              case "[":
                return N("punctuator", S());
              case "n":
                return S(), P("ull"), N("null", null);
              case "t":
                return S(), P("rue"), N("boolean", true);
              case "f":
                return S(), P("alse"), N("boolean", false);
              case "-":
              case "+":
                return "-" === S() && (y = -1), void (m = "sign");
              case ".":
                return p = S(), void (m = "decimalPointLeading");
              case "0":
                return p = S(), void (m = "zero");
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return p = S(), void (m = "decimalInteger");
              case "I":
                return S(), P("nfinity"), N("numeric", 1 / 0);
              case "N":
                return S(), P("aN"), N("numeric", NaN);
              case '"':
              case "'":
                return h = '"' === S(), p = "", void (m = "string");
            }
            throw j(S());
          }, identifierNameStartEscape: function() {
            if ("u" !== w)
              throw j(S());
            S();
            var u2 = O();
            switch (u2) {
              case "$":
              case "_":
                break;
              default:
                if (!r(u2))
                  throw L();
            }
            p += u2, m = "identifierName";
          }, identifierName: function() {
            switch (w) {
              case "$":
              case "_":
              case "‌":
              case "‍":
                return void (p += S());
              case "\\":
                return S(), void (m = "identifierNameEscape");
            }
            if (!t2(w))
              return N("identifier", p);
            p += S();
          }, identifierNameEscape: function() {
            if ("u" !== w)
              throw j(S());
            S();
            var u2 = O();
            switch (u2) {
              case "$":
              case "_":
              case "‌":
              case "‍":
                break;
              default:
                if (!t2(u2))
                  throw L();
            }
            p += u2, m = "identifierName";
          }, sign: function() {
            switch (w) {
              case ".":
                return p = S(), void (m = "decimalPointLeading");
              case "0":
                return p = S(), void (m = "zero");
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return p = S(), void (m = "decimalInteger");
              case "I":
                return S(), P("nfinity"), N("numeric", y * (1 / 0));
              case "N":
                return S(), P("aN"), N("numeric", NaN);
            }
            throw j(S());
          }, zero: function() {
            switch (w) {
              case ".":
                return p += S(), void (m = "decimalPoint");
              case "e":
              case "E":
                return p += S(), void (m = "decimalExponent");
              case "x":
              case "X":
                return p += S(), void (m = "hexadecimal");
            }
            return N("numeric", 0 * y);
          }, decimalInteger: function() {
            switch (w) {
              case ".":
                return p += S(), void (m = "decimalPoint");
              case "e":
              case "E":
                return p += S(), void (m = "decimalExponent");
            }
            if (!E(w))
              return N("numeric", y * Number(p));
            p += S();
          }, decimalPointLeading: function() {
            if (E(w))
              return p += S(), void (m = "decimalFraction");
            throw j(S());
          }, decimalPoint: function() {
            switch (w) {
              case "e":
              case "E":
                return p += S(), void (m = "decimalExponent");
            }
            return E(w) ? (p += S(), void (m = "decimalFraction")) : N("numeric", y * Number(p));
          }, decimalFraction: function() {
            switch (w) {
              case "e":
              case "E":
                return p += S(), void (m = "decimalExponent");
            }
            if (!E(w))
              return N("numeric", y * Number(p));
            p += S();
          }, decimalExponent: function() {
            switch (w) {
              case "+":
              case "-":
                return p += S(), void (m = "decimalExponentSign");
            }
            if (E(w))
              return p += S(), void (m = "decimalExponentInteger");
            throw j(S());
          }, decimalExponentSign: function() {
            if (E(w))
              return p += S(), void (m = "decimalExponentInteger");
            throw j(S());
          }, decimalExponentInteger: function() {
            if (!E(w))
              return N("numeric", y * Number(p));
            p += S();
          }, hexadecimal: function() {
            if (n2(w))
              return p += S(), void (m = "hexadecimalInteger");
            throw j(S());
          }, hexadecimalInteger: function() {
            if (!n2(w))
              return N("numeric", y * Number(p));
            p += S();
          }, string: function() {
            switch (w) {
              case "\\":
                return S(), void (p += function() {
                  switch (g()) {
                    case "b":
                      return S(), "\b";
                    case "f":
                      return S(), "\f";
                    case "n":
                      return S(), "\n";
                    case "r":
                      return S(), "\r";
                    case "t":
                      return S(), "	";
                    case "v":
                      return S(), "\v";
                    case "0":
                      if (S(), E(g()))
                        throw j(S());
                      return "\0";
                    case "x":
                      return S(), function() {
                        var u2 = "", D2 = g();
                        if (!n2(D2))
                          throw j(S());
                        if (u2 += S(), !n2(D2 = g()))
                          throw j(S());
                        return u2 += S(), String.fromCodePoint(parseInt(u2, 16));
                      }();
                    case "u":
                      return S(), O();
                    case "\n":
                    case "\u2028":
                    case "\u2029":
                      return S(), "";
                    case "\r":
                      return S(), "\n" === g() && S(), "";
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                    case "5":
                    case "6":
                    case "7":
                    case "8":
                    case "9":
                    case void 0:
                      throw j(S());
                  }
                  return S();
                }());
              case '"':
                return h ? (S(), N("string", p)) : void (p += S());
              case "'":
                return h ? void (p += S()) : (S(), N("string", p));
              case "\n":
              case "\r":
                throw j(S());
              case "\u2028":
              case "\u2029":
                !function(u2) {
                  console.warn("JSON5: '" + u2 + "' is not valid ECMAScript; consider escaping");
                }(w);
                break;
              case void 0:
                throw j(S());
            }
            p += S();
          }, start: function() {
            switch (w) {
              case "{":
              case "[":
                return N("punctuator", S());
            }
            m = "value";
          }, beforePropertyName: function() {
            switch (w) {
              case "$":
              case "_":
                return p = S(), void (m = "identifierName");
              case "\\":
                return S(), void (m = "identifierNameStartEscape");
              case "}":
                return N("punctuator", S());
              case '"':
              case "'":
                return h = '"' === S(), void (m = "string");
            }
            if (r(w))
              return p += S(), void (m = "identifierName");
            throw j(S());
          }, afterPropertyName: function() {
            if (":" === w)
              return N("punctuator", S());
            throw j(S());
          }, beforePropertyValue: function() {
            m = "value";
          }, afterPropertyValue: function() {
            switch (w) {
              case ",":
              case "}":
                return N("punctuator", S());
            }
            throw j(S());
          }, beforeArrayValue: function() {
            if ("]" === w)
              return N("punctuator", S());
            m = "value";
          }, afterArrayValue: function() {
            switch (w) {
              case ",":
              case "]":
                return N("punctuator", S());
            }
            throw j(S());
          }, end: function() {
            throw j(S());
          } };
          function N(u2, D2) {
            return { type: u2, value: D2, line: s, column: f };
          }
          function P(u2) {
            var D2 = true, F2 = false, e2 = void 0;
            try {
              for (var C2, A2 = u2[Symbol.iterator](); !(D2 = (C2 = A2.next()).done); D2 = true) {
                var r2 = C2.value;
                if (g() !== r2)
                  throw j(S());
                S();
              }
            } catch (u3) {
              F2 = true, e2 = u3;
            } finally {
              try {
                !D2 && A2.return && A2.return();
              } finally {
                if (F2)
                  throw e2;
              }
            }
          }
          function O() {
            for (var u2 = "", D2 = 4; D2-- > 0; ) {
              if (!n2(g()))
                throw j(S());
              u2 += S();
            }
            return String.fromCodePoint(parseInt(u2, 16));
          }
          var I = { start: function() {
            if ("eof" === d.type)
              throw J();
            _();
          }, beforePropertyName: function() {
            switch (d.type) {
              case "identifier":
              case "string":
                return l = d.value, void (a = "afterPropertyName");
              case "punctuator":
                return void V();
              case "eof":
                throw J();
            }
          }, afterPropertyName: function() {
            if ("eof" === d.type)
              throw J();
            a = "beforePropertyValue";
          }, beforePropertyValue: function() {
            if ("eof" === d.type)
              throw J();
            _();
          }, beforeArrayValue: function() {
            if ("eof" === d.type)
              throw J();
            "punctuator" !== d.type || "]" !== d.value ? _() : V();
          }, afterPropertyValue: function() {
            if ("eof" === d.type)
              throw J();
            switch (d.value) {
              case ",":
                return void (a = "beforePropertyName");
              case "}":
                V();
            }
          }, afterArrayValue: function() {
            if ("eof" === d.type)
              throw J();
            switch (d.value) {
              case ",":
                return void (a = "beforeArrayValue");
              case "]":
                V();
            }
          }, end: function() {
          } };
          function _() {
            var u2 = void 0;
            switch (d.type) {
              case "punctuator":
                switch (d.value) {
                  case "{":
                    u2 = {};
                    break;
                  case "[":
                    u2 = [];
                }
                break;
              case "null":
              case "boolean":
              case "numeric":
              case "string":
                u2 = d.value;
            }
            if (void 0 === v2)
              v2 = u2;
            else {
              var D2 = B[B.length - 1];
              Array.isArray(D2) ? D2.push(u2) : D2[l] = u2;
            }
            if (null !== u2 && "object" === (void 0 === u2 ? "undefined" : i2(u2)))
              B.push(u2), a = Array.isArray(u2) ? "beforeArrayValue" : "beforePropertyName";
            else {
              var F2 = B[B.length - 1];
              a = null == F2 ? "end" : Array.isArray(F2) ? "afterArrayValue" : "afterPropertyValue";
            }
          }
          function V() {
            B.pop();
            var u2 = B[B.length - 1];
            a = null == u2 ? "end" : Array.isArray(u2) ? "afterArrayValue" : "afterPropertyValue";
          }
          function j(u2) {
            return k(void 0 === u2 ? "JSON5: invalid end of input at " + s + ":" + f : "JSON5: invalid character '" + function(u3) {
              var D2 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
              if (D2[u3])
                return D2[u3];
              if (u3 < " ") {
                var F2 = u3.charCodeAt(0).toString(16);
                return "\\x" + ("00" + F2).substring(F2.length);
              }
              return u3;
            }(u2) + "' at " + s + ":" + f);
          }
          function J() {
            return k("JSON5: invalid end of input at " + s + ":" + f);
          }
          function L() {
            return k("JSON5: invalid identifier character at " + s + ":" + (f -= 5));
          }
          function k(u2) {
            var D2 = new SyntaxError(u2);
            return D2.lineNumber = s, D2.columnNumber = f, D2;
          }
          return { parse: function(u2, D2) {
            o = String(u2), a = "start", B = [], c = 0, s = 1, f = 0, d = void 0, l = void 0, v2 = void 0;
            do {
              d = b2(), I[a]();
            } while ("eof" !== d.type);
            return "function" == typeof D2 ? function u3(D3, F2, e2) {
              var C2 = D3[F2];
              if (null != C2 && "object" === (void 0 === C2 ? "undefined" : i2(C2)))
                for (var A2 in C2) {
                  var r2 = u3(C2, A2, e2);
                  void 0 === r2 ? delete C2[A2] : C2[A2] = r2;
                }
              return e2.call(D3, F2, C2);
            }({ "": v2 }, "", D2) : v2;
          }, stringify: function(u2, D2, F2) {
            var e2 = [], C2 = "", A2 = void 0, E2 = void 0, n3 = "", o2 = void 0;
            if (null == D2 || "object" !== (void 0 === D2 ? "undefined" : i2(D2)) || Array.isArray(D2) || (F2 = D2.space, o2 = D2.quote, D2 = D2.replacer), "function" == typeof D2)
              E2 = D2;
            else if (Array.isArray(D2)) {
              A2 = [];
              var a2 = true, B2 = false, c2 = void 0;
              try {
                for (var s2, f2 = D2[Symbol.iterator](); !(a2 = (s2 = f2.next()).done); a2 = true) {
                  var d2 = s2.value, l2 = void 0;
                  "string" == typeof d2 ? l2 = d2 : ("number" == typeof d2 || d2 instanceof String || d2 instanceof Number) && (l2 = String(d2)), void 0 !== l2 && A2.indexOf(l2) < 0 && A2.push(l2);
                }
              } catch (u3) {
                B2 = true, c2 = u3;
              } finally {
                try {
                  !a2 && f2.return && f2.return();
                } finally {
                  if (B2)
                    throw c2;
                }
              }
            }
            return F2 instanceof Number ? F2 = Number(F2) : F2 instanceof String && (F2 = String(F2)), "number" == typeof F2 ? F2 > 0 && (F2 = Math.min(10, Math.floor(F2)), n3 = "          ".substr(0, F2)) : "string" == typeof F2 && (n3 = F2.substr(0, 10)), v3("", { "": u2 });
            function v3(u3, D3) {
              var F3 = D3[u3];
              switch (null != F3 && ("function" == typeof F3.toJSON5 ? F3 = F3.toJSON5(u3) : "function" == typeof F3.toJSON && (F3 = F3.toJSON(u3))), E2 && (F3 = E2.call(D3, u3, F3)), F3 instanceof Number ? F3 = Number(F3) : F3 instanceof String ? F3 = String(F3) : F3 instanceof Boolean && (F3 = F3.valueOf()), F3) {
                case null:
                  return "null";
                case true:
                  return "true";
                case false:
                  return "false";
              }
              return "string" == typeof F3 ? m2(F3) : "number" == typeof F3 ? String(F3) : "object" === (void 0 === F3 ? "undefined" : i2(F3)) ? Array.isArray(F3) ? function(u4) {
                if (e2.indexOf(u4) >= 0)
                  throw TypeError("Converting circular structure to JSON5");
                e2.push(u4);
                var D4 = C2;
                C2 += n3;
                for (var F4 = [], A3 = 0; A3 < u4.length; A3++) {
                  var r2 = v3(String(A3), u4);
                  F4.push(void 0 !== r2 ? r2 : "null");
                }
                var t3 = void 0;
                if (0 === F4.length)
                  t3 = "[]";
                else if ("" === n3) {
                  var E3 = F4.join(",");
                  t3 = "[" + E3 + "]";
                } else {
                  var i3 = ",\n" + C2, o3 = F4.join(i3);
                  t3 = "[\n" + C2 + o3 + ",\n" + D4 + "]";
                }
                return e2.pop(), C2 = D4, t3;
              }(F3) : function(u4) {
                if (e2.indexOf(u4) >= 0)
                  throw TypeError("Converting circular structure to JSON5");
                e2.push(u4);
                var D4 = C2;
                C2 += n3;
                var F4 = A2 || Object.keys(u4), r2 = [], t3 = true, E3 = false, i3 = void 0;
                try {
                  for (var o3, a3 = F4[Symbol.iterator](); !(t3 = (o3 = a3.next()).done); t3 = true) {
                    var B3 = o3.value, c3 = v3(B3, u4);
                    if (void 0 !== c3) {
                      var s3 = p2(B3) + ":";
                      "" !== n3 && (s3 += " "), s3 += c3, r2.push(s3);
                    }
                  }
                } catch (u5) {
                  E3 = true, i3 = u5;
                } finally {
                  try {
                    !t3 && a3.return && a3.return();
                  } finally {
                    if (E3)
                      throw i3;
                  }
                }
                var f3 = void 0;
                if (0 === r2.length)
                  f3 = "{}";
                else {
                  var d3 = void 0;
                  if ("" === n3)
                    d3 = r2.join(","), f3 = "{" + d3 + "}";
                  else {
                    var l3 = ",\n" + C2;
                    d3 = r2.join(l3), f3 = "{\n" + C2 + d3 + ",\n" + D4 + "}";
                  }
                }
                return e2.pop(), C2 = D4, f3;
              }(F3) : void 0;
            }
            function m2(u3) {
              var D3 = { "'": 0.1, '"': 0.2 }, F3 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" }, e3 = "", C3 = true, A3 = false, r2 = void 0;
              try {
                for (var t3, E3 = u3[Symbol.iterator](); !(C3 = (t3 = E3.next()).done); C3 = true) {
                  var n4 = t3.value;
                  switch (n4) {
                    case "'":
                    case '"':
                      D3[n4]++, e3 += n4;
                      continue;
                  }
                  if (F3[n4])
                    e3 += F3[n4];
                  else if (n4 < " ") {
                    var i3 = n4.charCodeAt(0).toString(16);
                    e3 += "\\x" + ("00" + i3).substring(i3.length);
                  } else
                    e3 += n4;
                }
              } catch (u4) {
                A3 = true, r2 = u4;
              } finally {
                try {
                  !C3 && E3.return && E3.return();
                } finally {
                  if (A3)
                    throw r2;
                }
              }
              var a3 = o2 || Object.keys(D3).reduce(function(u4, F4) {
                return D3[u4] < D3[F4] ? u4 : F4;
              });
              return a3 + (e3 = e3.replace(new RegExp(a3, "g"), F3[a3])) + a3;
            }
            function p2(u3) {
              if (0 === u3.length)
                return m2(u3);
              var D3 = String.fromCodePoint(u3.codePointAt(0));
              if (!r(D3))
                return m2(u3);
              for (var F3 = D3.length; F3 < u3.length; F3++)
                if (!t2(String.fromCodePoint(u3.codePointAt(F3))))
                  return m2(u3);
              return u3;
            }
          } };
        });
      })(dist$1);
      const JSON5 = dist$1.exports;
      const specialValues = {
        null: null,
        true: true,
        false: false
      };
      function parseQuery$2(query) {
        if (query.substr(0, 1) !== "?") {
          throw new Error(
            "A valid query string passed to parseQuery should begin with '?'"
          );
        }
        query = query.substr(1);
        if (!query) {
          return {};
        }
        if (query.substr(0, 1) === "{" && query.substr(-1) === "}") {
          return JSON5.parse(query);
        }
        const queryArgs = query.split(/[,&]/g);
        const result2 = {};
        queryArgs.forEach((arg) => {
          const idx = arg.indexOf("=");
          if (idx >= 0) {
            let name2 = arg.substr(0, idx);
            let value = decodeURIComponent(arg.substr(idx + 1));
            if (specialValues.hasOwnProperty(value)) {
              value = specialValues[value];
            }
            if (name2.substr(-2) === "[]") {
              name2 = decodeURIComponent(name2.substr(0, name2.length - 2));
              if (!Array.isArray(result2[name2])) {
                result2[name2] = [];
              }
              result2[name2].push(value);
            } else {
              name2 = decodeURIComponent(name2);
              result2[name2] = value;
            }
          } else {
            if (arg.substr(0, 1) === "-") {
              result2[decodeURIComponent(arg.substr(1))] = false;
            } else if (arg.substr(0, 1) === "+") {
              result2[decodeURIComponent(arg.substr(1))] = true;
            } else {
              result2[decodeURIComponent(arg)] = true;
            }
          }
        });
        return result2;
      }
      var parseQuery_1 = parseQuery$2;
      const parseQuery$1 = parseQuery_1;
      function getOptions$1(loaderContext) {
        const query = loaderContext.query;
        if (typeof query === "string" && query !== "") {
          return parseQuery$1(loaderContext.query);
        }
        if (!query || typeof query !== "object") {
          return null;
        }
        return query;
      }
      var getOptions_1 = getOptions$1;
      const path$4 = require$$3;
      const matchRelativePath = /^\.\.?[/\\]/;
      function isAbsolutePath(str2) {
        return path$4.posix.isAbsolute(str2) || path$4.win32.isAbsolute(str2);
      }
      function isRelativePath(str2) {
        return matchRelativePath.test(str2);
      }
      function stringifyRequest$1(loaderContext, request) {
        const splitted = request.split("!");
        const context = loaderContext.context || loaderContext.options && loaderContext.options.context;
        return JSON.stringify(
          splitted.map((part) => {
            const splittedPart = part.match(/^(.*?)(\?.*)/);
            const query = splittedPart ? splittedPart[2] : "";
            let singlePath = splittedPart ? splittedPart[1] : part;
            if (isAbsolutePath(singlePath) && context) {
              singlePath = path$4.relative(context, singlePath);
              if (isAbsolutePath(singlePath)) {
                return singlePath + query;
              }
              if (isRelativePath(singlePath) === false) {
                singlePath = "./" + singlePath;
              }
            }
            return singlePath.replace(/\\/g, "/") + query;
          }).join("!")
        );
      }
      var stringifyRequest_1 = stringifyRequest$1;
      function getRemainingRequest$1(loaderContext) {
        if (loaderContext.remainingRequest) {
          return loaderContext.remainingRequest;
        }
        const request = loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((obj) => obj.request).concat([loaderContext.resource]);
        return request.join("!");
      }
      var getRemainingRequest_1 = getRemainingRequest$1;
      function getCurrentRequest$1(loaderContext) {
        if (loaderContext.currentRequest) {
          return loaderContext.currentRequest;
        }
        const request = loaderContext.loaders.slice(loaderContext.loaderIndex).map((obj) => obj.request).concat([loaderContext.resource]);
        return request.join("!");
      }
      var getCurrentRequest_1 = getCurrentRequest$1;
      const path$3 = require$$3;
      function isUrlRequest$1(url2, root2) {
        if (/^[a-z][a-z0-9+.-]*:/i.test(url2) && !path$3.win32.isAbsolute(url2)) {
          return false;
        }
        if (/^\/\//.test(url2)) {
          return false;
        }
        if (/^[{}[\]#*;,'§$%&(=?`´^°<>]/.test(url2)) {
          return false;
        }
        if ((root2 === void 0 || root2 === false) && /^\//.test(url2)) {
          return false;
        }
        return true;
      }
      var isUrlRequest_1 = isUrlRequest$1;
      const matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
      function urlToRequest$1(url2, root2) {
        if (url2 === "") {
          return "";
        }
        const moduleRequestRegex = /^[^?]*~/;
        let request;
        if (matchNativeWin32Path.test(url2)) {
          request = url2;
        } else if (root2 !== void 0 && root2 !== false && /^\//.test(url2)) {
          switch (typeof root2) {
            case "string":
              if (moduleRequestRegex.test(root2)) {
                request = root2.replace(/([^~/])$/, "$1/") + url2.slice(1);
              } else {
                request = root2 + url2;
              }
              break;
            case "boolean":
              request = url2;
              break;
            default:
              throw new Error(
                "Unexpected parameters to loader-utils 'urlToRequest': url = " + url2 + ", root = " + root2 + "."
              );
          }
        } else if (/^\.\.?\//.test(url2)) {
          request = url2;
        } else {
          request = "./" + url2;
        }
        if (moduleRequestRegex.test(request)) {
          request = request.replace(moduleRequestRegex, "");
        }
        return request;
      }
      var urlToRequest_1 = urlToRequest$1;
      function parseString$1(str2) {
        try {
          if (str2[0] === '"') {
            return JSON.parse(str2);
          }
          if (str2[0] === "'" && str2.substr(str2.length - 1) === "'") {
            return parseString$1(
              str2.replace(/\\.|"/g, (x) => x === '"' ? '\\"' : x).replace(/^'|'$/g, '"')
            );
          }
          return JSON.parse('"' + str2 + '"');
        } catch (e) {
          return str2;
        }
      }
      var parseString_1 = parseString$1;
      var big = { exports: {} };
      (function(module2) {
        (function(GLOBAL) {
          var Big, DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
          function _Big_() {
            function Big2(n2) {
              var x = this;
              if (!(x instanceof Big2))
                return n2 === UNDEFINED ? _Big_() : new Big2(n2);
              if (n2 instanceof Big2) {
                x.s = n2.s;
                x.e = n2.e;
                x.c = n2.c.slice();
              } else {
                parse2(x, n2);
              }
              x.constructor = Big2;
            }
            Big2.prototype = P;
            Big2.DP = DP;
            Big2.RM = RM;
            Big2.NE = NE;
            Big2.PE = PE;
            Big2.version = "5.2.2";
            return Big2;
          }
          function parse2(x, n2) {
            var e, i2, nl;
            if (n2 === 0 && 1 / n2 < 0)
              n2 = "-0";
            else if (!NUMERIC.test(n2 += ""))
              throw Error(INVALID + "number");
            x.s = n2.charAt(0) == "-" ? (n2 = n2.slice(1), -1) : 1;
            if ((e = n2.indexOf(".")) > -1)
              n2 = n2.replace(".", "");
            if ((i2 = n2.search(/e/i)) > 0) {
              if (e < 0)
                e = i2;
              e += +n2.slice(i2 + 1);
              n2 = n2.substring(0, i2);
            } else if (e < 0) {
              e = n2.length;
            }
            nl = n2.length;
            for (i2 = 0; i2 < nl && n2.charAt(i2) == "0"; )
              ++i2;
            if (i2 == nl) {
              x.c = [x.e = 0];
            } else {
              for (; nl > 0 && n2.charAt(--nl) == "0"; )
                ;
              x.e = e - i2 - 1;
              x.c = [];
              for (e = 0; i2 <= nl; )
                x.c[e++] = +n2.charAt(i2++);
            }
            return x;
          }
          function round(x, dp, rm, more) {
            var xc = x.c, i2 = x.e + dp + 1;
            if (i2 < xc.length) {
              if (rm === 1) {
                more = xc[i2] >= 5;
              } else if (rm === 2) {
                more = xc[i2] > 5 || xc[i2] == 5 && (more || i2 < 0 || xc[i2 + 1] !== UNDEFINED || xc[i2 - 1] & 1);
              } else if (rm === 3) {
                more = more || !!xc[0];
              } else {
                more = false;
                if (rm !== 0)
                  throw Error(INVALID_RM);
              }
              if (i2 < 1) {
                xc.length = 1;
                if (more) {
                  x.e = -dp;
                  xc[0] = 1;
                } else {
                  xc[0] = x.e = 0;
                }
              } else {
                xc.length = i2--;
                if (more) {
                  for (; ++xc[i2] > 9; ) {
                    xc[i2] = 0;
                    if (!i2--) {
                      ++x.e;
                      xc.unshift(1);
                    }
                  }
                }
                for (i2 = xc.length; !xc[--i2]; )
                  xc.pop();
              }
            } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
              throw Error(INVALID_RM);
            }
            return x;
          }
          function stringify2(x, id2, n2, k) {
            var e, s, Big2 = x.constructor, z = !x.c[0];
            if (n2 !== UNDEFINED) {
              if (n2 !== ~~n2 || n2 < (id2 == 3) || n2 > MAX_DP) {
                throw Error(id2 == 3 ? INVALID + "precision" : INVALID_DP);
              }
              x = new Big2(x);
              n2 = k - x.e;
              if (x.c.length > ++k)
                round(x, n2, Big2.RM);
              if (id2 == 2)
                k = x.e + n2 + 1;
              for (; x.c.length < k; )
                x.c.push(0);
            }
            e = x.e;
            s = x.c.join("");
            n2 = s.length;
            if (id2 != 2 && (id2 == 1 || id2 == 3 && k <= e || e <= Big2.NE || e >= Big2.PE)) {
              s = s.charAt(0) + (n2 > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
            } else if (e < 0) {
              for (; ++e; )
                s = "0" + s;
              s = "0." + s;
            } else if (e > 0) {
              if (++e > n2)
                for (e -= n2; e--; )
                  s += "0";
              else if (e < n2)
                s = s.slice(0, e) + "." + s.slice(e);
            } else if (n2 > 1) {
              s = s.charAt(0) + "." + s.slice(1);
            }
            return x.s < 0 && (!z || id2 == 4) ? "-" + s : s;
          }
          P.abs = function() {
            var x = new this.constructor(this);
            x.s = 1;
            return x;
          };
          P.cmp = function(y) {
            var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i2 = x.s, j = y.s, k = x.e, l = y.e;
            if (!xc[0] || !yc[0])
              return !xc[0] ? !yc[0] ? 0 : -j : i2;
            if (i2 != j)
              return i2;
            isneg = i2 < 0;
            if (k != l)
              return k > l ^ isneg ? 1 : -1;
            j = (k = xc.length) < (l = yc.length) ? k : l;
            for (i2 = -1; ++i2 < j; ) {
              if (xc[i2] != yc[i2])
                return xc[i2] > yc[i2] ^ isneg ? 1 : -1;
            }
            return k == l ? 0 : k > l ^ isneg ? 1 : -1;
          };
          P.div = function(y) {
            var x = this, Big2 = x.constructor, a = x.c, b2 = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
            if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
              throw Error(INVALID_DP);
            if (!b2[0])
              throw Error(DIV_BY_ZERO);
            if (!a[0])
              return new Big2(k * 0);
            var bl, bt, n2, cmp, ri, bz = b2.slice(), ai = bl = b2.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
            q.s = k;
            k = d < 0 ? 0 : d;
            bz.unshift(0);
            for (; rl++ < bl; )
              r.push(0);
            do {
              for (n2 = 0; n2 < 10; n2++) {
                if (bl != (rl = r.length)) {
                  cmp = bl > rl ? 1 : -1;
                } else {
                  for (ri = -1, cmp = 0; ++ri < bl; ) {
                    if (b2[ri] != r[ri]) {
                      cmp = b2[ri] > r[ri] ? 1 : -1;
                      break;
                    }
                  }
                }
                if (cmp < 0) {
                  for (bt = rl == bl ? b2 : bz; rl; ) {
                    if (r[--rl] < bt[rl]) {
                      ri = rl;
                      for (; ri && !r[--ri]; )
                        r[ri] = 9;
                      --r[ri];
                      r[rl] += 10;
                    }
                    r[rl] -= bt[rl];
                  }
                  for (; !r[0]; )
                    r.shift();
                } else {
                  break;
                }
              }
              qc[qi++] = cmp ? n2 : ++n2;
              if (r[0] && cmp)
                r[rl] = a[ai] || 0;
              else
                r = [a[ai]];
            } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
            if (!qc[0] && qi != 1) {
              qc.shift();
              q.e--;
            }
            if (qi > d)
              round(q, dp, Big2.RM, r[0] !== UNDEFINED);
            return q;
          };
          P.eq = function(y) {
            return !this.cmp(y);
          };
          P.gt = function(y) {
            return this.cmp(y) > 0;
          };
          P.gte = function(y) {
            return this.cmp(y) > -1;
          };
          P.lt = function(y) {
            return this.cmp(y) < 0;
          };
          P.lte = function(y) {
            return this.cmp(y) < 1;
          };
          P.minus = P.sub = function(y) {
            var i2, j, t2, xlty, x = this, Big2 = x.constructor, a = x.s, b2 = (y = new Big2(y)).s;
            if (a != b2) {
              y.s = -b2;
              return x.plus(y);
            }
            var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b2, y) : new Big2(xc[0] ? x : 0);
            }
            if (a = xe - ye) {
              if (xlty = a < 0) {
                a = -a;
                t2 = xc;
              } else {
                ye = xe;
                t2 = yc;
              }
              t2.reverse();
              for (b2 = a; b2--; )
                t2.push(0);
              t2.reverse();
            } else {
              j = ((xlty = xc.length < yc.length) ? xc : yc).length;
              for (a = b2 = 0; b2 < j; b2++) {
                if (xc[b2] != yc[b2]) {
                  xlty = xc[b2] < yc[b2];
                  break;
                }
              }
            }
            if (xlty) {
              t2 = xc;
              xc = yc;
              yc = t2;
              y.s = -y.s;
            }
            if ((b2 = (j = yc.length) - (i2 = xc.length)) > 0)
              for (; b2--; )
                xc[i2++] = 0;
            for (b2 = i2; j > a; ) {
              if (xc[--j] < yc[j]) {
                for (i2 = j; i2 && !xc[--i2]; )
                  xc[i2] = 9;
                --xc[i2];
                xc[j] += 10;
              }
              xc[j] -= yc[j];
            }
            for (; xc[--b2] === 0; )
              xc.pop();
            for (; xc[0] === 0; ) {
              xc.shift();
              --ye;
            }
            if (!xc[0]) {
              y.s = 1;
              xc = [ye = 0];
            }
            y.c = xc;
            y.e = ye;
            return y;
          };
          P.mod = function(y) {
            var ygtx, x = this, Big2 = x.constructor, a = x.s, b2 = (y = new Big2(y)).s;
            if (!y.c[0])
              throw Error(DIV_BY_ZERO);
            x.s = y.s = 1;
            ygtx = y.cmp(x) == 1;
            x.s = a;
            y.s = b2;
            if (ygtx)
              return new Big2(x);
            a = Big2.DP;
            b2 = Big2.RM;
            Big2.DP = Big2.RM = 0;
            x = x.div(y);
            Big2.DP = a;
            Big2.RM = b2;
            return this.minus(x.times(y));
          };
          P.plus = P.add = function(y) {
            var t2, x = this, Big2 = x.constructor, a = x.s, b2 = (y = new Big2(y)).s;
            if (a != b2) {
              y.s = -b2;
              return x.minus(y);
            }
            var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new Big2(xc[0] ? x : a * 0);
            xc = xc.slice();
            if (a = xe - ye) {
              if (a > 0) {
                ye = xe;
                t2 = yc;
              } else {
                a = -a;
                t2 = xc;
              }
              t2.reverse();
              for (; a--; )
                t2.push(0);
              t2.reverse();
            }
            if (xc.length - yc.length < 0) {
              t2 = yc;
              yc = xc;
              xc = t2;
            }
            a = yc.length;
            for (b2 = 0; a; xc[a] %= 10)
              b2 = (xc[--a] = xc[a] + yc[a] + b2) / 10 | 0;
            if (b2) {
              xc.unshift(b2);
              ++ye;
            }
            for (a = xc.length; xc[--a] === 0; )
              xc.pop();
            y.c = xc;
            y.e = ye;
            return y;
          };
          P.pow = function(n2) {
            var x = this, one = new x.constructor(1), y = one, isneg = n2 < 0;
            if (n2 !== ~~n2 || n2 < -MAX_POWER || n2 > MAX_POWER)
              throw Error(INVALID + "exponent");
            if (isneg)
              n2 = -n2;
            for (; ; ) {
              if (n2 & 1)
                y = y.times(x);
              n2 >>= 1;
              if (!n2)
                break;
              x = x.times(x);
            }
            return isneg ? one.div(y) : y;
          };
          P.round = function(dp, rm) {
            var Big2 = this.constructor;
            if (dp === UNDEFINED)
              dp = 0;
            else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
              throw Error(INVALID_DP);
            return round(new Big2(this), dp, rm === UNDEFINED ? Big2.RM : rm);
          };
          P.sqrt = function() {
            var r, c, t2, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2(0.5);
            if (!x.c[0])
              return new Big2(x);
            if (s < 0)
              throw Error(NAME + "No square root");
            s = Math.sqrt(x + "");
            if (s === 0 || s === 1 / 0) {
              c = x.c.join("");
              if (!(c.length + e & 1))
                c += "0";
              s = Math.sqrt(c);
              e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
              r = new Big2((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
            } else {
              r = new Big2(s);
            }
            e = r.e + (Big2.DP += 4);
            do {
              t2 = r;
              r = half.times(t2.plus(x.div(t2)));
            } while (t2.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
            return round(r, Big2.DP -= 4, Big2.RM);
          };
          P.times = P.mul = function(y) {
            var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b2 = yc.length, i2 = x.e, j = y.e;
            y.s = x.s == y.s ? 1 : -1;
            if (!xc[0] || !yc[0])
              return new Big2(y.s * 0);
            y.e = i2 + j;
            if (a < b2) {
              c = xc;
              xc = yc;
              yc = c;
              j = a;
              a = b2;
              b2 = j;
            }
            for (c = new Array(j = a + b2); j--; )
              c[j] = 0;
            for (i2 = b2; i2--; ) {
              b2 = 0;
              for (j = a + i2; j > i2; ) {
                b2 = c[j] + yc[i2] * xc[j - i2 - 1] + b2;
                c[j--] = b2 % 10;
                b2 = b2 / 10 | 0;
              }
              c[j] = (c[j] + b2) % 10;
            }
            if (b2)
              ++y.e;
            else
              c.shift();
            for (i2 = c.length; !c[--i2]; )
              c.pop();
            y.c = c;
            return y;
          };
          P.toExponential = function(dp) {
            return stringify2(this, 1, dp, dp);
          };
          P.toFixed = function(dp) {
            return stringify2(this, 2, dp, this.e + dp);
          };
          P.toPrecision = function(sd) {
            return stringify2(this, 3, sd, sd - 1);
          };
          P.toString = function() {
            return stringify2(this);
          };
          P.valueOf = P.toJSON = function() {
            return stringify2(this, 4);
          };
          Big = _Big_();
          Big["default"] = Big.Big = Big;
          if (module2.exports) {
            module2.exports = Big;
          } else {
            GLOBAL.Big = Big;
          }
        })(commonjsGlobal);
      })(big);
      var _polyfillNode_crypto = {};
      var _polyfillNode_crypto$1 = Object.freeze({
        __proto__: null,
        "default": _polyfillNode_crypto
      });
      var require$$1 = getAugmentedNamespace(_polyfillNode_crypto$1);
      const baseEncodeTables = {
        26: "abcdefghijklmnopqrstuvwxyz",
        32: "123456789abcdefghjkmnpqrstuvwxyz",
        // no 0lio
        36: "0123456789abcdefghijklmnopqrstuvwxyz",
        49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        // no lIO
        52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
        58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        // no 0lIO
        62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
        64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
      };
      function encodeBufferToBase(buffer, base2) {
        const encodeTable = baseEncodeTables[base2];
        if (!encodeTable) {
          throw new Error("Unknown encoding base" + base2);
        }
        const readLength = buffer.length;
        const Big = big.exports;
        Big.RM = Big.DP = 0;
        let b2 = new Big(0);
        for (let i2 = readLength - 1; i2 >= 0; i2--) {
          b2 = b2.times(256).plus(buffer[i2]);
        }
        let output = "";
        while (b2.gt(0)) {
          output = encodeTable[b2.mod(base2)] + output;
          b2 = b2.div(base2);
        }
        Big.DP = 20;
        Big.RM = 1;
        return output;
      }
      function getHashDigest$2(buffer, hashType, digestType, maxLength) {
        hashType = hashType || "md5";
        maxLength = maxLength || 9999;
        const hash2 = require$$1.createHash(hashType);
        hash2.update(buffer);
        if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62" || digestType === "base64") {
          return encodeBufferToBase(hash2.digest(), digestType.substr(4)).substr(
            0,
            maxLength
          );
        } else {
          return hash2.digest(digestType || "hex").substr(0, maxLength);
        }
      }
      var getHashDigest_1 = getHashDigest$2;
      var _emojisList_3_0_0_emojisList = [
        "🀄️",
        "🃏",
        "🅰️",
        "🅱️",
        "🅾️",
        "🅿️",
        "🆎",
        "🆑",
        "🆒",
        "🆓",
        "🆔",
        "🆕",
        "🆖",
        "🆗",
        "🆘",
        "🆙",
        "🆚",
        "🇦🇨",
        "🇦🇩",
        "🇦🇪",
        "🇦🇫",
        "🇦🇬",
        "🇦🇮",
        "🇦🇱",
        "🇦🇲",
        "🇦🇴",
        "🇦🇶",
        "🇦🇷",
        "🇦🇸",
        "🇦🇹",
        "🇦🇺",
        "🇦🇼",
        "🇦🇽",
        "🇦🇿",
        "🇦",
        "🇧🇦",
        "🇧🇧",
        "🇧🇩",
        "🇧🇪",
        "🇧🇫",
        "🇧🇬",
        "🇧🇭",
        "🇧🇮",
        "🇧🇯",
        "🇧🇱",
        "🇧🇲",
        "🇧🇳",
        "🇧🇴",
        "🇧🇶",
        "🇧🇷",
        "🇧🇸",
        "🇧🇹",
        "🇧🇻",
        "🇧🇼",
        "🇧🇾",
        "🇧🇿",
        "🇧",
        "🇨🇦",
        "🇨🇨",
        "🇨🇩",
        "🇨🇫",
        "🇨🇬",
        "🇨🇭",
        "🇨🇮",
        "🇨🇰",
        "🇨🇱",
        "🇨🇲",
        "🇨🇳",
        "🇨🇴",
        "🇨🇵",
        "🇨🇷",
        "🇨🇺",
        "🇨🇻",
        "🇨🇼",
        "🇨🇽",
        "🇨🇾",
        "🇨🇿",
        "🇨",
        "🇩🇪",
        "🇩🇬",
        "🇩🇯",
        "🇩🇰",
        "🇩🇲",
        "🇩🇴",
        "🇩🇿",
        "🇩",
        "🇪🇦",
        "🇪🇨",
        "🇪🇪",
        "🇪🇬",
        "🇪🇭",
        "🇪🇷",
        "🇪🇸",
        "🇪🇹",
        "🇪🇺",
        "🇪",
        "🇫🇮",
        "🇫🇯",
        "🇫🇰",
        "🇫🇲",
        "🇫🇴",
        "🇫🇷",
        "🇫",
        "🇬🇦",
        "🇬🇧",
        "🇬🇩",
        "🇬🇪",
        "🇬🇫",
        "🇬🇬",
        "🇬🇭",
        "🇬🇮",
        "🇬🇱",
        "🇬🇲",
        "🇬🇳",
        "🇬🇵",
        "🇬🇶",
        "🇬🇷",
        "🇬🇸",
        "🇬🇹",
        "🇬🇺",
        "🇬🇼",
        "🇬🇾",
        "🇬",
        "🇭🇰",
        "🇭🇲",
        "🇭🇳",
        "🇭🇷",
        "🇭🇹",
        "🇭🇺",
        "🇭",
        "🇮🇨",
        "🇮🇩",
        "🇮🇪",
        "🇮🇱",
        "🇮🇲",
        "🇮🇳",
        "🇮🇴",
        "🇮🇶",
        "🇮🇷",
        "🇮🇸",
        "🇮🇹",
        "🇮",
        "🇯🇪",
        "🇯🇲",
        "🇯🇴",
        "🇯🇵",
        "🇯",
        "🇰🇪",
        "🇰🇬",
        "🇰🇭",
        "🇰🇮",
        "🇰🇲",
        "🇰🇳",
        "🇰🇵",
        "🇰🇷",
        "🇰🇼",
        "🇰🇾",
        "🇰🇿",
        "🇰",
        "🇱🇦",
        "🇱🇧",
        "🇱🇨",
        "🇱🇮",
        "🇱🇰",
        "🇱🇷",
        "🇱🇸",
        "🇱🇹",
        "🇱🇺",
        "🇱🇻",
        "🇱🇾",
        "🇱",
        "🇲🇦",
        "🇲🇨",
        "🇲🇩",
        "🇲🇪",
        "🇲🇫",
        "🇲🇬",
        "🇲🇭",
        "🇲🇰",
        "🇲🇱",
        "🇲🇲",
        "🇲🇳",
        "🇲🇴",
        "🇲🇵",
        "🇲🇶",
        "🇲🇷",
        "🇲🇸",
        "🇲🇹",
        "🇲🇺",
        "🇲🇻",
        "🇲🇼",
        "🇲🇽",
        "🇲🇾",
        "🇲🇿",
        "🇲",
        "🇳🇦",
        "🇳🇨",
        "🇳🇪",
        "🇳🇫",
        "🇳🇬",
        "🇳🇮",
        "🇳🇱",
        "🇳🇴",
        "🇳🇵",
        "🇳🇷",
        "🇳🇺",
        "🇳🇿",
        "🇳",
        "🇴🇲",
        "🇴",
        "🇵🇦",
        "🇵🇪",
        "🇵🇫",
        "🇵🇬",
        "🇵🇭",
        "🇵🇰",
        "🇵🇱",
        "🇵🇲",
        "🇵🇳",
        "🇵🇷",
        "🇵🇸",
        "🇵🇹",
        "🇵🇼",
        "🇵🇾",
        "🇵",
        "🇶🇦",
        "🇶",
        "🇷🇪",
        "🇷🇴",
        "🇷🇸",
        "🇷🇺",
        "🇷🇼",
        "🇷",
        "🇸🇦",
        "🇸🇧",
        "🇸🇨",
        "🇸🇩",
        "🇸🇪",
        "🇸🇬",
        "🇸🇭",
        "🇸🇮",
        "🇸🇯",
        "🇸🇰",
        "🇸🇱",
        "🇸🇲",
        "🇸🇳",
        "🇸🇴",
        "🇸🇷",
        "🇸🇸",
        "🇸🇹",
        "🇸🇻",
        "🇸🇽",
        "🇸🇾",
        "🇸🇿",
        "🇸",
        "🇹🇦",
        "🇹🇨",
        "🇹🇩",
        "🇹🇫",
        "🇹🇬",
        "🇹🇭",
        "🇹🇯",
        "🇹🇰",
        "🇹🇱",
        "🇹🇲",
        "🇹🇳",
        "🇹🇴",
        "🇹🇷",
        "🇹🇹",
        "🇹🇻",
        "🇹🇼",
        "🇹🇿",
        "🇹",
        "🇺🇦",
        "🇺🇬",
        "🇺🇲",
        "🇺🇳",
        "🇺🇸",
        "🇺🇾",
        "🇺🇿",
        "🇺",
        "🇻🇦",
        "🇻🇨",
        "🇻🇪",
        "🇻🇬",
        "🇻🇮",
        "🇻🇳",
        "🇻🇺",
        "🇻",
        "🇼🇫",
        "🇼🇸",
        "🇼",
        "🇽🇰",
        "🇽",
        "🇾🇪",
        "🇾🇹",
        "🇾",
        "🇿🇦",
        "🇿🇲",
        "🇿🇼",
        "🇿",
        "🈁",
        "🈂️",
        "🈚️",
        "🈯️",
        "🈲",
        "🈳",
        "🈴",
        "🈵",
        "🈶",
        "🈷️",
        "🈸",
        "🈹",
        "🈺",
        "🉐",
        "🉑",
        "🌀",
        "🌁",
        "🌂",
        "🌃",
        "🌄",
        "🌅",
        "🌆",
        "🌇",
        "🌈",
        "🌉",
        "🌊",
        "🌋",
        "🌌",
        "🌍",
        "🌎",
        "🌏",
        "🌐",
        "🌑",
        "🌒",
        "🌓",
        "🌔",
        "🌕",
        "🌖",
        "🌗",
        "🌘",
        "🌙",
        "🌚",
        "🌛",
        "🌜",
        "🌝",
        "🌞",
        "🌟",
        "🌠",
        "🌡️",
        "🌤️",
        "🌥️",
        "🌦️",
        "🌧️",
        "🌨️",
        "🌩️",
        "🌪️",
        "🌫️",
        "🌬️",
        "🌭",
        "🌮",
        "🌯",
        "🌰",
        "🌱",
        "🌲",
        "🌳",
        "🌴",
        "🌵",
        "🌶️",
        "🌷",
        "🌸",
        "🌹",
        "🌺",
        "🌻",
        "🌼",
        "🌽",
        "🌾",
        "🌿",
        "🍀",
        "🍁",
        "🍂",
        "🍃",
        "🍄",
        "🍅",
        "🍆",
        "🍇",
        "🍈",
        "🍉",
        "🍊",
        "🍋",
        "🍌",
        "🍍",
        "🍎",
        "🍏",
        "🍐",
        "🍑",
        "🍒",
        "🍓",
        "🍔",
        "🍕",
        "🍖",
        "🍗",
        "🍘",
        "🍙",
        "🍚",
        "🍛",
        "🍜",
        "🍝",
        "🍞",
        "🍟",
        "🍠",
        "🍡",
        "🍢",
        "🍣",
        "🍤",
        "🍥",
        "🍦",
        "🍧",
        "🍨",
        "🍩",
        "🍪",
        "🍫",
        "🍬",
        "🍭",
        "🍮",
        "🍯",
        "🍰",
        "🍱",
        "🍲",
        "🍳",
        "🍴",
        "🍵",
        "🍶",
        "🍷",
        "🍸",
        "🍹",
        "🍺",
        "🍻",
        "🍼",
        "🍽️",
        "🍾",
        "🍿",
        "🎀",
        "🎁",
        "🎂",
        "🎃",
        "🎄",
        "🎅🏻",
        "🎅🏼",
        "🎅🏽",
        "🎅🏾",
        "🎅🏿",
        "🎅",
        "🎆",
        "🎇",
        "🎈",
        "🎉",
        "🎊",
        "🎋",
        "🎌",
        "🎍",
        "🎎",
        "🎏",
        "🎐",
        "🎑",
        "🎒",
        "🎓",
        "🎖️",
        "🎗️",
        "🎙️",
        "🎚️",
        "🎛️",
        "🎞️",
        "🎟️",
        "🎠",
        "🎡",
        "🎢",
        "🎣",
        "🎤",
        "🎥",
        "🎦",
        "🎧",
        "🎨",
        "🎩",
        "🎪",
        "🎫",
        "🎬",
        "🎭",
        "🎮",
        "🎯",
        "🎰",
        "🎱",
        "🎲",
        "🎳",
        "🎴",
        "🎵",
        "🎶",
        "🎷",
        "🎸",
        "🎹",
        "🎺",
        "🎻",
        "🎼",
        "🎽",
        "🎾",
        "🎿",
        "🏀",
        "🏁",
        "🏂🏻",
        "🏂🏼",
        "🏂🏽",
        "🏂🏾",
        "🏂🏿",
        "🏂",
        "🏃🏻‍♀️",
        "🏃🏻‍♂️",
        "🏃🏻",
        "🏃🏼‍♀️",
        "🏃🏼‍♂️",
        "🏃🏼",
        "🏃🏽‍♀️",
        "🏃🏽‍♂️",
        "🏃🏽",
        "🏃🏾‍♀️",
        "🏃🏾‍♂️",
        "🏃🏾",
        "🏃🏿‍♀️",
        "🏃🏿‍♂️",
        "🏃🏿",
        "🏃‍♀️",
        "🏃‍♂️",
        "🏃",
        "🏄🏻‍♀️",
        "🏄🏻‍♂️",
        "🏄🏻",
        "🏄🏼‍♀️",
        "🏄🏼‍♂️",
        "🏄🏼",
        "🏄🏽‍♀️",
        "🏄🏽‍♂️",
        "🏄🏽",
        "🏄🏾‍♀️",
        "🏄🏾‍♂️",
        "🏄🏾",
        "🏄🏿‍♀️",
        "🏄🏿‍♂️",
        "🏄🏿",
        "🏄‍♀️",
        "🏄‍♂️",
        "🏄",
        "🏅",
        "🏆",
        "🏇🏻",
        "🏇🏼",
        "🏇🏽",
        "🏇🏾",
        "🏇🏿",
        "🏇",
        "🏈",
        "🏉",
        "🏊🏻‍♀️",
        "🏊🏻‍♂️",
        "🏊🏻",
        "🏊🏼‍♀️",
        "🏊🏼‍♂️",
        "🏊🏼",
        "🏊🏽‍♀️",
        "🏊🏽‍♂️",
        "🏊🏽",
        "🏊🏾‍♀️",
        "🏊🏾‍♂️",
        "🏊🏾",
        "🏊🏿‍♀️",
        "🏊🏿‍♂️",
        "🏊🏿",
        "🏊‍♀️",
        "🏊‍♂️",
        "🏊",
        "🏋🏻‍♀️",
        "🏋🏻‍♂️",
        "🏋🏻",
        "🏋🏼‍♀️",
        "🏋🏼‍♂️",
        "🏋🏼",
        "🏋🏽‍♀️",
        "🏋🏽‍♂️",
        "🏋🏽",
        "🏋🏾‍♀️",
        "🏋🏾‍♂️",
        "🏋🏾",
        "🏋🏿‍♀️",
        "🏋🏿‍♂️",
        "🏋🏿",
        "🏋️‍♀️",
        "🏋️‍♂️",
        "🏋️",
        "🏌🏻‍♀️",
        "🏌🏻‍♂️",
        "🏌🏻",
        "🏌🏼‍♀️",
        "🏌🏼‍♂️",
        "🏌🏼",
        "🏌🏽‍♀️",
        "🏌🏽‍♂️",
        "🏌🏽",
        "🏌🏾‍♀️",
        "🏌🏾‍♂️",
        "🏌🏾",
        "🏌🏿‍♀️",
        "🏌🏿‍♂️",
        "🏌🏿",
        "🏌️‍♀️",
        "🏌️‍♂️",
        "🏌️",
        "🏍️",
        "🏎️",
        "🏏",
        "🏐",
        "🏑",
        "🏒",
        "🏓",
        "🏔️",
        "🏕️",
        "🏖️",
        "🏗️",
        "🏘️",
        "🏙️",
        "🏚️",
        "🏛️",
        "🏜️",
        "🏝️",
        "🏞️",
        "🏟️",
        "🏠",
        "🏡",
        "🏢",
        "🏣",
        "🏤",
        "🏥",
        "🏦",
        "🏧",
        "🏨",
        "🏩",
        "🏪",
        "🏫",
        "🏬",
        "🏭",
        "🏮",
        "🏯",
        "🏰",
        "🏳️‍🌈",
        "🏳️",
        "🏴‍☠️",
        "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
        "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
        "🏴󠁧󠁢󠁷󠁬󠁳󠁿",
        "🏴",
        "🏵️",
        "🏷️",
        "🏸",
        "🏹",
        "🏺",
        "🏻",
        "🏼",
        "🏽",
        "🏾",
        "🏿",
        "🐀",
        "🐁",
        "🐂",
        "🐃",
        "🐄",
        "🐅",
        "🐆",
        "🐇",
        "🐈",
        "🐉",
        "🐊",
        "🐋",
        "🐌",
        "🐍",
        "🐎",
        "🐏",
        "🐐",
        "🐑",
        "🐒",
        "🐓",
        "🐔",
        "🐕‍🦺",
        "🐕",
        "🐖",
        "🐗",
        "🐘",
        "🐙",
        "🐚",
        "🐛",
        "🐜",
        "🐝",
        "🐞",
        "🐟",
        "🐠",
        "🐡",
        "🐢",
        "🐣",
        "🐤",
        "🐥",
        "🐦",
        "🐧",
        "🐨",
        "🐩",
        "🐪",
        "🐫",
        "🐬",
        "🐭",
        "🐮",
        "🐯",
        "🐰",
        "🐱",
        "🐲",
        "🐳",
        "🐴",
        "🐵",
        "🐶",
        "🐷",
        "🐸",
        "🐹",
        "🐺",
        "🐻",
        "🐼",
        "🐽",
        "🐾",
        "🐿️",
        "👀",
        "👁‍🗨",
        "👁️",
        "👂🏻",
        "👂🏼",
        "👂🏽",
        "👂🏾",
        "👂🏿",
        "👂",
        "👃🏻",
        "👃🏼",
        "👃🏽",
        "👃🏾",
        "👃🏿",
        "👃",
        "👄",
        "👅",
        "👆🏻",
        "👆🏼",
        "👆🏽",
        "👆🏾",
        "👆🏿",
        "👆",
        "👇🏻",
        "👇🏼",
        "👇🏽",
        "👇🏾",
        "👇🏿",
        "👇",
        "👈🏻",
        "👈🏼",
        "👈🏽",
        "👈🏾",
        "👈🏿",
        "👈",
        "👉🏻",
        "👉🏼",
        "👉🏽",
        "👉🏾",
        "👉🏿",
        "👉",
        "👊🏻",
        "👊🏼",
        "👊🏽",
        "👊🏾",
        "👊🏿",
        "👊",
        "👋🏻",
        "👋🏼",
        "👋🏽",
        "👋🏾",
        "👋🏿",
        "👋",
        "👌🏻",
        "👌🏼",
        "👌🏽",
        "👌🏾",
        "👌🏿",
        "👌",
        "👍🏻",
        "👍🏼",
        "👍🏽",
        "👍🏾",
        "👍🏿",
        "👍",
        "👎🏻",
        "👎🏼",
        "👎🏽",
        "👎🏾",
        "👎🏿",
        "👎",
        "👏🏻",
        "👏🏼",
        "👏🏽",
        "👏🏾",
        "👏🏿",
        "👏",
        "👐🏻",
        "👐🏼",
        "👐🏽",
        "👐🏾",
        "👐🏿",
        "👐",
        "👑",
        "👒",
        "👓",
        "👔",
        "👕",
        "👖",
        "👗",
        "👘",
        "👙",
        "👚",
        "👛",
        "👜",
        "👝",
        "👞",
        "👟",
        "👠",
        "👡",
        "👢",
        "👣",
        "👤",
        "👥",
        "👦🏻",
        "👦🏼",
        "👦🏽",
        "👦🏾",
        "👦🏿",
        "👦",
        "👧🏻",
        "👧🏼",
        "👧🏽",
        "👧🏾",
        "👧🏿",
        "👧",
        "👨🏻‍🌾",
        "👨🏻‍🍳",
        "👨🏻‍🎓",
        "👨🏻‍🎤",
        "👨🏻‍🎨",
        "👨🏻‍🏫",
        "👨🏻‍🏭",
        "👨🏻‍💻",
        "👨🏻‍💼",
        "👨🏻‍🔧",
        "👨🏻‍🔬",
        "👨🏻‍🚀",
        "👨🏻‍🚒",
        "👨🏻‍🦯",
        "👨🏻‍🦰",
        "👨🏻‍🦱",
        "👨🏻‍🦲",
        "👨🏻‍🦳",
        "👨🏻‍🦼",
        "👨🏻‍🦽",
        "👨🏻‍⚕️",
        "👨🏻‍⚖️",
        "👨🏻‍✈️",
        "👨🏻",
        "👨🏼‍🌾",
        "👨🏼‍🍳",
        "👨🏼‍🎓",
        "👨🏼‍🎤",
        "👨🏼‍🎨",
        "👨🏼‍🏫",
        "👨🏼‍🏭",
        "👨🏼‍💻",
        "👨🏼‍💼",
        "👨🏼‍🔧",
        "👨🏼‍🔬",
        "👨🏼‍🚀",
        "👨🏼‍🚒",
        "👨🏼‍🤝‍👨🏻",
        "👨🏼‍🦯",
        "👨🏼‍🦰",
        "👨🏼‍🦱",
        "👨🏼‍🦲",
        "👨🏼‍🦳",
        "👨🏼‍🦼",
        "👨🏼‍🦽",
        "👨🏼‍⚕️",
        "👨🏼‍⚖️",
        "👨🏼‍✈️",
        "👨🏼",
        "👨🏽‍🌾",
        "👨🏽‍🍳",
        "👨🏽‍🎓",
        "👨🏽‍🎤",
        "👨🏽‍🎨",
        "👨🏽‍🏫",
        "👨🏽‍🏭",
        "👨🏽‍💻",
        "👨🏽‍💼",
        "👨🏽‍🔧",
        "👨🏽‍🔬",
        "👨🏽‍🚀",
        "👨🏽‍🚒",
        "👨🏽‍🤝‍👨🏻",
        "👨🏽‍🤝‍👨🏼",
        "👨🏽‍🦯",
        "👨🏽‍🦰",
        "👨🏽‍🦱",
        "👨🏽‍🦲",
        "👨🏽‍🦳",
        "👨🏽‍🦼",
        "👨🏽‍🦽",
        "👨🏽‍⚕️",
        "👨🏽‍⚖️",
        "👨🏽‍✈️",
        "👨🏽",
        "👨🏾‍🌾",
        "👨🏾‍🍳",
        "👨🏾‍🎓",
        "👨🏾‍🎤",
        "👨🏾‍🎨",
        "👨🏾‍🏫",
        "👨🏾‍🏭",
        "👨🏾‍💻",
        "👨🏾‍💼",
        "👨🏾‍🔧",
        "👨🏾‍🔬",
        "👨🏾‍🚀",
        "👨🏾‍🚒",
        "👨🏾‍🤝‍👨🏻",
        "👨🏾‍🤝‍👨🏼",
        "👨🏾‍🤝‍👨🏽",
        "👨🏾‍🦯",
        "👨🏾‍🦰",
        "👨🏾‍🦱",
        "👨🏾‍🦲",
        "👨🏾‍🦳",
        "👨🏾‍🦼",
        "👨🏾‍🦽",
        "👨🏾‍⚕️",
        "👨🏾‍⚖️",
        "👨🏾‍✈️",
        "👨🏾",
        "👨🏿‍🌾",
        "👨🏿‍🍳",
        "👨🏿‍🎓",
        "👨🏿‍🎤",
        "👨🏿‍🎨",
        "👨🏿‍🏫",
        "👨🏿‍🏭",
        "👨🏿‍💻",
        "👨🏿‍💼",
        "👨🏿‍🔧",
        "👨🏿‍🔬",
        "👨🏿‍🚀",
        "👨🏿‍🚒",
        "👨🏿‍🤝‍👨🏻",
        "👨🏿‍🤝‍👨🏼",
        "👨🏿‍🤝‍👨🏽",
        "👨🏿‍🤝‍👨🏾",
        "👨🏿‍🦯",
        "👨🏿‍🦰",
        "👨🏿‍🦱",
        "👨🏿‍🦲",
        "👨🏿‍🦳",
        "👨🏿‍🦼",
        "👨🏿‍🦽",
        "👨🏿‍⚕️",
        "👨🏿‍⚖️",
        "👨🏿‍✈️",
        "👨🏿",
        "👨‍🌾",
        "👨‍🍳",
        "👨‍🎓",
        "👨‍🎤",
        "👨‍🎨",
        "👨‍🏫",
        "👨‍🏭",
        "👨‍👦‍👦",
        "👨‍👦",
        "👨‍👧‍👦",
        "👨‍👧‍👧",
        "👨‍👧",
        "👨‍👨‍👦‍👦",
        "👨‍👨‍👦",
        "👨‍👨‍👧‍👦",
        "👨‍👨‍👧‍👧",
        "👨‍👨‍👧",
        "👨‍👩‍👦‍👦",
        "👨‍👩‍👦",
        "👨‍👩‍👧‍👦",
        "👨‍👩‍👧‍👧",
        "👨‍👩‍👧",
        "👨‍💻",
        "👨‍💼",
        "👨‍🔧",
        "👨‍🔬",
        "👨‍🚀",
        "👨‍🚒",
        "👨‍🦯",
        "👨‍🦰",
        "👨‍🦱",
        "👨‍🦲",
        "👨‍🦳",
        "👨‍🦼",
        "👨‍🦽",
        "👨‍⚕️",
        "👨‍⚖️",
        "👨‍✈️",
        "👨‍❤️‍👨",
        "👨‍❤️‍💋‍👨",
        "👨",
        "👩🏻‍🌾",
        "👩🏻‍🍳",
        "👩🏻‍🎓",
        "👩🏻‍🎤",
        "👩🏻‍🎨",
        "👩🏻‍🏫",
        "👩🏻‍🏭",
        "👩🏻‍💻",
        "👩🏻‍💼",
        "👩🏻‍🔧",
        "👩🏻‍🔬",
        "👩🏻‍🚀",
        "👩🏻‍🚒",
        "👩🏻‍🤝‍👨🏼",
        "👩🏻‍🤝‍👨🏽",
        "👩🏻‍🤝‍👨🏾",
        "👩🏻‍🤝‍👨🏿",
        "👩🏻‍🦯",
        "👩🏻‍🦰",
        "👩🏻‍🦱",
        "👩🏻‍🦲",
        "👩🏻‍🦳",
        "👩🏻‍🦼",
        "👩🏻‍🦽",
        "👩🏻‍⚕️",
        "👩🏻‍⚖️",
        "👩🏻‍✈️",
        "👩🏻",
        "👩🏼‍🌾",
        "👩🏼‍🍳",
        "👩🏼‍🎓",
        "👩🏼‍🎤",
        "👩🏼‍🎨",
        "👩🏼‍🏫",
        "👩🏼‍🏭",
        "👩🏼‍💻",
        "👩🏼‍💼",
        "👩🏼‍🔧",
        "👩🏼‍🔬",
        "👩🏼‍🚀",
        "👩🏼‍🚒",
        "👩🏼‍🤝‍👨🏻",
        "👩🏼‍🤝‍👨🏽",
        "👩🏼‍🤝‍👨🏾",
        "👩🏼‍🤝‍👨🏿",
        "👩🏼‍🤝‍👩🏻",
        "👩🏼‍🦯",
        "👩🏼‍🦰",
        "👩🏼‍🦱",
        "👩🏼‍🦲",
        "👩🏼‍🦳",
        "👩🏼‍🦼",
        "👩🏼‍🦽",
        "👩🏼‍⚕️",
        "👩🏼‍⚖️",
        "👩🏼‍✈️",
        "👩🏼",
        "👩🏽‍🌾",
        "👩🏽‍🍳",
        "👩🏽‍🎓",
        "👩🏽‍🎤",
        "👩🏽‍🎨",
        "👩🏽‍🏫",
        "👩🏽‍🏭",
        "👩🏽‍💻",
        "👩🏽‍💼",
        "👩🏽‍🔧",
        "👩🏽‍🔬",
        "👩🏽‍🚀",
        "👩🏽‍🚒",
        "👩🏽‍🤝‍👨🏻",
        "👩🏽‍🤝‍👨🏼",
        "👩🏽‍🤝‍👨🏾",
        "👩🏽‍🤝‍👨🏿",
        "👩🏽‍🤝‍👩🏻",
        "👩🏽‍🤝‍👩🏼",
        "👩🏽‍🦯",
        "👩🏽‍🦰",
        "👩🏽‍🦱",
        "👩🏽‍🦲",
        "👩🏽‍🦳",
        "👩🏽‍🦼",
        "👩🏽‍🦽",
        "👩🏽‍⚕️",
        "👩🏽‍⚖️",
        "👩🏽‍✈️",
        "👩🏽",
        "👩🏾‍🌾",
        "👩🏾‍🍳",
        "👩🏾‍🎓",
        "👩🏾‍🎤",
        "👩🏾‍🎨",
        "👩🏾‍🏫",
        "👩🏾‍🏭",
        "👩🏾‍💻",
        "👩🏾‍💼",
        "👩🏾‍🔧",
        "👩🏾‍🔬",
        "👩🏾‍🚀",
        "👩🏾‍🚒",
        "👩🏾‍🤝‍👨🏻",
        "👩🏾‍🤝‍👨🏼",
        "👩🏾‍🤝‍👨🏽",
        "👩🏾‍🤝‍👨🏿",
        "👩🏾‍🤝‍👩🏻",
        "👩🏾‍🤝‍👩🏼",
        "👩🏾‍🤝‍👩🏽",
        "👩🏾‍🦯",
        "👩🏾‍🦰",
        "👩🏾‍🦱",
        "👩🏾‍🦲",
        "👩🏾‍🦳",
        "👩🏾‍🦼",
        "👩🏾‍🦽",
        "👩🏾‍⚕️",
        "👩🏾‍⚖️",
        "👩🏾‍✈️",
        "👩🏾",
        "👩🏿‍🌾",
        "👩🏿‍🍳",
        "👩🏿‍🎓",
        "👩🏿‍🎤",
        "👩🏿‍🎨",
        "👩🏿‍🏫",
        "👩🏿‍🏭",
        "👩🏿‍💻",
        "👩🏿‍💼",
        "👩🏿‍🔧",
        "👩🏿‍🔬",
        "👩🏿‍🚀",
        "👩🏿‍🚒",
        "👩🏿‍🤝‍👨🏻",
        "👩🏿‍🤝‍👨🏼",
        "👩🏿‍🤝‍👨🏽",
        "👩🏿‍🤝‍👨🏾",
        "👩🏿‍🤝‍👩🏻",
        "👩🏿‍🤝‍👩🏼",
        "👩🏿‍🤝‍👩🏽",
        "👩🏿‍🤝‍👩🏾",
        "👩🏿‍🦯",
        "👩🏿‍🦰",
        "👩🏿‍🦱",
        "👩🏿‍🦲",
        "👩🏿‍🦳",
        "👩🏿‍🦼",
        "👩🏿‍🦽",
        "👩🏿‍⚕️",
        "👩🏿‍⚖️",
        "👩🏿‍✈️",
        "👩🏿",
        "👩‍🌾",
        "👩‍🍳",
        "👩‍🎓",
        "👩‍🎤",
        "👩‍🎨",
        "👩‍🏫",
        "👩‍🏭",
        "👩‍👦‍👦",
        "👩‍👦",
        "👩‍👧‍👦",
        "👩‍👧‍👧",
        "👩‍👧",
        "👩‍👩‍👦‍👦",
        "👩‍👩‍👦",
        "👩‍👩‍👧‍👦",
        "👩‍👩‍👧‍👧",
        "👩‍👩‍👧",
        "👩‍💻",
        "👩‍💼",
        "👩‍🔧",
        "👩‍🔬",
        "👩‍🚀",
        "👩‍🚒",
        "👩‍🦯",
        "👩‍🦰",
        "👩‍🦱",
        "👩‍🦲",
        "👩‍🦳",
        "👩‍🦼",
        "👩‍🦽",
        "👩‍⚕️",
        "👩‍⚖️",
        "👩‍✈️",
        "👩‍❤️‍👨",
        "👩‍❤️‍👩",
        "👩‍❤️‍💋‍👨",
        "👩‍❤️‍💋‍👩",
        "👩",
        "👪",
        "👫🏻",
        "👫🏼",
        "👫🏽",
        "👫🏾",
        "👫🏿",
        "👫",
        "👬🏻",
        "👬🏼",
        "👬🏽",
        "👬🏾",
        "👬🏿",
        "👬",
        "👭🏻",
        "👭🏼",
        "👭🏽",
        "👭🏾",
        "👭🏿",
        "👭",
        "👮🏻‍♀️",
        "👮🏻‍♂️",
        "👮🏻",
        "👮🏼‍♀️",
        "👮🏼‍♂️",
        "👮🏼",
        "👮🏽‍♀️",
        "👮🏽‍♂️",
        "👮🏽",
        "👮🏾‍♀️",
        "👮🏾‍♂️",
        "👮🏾",
        "👮🏿‍♀️",
        "👮🏿‍♂️",
        "👮🏿",
        "👮‍♀️",
        "👮‍♂️",
        "👮",
        "👯‍♀️",
        "👯‍♂️",
        "👯",
        "👰🏻",
        "👰🏼",
        "👰🏽",
        "👰🏾",
        "👰🏿",
        "👰",
        "👱🏻‍♀️",
        "👱🏻‍♂️",
        "👱🏻",
        "👱🏼‍♀️",
        "👱🏼‍♂️",
        "👱🏼",
        "👱🏽‍♀️",
        "👱🏽‍♂️",
        "👱🏽",
        "👱🏾‍♀️",
        "👱🏾‍♂️",
        "👱🏾",
        "👱🏿‍♀️",
        "👱🏿‍♂️",
        "👱🏿",
        "👱‍♀️",
        "👱‍♂️",
        "👱",
        "👲🏻",
        "👲🏼",
        "👲🏽",
        "👲🏾",
        "👲🏿",
        "👲",
        "👳🏻‍♀️",
        "👳🏻‍♂️",
        "👳🏻",
        "👳🏼‍♀️",
        "👳🏼‍♂️",
        "👳🏼",
        "👳🏽‍♀️",
        "👳🏽‍♂️",
        "👳🏽",
        "👳🏾‍♀️",
        "👳🏾‍♂️",
        "👳🏾",
        "👳🏿‍♀️",
        "👳🏿‍♂️",
        "👳🏿",
        "👳‍♀️",
        "👳‍♂️",
        "👳",
        "👴🏻",
        "👴🏼",
        "👴🏽",
        "👴🏾",
        "👴🏿",
        "👴",
        "👵🏻",
        "👵🏼",
        "👵🏽",
        "👵🏾",
        "👵🏿",
        "👵",
        "👶🏻",
        "👶🏼",
        "👶🏽",
        "👶🏾",
        "👶🏿",
        "👶",
        "👷🏻‍♀️",
        "👷🏻‍♂️",
        "👷🏻",
        "👷🏼‍♀️",
        "👷🏼‍♂️",
        "👷🏼",
        "👷🏽‍♀️",
        "👷🏽‍♂️",
        "👷🏽",
        "👷🏾‍♀️",
        "👷🏾‍♂️",
        "👷🏾",
        "👷🏿‍♀️",
        "👷🏿‍♂️",
        "👷🏿",
        "👷‍♀️",
        "👷‍♂️",
        "👷",
        "👸🏻",
        "👸🏼",
        "👸🏽",
        "👸🏾",
        "👸🏿",
        "👸",
        "👹",
        "👺",
        "👻",
        "👼🏻",
        "👼🏼",
        "👼🏽",
        "👼🏾",
        "👼🏿",
        "👼",
        "👽",
        "👾",
        "👿",
        "💀",
        "💁🏻‍♀️",
        "💁🏻‍♂️",
        "💁🏻",
        "💁🏼‍♀️",
        "💁🏼‍♂️",
        "💁🏼",
        "💁🏽‍♀️",
        "💁🏽‍♂️",
        "💁🏽",
        "💁🏾‍♀️",
        "💁🏾‍♂️",
        "💁🏾",
        "💁🏿‍♀️",
        "💁🏿‍♂️",
        "💁🏿",
        "💁‍♀️",
        "💁‍♂️",
        "💁",
        "💂🏻‍♀️",
        "💂🏻‍♂️",
        "💂🏻",
        "💂🏼‍♀️",
        "💂🏼‍♂️",
        "💂🏼",
        "💂🏽‍♀️",
        "💂🏽‍♂️",
        "💂🏽",
        "💂🏾‍♀️",
        "💂🏾‍♂️",
        "💂🏾",
        "💂🏿‍♀️",
        "💂🏿‍♂️",
        "💂🏿",
        "💂‍♀️",
        "💂‍♂️",
        "💂",
        "💃🏻",
        "💃🏼",
        "💃🏽",
        "💃🏾",
        "💃🏿",
        "💃",
        "💄",
        "💅🏻",
        "💅🏼",
        "💅🏽",
        "💅🏾",
        "💅🏿",
        "💅",
        "💆🏻‍♀️",
        "💆🏻‍♂️",
        "💆🏻",
        "💆🏼‍♀️",
        "💆🏼‍♂️",
        "💆🏼",
        "💆🏽‍♀️",
        "💆🏽‍♂️",
        "💆🏽",
        "💆🏾‍♀️",
        "💆🏾‍♂️",
        "💆🏾",
        "💆🏿‍♀️",
        "💆🏿‍♂️",
        "💆🏿",
        "💆‍♀️",
        "💆‍♂️",
        "💆",
        "💇🏻‍♀️",
        "💇🏻‍♂️",
        "💇🏻",
        "💇🏼‍♀️",
        "💇🏼‍♂️",
        "💇🏼",
        "💇🏽‍♀️",
        "💇🏽‍♂️",
        "💇🏽",
        "💇🏾‍♀️",
        "💇🏾‍♂️",
        "💇🏾",
        "💇🏿‍♀️",
        "💇🏿‍♂️",
        "💇🏿",
        "💇‍♀️",
        "💇‍♂️",
        "💇",
        "💈",
        "💉",
        "💊",
        "💋",
        "💌",
        "💍",
        "💎",
        "💏",
        "💐",
        "💑",
        "💒",
        "💓",
        "💔",
        "💕",
        "💖",
        "💗",
        "💘",
        "💙",
        "💚",
        "💛",
        "💜",
        "💝",
        "💞",
        "💟",
        "💠",
        "💡",
        "💢",
        "💣",
        "💤",
        "💥",
        "💦",
        "💧",
        "💨",
        "💩",
        "💪🏻",
        "💪🏼",
        "💪🏽",
        "💪🏾",
        "💪🏿",
        "💪",
        "💫",
        "💬",
        "💭",
        "💮",
        "💯",
        "💰",
        "💱",
        "💲",
        "💳",
        "💴",
        "💵",
        "💶",
        "💷",
        "💸",
        "💹",
        "💺",
        "💻",
        "💼",
        "💽",
        "💾",
        "💿",
        "📀",
        "📁",
        "📂",
        "📃",
        "📄",
        "📅",
        "📆",
        "📇",
        "📈",
        "📉",
        "📊",
        "📋",
        "📌",
        "📍",
        "📎",
        "📏",
        "📐",
        "📑",
        "📒",
        "📓",
        "📔",
        "📕",
        "📖",
        "📗",
        "📘",
        "📙",
        "📚",
        "📛",
        "📜",
        "📝",
        "📞",
        "📟",
        "📠",
        "📡",
        "📢",
        "📣",
        "📤",
        "📥",
        "📦",
        "📧",
        "📨",
        "📩",
        "📪",
        "📫",
        "📬",
        "📭",
        "📮",
        "📯",
        "📰",
        "📱",
        "📲",
        "📳",
        "📴",
        "📵",
        "📶",
        "📷",
        "📸",
        "📹",
        "📺",
        "📻",
        "📼",
        "📽️",
        "📿",
        "🔀",
        "🔁",
        "🔂",
        "🔃",
        "🔄",
        "🔅",
        "🔆",
        "🔇",
        "🔈",
        "🔉",
        "🔊",
        "🔋",
        "🔌",
        "🔍",
        "🔎",
        "🔏",
        "🔐",
        "🔑",
        "🔒",
        "🔓",
        "🔔",
        "🔕",
        "🔖",
        "🔗",
        "🔘",
        "🔙",
        "🔚",
        "🔛",
        "🔜",
        "🔝",
        "🔞",
        "🔟",
        "🔠",
        "🔡",
        "🔢",
        "🔣",
        "🔤",
        "🔥",
        "🔦",
        "🔧",
        "🔨",
        "🔩",
        "🔪",
        "🔫",
        "🔬",
        "🔭",
        "🔮",
        "🔯",
        "🔰",
        "🔱",
        "🔲",
        "🔳",
        "🔴",
        "🔵",
        "🔶",
        "🔷",
        "🔸",
        "🔹",
        "🔺",
        "🔻",
        "🔼",
        "🔽",
        "🕉️",
        "🕊️",
        "🕋",
        "🕌",
        "🕍",
        "🕎",
        "🕐",
        "🕑",
        "🕒",
        "🕓",
        "🕔",
        "🕕",
        "🕖",
        "🕗",
        "🕘",
        "🕙",
        "🕚",
        "🕛",
        "🕜",
        "🕝",
        "🕞",
        "🕟",
        "🕠",
        "🕡",
        "🕢",
        "🕣",
        "🕤",
        "🕥",
        "🕦",
        "🕧",
        "🕯️",
        "🕰️",
        "🕳️",
        "🕴🏻‍♀️",
        "🕴🏻‍♂️",
        "🕴🏻",
        "🕴🏼‍♀️",
        "🕴🏼‍♂️",
        "🕴🏼",
        "🕴🏽‍♀️",
        "🕴🏽‍♂️",
        "🕴🏽",
        "🕴🏾‍♀️",
        "🕴🏾‍♂️",
        "🕴🏾",
        "🕴🏿‍♀️",
        "🕴🏿‍♂️",
        "🕴🏿",
        "🕴️‍♀️",
        "🕴️‍♂️",
        "🕴️",
        "🕵🏻‍♀️",
        "🕵🏻‍♂️",
        "🕵🏻",
        "🕵🏼‍♀️",
        "🕵🏼‍♂️",
        "🕵🏼",
        "🕵🏽‍♀️",
        "🕵🏽‍♂️",
        "🕵🏽",
        "🕵🏾‍♀️",
        "🕵🏾‍♂️",
        "🕵🏾",
        "🕵🏿‍♀️",
        "🕵🏿‍♂️",
        "🕵🏿",
        "🕵️‍♀️",
        "🕵️‍♂️",
        "🕵️",
        "🕶️",
        "🕷️",
        "🕸️",
        "🕹️",
        "🕺🏻",
        "🕺🏼",
        "🕺🏽",
        "🕺🏾",
        "🕺🏿",
        "🕺",
        "🖇️",
        "🖊️",
        "🖋️",
        "🖌️",
        "🖍️",
        "🖐🏻",
        "🖐🏼",
        "🖐🏽",
        "🖐🏾",
        "🖐🏿",
        "🖐️",
        "🖕🏻",
        "🖕🏼",
        "🖕🏽",
        "🖕🏾",
        "🖕🏿",
        "🖕",
        "🖖🏻",
        "🖖🏼",
        "🖖🏽",
        "🖖🏾",
        "🖖🏿",
        "🖖",
        "🖤",
        "🖥️",
        "🖨️",
        "🖱️",
        "🖲️",
        "🖼️",
        "🗂️",
        "🗃️",
        "🗄️",
        "🗑️",
        "🗒️",
        "🗓️",
        "🗜️",
        "🗝️",
        "🗞️",
        "🗡️",
        "🗣️",
        "🗨️",
        "🗯️",
        "🗳️",
        "🗺️",
        "🗻",
        "🗼",
        "🗽",
        "🗾",
        "🗿",
        "😀",
        "😁",
        "😂",
        "😃",
        "😄",
        "😅",
        "😆",
        "😇",
        "😈",
        "😉",
        "😊",
        "😋",
        "😌",
        "😍",
        "😎",
        "😏",
        "😐",
        "😑",
        "😒",
        "😓",
        "😔",
        "😕",
        "😖",
        "😗",
        "😘",
        "😙",
        "😚",
        "😛",
        "😜",
        "😝",
        "😞",
        "😟",
        "😠",
        "😡",
        "😢",
        "😣",
        "😤",
        "😥",
        "😦",
        "😧",
        "😨",
        "😩",
        "😪",
        "😫",
        "😬",
        "😭",
        "😮",
        "😯",
        "😰",
        "😱",
        "😲",
        "😳",
        "😴",
        "😵",
        "😶",
        "😷",
        "😸",
        "😹",
        "😺",
        "😻",
        "😼",
        "😽",
        "😾",
        "😿",
        "🙀",
        "🙁",
        "🙂",
        "🙃",
        "🙄",
        "🙅🏻‍♀️",
        "🙅🏻‍♂️",
        "🙅🏻",
        "🙅🏼‍♀️",
        "🙅🏼‍♂️",
        "🙅🏼",
        "🙅🏽‍♀️",
        "🙅🏽‍♂️",
        "🙅🏽",
        "🙅🏾‍♀️",
        "🙅🏾‍♂️",
        "🙅🏾",
        "🙅🏿‍♀️",
        "🙅🏿‍♂️",
        "🙅🏿",
        "🙅‍♀️",
        "🙅‍♂️",
        "🙅",
        "🙆🏻‍♀️",
        "🙆🏻‍♂️",
        "🙆🏻",
        "🙆🏼‍♀️",
        "🙆🏼‍♂️",
        "🙆🏼",
        "🙆🏽‍♀️",
        "🙆🏽‍♂️",
        "🙆🏽",
        "🙆🏾‍♀️",
        "🙆🏾‍♂️",
        "🙆🏾",
        "🙆🏿‍♀️",
        "🙆🏿‍♂️",
        "🙆🏿",
        "🙆‍♀️",
        "🙆‍♂️",
        "🙆",
        "🙇🏻‍♀️",
        "🙇🏻‍♂️",
        "🙇🏻",
        "🙇🏼‍♀️",
        "🙇🏼‍♂️",
        "🙇🏼",
        "🙇🏽‍♀️",
        "🙇🏽‍♂️",
        "🙇🏽",
        "🙇🏾‍♀️",
        "🙇🏾‍♂️",
        "🙇🏾",
        "🙇🏿‍♀️",
        "🙇🏿‍♂️",
        "🙇🏿",
        "🙇‍♀️",
        "🙇‍♂️",
        "🙇",
        "🙈",
        "🙉",
        "🙊",
        "🙋🏻‍♀️",
        "🙋🏻‍♂️",
        "🙋🏻",
        "🙋🏼‍♀️",
        "🙋🏼‍♂️",
        "🙋🏼",
        "🙋🏽‍♀️",
        "🙋🏽‍♂️",
        "🙋🏽",
        "🙋🏾‍♀️",
        "🙋🏾‍♂️",
        "🙋🏾",
        "🙋🏿‍♀️",
        "🙋🏿‍♂️",
        "🙋🏿",
        "🙋‍♀️",
        "🙋‍♂️",
        "🙋",
        "🙌🏻",
        "🙌🏼",
        "🙌🏽",
        "🙌🏾",
        "🙌🏿",
        "🙌",
        "🙍🏻‍♀️",
        "🙍🏻‍♂️",
        "🙍🏻",
        "🙍🏼‍♀️",
        "🙍🏼‍♂️",
        "🙍🏼",
        "🙍🏽‍♀️",
        "🙍🏽‍♂️",
        "🙍🏽",
        "🙍🏾‍♀️",
        "🙍🏾‍♂️",
        "🙍🏾",
        "🙍🏿‍♀️",
        "🙍🏿‍♂️",
        "🙍🏿",
        "🙍‍♀️",
        "🙍‍♂️",
        "🙍",
        "🙎🏻‍♀️",
        "🙎🏻‍♂️",
        "🙎🏻",
        "🙎🏼‍♀️",
        "🙎🏼‍♂️",
        "🙎🏼",
        "🙎🏽‍♀️",
        "🙎🏽‍♂️",
        "🙎🏽",
        "🙎🏾‍♀️",
        "🙎🏾‍♂️",
        "🙎🏾",
        "🙎🏿‍♀️",
        "🙎🏿‍♂️",
        "🙎🏿",
        "🙎‍♀️",
        "🙎‍♂️",
        "🙎",
        "🙏🏻",
        "🙏🏼",
        "🙏🏽",
        "🙏🏾",
        "🙏🏿",
        "🙏",
        "🚀",
        "🚁",
        "🚂",
        "🚃",
        "🚄",
        "🚅",
        "🚆",
        "🚇",
        "🚈",
        "🚉",
        "🚊",
        "🚋",
        "🚌",
        "🚍",
        "🚎",
        "🚏",
        "🚐",
        "🚑",
        "🚒",
        "🚓",
        "🚔",
        "🚕",
        "🚖",
        "🚗",
        "🚘",
        "🚙",
        "🚚",
        "🚛",
        "🚜",
        "🚝",
        "🚞",
        "🚟",
        "🚠",
        "🚡",
        "🚢",
        "🚣🏻‍♀️",
        "🚣🏻‍♂️",
        "🚣🏻",
        "🚣🏼‍♀️",
        "🚣🏼‍♂️",
        "🚣🏼",
        "🚣🏽‍♀️",
        "🚣🏽‍♂️",
        "🚣🏽",
        "🚣🏾‍♀️",
        "🚣🏾‍♂️",
        "🚣🏾",
        "🚣🏿‍♀️",
        "🚣🏿‍♂️",
        "🚣🏿",
        "🚣‍♀️",
        "🚣‍♂️",
        "🚣",
        "🚤",
        "🚥",
        "🚦",
        "🚧",
        "🚨",
        "🚩",
        "🚪",
        "🚫",
        "🚬",
        "🚭",
        "🚮",
        "🚯",
        "🚰",
        "🚱",
        "🚲",
        "🚳",
        "🚴🏻‍♀️",
        "🚴🏻‍♂️",
        "🚴🏻",
        "🚴🏼‍♀️",
        "🚴🏼‍♂️",
        "🚴🏼",
        "🚴🏽‍♀️",
        "🚴🏽‍♂️",
        "🚴🏽",
        "🚴🏾‍♀️",
        "🚴🏾‍♂️",
        "🚴🏾",
        "🚴🏿‍♀️",
        "🚴🏿‍♂️",
        "🚴🏿",
        "🚴‍♀️",
        "🚴‍♂️",
        "🚴",
        "🚵🏻‍♀️",
        "🚵🏻‍♂️",
        "🚵🏻",
        "🚵🏼‍♀️",
        "🚵🏼‍♂️",
        "🚵🏼",
        "🚵🏽‍♀️",
        "🚵🏽‍♂️",
        "🚵🏽",
        "🚵🏾‍♀️",
        "🚵🏾‍♂️",
        "🚵🏾",
        "🚵🏿‍♀️",
        "🚵🏿‍♂️",
        "🚵🏿",
        "🚵‍♀️",
        "🚵‍♂️",
        "🚵",
        "🚶🏻‍♀️",
        "🚶🏻‍♂️",
        "🚶🏻",
        "🚶🏼‍♀️",
        "🚶🏼‍♂️",
        "🚶🏼",
        "🚶🏽‍♀️",
        "🚶🏽‍♂️",
        "🚶🏽",
        "🚶🏾‍♀️",
        "🚶🏾‍♂️",
        "🚶🏾",
        "🚶🏿‍♀️",
        "🚶🏿‍♂️",
        "🚶🏿",
        "🚶‍♀️",
        "🚶‍♂️",
        "🚶",
        "🚷",
        "🚸",
        "🚹",
        "🚺",
        "🚻",
        "🚼",
        "🚽",
        "🚾",
        "🚿",
        "🛀🏻",
        "🛀🏼",
        "🛀🏽",
        "🛀🏾",
        "🛀🏿",
        "🛀",
        "🛁",
        "🛂",
        "🛃",
        "🛄",
        "🛅",
        "🛋️",
        "🛌🏻",
        "🛌🏼",
        "🛌🏽",
        "🛌🏾",
        "🛌🏿",
        "🛌",
        "🛍️",
        "🛎️",
        "🛏️",
        "🛐",
        "🛑",
        "🛒",
        "🛕",
        "🛠️",
        "🛡️",
        "🛢️",
        "🛣️",
        "🛤️",
        "🛥️",
        "🛩️",
        "🛫",
        "🛬",
        "🛰️",
        "🛳️",
        "🛴",
        "🛵",
        "🛶",
        "🛷",
        "🛸",
        "🛹",
        "🛺",
        "🟠",
        "🟡",
        "🟢",
        "🟣",
        "🟤",
        "🟥",
        "🟦",
        "🟧",
        "🟨",
        "🟩",
        "🟪",
        "🟫",
        "🤍",
        "🤎",
        "🤏🏻",
        "🤏🏼",
        "🤏🏽",
        "🤏🏾",
        "🤏🏿",
        "🤏",
        "🤐",
        "🤑",
        "🤒",
        "🤓",
        "🤔",
        "🤕",
        "🤖",
        "🤗",
        "🤘🏻",
        "🤘🏼",
        "🤘🏽",
        "🤘🏾",
        "🤘🏿",
        "🤘",
        "🤙🏻",
        "🤙🏼",
        "🤙🏽",
        "🤙🏾",
        "🤙🏿",
        "🤙",
        "🤚🏻",
        "🤚🏼",
        "🤚🏽",
        "🤚🏾",
        "🤚🏿",
        "🤚",
        "🤛🏻",
        "🤛🏼",
        "🤛🏽",
        "🤛🏾",
        "🤛🏿",
        "🤛",
        "🤜🏻",
        "🤜🏼",
        "🤜🏽",
        "🤜🏾",
        "🤜🏿",
        "🤜",
        "🤝",
        "🤞🏻",
        "🤞🏼",
        "🤞🏽",
        "🤞🏾",
        "🤞🏿",
        "🤞",
        "🤟🏻",
        "🤟🏼",
        "🤟🏽",
        "🤟🏾",
        "🤟🏿",
        "🤟",
        "🤠",
        "🤡",
        "🤢",
        "🤣",
        "🤤",
        "🤥",
        "🤦🏻‍♀️",
        "🤦🏻‍♂️",
        "🤦🏻",
        "🤦🏼‍♀️",
        "🤦🏼‍♂️",
        "🤦🏼",
        "🤦🏽‍♀️",
        "🤦🏽‍♂️",
        "🤦🏽",
        "🤦🏾‍♀️",
        "🤦🏾‍♂️",
        "🤦🏾",
        "🤦🏿‍♀️",
        "🤦🏿‍♂️",
        "🤦🏿",
        "🤦‍♀️",
        "🤦‍♂️",
        "🤦",
        "🤧",
        "🤨",
        "🤩",
        "🤪",
        "🤫",
        "🤬",
        "🤭",
        "🤮",
        "🤯",
        "🤰🏻",
        "🤰🏼",
        "🤰🏽",
        "🤰🏾",
        "🤰🏿",
        "🤰",
        "🤱🏻",
        "🤱🏼",
        "🤱🏽",
        "🤱🏾",
        "🤱🏿",
        "🤱",
        "🤲🏻",
        "🤲🏼",
        "🤲🏽",
        "🤲🏾",
        "🤲🏿",
        "🤲",
        "🤳🏻",
        "🤳🏼",
        "🤳🏽",
        "🤳🏾",
        "🤳🏿",
        "🤳",
        "🤴🏻",
        "🤴🏼",
        "🤴🏽",
        "🤴🏾",
        "🤴🏿",
        "🤴",
        "🤵🏻‍♀️",
        "🤵🏻‍♂️",
        "🤵🏻",
        "🤵🏼‍♀️",
        "🤵🏼‍♂️",
        "🤵🏼",
        "🤵🏽‍♀️",
        "🤵🏽‍♂️",
        "🤵🏽",
        "🤵🏾‍♀️",
        "🤵🏾‍♂️",
        "🤵🏾",
        "🤵🏿‍♀️",
        "🤵🏿‍♂️",
        "🤵🏿",
        "🤵‍♀️",
        "🤵‍♂️",
        "🤵",
        "🤶🏻",
        "🤶🏼",
        "🤶🏽",
        "🤶🏾",
        "🤶🏿",
        "🤶",
        "🤷🏻‍♀️",
        "🤷🏻‍♂️",
        "🤷🏻",
        "🤷🏼‍♀️",
        "🤷🏼‍♂️",
        "🤷🏼",
        "🤷🏽‍♀️",
        "🤷🏽‍♂️",
        "🤷🏽",
        "🤷🏾‍♀️",
        "🤷🏾‍♂️",
        "🤷🏾",
        "🤷🏿‍♀️",
        "🤷🏿‍♂️",
        "🤷🏿",
        "🤷‍♀️",
        "🤷‍♂️",
        "🤷",
        "🤸🏻‍♀️",
        "🤸🏻‍♂️",
        "🤸🏻",
        "🤸🏼‍♀️",
        "🤸🏼‍♂️",
        "🤸🏼",
        "🤸🏽‍♀️",
        "🤸🏽‍♂️",
        "🤸🏽",
        "🤸🏾‍♀️",
        "🤸🏾‍♂️",
        "🤸🏾",
        "🤸🏿‍♀️",
        "🤸🏿‍♂️",
        "🤸🏿",
        "🤸‍♀️",
        "🤸‍♂️",
        "🤸",
        "🤹🏻‍♀️",
        "🤹🏻‍♂️",
        "🤹🏻",
        "🤹🏼‍♀️",
        "🤹🏼‍♂️",
        "🤹🏼",
        "🤹🏽‍♀️",
        "🤹🏽‍♂️",
        "🤹🏽",
        "🤹🏾‍♀️",
        "🤹🏾‍♂️",
        "🤹🏾",
        "🤹🏿‍♀️",
        "🤹🏿‍♂️",
        "🤹🏿",
        "🤹‍♀️",
        "🤹‍♂️",
        "🤹",
        "🤺",
        "🤼‍♀️",
        "🤼‍♂️",
        "🤼",
        "🤽🏻‍♀️",
        "🤽🏻‍♂️",
        "🤽🏻",
        "🤽🏼‍♀️",
        "🤽🏼‍♂️",
        "🤽🏼",
        "🤽🏽‍♀️",
        "🤽🏽‍♂️",
        "🤽🏽",
        "🤽🏾‍♀️",
        "🤽🏾‍♂️",
        "🤽🏾",
        "🤽🏿‍♀️",
        "🤽🏿‍♂️",
        "🤽🏿",
        "🤽‍♀️",
        "🤽‍♂️",
        "🤽",
        "🤾🏻‍♀️",
        "🤾🏻‍♂️",
        "🤾🏻",
        "🤾🏼‍♀️",
        "🤾🏼‍♂️",
        "🤾🏼",
        "🤾🏽‍♀️",
        "🤾🏽‍♂️",
        "🤾🏽",
        "🤾🏾‍♀️",
        "🤾🏾‍♂️",
        "🤾🏾",
        "🤾🏿‍♀️",
        "🤾🏿‍♂️",
        "🤾🏿",
        "🤾‍♀️",
        "🤾‍♂️",
        "🤾",
        "🤿",
        "🥀",
        "🥁",
        "🥂",
        "🥃",
        "🥄",
        "🥅",
        "🥇",
        "🥈",
        "🥉",
        "🥊",
        "🥋",
        "🥌",
        "🥍",
        "🥎",
        "🥏",
        "🥐",
        "🥑",
        "🥒",
        "🥓",
        "🥔",
        "🥕",
        "🥖",
        "🥗",
        "🥘",
        "🥙",
        "🥚",
        "🥛",
        "🥜",
        "🥝",
        "🥞",
        "🥟",
        "🥠",
        "🥡",
        "🥢",
        "🥣",
        "🥤",
        "🥥",
        "🥦",
        "🥧",
        "🥨",
        "🥩",
        "🥪",
        "🥫",
        "🥬",
        "🥭",
        "🥮",
        "🥯",
        "🥰",
        "🥱",
        "🥳",
        "🥴",
        "🥵",
        "🥶",
        "🥺",
        "🥻",
        "🥼",
        "🥽",
        "🥾",
        "🥿",
        "🦀",
        "🦁",
        "🦂",
        "🦃",
        "🦄",
        "🦅",
        "🦆",
        "🦇",
        "🦈",
        "🦉",
        "🦊",
        "🦋",
        "🦌",
        "🦍",
        "🦎",
        "🦏",
        "🦐",
        "🦑",
        "🦒",
        "🦓",
        "🦔",
        "🦕",
        "🦖",
        "🦗",
        "🦘",
        "🦙",
        "🦚",
        "🦛",
        "🦜",
        "🦝",
        "🦞",
        "🦟",
        "🦠",
        "🦡",
        "🦢",
        "🦥",
        "🦦",
        "🦧",
        "🦨",
        "🦩",
        "🦪",
        "🦮",
        "🦯",
        "🦰",
        "🦱",
        "🦲",
        "🦳",
        "🦴",
        "🦵🏻",
        "🦵🏼",
        "🦵🏽",
        "🦵🏾",
        "🦵🏿",
        "🦵",
        "🦶🏻",
        "🦶🏼",
        "🦶🏽",
        "🦶🏾",
        "🦶🏿",
        "🦶",
        "🦷",
        "🦸🏻‍♀️",
        "🦸🏻‍♂️",
        "🦸🏻",
        "🦸🏼‍♀️",
        "🦸🏼‍♂️",
        "🦸🏼",
        "🦸🏽‍♀️",
        "🦸🏽‍♂️",
        "🦸🏽",
        "🦸🏾‍♀️",
        "🦸🏾‍♂️",
        "🦸🏾",
        "🦸🏿‍♀️",
        "🦸🏿‍♂️",
        "🦸🏿",
        "🦸‍♀️",
        "🦸‍♂️",
        "🦸",
        "🦹🏻‍♀️",
        "🦹🏻‍♂️",
        "🦹🏻",
        "🦹🏼‍♀️",
        "🦹🏼‍♂️",
        "🦹🏼",
        "🦹🏽‍♀️",
        "🦹🏽‍♂️",
        "🦹🏽",
        "🦹🏾‍♀️",
        "🦹🏾‍♂️",
        "🦹🏾",
        "🦹🏿‍♀️",
        "🦹🏿‍♂️",
        "🦹🏿",
        "🦹‍♀️",
        "🦹‍♂️",
        "🦹",
        "🦺",
        "🦻🏻",
        "🦻🏼",
        "🦻🏽",
        "🦻🏾",
        "🦻🏿",
        "🦻",
        "🦼",
        "🦽",
        "🦾",
        "🦿",
        "🧀",
        "🧁",
        "🧂",
        "🧃",
        "🧄",
        "🧅",
        "🧆",
        "🧇",
        "🧈",
        "🧉",
        "🧊",
        "🧍🏻‍♀️",
        "🧍🏻‍♂️",
        "🧍🏻",
        "🧍🏼‍♀️",
        "🧍🏼‍♂️",
        "🧍🏼",
        "🧍🏽‍♀️",
        "🧍🏽‍♂️",
        "🧍🏽",
        "🧍🏾‍♀️",
        "🧍🏾‍♂️",
        "🧍🏾",
        "🧍🏿‍♀️",
        "🧍🏿‍♂️",
        "🧍🏿",
        "🧍‍♀️",
        "🧍‍♂️",
        "🧍",
        "🧎🏻‍♀️",
        "🧎🏻‍♂️",
        "🧎🏻",
        "🧎🏼‍♀️",
        "🧎🏼‍♂️",
        "🧎🏼",
        "🧎🏽‍♀️",
        "🧎🏽‍♂️",
        "🧎🏽",
        "🧎🏾‍♀️",
        "🧎🏾‍♂️",
        "🧎🏾",
        "🧎🏿‍♀️",
        "🧎🏿‍♂️",
        "🧎🏿",
        "🧎‍♀️",
        "🧎‍♂️",
        "🧎",
        "🧏🏻‍♀️",
        "🧏🏻‍♂️",
        "🧏🏻",
        "🧏🏼‍♀️",
        "🧏🏼‍♂️",
        "🧏🏼",
        "🧏🏽‍♀️",
        "🧏🏽‍♂️",
        "🧏🏽",
        "🧏🏾‍♀️",
        "🧏🏾‍♂️",
        "🧏🏾",
        "🧏🏿‍♀️",
        "🧏🏿‍♂️",
        "🧏🏿",
        "🧏‍♀️",
        "🧏‍♂️",
        "🧏",
        "🧐",
        "🧑🏻‍🤝‍🧑🏻",
        "🧑🏻",
        "🧑🏼‍🤝‍🧑🏻",
        "🧑🏼‍🤝‍🧑🏼",
        "🧑🏼",
        "🧑🏽‍🤝‍🧑🏻",
        "🧑🏽‍🤝‍🧑🏼",
        "🧑🏽‍🤝‍🧑🏽",
        "🧑🏽",
        "🧑🏾‍🤝‍🧑🏻",
        "🧑🏾‍🤝‍🧑🏼",
        "🧑🏾‍🤝‍🧑🏽",
        "🧑🏾‍🤝‍🧑🏾",
        "🧑🏾",
        "🧑🏿‍🤝‍🧑🏻",
        "🧑🏿‍🤝‍🧑🏼",
        "🧑🏿‍🤝‍🧑🏽",
        "🧑🏿‍🤝‍🧑🏾",
        "🧑🏿‍🤝‍🧑🏿",
        "🧑🏿",
        "🧑‍🤝‍🧑",
        "🧑",
        "🧒🏻",
        "🧒🏼",
        "🧒🏽",
        "🧒🏾",
        "🧒🏿",
        "🧒",
        "🧓🏻",
        "🧓🏼",
        "🧓🏽",
        "🧓🏾",
        "🧓🏿",
        "🧓",
        "🧔🏻",
        "🧔🏼",
        "🧔🏽",
        "🧔🏾",
        "🧔🏿",
        "🧔",
        "🧕🏻",
        "🧕🏼",
        "🧕🏽",
        "🧕🏾",
        "🧕🏿",
        "🧕",
        "🧖🏻‍♀️",
        "🧖🏻‍♂️",
        "🧖🏻",
        "🧖🏼‍♀️",
        "🧖🏼‍♂️",
        "🧖🏼",
        "🧖🏽‍♀️",
        "🧖🏽‍♂️",
        "🧖🏽",
        "🧖🏾‍♀️",
        "🧖🏾‍♂️",
        "🧖🏾",
        "🧖🏿‍♀️",
        "🧖🏿‍♂️",
        "🧖🏿",
        "🧖‍♀️",
        "🧖‍♂️",
        "🧖",
        "🧗🏻‍♀️",
        "🧗🏻‍♂️",
        "🧗🏻",
        "🧗🏼‍♀️",
        "🧗🏼‍♂️",
        "🧗🏼",
        "🧗🏽‍♀️",
        "🧗🏽‍♂️",
        "🧗🏽",
        "🧗🏾‍♀️",
        "🧗🏾‍♂️",
        "🧗🏾",
        "🧗🏿‍♀️",
        "🧗🏿‍♂️",
        "🧗🏿",
        "🧗‍♀️",
        "🧗‍♂️",
        "🧗",
        "🧘🏻‍♀️",
        "🧘🏻‍♂️",
        "🧘🏻",
        "🧘🏼‍♀️",
        "🧘🏼‍♂️",
        "🧘🏼",
        "🧘🏽‍♀️",
        "🧘🏽‍♂️",
        "🧘🏽",
        "🧘🏾‍♀️",
        "🧘🏾‍♂️",
        "🧘🏾",
        "🧘🏿‍♀️",
        "🧘🏿‍♂️",
        "🧘🏿",
        "🧘‍♀️",
        "🧘‍♂️",
        "🧘",
        "🧙🏻‍♀️",
        "🧙🏻‍♂️",
        "🧙🏻",
        "🧙🏼‍♀️",
        "🧙🏼‍♂️",
        "🧙🏼",
        "🧙🏽‍♀️",
        "🧙🏽‍♂️",
        "🧙🏽",
        "🧙🏾‍♀️",
        "🧙🏾‍♂️",
        "🧙🏾",
        "🧙🏿‍♀️",
        "🧙🏿‍♂️",
        "🧙🏿",
        "🧙‍♀️",
        "🧙‍♂️",
        "🧙",
        "🧚🏻‍♀️",
        "🧚🏻‍♂️",
        "🧚🏻",
        "🧚🏼‍♀️",
        "🧚🏼‍♂️",
        "🧚🏼",
        "🧚🏽‍♀️",
        "🧚🏽‍♂️",
        "🧚🏽",
        "🧚🏾‍♀️",
        "🧚🏾‍♂️",
        "🧚🏾",
        "🧚🏿‍♀️",
        "🧚🏿‍♂️",
        "🧚🏿",
        "🧚‍♀️",
        "🧚‍♂️",
        "🧚",
        "🧛🏻‍♀️",
        "🧛🏻‍♂️",
        "🧛🏻",
        "🧛🏼‍♀️",
        "🧛🏼‍♂️",
        "🧛🏼",
        "🧛🏽‍♀️",
        "🧛🏽‍♂️",
        "🧛🏽",
        "🧛🏾‍♀️",
        "🧛🏾‍♂️",
        "🧛🏾",
        "🧛🏿‍♀️",
        "🧛🏿‍♂️",
        "🧛🏿",
        "🧛‍♀️",
        "🧛‍♂️",
        "🧛",
        "🧜🏻‍♀️",
        "🧜🏻‍♂️",
        "🧜🏻",
        "🧜🏼‍♀️",
        "🧜🏼‍♂️",
        "🧜🏼",
        "🧜🏽‍♀️",
        "🧜🏽‍♂️",
        "🧜🏽",
        "🧜🏾‍♀️",
        "🧜🏾‍♂️",
        "🧜🏾",
        "🧜🏿‍♀️",
        "🧜🏿‍♂️",
        "🧜🏿",
        "🧜‍♀️",
        "🧜‍♂️",
        "🧜",
        "🧝🏻‍♀️",
        "🧝🏻‍♂️",
        "🧝🏻",
        "🧝🏼‍♀️",
        "🧝🏼‍♂️",
        "🧝🏼",
        "🧝🏽‍♀️",
        "🧝🏽‍♂️",
        "🧝🏽",
        "🧝🏾‍♀️",
        "🧝🏾‍♂️",
        "🧝🏾",
        "🧝🏿‍♀️",
        "🧝🏿‍♂️",
        "🧝🏿",
        "🧝‍♀️",
        "🧝‍♂️",
        "🧝",
        "🧞‍♀️",
        "🧞‍♂️",
        "🧞",
        "🧟‍♀️",
        "🧟‍♂️",
        "🧟",
        "🧠",
        "🧡",
        "🧢",
        "🧣",
        "🧤",
        "🧥",
        "🧦",
        "🧧",
        "🧨",
        "🧩",
        "🧪",
        "🧫",
        "🧬",
        "🧭",
        "🧮",
        "🧯",
        "🧰",
        "🧱",
        "🧲",
        "🧳",
        "🧴",
        "🧵",
        "🧶",
        "🧷",
        "🧸",
        "🧹",
        "🧺",
        "🧻",
        "🧼",
        "🧽",
        "🧾",
        "🧿",
        "🩰",
        "🩱",
        "🩲",
        "🩳",
        "🩸",
        "🩹",
        "🩺",
        "🪀",
        "🪁",
        "🪂",
        "🪐",
        "🪑",
        "🪒",
        "🪓",
        "🪔",
        "🪕",
        "‼️",
        "⁉️",
        "™️",
        "ℹ️",
        "↔️",
        "↕️",
        "↖️",
        "↗️",
        "↘️",
        "↙️",
        "↩️",
        "↪️",
        "#⃣",
        "⌚️",
        "⌛️",
        "⌨️",
        "⏏️",
        "⏩",
        "⏪",
        "⏫",
        "⏬",
        "⏭️",
        "⏮️",
        "⏯️",
        "⏰",
        "⏱️",
        "⏲️",
        "⏳",
        "⏸️",
        "⏹️",
        "⏺️",
        "Ⓜ️",
        "▪️",
        "▫️",
        "▶️",
        "◀️",
        "◻️",
        "◼️",
        "◽️",
        "◾️",
        "☀️",
        "☁️",
        "☂️",
        "☃️",
        "☄️",
        "☎️",
        "☑️",
        "☔️",
        "☕️",
        "☘️",
        "☝🏻",
        "☝🏼",
        "☝🏽",
        "☝🏾",
        "☝🏿",
        "☝️",
        "☠️",
        "☢️",
        "☣️",
        "☦️",
        "☪️",
        "☮️",
        "☯️",
        "☸️",
        "☹️",
        "☺️",
        "♀️",
        "♂️",
        "♈️",
        "♉️",
        "♊️",
        "♋️",
        "♌️",
        "♍️",
        "♎️",
        "♏️",
        "♐️",
        "♑️",
        "♒️",
        "♓️",
        "♟️",
        "♠️",
        "♣️",
        "♥️",
        "♦️",
        "♨️",
        "♻️",
        "♾",
        "♿️",
        "⚒️",
        "⚓️",
        "⚔️",
        "⚕️",
        "⚖️",
        "⚗️",
        "⚙️",
        "⚛️",
        "⚜️",
        "⚠️",
        "⚡️",
        "⚪️",
        "⚫️",
        "⚰️",
        "⚱️",
        "⚽️",
        "⚾️",
        "⛄️",
        "⛅️",
        "⛈️",
        "⛎",
        "⛏️",
        "⛑️",
        "⛓️",
        "⛔️",
        "⛩️",
        "⛪️",
        "⛰️",
        "⛱️",
        "⛲️",
        "⛳️",
        "⛴️",
        "⛵️",
        "⛷🏻",
        "⛷🏼",
        "⛷🏽",
        "⛷🏾",
        "⛷🏿",
        "⛷️",
        "⛸️",
        "⛹🏻‍♀️",
        "⛹🏻‍♂️",
        "⛹🏻",
        "⛹🏼‍♀️",
        "⛹🏼‍♂️",
        "⛹🏼",
        "⛹🏽‍♀️",
        "⛹🏽‍♂️",
        "⛹🏽",
        "⛹🏾‍♀️",
        "⛹🏾‍♂️",
        "⛹🏾",
        "⛹🏿‍♀️",
        "⛹🏿‍♂️",
        "⛹🏿",
        "⛹️‍♀️",
        "⛹️‍♂️",
        "⛹️",
        "⛺️",
        "⛽️",
        "✂️",
        "✅",
        "✈️",
        "✉️",
        "✊🏻",
        "✊🏼",
        "✊🏽",
        "✊🏾",
        "✊🏿",
        "✊",
        "✋🏻",
        "✋🏼",
        "✋🏽",
        "✋🏾",
        "✋🏿",
        "✋",
        "✌🏻",
        "✌🏼",
        "✌🏽",
        "✌🏾",
        "✌🏿",
        "✌️",
        "✍🏻",
        "✍🏼",
        "✍🏽",
        "✍🏾",
        "✍🏿",
        "✍️",
        "✏️",
        "✒️",
        "✔️",
        "✖️",
        "✝️",
        "✡️",
        "✨",
        "✳️",
        "✴️",
        "❄️",
        "❇️",
        "❌",
        "❎",
        "❓",
        "❔",
        "❕",
        "❗️",
        "❣️",
        "❤️",
        "➕",
        "➖",
        "➗",
        "➡️",
        "➰",
        "➿",
        "⤴️",
        "⤵️",
        "*⃣",
        "⬅️",
        "⬆️",
        "⬇️",
        "⬛️",
        "⬜️",
        "⭐️",
        "⭕️",
        "0⃣",
        "〰️",
        "〽️",
        "1⃣",
        "2⃣",
        "㊗️",
        "㊙️",
        "3⃣",
        "4⃣",
        "5⃣",
        "6⃣",
        "7⃣",
        "8⃣",
        "9⃣",
        "©️",
        "®️",
        ""
      ];
      const path$2 = require$$3;
      const emojisList = _emojisList_3_0_0_emojisList;
      const getHashDigest$1 = getHashDigest_1;
      const emojiRegex = /[\uD800-\uDFFF]./;
      const emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));
      const emojiCache = {};
      function encodeStringToEmoji(content, length) {
        if (emojiCache[content]) {
          return emojiCache[content];
        }
        length = length || 1;
        const emojis = [];
        do {
          if (!emojiList.length) {
            throw new Error("Ran out of emoji");
          }
          const index = Math.floor(Math.random() * emojiList.length);
          emojis.push(emojiList[index]);
          emojiList.splice(index, 1);
        } while (--length > 0);
        const emojiEncoding = emojis.join("");
        emojiCache[content] = emojiEncoding;
        return emojiEncoding;
      }
      function interpolateName$2(loaderContext, name2, options2) {
        let filename;
        const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
        if (typeof name2 === "function") {
          filename = name2(
            loaderContext.resourcePath,
            hasQuery ? loaderContext.resourceQuery : void 0
          );
        } else {
          filename = name2 || "[hash].[ext]";
        }
        const context = options2.context;
        const content = options2.content;
        const regExp = options2.regExp;
        let ext = "bin";
        let basename2 = "file";
        let directory = "";
        let folder = "";
        let query = "";
        if (loaderContext.resourcePath) {
          const parsed = path$2.parse(loaderContext.resourcePath);
          let resourcePath = loaderContext.resourcePath;
          if (parsed.ext) {
            ext = parsed.ext.substr(1);
          }
          if (parsed.dir) {
            basename2 = parsed.name;
            resourcePath = parsed.dir + path$2.sep;
          }
          if (typeof context !== "undefined") {
            directory = path$2.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
            directory = directory.substr(0, directory.length - 1);
          } else {
            directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
          }
          if (directory.length === 1) {
            directory = "";
          } else if (directory.length > 1) {
            folder = path$2.basename(directory);
          }
        }
        if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
          query = loaderContext.resourceQuery;
          const hashIdx = query.indexOf("#");
          if (hashIdx >= 0) {
            query = query.substr(0, hashIdx);
          }
        }
        let url2 = filename;
        if (content) {
          url2 = url2.replace(
            /\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi,
            (all, hashType, digestType, maxLength) => getHashDigest$1(content, hashType, digestType, parseInt(maxLength, 10))
          ).replace(
            /\[emoji(?::(\d+))?\]/gi,
            (all, length) => encodeStringToEmoji(content, parseInt(length, 10))
          );
        }
        url2 = url2.replace(/\[ext\]/gi, () => ext).replace(/\[name\]/gi, () => basename2).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
        if (regExp && loaderContext.resourcePath) {
          const match = loaderContext.resourcePath.match(new RegExp(regExp));
          match && match.forEach((matched, i2) => {
            url2 = url2.replace(new RegExp("\\[" + i2 + "\\]", "ig"), matched);
          });
        }
        if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
          url2 = loaderContext.options.customInterpolateName.call(
            loaderContext,
            url2,
            name2,
            options2
          );
        }
        return url2;
      }
      var interpolateName_1 = interpolateName$2;
      const getOptions = getOptions_1;
      const parseQuery = parseQuery_1;
      const stringifyRequest = stringifyRequest_1;
      const getRemainingRequest = getRemainingRequest_1;
      const getCurrentRequest = getCurrentRequest_1;
      const isUrlRequest = isUrlRequest_1;
      const urlToRequest = urlToRequest_1;
      const parseString = parseString_1;
      const getHashDigest = getHashDigest_1;
      const interpolateName$1 = interpolateName_1;
      lib$2.getOptions = getOptions;
      lib$2.parseQuery = parseQuery;
      lib$2.stringifyRequest = stringifyRequest;
      lib$2.getRemainingRequest = getRemainingRequest;
      lib$2.getCurrentRequest = getCurrentRequest;
      lib$2.isUrlRequest = isUrlRequest;
      lib$2.urlToRequest = urlToRequest;
      lib$2.parseString = parseString;
      lib$2.getHashDigest = getHashDigest;
      lib$2.interpolateName = interpolateName$1;
      var interpolateName = lib$2.interpolateName;
      var path$1 = require$$3;
      var _genericNames_2_0_1_genericNames = function createGenerator(pattern, options2) {
        options2 = options2 || {};
        var context = options2 && typeof options2.context === "string" ? options2.context : browser$1$1.cwd();
        var hashPrefix = options2 && typeof options2.hashPrefix === "string" ? options2.hashPrefix : "";
        return function generate2(localName, filepath) {
          var name2 = pattern.replace(/\[local\]/gi, localName);
          var loaderContext = {
            resourcePath: filepath
          };
          var loaderOptions = {
            content: hashPrefix + path$1.relative(context, filepath).replace(/\\/g, "/") + "+" + localName,
            context
          };
          var genericName = interpolateName(loaderContext, name2, loaderOptions);
          return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_ -￿]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
        };
      };
      var parser$2 = {};
      var lib$1 = {};
      Object.defineProperty(lib$1, "__esModule", {
        value: true
      });
      lib$1.replaceAll = replaceAll;
      var matchConstName = /[$#]?[\w-\.]+/g;
      function replaceAll(replacements, text) {
        var matches = void 0;
        while (matches = matchConstName.exec(text)) {
          var replacement = replacements[matches[0]];
          if (replacement) {
            text = text.slice(0, matches.index) + replacement + text.slice(matchConstName.lastIndex);
            matchConstName.lastIndex -= matches[0].length - replacement.length;
          }
        }
        return text;
      }
      lib$1.default = function(css, translations) {
        css.walkDecls(function(decl) {
          return decl.value = replaceAll(translations, decl.value);
        });
        css.walkAtRules("media", function(atRule2) {
          return atRule2.params = replaceAll(translations, atRule2.params);
        });
      };
      Object.defineProperty(parser$2, "__esModule", {
        value: true
      });
      var _icssReplaceSymbols = lib$1;
      var _icssReplaceSymbols2 = _interopRequireDefault$6(_icssReplaceSymbols);
      function _interopRequireDefault$6(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      const importRegexp = /^:import\((.+)\)$/;
      class Parser {
        constructor(pathFetcher, trace) {
          this.pathFetcher = pathFetcher;
          this.plugin = this.plugin.bind(this);
          this.exportTokens = {};
          this.translations = {};
          this.trace = trace;
        }
        plugin() {
          const parser2 = this;
          return {
            postcssPlugin: "css-modules-parser",
            OnceExit(css) {
              return Promise.all(parser2.fetchAllImports(css)).then(() => parser2.linkImportedSymbols(css)).then(() => parser2.extractExports(css));
            }
          };
        }
        fetchAllImports(css) {
          let imports = [];
          css.each((node2) => {
            if (node2.type == "rule" && node2.selector.match(importRegexp)) {
              imports.push(this.fetchImport(node2, css.source.input.from, imports.length));
            }
          });
          return imports;
        }
        linkImportedSymbols(css) {
          (0, _icssReplaceSymbols2.default)(css, this.translations);
        }
        extractExports(css) {
          css.each((node2) => {
            if (node2.type == "rule" && node2.selector == ":export")
              this.handleExport(node2);
          });
        }
        handleExport(exportNode) {
          exportNode.each((decl) => {
            if (decl.type == "decl") {
              Object.keys(this.translations).forEach((translation) => {
                decl.value = decl.value.replace(translation, this.translations[translation]);
              });
              this.exportTokens[decl.prop] = decl.value;
            }
          });
          exportNode.remove();
        }
        fetchImport(importNode, relativeTo, depNr) {
          let file = importNode.selector.match(importRegexp)[1], depTrace = this.trace + String.fromCharCode(depNr);
          return this.pathFetcher(file, relativeTo, depTrace).then((exports2) => {
            importNode.each((decl) => {
              if (decl.type == "decl") {
                this.translations[decl.prop] = exports2[decl.value];
              }
            });
            importNode.remove();
          }, (err) => console.log(err));
        }
      }
      parser$2.default = Parser;
      var loader = {};
      var _polyfillNode_fs = {};
      var _polyfillNode_fs$1 = Object.freeze({
        __proto__: null,
        "default": _polyfillNode_fs
      });
      var require$$0 = getAugmentedNamespace(_polyfillNode_fs$1);
      Object.defineProperty(loader, "__esModule", {
        value: true
      });
      var _postcss$1 = postcss_1;
      var _postcss2$1 = _interopRequireDefault$5(_postcss$1);
      var _fs$1 = require$$0;
      var _fs2 = _interopRequireDefault$5(_fs$1);
      var _path = require$$3;
      var _path2 = _interopRequireDefault$5(_path);
      var _parser$1 = parser$2;
      var _parser2$1 = _interopRequireDefault$5(_parser$1);
      function _interopRequireDefault$5(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      class Core {
        constructor(plugins) {
          this.plugins = plugins || Core.defaultPlugins;
        }
        load(sourceString, sourcePath, trace, pathFetcher) {
          let parser2 = new _parser2$1.default(pathFetcher, trace);
          return (0, _postcss2$1.default)(this.plugins.concat([parser2.plugin()])).process(sourceString, { from: "/" + sourcePath }).then((result2) => {
            return {
              injectableSource: result2.css,
              exportTokens: parser2.exportTokens
            };
          });
        }
      }
      const traceKeySorter = (a, b2) => {
        if (a.length < b2.length) {
          return a < b2.substring(0, a.length) ? -1 : 1;
        } else if (a.length > b2.length) {
          return a.substring(0, b2.length) <= b2 ? -1 : 1;
        } else {
          return a < b2 ? -1 : 1;
        }
      };
      class FileSystemLoader {
        constructor(root2, plugins) {
          this.root = root2;
          this.sources = {};
          this.traces = {};
          this.importNr = 0;
          this.core = new Core(plugins);
          this.tokensByFile = {};
        }
        fetch(_newPath, relativeTo, _trace) {
          let newPath = _newPath.replace(/^["']|["']$/g, ""), trace = _trace || String.fromCharCode(this.importNr++);
          return new Promise((resolve2, reject) => {
            let relativeDir = _path2.default.dirname(relativeTo), rootRelativePath = _path2.default.resolve(relativeDir, newPath), fileRelativePath = _path2.default.resolve(_path2.default.join(this.root, relativeDir), newPath);
            if (newPath[0] !== "." && newPath[0] !== "/") {
              try {
                fileRelativePath = __require.resolve(newPath);
              } catch (e) {
              }
            }
            const tokens = this.tokensByFile[fileRelativePath];
            if (tokens) {
              return resolve2(tokens);
            }
            _fs2.default.readFile(fileRelativePath, "utf-8", (err, source) => {
              if (err)
                reject(err);
              this.core.load(source, rootRelativePath, trace, this.fetch.bind(this)).then(({ injectableSource, exportTokens }) => {
                this.sources[fileRelativePath] = injectableSource;
                this.traces[trace] = fileRelativePath;
                this.tokensByFile[fileRelativePath] = exportTokens;
                resolve2(exportTokens);
              }, reject);
            });
          });
        }
        get finalSource() {
          const traces = this.traces;
          const sources = this.sources;
          let written = /* @__PURE__ */ new Set();
          return Object.keys(traces).sort(traceKeySorter).map((key) => {
            const filename = traces[key];
            if (written.has(filename)) {
              return null;
            }
            written.add(filename);
            return sources[filename];
          }).join("");
        }
      }
      loader.default = FileSystemLoader;
      var generateScopedName$1 = {};
      function hash$1(str2) {
        var hash2 = 5381, i2 = str2.length;
        while (i2) {
          hash2 = hash2 * 33 ^ str2.charCodeAt(--i2);
        }
        return hash2 >>> 0;
      }
      var _stringHash_1_1_3_stringHash = hash$1;
      Object.defineProperty(generateScopedName$1, "__esModule", {
        value: true
      });
      generateScopedName$1.default = generateScopedName;
      var _stringHash = _stringHash_1_1_3_stringHash;
      var _stringHash2 = _interopRequireDefault$4(_stringHash);
      function _interopRequireDefault$4(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function generateScopedName(name2, filename, css) {
        const i2 = css.indexOf(`.${name2}`);
        const lineNumber = css.substr(0, i2).split(/[\r\n]/).length;
        const hash2 = (0, _stringHash2.default)(css).toString(36).substr(0, 5);
        return `_${name2}_${hash2}_${lineNumber}`;
      }
      var saveJSON$1 = {};
      Object.defineProperty(saveJSON$1, "__esModule", {
        value: true
      });
      saveJSON$1.default = saveJSON;
      var _fs = require$$0;
      function saveJSON(cssFile, json) {
        return new Promise((resolve2, reject) => {
          (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json), (e) => e ? reject(e) : resolve2(json));
        });
      }
      var behaviours$1 = {};
      var src$4 = { exports: {} };
      var dist = { exports: {} };
      var processor = { exports: {} };
      var parser$1 = { exports: {} };
      var root$1 = { exports: {} };
      var container = { exports: {} };
      var node = { exports: {} };
      var util = {};
      var unesc = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = unesc2;
        function gobbleHex(str2) {
          var lower = str2.toLowerCase();
          var hex2 = "";
          var spaceTerminated = false;
          for (var i2 = 0; i2 < 6 && lower[i2] !== void 0; i2++) {
            var code2 = lower.charCodeAt(i2);
            var valid = code2 >= 97 && code2 <= 102 || code2 >= 48 && code2 <= 57;
            spaceTerminated = code2 === 32;
            if (!valid) {
              break;
            }
            hex2 += lower[i2];
          }
          if (hex2.length === 0) {
            return void 0;
          }
          var codePoint = parseInt(hex2, 16);
          var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
          if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
            return ["�", hex2.length + (spaceTerminated ? 1 : 0)];
          }
          return [String.fromCodePoint(codePoint), hex2.length + (spaceTerminated ? 1 : 0)];
        }
        var CONTAINS_ESCAPE = /\\/;
        function unesc2(str2) {
          var needToProcess = CONTAINS_ESCAPE.test(str2);
          if (!needToProcess) {
            return str2;
          }
          var ret = "";
          for (var i2 = 0; i2 < str2.length; i2++) {
            if (str2[i2] === "\\") {
              var gobbled = gobbleHex(str2.slice(i2 + 1, i2 + 7));
              if (gobbled !== void 0) {
                ret += gobbled[0];
                i2 += gobbled[1];
                continue;
              }
              if (str2[i2 + 1] === "\\") {
                ret += "\\";
                i2++;
                continue;
              }
              if (str2.length === i2 + 1) {
                ret += str2[i2];
              }
              continue;
            }
            ret += str2[i2];
          }
          return ret;
        }
        module2.exports = exports2.default;
      })(unesc, unesc.exports);
      var getProp = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = getProp2;
        function getProp2(obj) {
          for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            props[_key - 1] = arguments[_key];
          }
          while (props.length > 0) {
            var prop = props.shift();
            if (!obj[prop]) {
              return void 0;
            }
            obj = obj[prop];
          }
          return obj;
        }
        module2.exports = exports2.default;
      })(getProp, getProp.exports);
      var ensureObject = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = ensureObject2;
        function ensureObject2(obj) {
          for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            props[_key - 1] = arguments[_key];
          }
          while (props.length > 0) {
            var prop = props.shift();
            if (!obj[prop]) {
              obj[prop] = {};
            }
            obj = obj[prop];
          }
        }
        module2.exports = exports2.default;
      })(ensureObject, ensureObject.exports);
      var stripComments = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = stripComments2;
        function stripComments2(str2) {
          var s = "";
          var commentStart2 = str2.indexOf("/*");
          var lastEnd = 0;
          while (commentStart2 >= 0) {
            s = s + str2.slice(lastEnd, commentStart2);
            var commentEnd2 = str2.indexOf("*/", commentStart2 + 2);
            if (commentEnd2 < 0) {
              return s;
            }
            lastEnd = commentEnd2 + 2;
            commentStart2 = str2.indexOf("/*", lastEnd);
          }
          s = s + str2.slice(lastEnd);
          return s;
        }
        module2.exports = exports2.default;
      })(stripComments, stripComments.exports);
      util.__esModule = true;
      util.stripComments = util.ensureObject = util.getProp = util.unesc = void 0;
      var _unesc = _interopRequireDefault$3(unesc.exports);
      util.unesc = _unesc["default"];
      var _getProp = _interopRequireDefault$3(getProp.exports);
      util.getProp = _getProp["default"];
      var _ensureObject = _interopRequireDefault$3(ensureObject.exports);
      util.ensureObject = _ensureObject["default"];
      var _stripComments = _interopRequireDefault$3(stripComments.exports);
      util.stripComments = _stripComments["default"];
      function _interopRequireDefault$3(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _util = util;
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var cloneNode2 = function cloneNode3(obj, parent) {
          if (typeof obj !== "object" || obj === null) {
            return obj;
          }
          var cloned = new obj.constructor();
          for (var i2 in obj) {
            if (!obj.hasOwnProperty(i2)) {
              continue;
            }
            var value = obj[i2];
            var type2 = typeof value;
            if (i2 === "parent" && type2 === "object") {
              if (parent) {
                cloned[i2] = parent;
              }
            } else if (value instanceof Array) {
              cloned[i2] = value.map(function(j) {
                return cloneNode3(j, cloned);
              });
            } else {
              cloned[i2] = cloneNode3(value, cloned);
            }
          }
          return cloned;
        };
        var Node2 = function() {
          function Node3(opts) {
            if (opts === void 0) {
              opts = {};
            }
            Object.assign(this, opts);
            this.spaces = this.spaces || {};
            this.spaces.before = this.spaces.before || "";
            this.spaces.after = this.spaces.after || "";
          }
          var _proto = Node3.prototype;
          _proto.remove = function remove2() {
            if (this.parent) {
              this.parent.removeChild(this);
            }
            this.parent = void 0;
            return this;
          };
          _proto.replaceWith = function replaceWith() {
            if (this.parent) {
              for (var index in arguments) {
                this.parent.insertBefore(this, arguments[index]);
              }
              this.remove();
            }
            return this;
          };
          _proto.next = function next() {
            return this.parent.at(this.parent.index(this) + 1);
          };
          _proto.prev = function prev() {
            return this.parent.at(this.parent.index(this) - 1);
          };
          _proto.clone = function clone2(overrides) {
            if (overrides === void 0) {
              overrides = {};
            }
            var cloned = cloneNode2(this);
            for (var name2 in overrides) {
              cloned[name2] = overrides[name2];
            }
            return cloned;
          };
          _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name2, value, valueEscaped) {
            if (!this.raws) {
              this.raws = {};
            }
            var originalValue = this[name2];
            var originalEscaped = this.raws[name2];
            this[name2] = originalValue + value;
            if (originalEscaped || valueEscaped !== value) {
              this.raws[name2] = (originalEscaped || originalValue) + valueEscaped;
            } else {
              delete this.raws[name2];
            }
          };
          _proto.setPropertyAndEscape = function setPropertyAndEscape(name2, value, valueEscaped) {
            if (!this.raws) {
              this.raws = {};
            }
            this[name2] = value;
            this.raws[name2] = valueEscaped;
          };
          _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name2, value) {
            this[name2] = value;
            if (this.raws) {
              delete this.raws[name2];
            }
          };
          _proto.isAtPosition = function isAtPosition(line, column) {
            if (this.source && this.source.start && this.source.end) {
              if (this.source.start.line > line) {
                return false;
              }
              if (this.source.end.line < line) {
                return false;
              }
              if (this.source.start.line === line && this.source.start.column > column) {
                return false;
              }
              if (this.source.end.line === line && this.source.end.column < column) {
                return false;
              }
              return true;
            }
            return void 0;
          };
          _proto.stringifyProperty = function stringifyProperty(name2) {
            return this.raws && this.raws[name2] || this[name2];
          };
          _proto.valueToString = function valueToString() {
            return String(this.stringifyProperty("value"));
          };
          _proto.toString = function toString2() {
            return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
          };
          _createClass2(Node3, [{
            key: "rawSpaceBefore",
            get: function get2() {
              var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
              if (rawSpace === void 0) {
                rawSpace = this.spaces && this.spaces.before;
              }
              return rawSpace || "";
            },
            set: function set(raw) {
              (0, _util.ensureObject)(this, "raws", "spaces");
              this.raws.spaces.before = raw;
            }
          }, {
            key: "rawSpaceAfter",
            get: function get2() {
              var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
              if (rawSpace === void 0) {
                rawSpace = this.spaces.after;
              }
              return rawSpace || "";
            },
            set: function set(raw) {
              (0, _util.ensureObject)(this, "raws", "spaces");
              this.raws.spaces.after = raw;
            }
          }]);
          return Node3;
        }();
        exports2["default"] = Node2;
        module2.exports = exports2.default;
      })(node, node.exports);
      var types$1 = {};
      types$1.__esModule = true;
      types$1.UNIVERSAL = types$1.ATTRIBUTE = types$1.CLASS = types$1.COMBINATOR = types$1.COMMENT = types$1.ID = types$1.NESTING = types$1.PSEUDO = types$1.ROOT = types$1.SELECTOR = types$1.STRING = types$1.TAG = void 0;
      var TAG = "tag";
      types$1.TAG = TAG;
      var STRING = "string";
      types$1.STRING = STRING;
      var SELECTOR = "selector";
      types$1.SELECTOR = SELECTOR;
      var ROOT = "root";
      types$1.ROOT = ROOT;
      var PSEUDO = "pseudo";
      types$1.PSEUDO = PSEUDO;
      var NESTING = "nesting";
      types$1.NESTING = NESTING;
      var ID = "id";
      types$1.ID = ID;
      var COMMENT = "comment";
      types$1.COMMENT = COMMENT;
      var COMBINATOR = "combinator";
      types$1.COMBINATOR = COMBINATOR;
      var CLASS = "class";
      types$1.CLASS = CLASS;
      var ATTRIBUTE = "attribute";
      types$1.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = "universal";
      types$1.UNIVERSAL = UNIVERSAL;
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var types2 = _interopRequireWildcard2(types$1);
        function _getRequireWildcardCache() {
          if (typeof WeakMap !== "function")
            return null;
          var cache = /* @__PURE__ */ new WeakMap();
          _getRequireWildcardCache = function _getRequireWildcardCache2() {
            return cache;
          };
          return cache;
        }
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return { "default": obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj["default"] = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it;
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i2 = 0;
              return function() {
                if (i2 >= o.length)
                  return { done: true };
                return { done: false, value: o[i2++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          it = o[Symbol.iterator]();
          return it.next.bind(it);
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n2 = Object.prototype.toString.call(o).slice(8, -1);
          if (n2 === "Object" && o.constructor)
            n2 = o.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
            arr2[i2] = arr[i2];
          }
          return arr2;
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Container2 = function(_Node) {
          _inheritsLoose2(Container3, _Node);
          function Container3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            if (!_this.nodes) {
              _this.nodes = [];
            }
            return _this;
          }
          var _proto = Container3.prototype;
          _proto.append = function append(selector2) {
            selector2.parent = this;
            this.nodes.push(selector2);
            return this;
          };
          _proto.prepend = function prepend(selector2) {
            selector2.parent = this;
            this.nodes.unshift(selector2);
            return this;
          };
          _proto.at = function at2(index) {
            return this.nodes[index];
          };
          _proto.index = function index(child) {
            if (typeof child === "number") {
              return child;
            }
            return this.nodes.indexOf(child);
          };
          _proto.removeChild = function removeChild(child) {
            child = this.index(child);
            this.at(child).parent = void 0;
            this.nodes.splice(child, 1);
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (index >= child) {
                this.indexes[id2] = index - 1;
              }
            }
            return this;
          };
          _proto.removeAll = function removeAll() {
            for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
              var node2 = _step.value;
              node2.parent = void 0;
            }
            this.nodes = [];
            return this;
          };
          _proto.empty = function empty() {
            return this.removeAll();
          };
          _proto.insertAfter = function insertAfter(oldNode, newNode) {
            newNode.parent = this;
            var oldIndex = this.index(oldNode);
            this.nodes.splice(oldIndex + 1, 0, newNode);
            newNode.parent = this;
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (oldIndex <= index) {
                this.indexes[id2] = index + 1;
              }
            }
            return this;
          };
          _proto.insertBefore = function insertBefore(oldNode, newNode) {
            newNode.parent = this;
            var oldIndex = this.index(oldNode);
            this.nodes.splice(oldIndex, 0, newNode);
            newNode.parent = this;
            var index;
            for (var id2 in this.indexes) {
              index = this.indexes[id2];
              if (index <= oldIndex) {
                this.indexes[id2] = index + 1;
              }
            }
            return this;
          };
          _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
            var found = void 0;
            this.each(function(node2) {
              if (node2.atPosition) {
                var foundChild = node2.atPosition(line, col);
                if (foundChild) {
                  found = foundChild;
                  return false;
                }
              } else if (node2.isAtPosition(line, col)) {
                found = node2;
                return false;
              }
            });
            return found;
          };
          _proto.atPosition = function atPosition(line, col) {
            if (this.isAtPosition(line, col)) {
              return this._findChildAtPosition(line, col) || this;
            } else {
              return void 0;
            }
          };
          _proto._inferEndPosition = function _inferEndPosition() {
            if (this.last && this.last.source && this.last.source.end) {
              this.source = this.source || {};
              this.source.end = this.source.end || {};
              Object.assign(this.source.end, this.last.source.end);
            }
          };
          _proto.each = function each(callback) {
            if (!this.lastEach) {
              this.lastEach = 0;
            }
            if (!this.indexes) {
              this.indexes = {};
            }
            this.lastEach++;
            var id2 = this.lastEach;
            this.indexes[id2] = 0;
            if (!this.length) {
              return void 0;
            }
            var index, result2;
            while (this.indexes[id2] < this.length) {
              index = this.indexes[id2];
              result2 = callback(this.at(index), index);
              if (result2 === false) {
                break;
              }
              this.indexes[id2] += 1;
            }
            delete this.indexes[id2];
            if (result2 === false) {
              return false;
            }
          };
          _proto.walk = function walk2(callback) {
            return this.each(function(node2, i2) {
              var result2 = callback(node2, i2);
              if (result2 !== false && node2.length) {
                result2 = node2.walk(callback);
              }
              if (result2 === false) {
                return false;
              }
            });
          };
          _proto.walkAttributes = function walkAttributes(callback) {
            var _this2 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.ATTRIBUTE) {
                return callback.call(_this2, selector2);
              }
            });
          };
          _proto.walkClasses = function walkClasses(callback) {
            var _this3 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.CLASS) {
                return callback.call(_this3, selector2);
              }
            });
          };
          _proto.walkCombinators = function walkCombinators(callback) {
            var _this4 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.COMBINATOR) {
                return callback.call(_this4, selector2);
              }
            });
          };
          _proto.walkComments = function walkComments(callback) {
            var _this5 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.COMMENT) {
                return callback.call(_this5, selector2);
              }
            });
          };
          _proto.walkIds = function walkIds(callback) {
            var _this6 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.ID) {
                return callback.call(_this6, selector2);
              }
            });
          };
          _proto.walkNesting = function walkNesting(callback) {
            var _this7 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.NESTING) {
                return callback.call(_this7, selector2);
              }
            });
          };
          _proto.walkPseudos = function walkPseudos(callback) {
            var _this8 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.PSEUDO) {
                return callback.call(_this8, selector2);
              }
            });
          };
          _proto.walkTags = function walkTags(callback) {
            var _this9 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.TAG) {
                return callback.call(_this9, selector2);
              }
            });
          };
          _proto.walkUniversals = function walkUniversals(callback) {
            var _this10 = this;
            return this.walk(function(selector2) {
              if (selector2.type === types2.UNIVERSAL) {
                return callback.call(_this10, selector2);
              }
            });
          };
          _proto.split = function split(callback) {
            var _this11 = this;
            var current = [];
            return this.reduce(function(memo, node2, index) {
              var split2 = callback.call(_this11, node2);
              current.push(node2);
              if (split2) {
                memo.push(current);
                current = [];
              } else if (index === _this11.length - 1) {
                memo.push(current);
              }
              return memo;
            }, []);
          };
          _proto.map = function map2(callback) {
            return this.nodes.map(callback);
          };
          _proto.reduce = function reduce(callback, memo) {
            return this.nodes.reduce(callback, memo);
          };
          _proto.every = function every(callback) {
            return this.nodes.every(callback);
          };
          _proto.some = function some(callback) {
            return this.nodes.some(callback);
          };
          _proto.filter = function filter2(callback) {
            return this.nodes.filter(callback);
          };
          _proto.sort = function sort(callback) {
            return this.nodes.sort(callback);
          };
          _proto.toString = function toString2() {
            return this.map(String).join("");
          };
          _createClass2(Container3, [{
            key: "first",
            get: function get2() {
              return this.at(0);
            }
          }, {
            key: "last",
            get: function get2() {
              return this.at(this.length - 1);
            }
          }, {
            key: "length",
            get: function get2() {
              return this.nodes.length;
            }
          }]);
          return Container3;
        }(_node["default"]);
        exports2["default"] = Container2;
        module2.exports = exports2.default;
      })(container, container.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _container = _interopRequireDefault2(container.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Root2 = function(_Container) {
          _inheritsLoose2(Root3, _Container);
          function Root3(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.ROOT;
            return _this;
          }
          var _proto = Root3.prototype;
          _proto.toString = function toString2() {
            var str2 = this.reduce(function(memo, selector2) {
              memo.push(String(selector2));
              return memo;
            }, []).join(",");
            return this.trailingComma ? str2 + "," : str2;
          };
          _proto.error = function error2(message, options2) {
            if (this._error) {
              return this._error(message, options2);
            } else {
              return new Error(message);
            }
          };
          _createClass2(Root3, [{
            key: "errorGenerator",
            set: function set(handler) {
              this._error = handler;
            }
          }]);
          return Root3;
        }(_container["default"]);
        exports2["default"] = Root2;
        module2.exports = exports2.default;
      })(root$1, root$1.exports);
      var selector$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _container = _interopRequireDefault2(container.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Selector = function(_Container) {
          _inheritsLoose2(Selector2, _Container);
          function Selector2(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.SELECTOR;
            return _this;
          }
          return Selector2;
        }(_container["default"]);
        exports2["default"] = Selector;
        module2.exports = exports2.default;
      })(selector$1, selector$1.exports);
      var className$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _cssesc2 = _interopRequireDefault2(cssesc_1);
        var _util = util;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var ClassName = function(_Node) {
          _inheritsLoose2(ClassName2, _Node);
          function ClassName2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.CLASS;
            _this._constructed = true;
            return _this;
          }
          var _proto = ClassName2.prototype;
          _proto.valueToString = function valueToString() {
            return "." + _Node.prototype.valueToString.call(this);
          };
          _createClass2(ClassName2, [{
            key: "value",
            get: function get2() {
              return this._value;
            },
            set: function set(v2) {
              if (this._constructed) {
                var escaped = (0, _cssesc2["default"])(v2, {
                  isIdentifier: true
                });
                if (escaped !== v2) {
                  (0, _util.ensureObject)(this, "raws");
                  this.raws.value = escaped;
                } else if (this.raws) {
                  delete this.raws.value;
                }
              }
              this._value = v2;
            }
          }]);
          return ClassName2;
        }(_node["default"]);
        exports2["default"] = ClassName;
        module2.exports = exports2.default;
      })(className$1, className$1.exports);
      var comment$2 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Comment2 = function(_Node) {
          _inheritsLoose2(Comment3, _Node);
          function Comment3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.COMMENT;
            return _this;
          }
          return Comment3;
        }(_node["default"]);
        exports2["default"] = Comment2;
        module2.exports = exports2.default;
      })(comment$2, comment$2.exports);
      var id$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var ID2 = function(_Node) {
          _inheritsLoose2(ID3, _Node);
          function ID3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.ID;
            return _this;
          }
          var _proto = ID3.prototype;
          _proto.valueToString = function valueToString() {
            return "#" + _Node.prototype.valueToString.call(this);
          };
          return ID3;
        }(_node["default"]);
        exports2["default"] = ID2;
        module2.exports = exports2.default;
      })(id$1, id$1.exports);
      var tag$1 = { exports: {} };
      var namespace = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _cssesc2 = _interopRequireDefault2(cssesc_1);
        var _util = util;
        var _node = _interopRequireDefault2(node.exports);
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Namespace = function(_Node) {
          _inheritsLoose2(Namespace2, _Node);
          function Namespace2() {
            return _Node.apply(this, arguments) || this;
          }
          var _proto = Namespace2.prototype;
          _proto.qualifiedName = function qualifiedName(value) {
            if (this.namespace) {
              return this.namespaceString + "|" + value;
            } else {
              return value;
            }
          };
          _proto.valueToString = function valueToString() {
            return this.qualifiedName(_Node.prototype.valueToString.call(this));
          };
          _createClass2(Namespace2, [{
            key: "namespace",
            get: function get2() {
              return this._namespace;
            },
            set: function set(namespace2) {
              if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
                this._namespace = namespace2;
                if (this.raws) {
                  delete this.raws.namespace;
                }
                return;
              }
              var escaped = (0, _cssesc2["default"])(namespace2, {
                isIdentifier: true
              });
              this._namespace = namespace2;
              if (escaped !== namespace2) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.namespace = escaped;
              } else if (this.raws) {
                delete this.raws.namespace;
              }
            }
          }, {
            key: "ns",
            get: function get2() {
              return this._namespace;
            },
            set: function set(namespace2) {
              this.namespace = namespace2;
            }
          }, {
            key: "namespaceString",
            get: function get2() {
              if (this.namespace) {
                var ns = this.stringifyProperty("namespace");
                if (ns === true) {
                  return "";
                } else {
                  return ns;
                }
              } else {
                return "";
              }
            }
          }]);
          return Namespace2;
        }(_node["default"]);
        exports2["default"] = Namespace;
        module2.exports = exports2.default;
      })(namespace, namespace.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _namespace2 = _interopRequireDefault2(namespace.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Tag = function(_Namespace) {
          _inheritsLoose2(Tag2, _Namespace);
          function Tag2(opts) {
            var _this;
            _this = _Namespace.call(this, opts) || this;
            _this.type = _types2.TAG;
            return _this;
          }
          return Tag2;
        }(_namespace2["default"]);
        exports2["default"] = Tag;
        module2.exports = exports2.default;
      })(tag$1, tag$1.exports);
      var string$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var String2 = function(_Node) {
          _inheritsLoose2(String3, _Node);
          function String3(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.STRING;
            return _this;
          }
          return String3;
        }(_node["default"]);
        exports2["default"] = String2;
        module2.exports = exports2.default;
      })(string$1, string$1.exports);
      var pseudo$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _container = _interopRequireDefault2(container.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Pseudo = function(_Container) {
          _inheritsLoose2(Pseudo2, _Container);
          function Pseudo2(opts) {
            var _this;
            _this = _Container.call(this, opts) || this;
            _this.type = _types2.PSEUDO;
            return _this;
          }
          var _proto = Pseudo2.prototype;
          _proto.toString = function toString2() {
            var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
          };
          return Pseudo2;
        }(_container["default"]);
        exports2["default"] = Pseudo;
        module2.exports = exports2.default;
      })(pseudo$1, pseudo$1.exports);
      var attribute$1 = {};
      (function(exports2) {
        exports2.__esModule = true;
        exports2.unescapeValue = unescapeValue2;
        exports2["default"] = void 0;
        var _cssesc2 = _interopRequireDefault2(cssesc_1);
        var _unesc2 = _interopRequireDefault2(unesc.exports);
        var _namespace2 = _interopRequireDefault2(namespace.exports);
        var _types2 = types$1;
        var _CSSESC_QUOTE_OPTIONS2;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var deprecate2 = browser$1;
        var WRAPPED_IN_QUOTES2 = /^('|")([^]*)\1$/;
        var warnOfDeprecatedValueAssignment2 = deprecate2(function() {
        }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
        var warnOfDeprecatedQuotedAssignment2 = deprecate2(function() {
        }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
        var warnOfDeprecatedConstructor2 = deprecate2(function() {
        }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
        function unescapeValue2(value) {
          var deprecatedUsage = false;
          var quoteMark = null;
          var unescaped = value;
          var m = unescaped.match(WRAPPED_IN_QUOTES2);
          if (m) {
            quoteMark = m[1];
            unescaped = m[2];
          }
          unescaped = (0, _unesc2["default"])(unescaped);
          if (unescaped !== value) {
            deprecatedUsage = true;
          }
          return {
            deprecatedUsage,
            unescaped,
            quoteMark
          };
        }
        function handleDeprecatedContructorOpts2(opts) {
          if (opts.quoteMark !== void 0) {
            return opts;
          }
          if (opts.value === void 0) {
            return opts;
          }
          warnOfDeprecatedConstructor2();
          var _unescapeValue = unescapeValue2(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
          if (!opts.raws) {
            opts.raws = {};
          }
          if (opts.raws.value === void 0) {
            opts.raws.value = opts.value;
          }
          opts.value = unescaped;
          opts.quoteMark = quoteMark;
          return opts;
        }
        var Attribute2 = function(_Namespace) {
          _inheritsLoose2(Attribute3, _Namespace);
          function Attribute3(opts) {
            var _this;
            if (opts === void 0) {
              opts = {};
            }
            _this = _Namespace.call(this, handleDeprecatedContructorOpts2(opts)) || this;
            _this.type = _types2.ATTRIBUTE;
            _this.raws = _this.raws || {};
            Object.defineProperty(_this.raws, "unquoted", {
              get: deprecate2(function() {
                return _this.value;
              }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
              set: deprecate2(function() {
                return _this.value;
              }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
            });
            _this._constructed = true;
            return _this;
          }
          var _proto = Attribute3.prototype;
          _proto.getQuotedValue = function getQuotedValue(options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var quoteMark = this._determineQuoteMark(options2);
            var cssescopts = CSSESC_QUOTE_OPTIONS2[quoteMark];
            var escaped = (0, _cssesc2["default"])(this._value, cssescopts);
            return escaped;
          };
          _proto._determineQuoteMark = function _determineQuoteMark(options2) {
            return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
          };
          _proto.setValue = function setValue(value, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            this._value = value;
            this._quoteMark = this._determineQuoteMark(options2);
            this._syncRawValue();
          };
          _proto.smartQuoteMark = function smartQuoteMark(options2) {
            var v2 = this.value;
            var numSingleQuotes = v2.replace(/[^']/g, "").length;
            var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
            if (numSingleQuotes + numDoubleQuotes === 0) {
              var escaped = (0, _cssesc2["default"])(v2, {
                isIdentifier: true
              });
              if (escaped === v2) {
                return Attribute3.NO_QUOTE;
              } else {
                var pref = this.preferredQuoteMark(options2);
                if (pref === Attribute3.NO_QUOTE) {
                  var quote = this.quoteMark || options2.quoteMark || Attribute3.DOUBLE_QUOTE;
                  var opts = CSSESC_QUOTE_OPTIONS2[quote];
                  var quoteValue = (0, _cssesc2["default"])(v2, opts);
                  if (quoteValue.length < escaped.length) {
                    return quote;
                  }
                }
                return pref;
              }
            } else if (numDoubleQuotes === numSingleQuotes) {
              return this.preferredQuoteMark(options2);
            } else if (numDoubleQuotes < numSingleQuotes) {
              return Attribute3.DOUBLE_QUOTE;
            } else {
              return Attribute3.SINGLE_QUOTE;
            }
          };
          _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
            var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
            if (quoteMark === void 0) {
              quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
            }
            if (quoteMark === void 0) {
              quoteMark = Attribute3.DOUBLE_QUOTE;
            }
            return quoteMark;
          };
          _proto._syncRawValue = function _syncRawValue() {
            var rawValue = (0, _cssesc2["default"])(this._value, CSSESC_QUOTE_OPTIONS2[this.quoteMark]);
            if (rawValue === this._value) {
              if (this.raws) {
                delete this.raws.value;
              }
            } else {
              this.raws.value = rawValue;
            }
          };
          _proto._handleEscapes = function _handleEscapes(prop, value) {
            if (this._constructed) {
              var escaped = (0, _cssesc2["default"])(value, {
                isIdentifier: true
              });
              if (escaped !== value) {
                this.raws[prop] = escaped;
              } else {
                delete this.raws[prop];
              }
            }
          };
          _proto._spacesFor = function _spacesFor(name2) {
            var attrSpaces = {
              before: "",
              after: ""
            };
            var spaces = this.spaces[name2] || {};
            var rawSpaces = this.raws.spaces && this.raws.spaces[name2] || {};
            return Object.assign(attrSpaces, spaces, rawSpaces);
          };
          _proto._stringFor = function _stringFor(name2, spaceName, concat2) {
            if (spaceName === void 0) {
              spaceName = name2;
            }
            if (concat2 === void 0) {
              concat2 = defaultAttrConcat2;
            }
            var attrSpaces = this._spacesFor(spaceName);
            return concat2(this.stringifyProperty(name2), attrSpaces);
          };
          _proto.offsetOf = function offsetOf(name2) {
            var count = 1;
            var attributeSpaces = this._spacesFor("attribute");
            count += attributeSpaces.before.length;
            if (name2 === "namespace" || name2 === "ns") {
              return this.namespace ? count : -1;
            }
            if (name2 === "attributeNS") {
              return count;
            }
            count += this.namespaceString.length;
            if (this.namespace) {
              count += 1;
            }
            if (name2 === "attribute") {
              return count;
            }
            count += this.stringifyProperty("attribute").length;
            count += attributeSpaces.after.length;
            var operatorSpaces = this._spacesFor("operator");
            count += operatorSpaces.before.length;
            var operator = this.stringifyProperty("operator");
            if (name2 === "operator") {
              return operator ? count : -1;
            }
            count += operator.length;
            count += operatorSpaces.after.length;
            var valueSpaces = this._spacesFor("value");
            count += valueSpaces.before.length;
            var value = this.stringifyProperty("value");
            if (name2 === "value") {
              return value ? count : -1;
            }
            count += value.length;
            count += valueSpaces.after.length;
            var insensitiveSpaces = this._spacesFor("insensitive");
            count += insensitiveSpaces.before.length;
            if (name2 === "insensitive") {
              return this.insensitive ? count : -1;
            }
            return -1;
          };
          _proto.toString = function toString2() {
            var _this2 = this;
            var selector2 = [this.rawSpaceBefore, "["];
            selector2.push(this._stringFor("qualifiedAttribute", "attribute"));
            if (this.operator && (this.value || this.value === "")) {
              selector2.push(this._stringFor("operator"));
              selector2.push(this._stringFor("value"));
              selector2.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
                if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                  attrSpaces.before = " ";
                }
                return defaultAttrConcat2(attrValue, attrSpaces);
              }));
            }
            selector2.push("]");
            selector2.push(this.rawSpaceAfter);
            return selector2.join("");
          };
          _createClass2(Attribute3, [{
            key: "quoted",
            get: function get2() {
              var qm = this.quoteMark;
              return qm === "'" || qm === '"';
            },
            set: function set(value) {
              warnOfDeprecatedQuotedAssignment2();
            }
            /**
             * returns a single (`'`) or double (`"`) quote character if the value is quoted.
             * returns `null` if the value is not quoted.
             * returns `undefined` if the quotation state is unknown (this can happen when
             * the attribute is constructed without specifying a quote mark.)
             */
          }, {
            key: "quoteMark",
            get: function get2() {
              return this._quoteMark;
            },
            set: function set(quoteMark) {
              if (!this._constructed) {
                this._quoteMark = quoteMark;
                return;
              }
              if (this._quoteMark !== quoteMark) {
                this._quoteMark = quoteMark;
                this._syncRawValue();
              }
            }
          }, {
            key: "qualifiedAttribute",
            get: function get2() {
              return this.qualifiedName(this.raws.attribute || this.attribute);
            }
          }, {
            key: "insensitiveFlag",
            get: function get2() {
              return this.insensitive ? "i" : "";
            }
          }, {
            key: "value",
            get: function get2() {
              return this._value;
            },
            set: function set(v2) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue2(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment2();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v2;
              }
            }
          }, {
            key: "attribute",
            get: function get2() {
              return this._attribute;
            },
            set: function set(name2) {
              this._handleEscapes("attribute", name2);
              this._attribute = name2;
            }
          }]);
          return Attribute3;
        }(_namespace2["default"]);
        exports2["default"] = Attribute2;
        Attribute2.NO_QUOTE = null;
        Attribute2.SINGLE_QUOTE = "'";
        Attribute2.DOUBLE_QUOTE = '"';
        var CSSESC_QUOTE_OPTIONS2 = (_CSSESC_QUOTE_OPTIONS2 = {
          "'": {
            quotes: "single",
            wrap: true
          },
          '"': {
            quotes: "double",
            wrap: true
          }
        }, _CSSESC_QUOTE_OPTIONS2[null] = {
          isIdentifier: true
        }, _CSSESC_QUOTE_OPTIONS2);
        function defaultAttrConcat2(attrValue, attrSpaces) {
          return "" + attrSpaces.before + attrValue + attrSpaces.after;
        }
      })(attribute$1);
      var universal$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _namespace2 = _interopRequireDefault2(namespace.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Universal = function(_Namespace) {
          _inheritsLoose2(Universal2, _Namespace);
          function Universal2(opts) {
            var _this;
            _this = _Namespace.call(this, opts) || this;
            _this.type = _types2.UNIVERSAL;
            _this.value = "*";
            return _this;
          }
          return Universal2;
        }(_namespace2["default"]);
        exports2["default"] = Universal;
        module2.exports = exports2.default;
      })(universal$1, universal$1.exports);
      var combinator$2 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Combinator = function(_Node) {
          _inheritsLoose2(Combinator2, _Node);
          function Combinator2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.COMBINATOR;
            return _this;
          }
          return Combinator2;
        }(_node["default"]);
        exports2["default"] = Combinator;
        module2.exports = exports2.default;
      })(combinator$2, combinator$2.exports);
      var nesting$1 = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _node = _interopRequireDefault2(node.exports);
        var _types2 = types$1;
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        var Nesting = function(_Node) {
          _inheritsLoose2(Nesting2, _Node);
          function Nesting2(opts) {
            var _this;
            _this = _Node.call(this, opts) || this;
            _this.type = _types2.NESTING;
            _this.value = "&";
            return _this;
          }
          return Nesting2;
        }(_node["default"]);
        exports2["default"] = Nesting;
        module2.exports = exports2.default;
      })(nesting$1, nesting$1.exports);
      var sortAscending = { exports: {} };
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = sortAscending2;
        function sortAscending2(list2) {
          return list2.sort(function(a, b2) {
            return a - b2;
          });
        }
        module2.exports = exports2.default;
      })(sortAscending, sortAscending.exports);
      var tokenize = {};
      var tokenTypes = {};
      tokenTypes.__esModule = true;
      tokenTypes.combinator = tokenTypes.word = tokenTypes.comment = tokenTypes.str = tokenTypes.tab = tokenTypes.newline = tokenTypes.feed = tokenTypes.cr = tokenTypes.backslash = tokenTypes.bang = tokenTypes.slash = tokenTypes.doubleQuote = tokenTypes.singleQuote = tokenTypes.space = tokenTypes.greaterThan = tokenTypes.pipe = tokenTypes.equals = tokenTypes.plus = tokenTypes.caret = tokenTypes.tilde = tokenTypes.dollar = tokenTypes.closeSquare = tokenTypes.openSquare = tokenTypes.closeParenthesis = tokenTypes.openParenthesis = tokenTypes.semicolon = tokenTypes.colon = tokenTypes.comma = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
      var ampersand = 38;
      tokenTypes.ampersand = ampersand;
      var asterisk = 42;
      tokenTypes.asterisk = asterisk;
      var at = 64;
      tokenTypes.at = at;
      var comma$1 = 44;
      tokenTypes.comma = comma$1;
      var colon$1 = 58;
      tokenTypes.colon = colon$1;
      var semicolon = 59;
      tokenTypes.semicolon = semicolon;
      var openParenthesis = 40;
      tokenTypes.openParenthesis = openParenthesis;
      var closeParenthesis = 41;
      tokenTypes.closeParenthesis = closeParenthesis;
      var openSquare = 91;
      tokenTypes.openSquare = openSquare;
      var closeSquare = 93;
      tokenTypes.closeSquare = closeSquare;
      var dollar = 36;
      tokenTypes.dollar = dollar;
      var tilde = 126;
      tokenTypes.tilde = tilde;
      var caret = 94;
      tokenTypes.caret = caret;
      var plus$2 = 43;
      tokenTypes.plus = plus$2;
      var equals = 61;
      tokenTypes.equals = equals;
      var pipe = 124;
      tokenTypes.pipe = pipe;
      var greaterThan = 62;
      tokenTypes.greaterThan = greaterThan;
      var space = 32;
      tokenTypes.space = space;
      var singleQuote$1 = 39;
      tokenTypes.singleQuote = singleQuote$1;
      var doubleQuote$1 = 34;
      tokenTypes.doubleQuote = doubleQuote$1;
      var slash$1 = 47;
      tokenTypes.slash = slash$1;
      var bang = 33;
      tokenTypes.bang = bang;
      var backslash$1 = 92;
      tokenTypes.backslash = backslash$1;
      var cr = 13;
      tokenTypes.cr = cr;
      var feed = 12;
      tokenTypes.feed = feed;
      var newline = 10;
      tokenTypes.newline = newline;
      var tab = 9;
      tokenTypes.tab = tab;
      var str = singleQuote$1;
      tokenTypes.str = str;
      var comment$1 = -1;
      tokenTypes.comment = comment$1;
      var word = -2;
      tokenTypes.word = word;
      var combinator$1 = -3;
      tokenTypes.combinator = combinator$1;
      (function(exports2) {
        exports2.__esModule = true;
        exports2["default"] = tokenize2;
        exports2.FIELDS = void 0;
        var t2 = _interopRequireWildcard2(tokenTypes);
        var _unescapable2, _wordDelimiters2;
        function _getRequireWildcardCache() {
          if (typeof WeakMap !== "function")
            return null;
          var cache = /* @__PURE__ */ new WeakMap();
          _getRequireWildcardCache = function _getRequireWildcardCache2() {
            return cache;
          };
          return cache;
        }
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return { "default": obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj["default"] = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        var unescapable2 = (_unescapable2 = {}, _unescapable2[t2.tab] = true, _unescapable2[t2.newline] = true, _unescapable2[t2.cr] = true, _unescapable2[t2.feed] = true, _unescapable2);
        var wordDelimiters2 = (_wordDelimiters2 = {}, _wordDelimiters2[t2.space] = true, _wordDelimiters2[t2.tab] = true, _wordDelimiters2[t2.newline] = true, _wordDelimiters2[t2.cr] = true, _wordDelimiters2[t2.feed] = true, _wordDelimiters2[t2.ampersand] = true, _wordDelimiters2[t2.asterisk] = true, _wordDelimiters2[t2.bang] = true, _wordDelimiters2[t2.comma] = true, _wordDelimiters2[t2.colon] = true, _wordDelimiters2[t2.semicolon] = true, _wordDelimiters2[t2.openParenthesis] = true, _wordDelimiters2[t2.closeParenthesis] = true, _wordDelimiters2[t2.openSquare] = true, _wordDelimiters2[t2.closeSquare] = true, _wordDelimiters2[t2.singleQuote] = true, _wordDelimiters2[t2.doubleQuote] = true, _wordDelimiters2[t2.plus] = true, _wordDelimiters2[t2.pipe] = true, _wordDelimiters2[t2.tilde] = true, _wordDelimiters2[t2.greaterThan] = true, _wordDelimiters2[t2.equals] = true, _wordDelimiters2[t2.dollar] = true, _wordDelimiters2[t2.caret] = true, _wordDelimiters2[t2.slash] = true, _wordDelimiters2);
        var hex2 = {};
        var hexChars2 = "0123456789abcdefABCDEF";
        for (var i2 = 0; i2 < hexChars2.length; i2++) {
          hex2[hexChars2.charCodeAt(i2)] = true;
        }
        function consumeWord2(css, start) {
          var next = start;
          var code2;
          do {
            code2 = css.charCodeAt(next);
            if (wordDelimiters2[code2]) {
              return next - 1;
            } else if (code2 === t2.backslash) {
              next = consumeEscape2(css, next) + 1;
            } else {
              next++;
            }
          } while (next < css.length);
          return next - 1;
        }
        function consumeEscape2(css, start) {
          var next = start;
          var code2 = css.charCodeAt(next + 1);
          if (unescapable2[code2])
            ;
          else if (hex2[code2]) {
            var hexDigits = 0;
            do {
              next++;
              hexDigits++;
              code2 = css.charCodeAt(next + 1);
            } while (hex2[code2] && hexDigits < 6);
            if (hexDigits < 6 && code2 === t2.space) {
              next++;
            }
          } else {
            next++;
          }
          return next;
        }
        var FIELDS2 = {
          TYPE: 0,
          START_LINE: 1,
          START_COL: 2,
          END_LINE: 3,
          END_COL: 4,
          START_POS: 5,
          END_POS: 6
        };
        exports2.FIELDS = FIELDS2;
        function tokenize2(input2) {
          var tokens = [];
          var css = input2.css.valueOf();
          var _css = css, length = _css.length;
          var offset = -1;
          var line = 1;
          var start = 0;
          var end = 0;
          var code2, content, endColumn, endLine, escaped, escapePos, last2, lines2, next, nextLine, nextOffset, quote, tokenType;
          function unclosed(what, fix) {
            if (input2.safe) {
              css += fix;
              next = css.length - 1;
            } else {
              throw input2.error("Unclosed " + what, line, start - offset, start);
            }
          }
          while (start < length) {
            code2 = css.charCodeAt(start);
            if (code2 === t2.newline) {
              offset = start;
              line += 1;
            }
            switch (code2) {
              case t2.space:
              case t2.tab:
              case t2.newline:
              case t2.cr:
              case t2.feed:
                next = start;
                do {
                  next += 1;
                  code2 = css.charCodeAt(next);
                  if (code2 === t2.newline) {
                    offset = next;
                    line += 1;
                  }
                } while (code2 === t2.space || code2 === t2.newline || code2 === t2.tab || code2 === t2.cr || code2 === t2.feed);
                tokenType = t2.space;
                endLine = line;
                endColumn = next - offset - 1;
                end = next;
                break;
              case t2.plus:
              case t2.greaterThan:
              case t2.tilde:
              case t2.pipe:
                next = start;
                do {
                  next += 1;
                  code2 = css.charCodeAt(next);
                } while (code2 === t2.plus || code2 === t2.greaterThan || code2 === t2.tilde || code2 === t2.pipe);
                tokenType = t2.combinator;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;
              case t2.asterisk:
              case t2.ampersand:
              case t2.bang:
              case t2.comma:
              case t2.equals:
              case t2.dollar:
              case t2.caret:
              case t2.openSquare:
              case t2.closeSquare:
              case t2.colon:
              case t2.semicolon:
              case t2.openParenthesis:
              case t2.closeParenthesis:
                next = start;
                tokenType = code2;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;
              case t2.singleQuote:
              case t2.doubleQuote:
                quote = code2 === t2.singleQuote ? "'" : '"';
                next = start;
                do {
                  escaped = false;
                  next = css.indexOf(quote, next + 1);
                  if (next === -1) {
                    unclosed("quote", quote);
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === t2.backslash) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                tokenType = t2.str;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;
              default:
                if (code2 === t2.slash && css.charCodeAt(start + 1) === t2.asterisk) {
                  next = css.indexOf("*/", start + 2) + 1;
                  if (next === 0) {
                    unclosed("comment", "*/");
                  }
                  content = css.slice(start, next + 1);
                  lines2 = content.split("\n");
                  last2 = lines2.length - 1;
                  if (last2 > 0) {
                    nextLine = line + last2;
                    nextOffset = next - lines2[last2].length;
                  } else {
                    nextLine = line;
                    nextOffset = offset;
                  }
                  tokenType = t2.comment;
                  line = nextLine;
                  endLine = nextLine;
                  endColumn = next - nextOffset;
                } else if (code2 === t2.slash) {
                  next = start;
                  tokenType = code2;
                  endLine = line;
                  endColumn = start - offset;
                  end = next + 1;
                } else {
                  next = consumeWord2(css, start);
                  tokenType = t2.word;
                  endLine = line;
                  endColumn = next - offset;
                }
                end = next + 1;
                break;
            }
            tokens.push([
              tokenType,
              // [0] Token type
              line,
              // [1] Starting line
              start - offset,
              // [2] Starting column
              endLine,
              // [3] Ending line
              endColumn,
              // [4] Ending column
              start,
              // [5] Start position / Source index
              end
              // [6] End position
            ]);
            if (nextOffset) {
              offset = nextOffset;
              nextOffset = null;
            }
            start = end;
          }
          return tokens;
        }
      })(tokenize);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _root2 = _interopRequireDefault2(root$1.exports);
        var _selector2 = _interopRequireDefault2(selector$1.exports);
        var _className2 = _interopRequireDefault2(className$1.exports);
        var _comment2 = _interopRequireDefault2(comment$2.exports);
        var _id2 = _interopRequireDefault2(id$1.exports);
        var _tag2 = _interopRequireDefault2(tag$1.exports);
        var _string2 = _interopRequireDefault2(string$1.exports);
        var _pseudo2 = _interopRequireDefault2(pseudo$1.exports);
        var _attribute2 = _interopRequireWildcard2(attribute$1);
        var _universal2 = _interopRequireDefault2(universal$1.exports);
        var _combinator2 = _interopRequireDefault2(combinator$2.exports);
        var _nesting2 = _interopRequireDefault2(nesting$1.exports);
        var _sortAscending = _interopRequireDefault2(sortAscending.exports);
        var _tokenize = _interopRequireWildcard2(tokenize);
        var tokens = _interopRequireWildcard2(tokenTypes);
        var types2 = _interopRequireWildcard2(types$1);
        var _util = util;
        var _WHITESPACE_TOKENS, _Object$assign;
        function _getRequireWildcardCache() {
          if (typeof WeakMap !== "function")
            return null;
          var cache = /* @__PURE__ */ new WeakMap();
          _getRequireWildcardCache = function _getRequireWildcardCache2() {
            return cache;
          };
          return cache;
        }
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return { "default": obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj["default"] = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
        var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
        function tokenStart(token) {
          return {
            line: token[_tokenize.FIELDS.START_LINE],
            column: token[_tokenize.FIELDS.START_COL]
          };
        }
        function tokenEnd(token) {
          return {
            line: token[_tokenize.FIELDS.END_LINE],
            column: token[_tokenize.FIELDS.END_COL]
          };
        }
        function getSource2(startLine, startColumn, endLine, endColumn) {
          return {
            start: {
              line: startLine,
              column: startColumn
            },
            end: {
              line: endLine,
              column: endColumn
            }
          };
        }
        function getTokenSource(token) {
          return getSource2(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
        }
        function getTokenSourceSpan(startToken, endToken) {
          if (!startToken) {
            return void 0;
          }
          return getSource2(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
        }
        function unescapeProp(node2, prop) {
          var value = node2[prop];
          if (typeof value !== "string") {
            return;
          }
          if (value.indexOf("\\") !== -1) {
            (0, _util.ensureObject)(node2, "raws");
            node2[prop] = (0, _util.unesc)(value);
            if (node2.raws[prop] === void 0) {
              node2.raws[prop] = value;
            }
          }
          return node2;
        }
        function indexesOf(array, item) {
          var i2 = -1;
          var indexes = [];
          while ((i2 = array.indexOf(item, i2 + 1)) !== -1) {
            indexes.push(i2);
          }
          return indexes;
        }
        function uniqs() {
          var list2 = Array.prototype.concat.apply([], arguments);
          return list2.filter(function(item, i2) {
            return i2 === list2.indexOf(item);
          });
        }
        var Parser2 = function() {
          function Parser3(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            this.rule = rule2;
            this.options = Object.assign({
              lossy: false,
              safe: false
            }, options2);
            this.position = 0;
            this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
            this.tokens = (0, _tokenize["default"])({
              css: this.css,
              error: this._errorGenerator(),
              safe: this.options.safe
            });
            var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
            this.root = new _root2["default"]({
              source: rootSource
            });
            this.root.errorGenerator = this._errorGenerator();
            var selector2 = new _selector2["default"]({
              source: {
                start: {
                  line: 1,
                  column: 1
                }
              }
            });
            this.root.append(selector2);
            this.current = selector2;
            this.loop();
          }
          var _proto = Parser3.prototype;
          _proto._errorGenerator = function _errorGenerator() {
            var _this = this;
            return function(message, errorOptions) {
              if (typeof _this.rule === "string") {
                return new Error(message);
              }
              return _this.rule.error(message, errorOptions);
            };
          };
          _proto.attribute = function attribute2() {
            var attr = [];
            var startingToken = this.currToken;
            this.position++;
            while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
              attr.push(this.currToken);
              this.position++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
              return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
            }
            var len = attr.length;
            var node2 = {
              source: getSource2(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            };
            if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
              return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
            }
            var pos = 0;
            var spaceBefore = "";
            var commentBefore = "";
            var lastAdded = null;
            var spaceAfterMeaningfulToken = false;
            while (pos < len) {
              var token = attr[pos];
              var content = this.content(token);
              var next = attr[pos + 1];
              switch (token[_tokenize.FIELDS.TYPE]) {
                case tokens.space:
                  spaceAfterMeaningfulToken = true;
                  if (this.options.lossy) {
                    break;
                  }
                  if (lastAdded) {
                    (0, _util.ensureObject)(node2, "spaces", lastAdded);
                    var prevContent = node2.spaces[lastAdded].after || "";
                    node2.spaces[lastAdded].after = prevContent + content;
                    var existingComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || null;
                    if (existingComment) {
                      node2.raws.spaces[lastAdded].after = existingComment + content;
                    }
                  } else {
                    spaceBefore = spaceBefore + content;
                    commentBefore = commentBefore + content;
                  }
                  break;
                case tokens.asterisk:
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  } else if ((!node2.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node2, "spaces", "attribute");
                      node2.spaces.attribute.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                      node2.raws.spaces.attribute.before = spaceBefore;
                      commentBefore = "";
                    }
                    node2.namespace = (node2.namespace || "") + content;
                    var rawValue = (0, _util.getProp)(node2, "raws", "namespace") || null;
                    if (rawValue) {
                      node2.raws.namespace += content;
                    }
                    lastAdded = "namespace";
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.dollar:
                  if (lastAdded === "value") {
                    var oldRawValue = (0, _util.getProp)(node2, "raws", "value");
                    node2.value += "$";
                    if (oldRawValue) {
                      node2.raws.value = oldRawValue + "$";
                    }
                    break;
                  }
                case tokens.caret:
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.combinator:
                  if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  }
                  if (content !== "|") {
                    spaceAfterMeaningfulToken = false;
                    break;
                  }
                  if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                    node2.operator = content;
                    lastAdded = "operator";
                  } else if (!node2.namespace && !node2.attribute) {
                    node2.namespace = true;
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.word:
                  if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                  !node2.operator && !node2.namespace) {
                    node2.namespace = content;
                    lastAdded = "namespace";
                  } else if (!node2.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node2, "spaces", "attribute");
                      node2.spaces.attribute.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                      node2.raws.spaces.attribute.before = commentBefore;
                      commentBefore = "";
                    }
                    node2.attribute = (node2.attribute || "") + content;
                    var _rawValue = (0, _util.getProp)(node2, "raws", "attribute") || null;
                    if (_rawValue) {
                      node2.raws.attribute += content;
                    }
                    lastAdded = "attribute";
                  } else if (!node2.value && node2.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                    var _unescaped = (0, _util.unesc)(content);
                    var _oldRawValue = (0, _util.getProp)(node2, "raws", "value") || "";
                    var oldValue = node2.value || "";
                    node2.value = oldValue + _unescaped;
                    node2.quoteMark = null;
                    if (_unescaped !== content || _oldRawValue) {
                      (0, _util.ensureObject)(node2, "raws");
                      node2.raws.value = (_oldRawValue || oldValue) + content;
                    }
                    lastAdded = "value";
                  } else {
                    var insensitive = content === "i" || content === "I";
                    if ((node2.value || node2.value === "") && (node2.quoteMark || spaceAfterMeaningfulToken)) {
                      node2.insensitive = insensitive;
                      if (!insensitive || content === "I") {
                        (0, _util.ensureObject)(node2, "raws");
                        node2.raws.insensitiveFlag = content;
                      }
                      lastAdded = "insensitive";
                      if (spaceBefore) {
                        (0, _util.ensureObject)(node2, "spaces", "insensitive");
                        node2.spaces.insensitive.before = spaceBefore;
                        spaceBefore = "";
                      }
                      if (commentBefore) {
                        (0, _util.ensureObject)(node2, "raws", "spaces", "insensitive");
                        node2.raws.spaces.insensitive.before = commentBefore;
                        commentBefore = "";
                      }
                    } else if (node2.value || node2.value === "") {
                      lastAdded = "value";
                      node2.value += content;
                      if (node2.raws.value) {
                        node2.raws.value += content;
                      }
                    }
                  }
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.str:
                  if (!node2.attribute || !node2.operator) {
                    return this.error("Expected an attribute followed by an operator preceding the string.", {
                      index: token[_tokenize.FIELDS.START_POS]
                    });
                  }
                  var _unescapeValue = (0, _attribute2.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                  node2.value = unescaped;
                  node2.quoteMark = quoteMark;
                  lastAdded = "value";
                  (0, _util.ensureObject)(node2, "raws");
                  node2.raws.value = content;
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.equals:
                  if (!node2.attribute) {
                    return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                  }
                  if (node2.value) {
                    return this.error('Unexpected "=" found; an operator was already defined.', {
                      index: token[_tokenize.FIELDS.START_POS]
                    });
                  }
                  node2.operator = node2.operator ? node2.operator + content : content;
                  lastAdded = "operator";
                  spaceAfterMeaningfulToken = false;
                  break;
                case tokens.comment:
                  if (lastAdded) {
                    if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                      var lastComment = (0, _util.getProp)(node2, "spaces", lastAdded, "after") || "";
                      var rawLastComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || lastComment;
                      (0, _util.ensureObject)(node2, "raws", "spaces", lastAdded);
                      node2.raws.spaces[lastAdded].after = rawLastComment + content;
                    } else {
                      var lastValue = node2[lastAdded] || "";
                      var rawLastValue = (0, _util.getProp)(node2, "raws", lastAdded) || lastValue;
                      (0, _util.ensureObject)(node2, "raws");
                      node2.raws[lastAdded] = rawLastValue + content;
                    }
                  } else {
                    commentBefore = commentBefore + content;
                  }
                  break;
                default:
                  return this.error('Unexpected "' + content + '" found.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
              }
              pos++;
            }
            unescapeProp(node2, "attribute");
            unescapeProp(node2, "namespace");
            this.newNode(new _attribute2["default"](node2));
            this.position++;
          };
          _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
            if (stopPosition < 0) {
              stopPosition = this.tokens.length;
            }
            var startPosition = this.position;
            var nodes = [];
            var space2 = "";
            var lastComment = void 0;
            do {
              if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
                if (!this.options.lossy) {
                  space2 += this.content();
                }
              } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
                var spaces = {};
                if (space2) {
                  spaces.before = space2;
                  space2 = "";
                }
                lastComment = new _comment2["default"]({
                  value: this.content(),
                  source: getTokenSource(this.currToken),
                  sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                  spaces
                });
                nodes.push(lastComment);
              }
            } while (++this.position < stopPosition);
            if (space2) {
              if (lastComment) {
                lastComment.spaces.after = space2;
              } else if (!this.options.lossy) {
                var firstToken = this.tokens[startPosition];
                var lastToken = this.tokens[this.position - 1];
                nodes.push(new _string2["default"]({
                  value: "",
                  source: getSource2(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                  sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                  spaces: {
                    before: space2,
                    after: ""
                  }
                }));
              }
            }
            return nodes;
          };
          _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
            var _this2 = this;
            if (requiredSpace === void 0) {
              requiredSpace = false;
            }
            var space2 = "";
            var rawSpace = "";
            nodes.forEach(function(n2) {
              var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
              var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
              space2 += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
              rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
            });
            if (rawSpace === space2) {
              rawSpace = void 0;
            }
            var result2 = {
              space: space2,
              rawSpace
            };
            return result2;
          };
          _proto.isNamedCombinator = function isNamedCombinator(position) {
            if (position === void 0) {
              position = this.position;
            }
            return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
          };
          _proto.namedCombinator = function namedCombinator() {
            if (this.isNamedCombinator()) {
              var nameRaw = this.content(this.tokens[this.position + 1]);
              var name2 = (0, _util.unesc)(nameRaw).toLowerCase();
              var raws = {};
              if (name2 !== nameRaw) {
                raws.value = "/" + nameRaw + "/";
              }
              var node2 = new _combinator2["default"]({
                value: "/" + name2 + "/",
                source: getSource2(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                raws
              });
              this.position = this.position + 3;
              return node2;
            } else {
              this.unexpected();
            }
          };
          _proto.combinator = function combinator2() {
            var _this3 = this;
            if (this.content() === "|") {
              return this.namespace();
            }
            var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
            if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
              var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
              if (nodes.length > 0) {
                var last2 = this.current.last;
                if (last2) {
                  var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                  if (rawSpace !== void 0) {
                    last2.rawSpaceAfter += rawSpace;
                  }
                  last2.spaces.after += space2;
                } else {
                  nodes.forEach(function(n2) {
                    return _this3.newNode(n2);
                  });
                }
              }
              return;
            }
            var firstToken = this.currToken;
            var spaceOrDescendantSelectorNodes = void 0;
            if (nextSigTokenPos > this.position) {
              spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            }
            var node2;
            if (this.isNamedCombinator()) {
              node2 = this.namedCombinator();
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
              node2 = new _combinator2["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
              });
              this.position++;
            } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]])
              ;
            else if (!spaceOrDescendantSelectorNodes) {
              this.unexpected();
            }
            if (node2) {
              if (spaceOrDescendantSelectorNodes) {
                var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
                node2.spaces.before = _space;
                node2.rawSpaceBefore = _rawSpace;
              }
            } else {
              var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
              if (!_rawSpace2) {
                _rawSpace2 = _space2;
              }
              var spaces = {};
              var raws = {
                spaces: {}
              };
              if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
                spaces.before = _space2.slice(0, _space2.length - 1);
                raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
              } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
                spaces.after = _space2.slice(1);
                raws.spaces.after = _rawSpace2.slice(1);
              } else {
                raws.value = _rawSpace2;
              }
              node2 = new _combinator2["default"]({
                value: " ",
                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces,
                raws
              });
            }
            if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
              node2.spaces.after = this.optionalSpace(this.content());
              this.position++;
            }
            return this.newNode(node2);
          };
          _proto.comma = function comma2() {
            if (this.position === this.tokens.length - 1) {
              this.root.trailingComma = true;
              this.position++;
              return;
            }
            this.current._inferEndPosition();
            var selector2 = new _selector2["default"]({
              source: {
                start: tokenStart(this.tokens[this.position + 1])
              }
            });
            this.current.parent.append(selector2);
            this.current = selector2;
            this.position++;
          };
          _proto.comment = function comment2() {
            var current = this.currToken;
            this.newNode(new _comment2["default"]({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.error = function error2(message, opts) {
            throw this.root.error(message, opts);
          };
          _proto.missingBackslash = function missingBackslash() {
            return this.error("Expected a backslash preceding the semicolon.", {
              index: this.currToken[_tokenize.FIELDS.START_POS]
            });
          };
          _proto.missingParenthesis = function missingParenthesis() {
            return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.missingSquareBracket = function missingSquareBracket() {
            return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.unexpected = function unexpected() {
            return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
          };
          _proto.namespace = function namespace2() {
            var before = this.prevToken && this.content(this.prevToken) || true;
            if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
              this.position++;
              return this.word(before);
            } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
              this.position++;
              return this.universal(before);
            }
          };
          _proto.nesting = function nesting2() {
            if (this.nextToken) {
              var nextContent = this.content(this.nextToken);
              if (nextContent === "|") {
                this.position++;
                return;
              }
            }
            var current = this.currToken;
            this.newNode(new _nesting2["default"]({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.parentheses = function parentheses() {
            var last2 = this.current.last;
            var unbalanced = 1;
            this.position++;
            if (last2 && last2.type === types2.PSEUDO) {
              var selector2 = new _selector2["default"]({
                source: {
                  start: tokenStart(this.tokens[this.position - 1])
                }
              });
              var cache = this.current;
              last2.append(selector2);
              this.current = selector2;
              while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                  unbalanced--;
                }
                if (unbalanced) {
                  this.parse();
                } else {
                  this.current.source.end = tokenEnd(this.currToken);
                  this.current.parent.source.end = tokenEnd(this.currToken);
                  this.position++;
                }
              }
              this.current = cache;
            } else {
              var parenStart = this.currToken;
              var parenValue = "(";
              var parenEnd;
              while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                  unbalanced--;
                }
                parenEnd = this.currToken;
                parenValue += this.parseParenthesisToken(this.currToken);
                this.position++;
              }
              if (last2) {
                last2.appendToPropertyAndEscape("value", parenValue, parenValue);
              } else {
                this.newNode(new _string2["default"]({
                  value: parenValue,
                  source: getSource2(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                  sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
                }));
              }
            }
            if (unbalanced) {
              return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
            }
          };
          _proto.pseudo = function pseudo2() {
            var _this4 = this;
            var pseudoStr = "";
            var startingToken = this.currToken;
            while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
              pseudoStr += this.content();
              this.position++;
            }
            if (!this.currToken) {
              return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
              this.splitWord(false, function(first, length) {
                pseudoStr += first;
                _this4.newNode(new _pseudo2["default"]({
                  value: pseudoStr,
                  source: getTokenSourceSpan(startingToken, _this4.currToken),
                  sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
                }));
                if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                  _this4.error("Misplaced parenthesis.", {
                    index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                  });
                }
              });
            } else {
              return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
            }
          };
          _proto.space = function space2() {
            var content = this.content();
            if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node2) {
              return node2.type === "comment";
            })) {
              this.spaces = this.optionalSpace(content);
              this.position++;
            } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              this.current.last.spaces.after = this.optionalSpace(content);
              this.position++;
            } else {
              this.combinator();
            }
          };
          _proto.string = function string2() {
            var current = this.currToken;
            this.newNode(new _string2["default"]({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }));
            this.position++;
          };
          _proto.universal = function universal2(namespace2) {
            var nextToken = this.nextToken;
            if (nextToken && this.content(nextToken) === "|") {
              this.position++;
              return this.namespace();
            }
            var current = this.currToken;
            this.newNode(new _universal2["default"]({
              value: this.content(),
              source: getTokenSource(current),
              sourceIndex: current[_tokenize.FIELDS.START_POS]
            }), namespace2);
            this.position++;
          };
          _proto.splitWord = function splitWord(namespace2, firstCallback) {
            var _this5 = this;
            var nextToken = this.nextToken;
            var word2 = this.content();
            while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
              this.position++;
              var current = this.content();
              word2 += current;
              if (current.lastIndexOf("\\") === current.length - 1) {
                var next = this.nextToken;
                if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                  word2 += this.requiredSpace(this.content(next));
                  this.position++;
                }
              }
              nextToken = this.nextToken;
            }
            var hasClass = indexesOf(word2, ".").filter(function(i2) {
              var escapedDot = word2[i2 - 1] === "\\";
              var isKeyframesPercent = /^\d+\.\d+%$/.test(word2);
              return !escapedDot && !isKeyframesPercent;
            });
            var hasId = indexesOf(word2, "#").filter(function(i2) {
              return word2[i2 - 1] !== "\\";
            });
            var interpolations = indexesOf(word2, "#{");
            if (interpolations.length) {
              hasId = hasId.filter(function(hashIndex) {
                return !~interpolations.indexOf(hashIndex);
              });
            }
            var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
            indices.forEach(function(ind, i2) {
              var index = indices[i2 + 1] || word2.length;
              var value = word2.slice(ind, index);
              if (i2 === 0 && firstCallback) {
                return firstCallback.call(_this5, value, indices.length);
              }
              var node2;
              var current2 = _this5.currToken;
              var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
              var source = getSource2(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
              if (~hasClass.indexOf(ind)) {
                var classNameOpts = {
                  value: value.slice(1),
                  source,
                  sourceIndex
                };
                node2 = new _className2["default"](unescapeProp(classNameOpts, "value"));
              } else if (~hasId.indexOf(ind)) {
                var idOpts = {
                  value: value.slice(1),
                  source,
                  sourceIndex
                };
                node2 = new _id2["default"](unescapeProp(idOpts, "value"));
              } else {
                var tagOpts = {
                  value,
                  source,
                  sourceIndex
                };
                unescapeProp(tagOpts, "value");
                node2 = new _tag2["default"](tagOpts);
              }
              _this5.newNode(node2, namespace2);
              namespace2 = null;
            });
            this.position++;
          };
          _proto.word = function word2(namespace2) {
            var nextToken = this.nextToken;
            if (nextToken && this.content(nextToken) === "|") {
              this.position++;
              return this.namespace();
            }
            return this.splitWord(namespace2);
          };
          _proto.loop = function loop() {
            while (this.position < this.tokens.length) {
              this.parse(true);
            }
            this.current._inferEndPosition();
            return this.root;
          };
          _proto.parse = function parse2(throwOnParenthesis) {
            switch (this.currToken[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                this.space();
                break;
              case tokens.comment:
                this.comment();
                break;
              case tokens.openParenthesis:
                this.parentheses();
                break;
              case tokens.closeParenthesis:
                if (throwOnParenthesis) {
                  this.missingParenthesis();
                }
                break;
              case tokens.openSquare:
                this.attribute();
                break;
              case tokens.dollar:
              case tokens.caret:
              case tokens.equals:
              case tokens.word:
                this.word();
                break;
              case tokens.colon:
                this.pseudo();
                break;
              case tokens.comma:
                this.comma();
                break;
              case tokens.asterisk:
                this.universal();
                break;
              case tokens.ampersand:
                this.nesting();
                break;
              case tokens.slash:
              case tokens.combinator:
                this.combinator();
                break;
              case tokens.str:
                this.string();
                break;
              case tokens.closeSquare:
                this.missingSquareBracket();
              case tokens.semicolon:
                this.missingBackslash();
              default:
                this.unexpected();
            }
          };
          _proto.expected = function expected(description2, index, found) {
            if (Array.isArray(description2)) {
              var last2 = description2.pop();
              description2 = description2.join(", ") + " or " + last2;
            }
            var an = /^[aeiou]/.test(description2[0]) ? "an" : "a";
            if (!found) {
              return this.error("Expected " + an + " " + description2 + ".", {
                index
              });
            }
            return this.error("Expected " + an + " " + description2 + ', found "' + found + '" instead.', {
              index
            });
          };
          _proto.requiredSpace = function requiredSpace(space2) {
            return this.options.lossy ? " " : space2;
          };
          _proto.optionalSpace = function optionalSpace(space2) {
            return this.options.lossy ? "" : space2;
          };
          _proto.lossySpace = function lossySpace(space2, required) {
            if (this.options.lossy) {
              return required ? " " : "";
            } else {
              return space2;
            }
          };
          _proto.parseParenthesisToken = function parseParenthesisToken(token) {
            var content = this.content(token);
            if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
              return this.requiredSpace(content);
            } else {
              return content;
            }
          };
          _proto.newNode = function newNode(node2, namespace2) {
            if (namespace2) {
              if (/^ +$/.test(namespace2)) {
                if (!this.options.lossy) {
                  this.spaces = (this.spaces || "") + namespace2;
                }
                namespace2 = true;
              }
              node2.namespace = namespace2;
              unescapeProp(node2, "namespace");
            }
            if (this.spaces) {
              node2.spaces.before = this.spaces;
              this.spaces = "";
            }
            return this.current.append(node2);
          };
          _proto.content = function content(token) {
            if (token === void 0) {
              token = this.currToken;
            }
            return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
          };
          _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
            if (startPosition === void 0) {
              startPosition = this.position + 1;
            }
            var searchPosition = startPosition;
            while (searchPosition < this.tokens.length) {
              if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
                searchPosition++;
                continue;
              } else {
                return searchPosition;
              }
            }
            return -1;
          };
          _createClass2(Parser3, [{
            key: "currToken",
            get: function get2() {
              return this.tokens[this.position];
            }
          }, {
            key: "nextToken",
            get: function get2() {
              return this.tokens[this.position + 1];
            }
          }, {
            key: "prevToken",
            get: function get2() {
              return this.tokens[this.position - 1];
            }
          }]);
          return Parser3;
        }();
        exports2["default"] = Parser2;
        module2.exports = exports2.default;
      })(parser$1, parser$1.exports);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _parser3 = _interopRequireDefault2(parser$1.exports);
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var Processor2 = function() {
          function Processor3(func, options2) {
            this.func = func || function noop2() {
            };
            this.funcRes = null;
            this.options = options2;
          }
          var _proto = Processor3.prototype;
          _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var merged = Object.assign({}, this.options, options2);
            if (merged.updateSelector === false) {
              return false;
            } else {
              return typeof rule2 !== "string";
            }
          };
          _proto._isLossy = function _isLossy(options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var merged = Object.assign({}, this.options, options2);
            if (merged.lossless === false) {
              return true;
            } else {
              return false;
            }
          };
          _proto._root = function _root2(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var parser2 = new _parser3["default"](rule2, this._parseOptions(options2));
            return parser2.root;
          };
          _proto._parseOptions = function _parseOptions(options2) {
            return {
              lossy: this._isLossy(options2)
            };
          };
          _proto._run = function _run(rule2, options2) {
            var _this = this;
            if (options2 === void 0) {
              options2 = {};
            }
            return new Promise(function(resolve2, reject) {
              try {
                var root2 = _this._root(rule2, options2);
                Promise.resolve(_this.func(root2)).then(function(transform2) {
                  var string2 = void 0;
                  if (_this._shouldUpdateSelector(rule2, options2)) {
                    string2 = root2.toString();
                    rule2.selector = string2;
                  }
                  return {
                    transform: transform2,
                    root: root2,
                    string: string2
                  };
                }).then(resolve2, reject);
              } catch (e) {
                reject(e);
                return;
              }
            });
          };
          _proto._runSync = function _runSync(rule2, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            var root2 = this._root(rule2, options2);
            var transform2 = this.func(root2);
            if (transform2 && typeof transform2.then === "function") {
              throw new Error("Selector processor returned a promise to a synchronous call.");
            }
            var string2 = void 0;
            if (options2.updateSelector && typeof rule2 !== "string") {
              string2 = root2.toString();
              rule2.selector = string2;
            }
            return {
              transform: transform2,
              root: root2,
              string: string2
            };
          };
          _proto.ast = function ast(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.root;
            });
          };
          _proto.astSync = function astSync(rule2, options2) {
            return this._runSync(rule2, options2).root;
          };
          _proto.transform = function transform2(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.transform;
            });
          };
          _proto.transformSync = function transformSync(rule2, options2) {
            return this._runSync(rule2, options2).transform;
          };
          _proto.process = function process(rule2, options2) {
            return this._run(rule2, options2).then(function(result2) {
              return result2.string || result2.root.toString();
            });
          };
          _proto.processSync = function processSync(rule2, options2) {
            var result2 = this._runSync(rule2, options2);
            return result2.string || result2.root.toString();
          };
          return Processor3;
        }();
        exports2["default"] = Processor2;
        module2.exports = exports2.default;
      })(processor, processor.exports);
      var selectors = {};
      var constructors = {};
      constructors.__esModule = true;
      constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
      var _attribute = _interopRequireDefault$2(attribute$1);
      var _className = _interopRequireDefault$2(className$1.exports);
      var _combinator = _interopRequireDefault$2(combinator$2.exports);
      var _comment = _interopRequireDefault$2(comment$2.exports);
      var _id = _interopRequireDefault$2(id$1.exports);
      var _nesting = _interopRequireDefault$2(nesting$1.exports);
      var _pseudo = _interopRequireDefault$2(pseudo$1.exports);
      var _root = _interopRequireDefault$2(root$1.exports);
      var _selector = _interopRequireDefault$2(selector$1.exports);
      var _string = _interopRequireDefault$2(string$1.exports);
      var _tag = _interopRequireDefault$2(tag$1.exports);
      var _universal = _interopRequireDefault$2(universal$1.exports);
      function _interopRequireDefault$2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var attribute = function attribute2(opts) {
        return new _attribute["default"](opts);
      };
      constructors.attribute = attribute;
      var className = function className2(opts) {
        return new _className["default"](opts);
      };
      constructors.className = className;
      var combinator = function combinator2(opts) {
        return new _combinator["default"](opts);
      };
      constructors.combinator = combinator;
      var comment = function comment2(opts) {
        return new _comment["default"](opts);
      };
      constructors.comment = comment;
      var id = function id2(opts) {
        return new _id["default"](opts);
      };
      constructors.id = id;
      var nesting = function nesting2(opts) {
        return new _nesting["default"](opts);
      };
      constructors.nesting = nesting;
      var pseudo = function pseudo2(opts) {
        return new _pseudo["default"](opts);
      };
      constructors.pseudo = pseudo;
      var root = function root2(opts) {
        return new _root["default"](opts);
      };
      constructors.root = root;
      var selector = function selector2(opts) {
        return new _selector["default"](opts);
      };
      constructors.selector = selector;
      var string = function string2(opts) {
        return new _string["default"](opts);
      };
      constructors.string = string;
      var tag = function tag2(opts) {
        return new _tag["default"](opts);
      };
      constructors.tag = tag;
      var universal = function universal2(opts) {
        return new _universal["default"](opts);
      };
      constructors.universal = universal;
      var guards = {};
      guards.__esModule = true;
      guards.isNode = isNode;
      guards.isPseudoElement = isPseudoElement;
      guards.isPseudoClass = isPseudoClass;
      guards.isContainer = isContainer;
      guards.isNamespace = isNamespace;
      guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = guards.isPseudo = guards.isNesting = guards.isIdentifier = guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
      var _types = types$1;
      var _IS_TYPE;
      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
      function isNode(node2) {
        return typeof node2 === "object" && IS_TYPE[node2.type];
      }
      function isNodeType(type2, node2) {
        return isNode(node2) && node2.type === type2;
      }
      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      guards.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      guards.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      guards.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      guards.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      guards.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      guards.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      guards.isPseudo = isPseudo;
      var isRoot = isNodeType.bind(null, _types.ROOT);
      guards.isRoot = isRoot;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      guards.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      guards.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      guards.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      guards.isUniversal = isUniversal;
      function isPseudoElement(node2) {
        return isPseudo(node2) && node2.value && (node2.value.startsWith("::") || node2.value.toLowerCase() === ":before" || node2.value.toLowerCase() === ":after" || node2.value.toLowerCase() === ":first-letter" || node2.value.toLowerCase() === ":first-line");
      }
      function isPseudoClass(node2) {
        return isPseudo(node2) && !isPseudoElement(node2);
      }
      function isContainer(node2) {
        return !!(isNode(node2) && node2.walk);
      }
      function isNamespace(node2) {
        return isAttribute(node2) || isTag(node2);
      }
      (function(exports2) {
        exports2.__esModule = true;
        var _types2 = types$1;
        Object.keys(_types2).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          if (key in exports2 && exports2[key] === _types2[key])
            return;
          exports2[key] = _types2[key];
        });
        var _constructors = constructors;
        Object.keys(_constructors).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          if (key in exports2 && exports2[key] === _constructors[key])
            return;
          exports2[key] = _constructors[key];
        });
        var _guards = guards;
        Object.keys(_guards).forEach(function(key) {
          if (key === "default" || key === "__esModule")
            return;
          if (key in exports2 && exports2[key] === _guards[key])
            return;
          exports2[key] = _guards[key];
        });
      })(selectors);
      (function(module2, exports2) {
        exports2.__esModule = true;
        exports2["default"] = void 0;
        var _processor = _interopRequireDefault2(processor.exports);
        var selectors$12 = _interopRequireWildcard2(selectors);
        function _getRequireWildcardCache() {
          if (typeof WeakMap !== "function")
            return null;
          var cache = /* @__PURE__ */ new WeakMap();
          _getRequireWildcardCache = function _getRequireWildcardCache2() {
            return cache;
          };
          return cache;
        }
        function _interopRequireWildcard2(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return { "default": obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj["default"] = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        function _interopRequireDefault2(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var parser2 = function parser3(processor2) {
          return new _processor["default"](processor2);
        };
        Object.assign(parser2, selectors$12);
        delete parser2.__esModule;
        var _default = parser2;
        exports2["default"] = _default;
        module2.exports = exports2.default;
      })(dist, dist.exports);
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus$1 = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;
      var parse$4 = function(input2) {
        var tokens = [];
        var value = input2;
        var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
        var pos = 0;
        var code2 = value.charCodeAt(pos);
        var max = value.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;
        var name2 = "";
        var before = "";
        var after = "";
        while (pos < max) {
          if (code2 <= 32) {
            next = pos;
            do {
              next += 1;
              code2 = value.charCodeAt(next);
            } while (code2 <= 32);
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code2 === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (code2 === comma || code2 === colon || code2 === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          } else if (code2 === singleQuote || code2 === doubleQuote) {
            next = pos;
            quote = code2 === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote
            };
            do {
              escape2 = false;
              next = value.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value += quote;
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code2 = value.charCodeAt(pos);
          } else if (code2 === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next + 2
            };
            if (next === -1) {
              token.unclosed = true;
              next = value.length;
              token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code2 = value.charCodeAt(pos);
          } else if ((code2 === slash || code2 === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token
            });
            pos += 1;
            code2 = value.charCodeAt(pos);
          } else if (code2 === slash || code2 === comma || code2 === colon) {
            token = value[pos];
            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before,
              after: ""
            });
            before = "";
            pos += 1;
            code2 = value.charCodeAt(pos);
          } else if (openParentheses === code2) {
            next = pos;
            do {
              next += 1;
              code2 = value.charCodeAt(next);
            } while (code2 <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name2.length,
              value: name2,
              before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name2 === "url" && code2 !== singleQuote && code2 !== doubleQuote) {
              next -= 1;
              do {
                escape2 = false;
                next = value.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape2 = !escape2;
                  }
                } else {
                  value += ")";
                  next = value.length - 1;
                  token.unclosed = true;
                }
              } while (escape2);
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code2 = value.charCodeAt(whitespacePos);
              } while (code2 <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                    {
                      type: "word",
                      sourceIndex: pos,
                      sourceEndIndex: whitespacePos + 1,
                      value: value.slice(pos, whitespacePos + 1)
                    }
                  ];
                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next,
                    value: value.slice(whitespacePos + 1, next)
                  });
                } else {
                  token.after = value.slice(whitespacePos + 1, next);
                  token.sourceEndIndex = next;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              token.sourceEndIndex = token.unclosed ? next : pos;
              code2 = value.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name2 = "";
          } else if (closeParentheses === code2 && balanced) {
            pos += 1;
            code2 = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
          } else {
            next = pos;
            do {
              if (code2 === backslash) {
                next += 1;
              }
              next += 1;
              code2 = value.charCodeAt(next);
            } while (next < max && !(code2 <= 32 || code2 === singleQuote || code2 === doubleQuote || code2 === comma || code2 === colon || code2 === slash || code2 === openParentheses || code2 === star && parent && parent.type === "function" && parent.value === "calc" || code2 === slash && parent.type === "function" && parent.value === "calc" || code2 === closeParentheses && balanced));
            token = value.slice(pos, next);
            if (openParentheses === code2) {
              name2 = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus$1 === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          }
        }
        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value.length;
        }
        return stack[0].nodes;
      };
      var walk$1 = function walk2(nodes, cb, bubble) {
        var i2, max, node2, result2;
        for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
          node2 = nodes[i2];
          if (!bubble) {
            result2 = cb(node2, i2, nodes);
          }
          if (result2 !== false && node2.type === "function" && Array.isArray(node2.nodes)) {
            walk2(node2.nodes, cb, bubble);
          }
          if (bubble) {
            cb(node2, i2, nodes);
          }
        }
      };
      function stringifyNode(node2, custom) {
        var type2 = node2.type;
        var value = node2.value;
        var buf;
        var customResult;
        if (custom && (customResult = custom(node2)) !== void 0) {
          return customResult;
        } else if (type2 === "word" || type2 === "space") {
          return value;
        } else if (type2 === "string") {
          buf = node2.quote || "";
          return buf + value + (node2.unclosed ? "" : buf);
        } else if (type2 === "comment") {
          return "/*" + value + (node2.unclosed ? "" : "*/");
        } else if (type2 === "div") {
          return (node2.before || "") + value + (node2.after || "");
        } else if (Array.isArray(node2.nodes)) {
          buf = stringify$1(node2.nodes, custom);
          if (type2 !== "function") {
            return buf;
          }
          return value + "(" + (node2.before || "") + buf + (node2.after || "") + (node2.unclosed ? "" : ")");
        }
        return value;
      }
      function stringify$1(nodes, custom) {
        var result2, i2;
        if (Array.isArray(nodes)) {
          result2 = "";
          for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
            result2 = stringifyNode(nodes[i2], custom) + result2;
          }
          return result2;
        }
        return stringifyNode(nodes, custom);
      }
      var stringify_1 = stringify$1;
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);
      function likeNumber(value) {
        var code2 = value.charCodeAt(0);
        var nextCode;
        if (code2 === plus || code2 === minus) {
          nextCode = value.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          var nextNextCode = value.charCodeAt(2);
          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code2 === dot) {
          nextCode = value.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code2 >= 48 && code2 <= 57) {
          return true;
        }
        return false;
      }
      var unit = function(value) {
        var pos = 0;
        var length = value.length;
        var code2;
        var nextCode;
        var nextNextCode;
        if (length === 0 || !likeNumber(value)) {
          return false;
        }
        code2 = value.charCodeAt(pos);
        if (code2 === plus || code2 === minus) {
          pos++;
        }
        while (pos < length) {
          code2 = value.charCodeAt(pos);
          if (code2 < 48 || code2 > 57) {
            break;
          }
          pos += 1;
        }
        code2 = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        if (code2 === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;
          while (pos < length) {
            code2 = value.charCodeAt(pos);
            if (code2 < 48 || code2 > 57) {
              break;
            }
            pos += 1;
          }
        }
        code2 = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        nextNextCode = value.charCodeAt(pos + 2);
        if ((code2 === exp || code2 === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;
          while (pos < length) {
            code2 = value.charCodeAt(pos);
            if (code2 < 48 || code2 > 57) {
              break;
            }
            pos += 1;
          }
        }
        return {
          number: value.slice(0, pos),
          unit: value.slice(pos)
        };
      };
      var parse$3 = parse$4;
      var walk = walk$1;
      var stringify = stringify_1;
      function ValueParser(value) {
        if (this instanceof ValueParser) {
          this.nodes = parse$3(value);
          return this;
        }
        return new ValueParser(value);
      }
      ValueParser.prototype.toString = function() {
        return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
      };
      ValueParser.prototype.walk = function(cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };
      ValueParser.unit = unit;
      ValueParser.walk = walk;
      ValueParser.stringify = stringify;
      var lib = ValueParser;
      const matchValueName = /[$]?[\w-]+/g;
      const replaceValueSymbols$2 = (value, replacements) => {
        let matches;
        while (matches = matchValueName.exec(value)) {
          const replacement = replacements[matches[0]];
          if (replacement) {
            value = value.slice(0, matches.index) + replacement + value.slice(matchValueName.lastIndex);
            matchValueName.lastIndex -= matches[0].length - replacement.length;
          }
        }
        return value;
      };
      var replaceValueSymbols_1 = replaceValueSymbols$2;
      const replaceValueSymbols$1 = replaceValueSymbols_1;
      const replaceSymbols$1 = (css, replacements) => {
        css.walk((node2) => {
          if (node2.type === "decl" && node2.value) {
            node2.value = replaceValueSymbols$1(node2.value.toString(), replacements);
          } else if (node2.type === "rule" && node2.selector) {
            node2.selector = replaceValueSymbols$1(
              node2.selector.toString(),
              replacements
            );
          } else if (node2.type === "atrule" && node2.params) {
            node2.params = replaceValueSymbols$1(node2.params.toString(), replacements);
          }
        });
      };
      var replaceSymbols_1 = replaceSymbols$1;
      const importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
      const balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
      const getDeclsObject = (rule2) => {
        const object2 = {};
        rule2.walkDecls((decl) => {
          const before = decl.raws.before ? decl.raws.before.trim() : "";
          object2[before + decl.prop] = decl.value;
        });
        return object2;
      };
      const extractICSS$2 = (css, removeRules = true, mode = "auto") => {
        const icssImports = {};
        const icssExports = {};
        function addImports(node2, path2) {
          const unquoted = path2.replace(/'|"/g, "");
          icssImports[unquoted] = Object.assign(
            icssImports[unquoted] || {},
            getDeclsObject(node2)
          );
          if (removeRules) {
            node2.remove();
          }
        }
        function addExports(node2) {
          Object.assign(icssExports, getDeclsObject(node2));
          if (removeRules) {
            node2.remove();
          }
        }
        css.each((node2) => {
          if (node2.type === "rule" && mode !== "at-rule") {
            if (node2.selector.slice(0, 7) === ":import") {
              const matches = importPattern.exec(node2.selector);
              if (matches) {
                addImports(node2, matches[1]);
              }
            }
            if (node2.selector === ":export") {
              addExports(node2);
            }
          }
          if (node2.type === "atrule" && mode !== "rule") {
            if (node2.name === "icss-import") {
              const matches = balancedQuotes.exec(node2.params);
              if (matches) {
                addImports(node2, matches[1]);
              }
            }
            if (node2.name === "icss-export") {
              addExports(node2);
            }
          }
        });
        return { icssImports, icssExports };
      };
      var extractICSS_1 = extractICSS$2;
      const createImports = (imports, postcss2, mode = "rule") => {
        return Object.keys(imports).map((path2) => {
          const aliases = imports[path2];
          const declarations = Object.keys(aliases).map(
            (key) => postcss2.decl({
              prop: key,
              value: aliases[key],
              raws: { before: "\n  " }
            })
          );
          const hasDeclarations = declarations.length > 0;
          const rule2 = mode === "rule" ? postcss2.rule({
            selector: `:import('${path2}')`,
            raws: { after: hasDeclarations ? "\n" : "" }
          }) : postcss2.atRule({
            name: "icss-import",
            params: `'${path2}'`,
            raws: { after: hasDeclarations ? "\n" : "" }
          });
          if (hasDeclarations) {
            rule2.append(declarations);
          }
          return rule2;
        });
      };
      const createExports = (exports2, postcss2, mode = "rule") => {
        const declarations = Object.keys(exports2).map(
          (key) => postcss2.decl({
            prop: key,
            value: exports2[key],
            raws: { before: "\n  " }
          })
        );
        if (declarations.length === 0) {
          return [];
        }
        const rule2 = mode === "rule" ? postcss2.rule({
          selector: `:export`,
          raws: { after: "\n" }
        }) : postcss2.atRule({
          name: "icss-export",
          raws: { after: "\n" }
        });
        rule2.append(declarations);
        return [rule2];
      };
      const createICSSRules$1 = (imports, exports2, postcss2, mode) => [
        ...createImports(imports, postcss2, mode),
        ...createExports(exports2, postcss2, mode)
      ];
      var createICSSRules_1 = createICSSRules$1;
      const replaceValueSymbols = replaceValueSymbols_1;
      const replaceSymbols = replaceSymbols_1;
      const extractICSS$1 = extractICSS_1;
      const createICSSRules = createICSSRules_1;
      var src$3 = {
        replaceValueSymbols,
        replaceSymbols,
        extractICSS: extractICSS$1,
        createICSSRules
      };
      const selectorParser$2 = dist.exports;
      const valueParser = lib;
      const { extractICSS } = src$3;
      const isSpacing = (node2) => node2.type === "combinator" && node2.value === " ";
      function normalizeNodeArray(nodes) {
        const array = [];
        nodes.forEach((x) => {
          if (Array.isArray(x)) {
            normalizeNodeArray(x).forEach((item) => {
              array.push(item);
            });
          } else if (x) {
            array.push(x);
          }
        });
        if (array.length > 0 && isSpacing(array[array.length - 1])) {
          array.pop();
        }
        return array;
      }
      function localizeNode(rule2, mode, localAliasMap) {
        const transform2 = (node2, context) => {
          if (context.ignoreNextSpacing && !isSpacing(node2)) {
            throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
          }
          if (context.enforceNoSpacing && isSpacing(node2)) {
            throw new Error("Missing whitespace before " + context.enforceNoSpacing);
          }
          let newNodes;
          switch (node2.type) {
            case "root": {
              let resultingGlobal;
              context.hasPureGlobals = false;
              newNodes = node2.nodes.map((n2) => {
                const nContext = {
                  global: context.global,
                  lastWasSpacing: true,
                  hasLocals: false,
                  explicit: false
                };
                n2 = transform2(n2, nContext);
                if (typeof resultingGlobal === "undefined") {
                  resultingGlobal = nContext.global;
                } else if (resultingGlobal !== nContext.global) {
                  throw new Error(
                    'Inconsistent rule global/local result in rule "' + node2 + '" (multiple selectors must result in the same mode for the rule)'
                  );
                }
                if (!nContext.hasLocals) {
                  context.hasPureGlobals = true;
                }
                return n2;
              });
              context.global = resultingGlobal;
              node2.nodes = normalizeNodeArray(newNodes);
              break;
            }
            case "selector": {
              newNodes = node2.map((childNode) => transform2(childNode, context));
              node2 = node2.clone();
              node2.nodes = normalizeNodeArray(newNodes);
              break;
            }
            case "combinator": {
              if (isSpacing(node2)) {
                if (context.ignoreNextSpacing) {
                  context.ignoreNextSpacing = false;
                  context.lastWasSpacing = false;
                  context.enforceNoSpacing = false;
                  return null;
                }
                context.lastWasSpacing = true;
                return node2;
              }
              break;
            }
            case "pseudo": {
              let childContext;
              const isNested = !!node2.length;
              const isScoped = node2.value === ":local" || node2.value === ":global";
              const isImportExport = node2.value === ":import" || node2.value === ":export";
              if (isImportExport) {
                context.hasLocals = true;
              } else if (isNested) {
                if (isScoped) {
                  if (node2.nodes.length === 0) {
                    throw new Error(`${node2.value}() can't be empty`);
                  }
                  if (context.inside) {
                    throw new Error(
                      `A ${node2.value} is not allowed inside of a ${context.inside}(...)`
                    );
                  }
                  childContext = {
                    global: node2.value === ":global",
                    inside: node2.value,
                    hasLocals: false,
                    explicit: true
                  };
                  newNodes = node2.map((childNode) => transform2(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
                  if (newNodes.length) {
                    const { before, after } = node2.spaces;
                    const first = newNodes[0];
                    const last2 = newNodes[newNodes.length - 1];
                    first.spaces = { before, after: first.spaces.after };
                    last2.spaces = { before: last2.spaces.before, after };
                  }
                  node2 = newNodes;
                  break;
                } else {
                  childContext = {
                    global: context.global,
                    inside: context.inside,
                    lastWasSpacing: true,
                    hasLocals: false,
                    explicit: context.explicit
                  };
                  newNodes = node2.map(
                    (childNode) => transform2(childNode, childContext)
                  );
                  node2 = node2.clone();
                  node2.nodes = normalizeNodeArray(newNodes);
                  if (childContext.hasLocals) {
                    context.hasLocals = true;
                  }
                }
                break;
              } else if (isScoped) {
                if (context.inside) {
                  throw new Error(
                    `A ${node2.value} is not allowed inside of a ${context.inside}(...)`
                  );
                }
                const addBackSpacing = !!node2.spaces.before;
                context.ignoreNextSpacing = context.lastWasSpacing ? node2.value : false;
                context.enforceNoSpacing = context.lastWasSpacing ? false : node2.value;
                context.global = node2.value === ":global";
                context.explicit = true;
                return addBackSpacing ? selectorParser$2.combinator({ value: " " }) : null;
              }
              break;
            }
            case "id":
            case "class": {
              if (!node2.value) {
                throw new Error("Invalid class or id selector syntax");
              }
              if (context.global) {
                break;
              }
              const isImportedValue = localAliasMap.has(node2.value);
              const isImportedWithExplicitScope = isImportedValue && context.explicit;
              if (!isImportedValue || isImportedWithExplicitScope) {
                const innerNode = node2.clone();
                innerNode.spaces = { before: "", after: "" };
                node2 = selectorParser$2.pseudo({
                  value: ":local",
                  nodes: [innerNode],
                  spaces: node2.spaces
                });
                context.hasLocals = true;
              }
              break;
            }
          }
          context.lastWasSpacing = false;
          context.ignoreNextSpacing = false;
          context.enforceNoSpacing = false;
          return node2;
        };
        const rootContext = {
          global: mode === "global",
          hasPureGlobals: false
        };
        rootContext.selector = selectorParser$2((root2) => {
          transform2(root2, rootContext);
        }).processSync(rule2, { updateSelector: false, lossless: true });
        return rootContext;
      }
      function localizeDeclNode(node2, context) {
        switch (node2.type) {
          case "word":
            if (context.localizeNextItem) {
              if (!context.localAliasMap.has(node2.value)) {
                node2.value = ":local(" + node2.value + ")";
                context.localizeNextItem = false;
              }
            }
            break;
          case "function":
            if (context.options && context.options.rewriteUrl && node2.value.toLowerCase() === "url") {
              node2.nodes.map((nestedNode) => {
                if (nestedNode.type !== "string" && nestedNode.type !== "word") {
                  return;
                }
                let newUrl = context.options.rewriteUrl(
                  context.global,
                  nestedNode.value
                );
                switch (nestedNode.type) {
                  case "string":
                    if (nestedNode.quote === "'") {
                      newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                    }
                    if (nestedNode.quote === '"') {
                      newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                    }
                    break;
                  case "word":
                    newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                    break;
                }
                nestedNode.value = newUrl;
              });
            }
            break;
        }
        return node2;
      }
      function isWordAFunctionArgument(wordNode, functionNode) {
        return functionNode ? functionNode.nodes.some(
          (functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex
        ) : false;
      }
      function localizeDeclarationValues(localize, declaration2, context) {
        const valueNodes = valueParser(declaration2.value);
        valueNodes.walk((node2, index, nodes) => {
          const subContext = {
            options: context.options,
            global: context.global,
            localizeNextItem: localize && !context.global,
            localAliasMap: context.localAliasMap
          };
          nodes[index] = localizeDeclNode(node2, subContext);
        });
        declaration2.value = valueNodes.toString();
      }
      function localizeDeclaration(declaration2, context) {
        const isAnimation = /animation$/i.test(declaration2.prop);
        if (isAnimation) {
          const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
          const animationKeywords = {
            $alternate: 1,
            "$alternate-reverse": 1,
            $backwards: 1,
            $both: 1,
            $ease: 1,
            "$ease-in": 1,
            "$ease-in-out": 1,
            "$ease-out": 1,
            $forwards: 1,
            $infinite: 1,
            $linear: 1,
            $none: Infinity,
            // No matter how many times you write none, it will never be an animation name
            $normal: 1,
            $paused: 1,
            $reverse: 1,
            $running: 1,
            "$step-end": 1,
            "$step-start": 1,
            $initial: Infinity,
            $inherit: Infinity,
            $unset: Infinity
          };
          let parsedAnimationKeywords = {};
          let stepsFunctionNode = null;
          const valueNodes = valueParser(declaration2.value).walk((node2) => {
            if (node2.type === "div") {
              parsedAnimationKeywords = {};
            }
            if (node2.type === "function" && node2.value.toLowerCase() === "steps") {
              stepsFunctionNode = node2;
            }
            const value = node2.type === "word" && !isWordAFunctionArgument(node2, stepsFunctionNode) ? node2.value.toLowerCase() : null;
            let shouldParseAnimationName = false;
            if (value && validIdent.test(value)) {
              if ("$" + value in animationKeywords) {
                parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
                shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
              } else {
                shouldParseAnimationName = true;
              }
            }
            const subContext = {
              options: context.options,
              global: context.global,
              localizeNextItem: shouldParseAnimationName && !context.global,
              localAliasMap: context.localAliasMap
            };
            return localizeDeclNode(node2, subContext);
          });
          declaration2.value = valueNodes.toString();
          return;
        }
        const isAnimationName = /animation(-name)?$/i.test(declaration2.prop);
        if (isAnimationName) {
          return localizeDeclarationValues(true, declaration2, context);
        }
        const hasUrl = /url\(/i.test(declaration2.value);
        if (hasUrl) {
          return localizeDeclarationValues(false, declaration2, context);
        }
      }
      src$4.exports = (options2 = {}) => {
        if (options2 && options2.mode && options2.mode !== "global" && options2.mode !== "local" && options2.mode !== "pure") {
          throw new Error(
            'options.mode must be either "global", "local" or "pure" (default "local")'
          );
        }
        const pureMode = options2 && options2.mode === "pure";
        const globalMode = options2 && options2.mode === "global";
        return {
          postcssPlugin: "postcss-modules-local-by-default",
          prepare() {
            const localAliasMap = /* @__PURE__ */ new Map();
            return {
              Once(root2) {
                const { icssImports } = extractICSS(root2, false);
                Object.keys(icssImports).forEach((key) => {
                  Object.keys(icssImports[key]).forEach((prop) => {
                    localAliasMap.set(prop, icssImports[key][prop]);
                  });
                });
                root2.walkAtRules((atRule2) => {
                  if (/keyframes$/i.test(atRule2.name)) {
                    const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(
                      atRule2.params
                    );
                    const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(
                      atRule2.params
                    );
                    let globalKeyframes = globalMode;
                    if (globalMatch) {
                      if (pureMode) {
                        throw atRule2.error(
                          "@keyframes :global(...) is not allowed in pure mode"
                        );
                      }
                      atRule2.params = globalMatch[1];
                      globalKeyframes = true;
                    } else if (localMatch) {
                      atRule2.params = localMatch[0];
                      globalKeyframes = false;
                    } else if (!globalMode) {
                      if (atRule2.params && !localAliasMap.has(atRule2.params)) {
                        atRule2.params = ":local(" + atRule2.params + ")";
                      }
                    }
                    atRule2.walkDecls((declaration2) => {
                      localizeDeclaration(declaration2, {
                        localAliasMap,
                        options: options2,
                        global: globalKeyframes
                      });
                    });
                  } else if (atRule2.nodes) {
                    atRule2.nodes.forEach((declaration2) => {
                      if (declaration2.type === "decl") {
                        localizeDeclaration(declaration2, {
                          localAliasMap,
                          options: options2,
                          global: globalMode
                        });
                      }
                    });
                  }
                });
                root2.walkRules((rule2) => {
                  if (rule2.parent && rule2.parent.type === "atrule" && /keyframes$/i.test(rule2.parent.name)) {
                    return;
                  }
                  const context = localizeNode(rule2, options2.mode, localAliasMap);
                  context.options = options2;
                  context.localAliasMap = localAliasMap;
                  if (pureMode && context.hasPureGlobals) {
                    throw rule2.error(
                      'Selector "' + rule2.selector + '" is not pure (pure selectors must contain at least one local class or id)'
                    );
                  }
                  rule2.selector = context.selector;
                  if (rule2.nodes) {
                    rule2.nodes.forEach(
                      (declaration2) => localizeDeclaration(declaration2, context)
                    );
                  }
                });
              }
            };
          }
        };
      };
      src$4.exports.postcss = true;
      var src$2 = { exports: {} };
      const PERMANENT_MARKER = 2;
      const TEMPORARY_MARKER = 1;
      function createError(node2, graph) {
        const er = new Error("Nondeterministic import's order");
        const related = graph[node2];
        const relatedNode = related.find(
          (relatedNode2) => graph[relatedNode2].indexOf(node2) > -1
        );
        er.nodes = [node2, relatedNode];
        return er;
      }
      function walkGraph(node2, graph, state, result2, strict) {
        if (state[node2] === PERMANENT_MARKER) {
          return;
        }
        if (state[node2] === TEMPORARY_MARKER) {
          if (strict) {
            return createError(node2, graph);
          }
          return;
        }
        state[node2] = TEMPORARY_MARKER;
        const children = graph[node2];
        const length = children.length;
        for (let i2 = 0; i2 < length; ++i2) {
          const error2 = walkGraph(children[i2], graph, state, result2, strict);
          if (error2 instanceof Error) {
            return error2;
          }
        }
        state[node2] = PERMANENT_MARKER;
        result2.push(node2);
      }
      function topologicalSort$1(graph, strict) {
        const result2 = [];
        const state = {};
        const nodes = Object.keys(graph);
        const length = nodes.length;
        for (let i2 = 0; i2 < length; ++i2) {
          const er = walkGraph(nodes[i2], graph, state, result2, strict);
          if (er instanceof Error) {
            return er;
          }
        }
        return result2;
      }
      var topologicalSort_1 = topologicalSort$1;
      const topologicalSort = topologicalSort_1;
      const matchImports$1 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
      const icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
      const VISITED_MARKER = 1;
      function addImportToGraph(importId, parentId, graph, visited) {
        const siblingsId = parentId + "_siblings";
        const visitedId = parentId + "_" + importId;
        if (visited[visitedId] !== VISITED_MARKER) {
          if (!Array.isArray(visited[siblingsId])) {
            visited[siblingsId] = [];
          }
          const siblings = visited[siblingsId];
          if (Array.isArray(graph[importId])) {
            graph[importId] = graph[importId].concat(siblings);
          } else {
            graph[importId] = siblings.slice();
          }
          visited[visitedId] = VISITED_MARKER;
          siblings.push(importId);
        }
      }
      src$2.exports = (options2 = {}) => {
        let importIndex = 0;
        const createImportedName = typeof options2.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options2.createImportedName;
        const failOnWrongOrder = options2.failOnWrongOrder;
        return {
          postcssPlugin: "postcss-modules-extract-imports",
          prepare() {
            const graph = {};
            const visited = {};
            const existingImports = {};
            const importDecls = {};
            const imports = {};
            return {
              Once(root2, postcss2) {
                root2.walkRules((rule2) => {
                  const matches = icssImport.exec(rule2.selector);
                  if (matches) {
                    const [
                      ,
                      /*match*/
                      doubleQuotePath,
                      singleQuotePath
                    ] = matches;
                    const importPath = doubleQuotePath || singleQuotePath;
                    addImportToGraph(importPath, "root", graph, visited);
                    existingImports[importPath] = rule2;
                  }
                });
                root2.walkDecls(/^composes$/, (declaration2) => {
                  const matches = declaration2.value.match(matchImports$1);
                  if (!matches) {
                    return;
                  }
                  let tmpSymbols;
                  let [
                    ,
                    /*match*/
                    symbols2,
                    doubleQuotePath,
                    singleQuotePath,
                    global2
                  ] = matches;
                  if (global2) {
                    tmpSymbols = symbols2.split(/\s+/).map((s) => `global(${s})`);
                  } else {
                    const importPath = doubleQuotePath || singleQuotePath;
                    let parent = declaration2.parent;
                    let parentIndexes = "";
                    while (parent.type !== "root") {
                      parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                      parent = parent.parent;
                    }
                    const { selector: selector2 } = declaration2.parent;
                    const parentRule = `_${parentIndexes}${selector2}`;
                    addImportToGraph(importPath, parentRule, graph, visited);
                    importDecls[importPath] = declaration2;
                    imports[importPath] = imports[importPath] || {};
                    tmpSymbols = symbols2.split(/\s+/).map((s) => {
                      if (!imports[importPath][s]) {
                        imports[importPath][s] = createImportedName(s, importPath);
                      }
                      return imports[importPath][s];
                    });
                  }
                  declaration2.value = tmpSymbols.join(" ");
                });
                const importsOrder = topologicalSort(graph, failOnWrongOrder);
                if (importsOrder instanceof Error) {
                  const importPath = importsOrder.nodes.find(
                    (importPath2) => (
                      // eslint-disable-next-line no-prototype-builtins
                      importDecls.hasOwnProperty(importPath2)
                    )
                  );
                  const decl = importDecls[importPath];
                  throw decl.error(
                    "Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".",
                    {
                      plugin: "postcss-modules-extract-imports",
                      word: "composes"
                    }
                  );
                }
                let lastImportRule;
                importsOrder.forEach((path2) => {
                  const importedSymbols = imports[path2];
                  let rule2 = existingImports[path2];
                  if (!rule2 && importedSymbols) {
                    rule2 = postcss2.rule({
                      selector: `:import("${path2}")`,
                      raws: { after: "\n" }
                    });
                    if (lastImportRule) {
                      root2.insertAfter(lastImportRule, rule2);
                    } else {
                      root2.prepend(rule2);
                    }
                  }
                  lastImportRule = rule2;
                  if (!importedSymbols) {
                    return;
                  }
                  Object.keys(importedSymbols).forEach((importedSymbol) => {
                    rule2.append(
                      postcss2.decl({
                        value: importedSymbol,
                        prop: importedSymbols[importedSymbol],
                        raws: { before: "\n  " }
                      })
                    );
                  });
                });
              }
            };
          }
        };
      };
      src$2.exports.postcss = true;
      const selectorParser$1 = dist.exports;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      function getSingleLocalNamesForComposes(root2) {
        return root2.nodes.map((node2) => {
          if (node2.type !== "selector" || node2.nodes.length !== 1) {
            throw new Error(
              `composition is only allowed when selector is single :local class name not in "${root2}"`
            );
          }
          node2 = node2.nodes[0];
          if (node2.type !== "pseudo" || node2.value !== ":local" || node2.nodes.length !== 1) {
            throw new Error(
              'composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node2 + '" is weird'
            );
          }
          node2 = node2.first;
          if (node2.type !== "selector" || node2.length !== 1) {
            throw new Error(
              'composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node2 + '" is weird'
            );
          }
          node2 = node2.first;
          if (node2.type !== "class") {
            throw new Error(
              'composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node2 + '" is weird'
            );
          }
          return node2.value;
        });
      }
      const whitespace = "[\\x20\\t\\r\\n\\f]";
      const unescapeRegExp = new RegExp(
        "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
        "ig"
      );
      function unescape$1(str2) {
        return str2.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {
          const high = "0x" + escaped - 65536;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? (
            // BMP codepoint
            String.fromCharCode(high + 65536)
          ) : (
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
          );
        });
      }
      const plugin = (options2 = {}) => {
        const generateScopedName2 = options2 && options2.generateScopedName || plugin.generateScopedName;
        const generateExportEntry = options2 && options2.generateExportEntry || plugin.generateExportEntry;
        const exportGlobals = options2 && options2.exportGlobals;
        return {
          postcssPlugin: "postcss-modules-scope",
          Once(root2, { rule: rule2 }) {
            const exports2 = /* @__PURE__ */ Object.create(null);
            function exportScopedName(name2, rawName) {
              const scopedName = generateScopedName2(
                rawName ? rawName : name2,
                root2.source.input.from,
                root2.source.input.css
              );
              const exportEntry = generateExportEntry(
                rawName ? rawName : name2,
                scopedName,
                root2.source.input.from,
                root2.source.input.css
              );
              const { key, value } = exportEntry;
              exports2[key] = exports2[key] || [];
              if (exports2[key].indexOf(value) < 0) {
                exports2[key].push(value);
              }
              return scopedName;
            }
            function localizeNode2(node2) {
              switch (node2.type) {
                case "selector":
                  node2.nodes = node2.map(localizeNode2);
                  return node2;
                case "class":
                  return selectorParser$1.className({
                    value: exportScopedName(
                      node2.value,
                      node2.raws && node2.raws.value ? node2.raws.value : null
                    )
                  });
                case "id": {
                  return selectorParser$1.id({
                    value: exportScopedName(
                      node2.value,
                      node2.raws && node2.raws.value ? node2.raws.value : null
                    )
                  });
                }
              }
              throw new Error(
                `${node2.type} ("${node2}") is not allowed in a :local block`
              );
            }
            function traverseNode2(node2) {
              switch (node2.type) {
                case "pseudo":
                  if (node2.value === ":local") {
                    if (node2.nodes.length !== 1) {
                      throw new Error('Unexpected comma (",") in :local block');
                    }
                    const selector2 = localizeNode2(node2.first, node2.spaces);
                    selector2.first.spaces = node2.spaces;
                    const nextNode = node2.next();
                    if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector2.last.value)) {
                      selector2.last.spaces.after = " ";
                    }
                    node2.replaceWith(selector2);
                    return;
                  }
                case "root":
                case "selector": {
                  node2.each(traverseNode2);
                  break;
                }
                case "id":
                case "class":
                  if (exportGlobals) {
                    exports2[node2.value] = [node2.value];
                  }
                  break;
              }
              return node2;
            }
            const importedNames = {};
            root2.walkRules(/^:import\(.+\)$/, (rule3) => {
              rule3.walkDecls((decl) => {
                importedNames[decl.prop] = true;
              });
            });
            root2.walkRules((rule3) => {
              let parsedSelector = selectorParser$1().astSync(rule3);
              rule3.selector = traverseNode2(parsedSelector.clone()).toString();
              rule3.walkDecls(/composes|compose-with/i, (decl) => {
                const localNames = getSingleLocalNamesForComposes(parsedSelector);
                const classes = decl.value.split(/\s+/);
                classes.forEach((className2) => {
                  const global2 = /^global\(([^)]+)\)$/.exec(className2);
                  if (global2) {
                    localNames.forEach((exportedName) => {
                      exports2[exportedName].push(global2[1]);
                    });
                  } else if (hasOwnProperty.call(importedNames, className2)) {
                    localNames.forEach((exportedName) => {
                      exports2[exportedName].push(className2);
                    });
                  } else if (hasOwnProperty.call(exports2, className2)) {
                    localNames.forEach((exportedName) => {
                      exports2[className2].forEach((item) => {
                        exports2[exportedName].push(item);
                      });
                    });
                  } else {
                    throw decl.error(
                      `referenced class name "${className2}" in ${decl.prop} not found`
                    );
                  }
                });
                decl.remove();
              });
              rule3.walkDecls((decl) => {
                if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                  return;
                }
                let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
                tokens = tokens.map((token, idx) => {
                  if (idx === 0 || tokens[idx - 1] === ",") {
                    let result2 = token;
                    const localMatch = /:local\s*\((.+?)\)/.exec(token);
                    if (localMatch) {
                      const input2 = localMatch.input;
                      const matchPattern = localMatch[0];
                      const matchVal = localMatch[1];
                      const newVal = exportScopedName(matchVal);
                      result2 = input2.replace(matchPattern, newVal);
                    } else {
                      return token;
                    }
                    return result2;
                  } else {
                    return token;
                  }
                });
                decl.value = tokens.join("");
              });
            });
            root2.walkAtRules(/keyframes$/i, (atRule2) => {
              const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule2.params);
              if (!localMatch) {
                return;
              }
              atRule2.params = exportScopedName(localMatch[1]);
            });
            const exportedNames = Object.keys(exports2);
            if (exportedNames.length > 0) {
              const exportRule = rule2({ selector: ":export" });
              exportedNames.forEach(
                (exportedName) => exportRule.append({
                  prop: exportedName,
                  value: exports2[exportedName].join(" "),
                  raws: { before: "\n  " }
                })
              );
              root2.append(exportRule);
            }
          }
        };
      };
      plugin.postcss = true;
      plugin.generateScopedName = function(name2, path2) {
        const sanitisedPath = path2.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
        return `_${sanitisedPath}__${name2}`.trim();
      };
      plugin.generateExportEntry = function(name2, scopedName) {
        return {
          key: unescape$1(name2),
          value: unescape$1(scopedName)
        };
      };
      var src$1 = plugin;
      var src = { exports: {} };
      const ICSSUtils = src$3;
      const matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
      const matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
      const matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
      src.exports = (options2) => {
        let importIndex = 0;
        const createImportedName = options2 && options2.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
        return {
          postcssPlugin: "postcss-modules-values",
          prepare(result2) {
            const importAliases = [];
            const definitions = {};
            return {
              Once(root2, postcss2) {
                root2.walkAtRules(/value/i, (atRule2) => {
                  const matches = atRule2.params.match(matchImports);
                  if (matches) {
                    let [
                      ,
                      /*match*/
                      aliases,
                      path2
                    ] = matches;
                    if (definitions[path2]) {
                      path2 = definitions[path2];
                    }
                    const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias) => {
                      const tokens = matchImport.exec(alias);
                      if (tokens) {
                        const [
                          ,
                          /*match*/
                          theirName,
                          myName = theirName
                        ] = tokens;
                        const importedName = createImportedName(myName);
                        definitions[myName] = importedName;
                        return { theirName, importedName };
                      } else {
                        throw new Error(`@import statement "${alias}" is invalid!`);
                      }
                    });
                    importAliases.push({ path: path2, imports });
                    atRule2.remove();
                    return;
                  }
                  if (atRule2.params.indexOf("@value") !== -1) {
                    result2.warn("Invalid value definition: " + atRule2.params);
                  }
                  let [, key, value] = `${atRule2.params}${atRule2.raws.between}`.match(
                    matchValueDefinition
                  );
                  const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                  if (normalizedValue.length === 0) {
                    result2.warn("Invalid value definition: " + atRule2.params);
                    atRule2.remove();
                    return;
                  }
                  let isOnlySpace = /^\s+$/.test(normalizedValue);
                  if (!isOnlySpace) {
                    value = value.trim();
                  }
                  definitions[key] = ICSSUtils.replaceValueSymbols(
                    value,
                    definitions
                  );
                  atRule2.remove();
                });
                if (!Object.keys(definitions).length) {
                  return;
                }
                ICSSUtils.replaceSymbols(root2, definitions);
                const exportDeclarations = Object.keys(definitions).map(
                  (key) => postcss2.decl({
                    value: definitions[key],
                    prop: key,
                    raws: { before: "\n  " }
                  })
                );
                if (exportDeclarations.length > 0) {
                  const exportRule = postcss2.rule({
                    selector: ":export",
                    raws: { after: "\n" }
                  });
                  exportRule.append(exportDeclarations);
                  root2.prepend(exportRule);
                }
                importAliases.reverse().forEach(({ path: path2, imports }) => {
                  const importRule = postcss2.rule({
                    selector: `:import(${path2})`,
                    raws: { after: "\n" }
                  });
                  imports.forEach(({ theirName, importedName }) => {
                    importRule.append({
                      value: theirName,
                      prop: importedName,
                      raws: { before: "\n  " }
                    });
                  });
                  root2.prepend(importRule);
                });
              }
            };
          }
        };
      };
      src.exports.postcss = true;
      Object.defineProperty(behaviours$1, "__esModule", {
        value: true
      });
      behaviours$1.behaviours = void 0;
      behaviours$1.getDefaultPlugins = getDefaultPlugins;
      behaviours$1.isValidBehaviour = isValidBehaviour;
      var _postcssModulesLocalByDefault = src$4.exports;
      var _postcssModulesLocalByDefault2 = _interopRequireDefault$1(_postcssModulesLocalByDefault);
      var _postcssModulesExtractImports = src$2.exports;
      var _postcssModulesExtractImports2 = _interopRequireDefault$1(_postcssModulesExtractImports);
      var _postcssModulesScope = src$1;
      var _postcssModulesScope2 = _interopRequireDefault$1(_postcssModulesScope);
      var _postcssModulesValues = src.exports;
      var _postcssModulesValues2 = _interopRequireDefault$1(_postcssModulesValues);
      function _interopRequireDefault$1(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      const behaviours = behaviours$1.behaviours = {
        LOCAL: "local",
        GLOBAL: "global"
      };
      function getDefaultPlugins({
        behaviour,
        generateScopedName: generateScopedName2,
        exportGlobals
      }) {
        const scope2 = (0, _postcssModulesScope2.default)({ generateScopedName: generateScopedName2, exportGlobals });
        const plugins = {
          [behaviours.LOCAL]: [_postcssModulesValues2.default, _postcssModulesLocalByDefault2.default, _postcssModulesExtractImports2.default, scope2],
          [behaviours.GLOBAL]: [_postcssModulesValues2.default, _postcssModulesExtractImports2.default, scope2]
        };
        return plugins[behaviour];
      }
      function isValidBehaviour(behaviour) {
        return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
      }
      var _postcss = postcss_1;
      var _postcss2 = _interopRequireDefault(_postcss);
      var _lodash = _lodash_camelcase_4_3_0_lodash_camelcase;
      var _lodash2 = _interopRequireDefault(_lodash);
      var _genericNames = _genericNames_2_0_1_genericNames;
      var _genericNames2 = _interopRequireDefault(_genericNames);
      var _parser = parser$2;
      var _parser2 = _interopRequireDefault(_parser);
      var _loader = loader;
      var _loader2 = _interopRequireDefault(_loader);
      var _generateScopedName = generateScopedName$1;
      var _generateScopedName2 = _interopRequireDefault(_generateScopedName);
      var _saveJSON = saveJSON$1;
      var _saveJSON2 = _interopRequireDefault(_saveJSON);
      var _behaviours = behaviours$1;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _asyncToGenerator(fn) {
        return function() {
          var gen = fn.apply(this, arguments);
          return new Promise(function(resolve2, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error2) {
                reject(error2);
                return;
              }
              if (info.done) {
                resolve2(value);
              } else {
                return Promise.resolve(value).then(function(value2) {
                  step("next", value2);
                }, function(err) {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        };
      }
      const PLUGIN_NAME = "postcss-modules";
      function getDefaultScopeBehaviour(opts) {
        if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {
          return opts.scopeBehaviour;
        }
        return _behaviours.behaviours.LOCAL;
      }
      function getScopedNameGenerator(opts) {
        const scopedNameGenerator = opts.generateScopedName || _generateScopedName2.default;
        if (typeof scopedNameGenerator === "function")
          return scopedNameGenerator;
        return (0, _genericNames2.default)(scopedNameGenerator, {
          context: browser$1$1.cwd(),
          hashPrefix: opts.hashPrefix
        });
      }
      function getLoader(opts, plugins) {
        const root2 = typeof opts.root === "undefined" ? "/" : opts.root;
        return typeof opts.Loader === "function" ? new opts.Loader(root2, plugins) : new _loader2.default(root2, plugins);
      }
      function isGlobalModule(globalModules, inputFile) {
        return globalModules.some((regex2) => inputFile.match(regex2));
      }
      function getDefaultPluginsList(opts, inputFile) {
        const globalModulesList = opts.globalModulePaths || null;
        const exportGlobals = opts.exportGlobals || false;
        const defaultBehaviour = getDefaultScopeBehaviour(opts);
        const generateScopedName2 = getScopedNameGenerator(opts);
        if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
          return (0, _behaviours.getDefaultPlugins)({
            behaviour: _behaviours.behaviours.GLOBAL,
            generateScopedName: generateScopedName2,
            exportGlobals
          });
        }
        return (0, _behaviours.getDefaultPlugins)({
          behaviour: defaultBehaviour,
          generateScopedName: generateScopedName2,
          exportGlobals
        });
      }
      function isOurPlugin(plugin2) {
        return plugin2.postcssPlugin === PLUGIN_NAME;
      }
      function dashesCamelCase(string2) {
        return string2.replace(/-+(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
      }
      build.exports = (opts = {}) => {
        return {
          postcssPlugin: PLUGIN_NAME,
          OnceExit(css, { result: result2 }) {
            return _asyncToGenerator(function* () {
              const getJSON = opts.getJSON || _saveJSON2.default;
              const inputFile = css.source.input.file;
              const pluginList = getDefaultPluginsList(opts, inputFile);
              const resultPluginIndex = result2.processor.plugins.findIndex(function(plugin2) {
                return isOurPlugin(plugin2);
              });
              if (resultPluginIndex === -1) {
                throw new Error("Plugin missing from options.");
              }
              const earlierPlugins = result2.processor.plugins.slice(0, resultPluginIndex);
              const loaderPlugins = [...earlierPlugins, ...pluginList];
              const loader2 = getLoader(opts, loaderPlugins);
              const parser2 = new _parser2.default(loader2.fetch.bind(loader2));
              yield (0, _postcss2.default)([...pluginList, parser2.plugin()]).process(css, {
                from: inputFile
              });
              const out = loader2.finalSource;
              if (out)
                css.prepend(out);
              if (opts.localsConvention) {
                const isFunc = typeof opts.localsConvention === "function";
                parser2.exportTokens = Object.entries(parser2.exportTokens).reduce(function(tokens, [className2, value]) {
                  if (isFunc) {
                    tokens[opts.localsConvention(className2, value, inputFile)] = value;
                    return tokens;
                  }
                  switch (opts.localsConvention) {
                    case "camelCase":
                      tokens[className2] = value;
                      tokens[(0, _lodash2.default)(className2)] = value;
                      break;
                    case "camelCaseOnly":
                      tokens[(0, _lodash2.default)(className2)] = value;
                      break;
                    case "dashes":
                      tokens[className2] = value;
                      tokens[dashesCamelCase(className2)] = value;
                      break;
                    case "dashesOnly":
                      tokens[dashesCamelCase(className2)] = value;
                      break;
                  }
                  return tokens;
                }, {});
              }
              result2.messages.push({
                type: "export",
                plugin: "postcss-modules",
                exportTokens: parser2.exportTokens
              });
              return getJSON(css.source.input.file, parser2.exportTokens, result2.opts.to);
            })();
          }
        };
      };
      build.exports.postcss = true;
      Object.defineProperty(compilerSfc_cjs, "__esModule", { value: true });
      var CompilerDOM = require$$0$1;
      var sourceMap = sourceMap$2;
      var hash = hashSum;
      var path = require$$3;
      var compilerCore = require$$4;
      var url = require$$5;
      var shared = require$$6;
      var CompilerSSR = compilerSsr_cjs;
      var postcss = postcss_1;
      var selectorParser = dist$2.exports;
      var merge = _mergeSourceMap_1_1_0_mergeSourceMap;
      var MagicString = require$$11;
      var parser = lib$3;
      var estreeWalker = estreeWalker$1.exports;
      function _interopDefaultLegacy$1(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      function _interopNamespace$1(e) {
        if (e && e.__esModule)
          return e;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            n2[k] = e[k];
          });
        }
        n2["default"] = e;
        return Object.freeze(n2);
      }
      var CompilerDOM__namespace = _interopNamespace$1(CompilerDOM);
      var hash__default = _interopDefaultLegacy$1(hash);
      var path__default = _interopDefaultLegacy$1(path);
      var CompilerSSR__namespace = _interopNamespace$1(CompilerSSR);
      var postcss__default = _interopDefaultLegacy$1(postcss);
      var selectorParser__default = _interopDefaultLegacy$1(selectorParser);
      var merge__default = _interopDefaultLegacy$1(merge);
      var MagicString__default = _interopDefaultLegacy$1(MagicString);
      const CSS_VARS_HELPER = `useCssVars`;
      const cssVarRE = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([^'"][^)]*))\s*\)/g;
      function genCssVarsFromList(vars, id2, isProd) {
        return `{
  ${vars.map((key) => `"${genVarName(id2, key, isProd)}": (${key})`).join(",\n  ")}
}`;
      }
      function genVarName(id2, raw, isProd) {
        if (isProd) {
          return hash__default(id2 + raw);
        } else {
          return `${id2}-${raw.replace(/([^\w-])/g, "_")}`;
        }
      }
      function parseCssVars(sfc) {
        const vars = [];
        sfc.styles.forEach((style) => {
          let match;
          while (match = cssVarRE.exec(style.content)) {
            vars.push(match[1] || match[2] || match[3]);
          }
        });
        return vars;
      }
      const cssVarsPlugin = (opts) => {
        const { id: id2, isProd } = opts;
        return {
          postcssPlugin: "vue-sfc-vars",
          Declaration(decl) {
            if (cssVarRE.test(decl.value)) {
              decl.value = decl.value.replace(cssVarRE, (_, $1, $2, $3) => {
                return `var(--${genVarName(id2, $1 || $2 || $3, isProd)})`;
              });
            }
          }
        };
      };
      cssVarsPlugin.postcss = true;
      function genCssVarsCode(vars, bindings, id2, isProd) {
        const varsExp = genCssVarsFromList(vars, id2, isProd);
        const exp2 = CompilerDOM.createSimpleExpression(varsExp, false);
        const context = CompilerDOM.createTransformContext(CompilerDOM.createRoot([]), {
          prefixIdentifiers: true,
          inline: true,
          bindingMetadata: bindings
        });
        const transformed = CompilerDOM.processExpression(exp2, context);
        const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c) => {
          return typeof c === "string" ? c : c.content;
        }).join("");
        return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
      }
      function genNormalScriptCssVarsCode(cssVars, bindings, id2, isProd) {
        return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(cssVars, bindings, id2, isProd)}}
const __setup__ = __default__.setup
__default__.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
      }
      const hasWarned = {};
      function warnOnce(msg) {
        const isNodeProd = typeof browser$1$1 !== "undefined" && browser$1$1.env.NODE_ENV === "production";
        if (!isNodeProd && true && !hasWarned[msg]) {
          hasWarned[msg] = true;
          warn(msg);
        }
      }
      function warn(msg) {
        console.warn(`\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${msg}\x1B[0m
`);
      }
      function warnExperimental(feature, rfcId) {
        if (typeof window !== "undefined") {
          return;
        }
        warnOnce(`${feature} is still an experimental proposal.
Follow its status at https://github.com/vuejs/rfcs/pull/${rfcId}.`);
        warnOnce(`When using experimental features,
it is recommended to pin your vue dependencies to exact versions to avoid breakage.`);
      }
      const SFC_CACHE_MAX_SIZE = 500;
      const sourceToSFC = new _lruCache_5_1_1_lruCache(SFC_CACHE_MAX_SIZE);
      function parse$2(source, { sourceMap: sourceMap2 = true, filename = "anonymous.vue", sourceRoot = "", pad: pad2 = false, compiler = CompilerDOM__namespace } = {}) {
        const sourceKey = source + sourceMap2 + filename + sourceRoot + pad2 + compiler.parse;
        const cache = sourceToSFC.get(sourceKey);
        if (cache) {
          return cache;
        }
        const descriptor = {
          filename,
          source,
          template: null,
          script: null,
          scriptSetup: null,
          styles: [],
          customBlocks: [],
          cssVars: [],
          slotted: false
        };
        const errors2 = [];
        const ast = compiler.parse(source, {
          // there are no components at SFC parsing level
          isNativeTag: () => true,
          // preserve all whitespaces
          isPreTag: () => true,
          getTextMode: ({ tag: tag2, props }, parent) => {
            if (!parent && tag2 !== "template" || // <template lang="xxx"> should also be treated as raw text
            tag2 === "template" && props.some((p) => p.type === 6 && p.name === "lang" && p.value && p.value.content && p.value.content !== "html")) {
              return 2;
            } else {
              return 0;
            }
          },
          onError: (e) => {
            errors2.push(e);
          }
        });
        ast.children.forEach((node2) => {
          if (node2.type !== 1) {
            return;
          }
          if (!node2.children.length && !hasSrc(node2) && node2.tag !== "template") {
            return;
          }
          switch (node2.tag) {
            case "template":
              if (!descriptor.template) {
                const templateBlock = descriptor.template = createBlock(node2, source, false);
                templateBlock.ast = node2;
              } else {
                errors2.push(createDuplicateBlockError(node2));
              }
              break;
            case "script":
              const scriptBlock = createBlock(node2, source, pad2);
              const isSetup = !!scriptBlock.attrs.setup;
              if (isSetup && !descriptor.scriptSetup) {
                descriptor.scriptSetup = scriptBlock;
                break;
              }
              if (!isSetup && !descriptor.script) {
                descriptor.script = scriptBlock;
                break;
              }
              errors2.push(createDuplicateBlockError(node2, isSetup));
              break;
            case "style":
              const styleBlock = createBlock(node2, source, pad2);
              if (styleBlock.attrs.vars) {
                errors2.push(new SyntaxError(`<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`));
              }
              descriptor.styles.push(styleBlock);
              break;
            default:
              descriptor.customBlocks.push(createBlock(node2, source, pad2));
              break;
          }
        });
        if (descriptor.scriptSetup) {
          if (descriptor.scriptSetup.src) {
            errors2.push(new SyntaxError(`<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`));
            descriptor.scriptSetup = null;
          }
          if (descriptor.script && descriptor.script.src) {
            errors2.push(new SyntaxError(`<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`));
            descriptor.script = null;
          }
        }
        if (sourceMap2) {
          const genMap = (block) => {
            if (block && !block.src) {
              block.map = generateSourceMap(filename, source, block.content, sourceRoot, !pad2 || block.type === "template" ? block.loc.start.line - 1 : 0);
            }
          };
          genMap(descriptor.template);
          genMap(descriptor.script);
          descriptor.styles.forEach(genMap);
          descriptor.customBlocks.forEach(genMap);
        }
        descriptor.cssVars = parseCssVars(descriptor);
        if (descriptor.cssVars.length) {
          warnExperimental(`v-bind() CSS variable injection`, 231);
        }
        const slottedRE = /(?:::v-|:)slotted\(/;
        descriptor.slotted = descriptor.styles.some((s) => s.scoped && slottedRE.test(s.content));
        const result2 = {
          descriptor,
          errors: errors2
        };
        sourceToSFC.set(sourceKey, result2);
        return result2;
      }
      function createDuplicateBlockError(node2, isScriptSetup = false) {
        const err = new SyntaxError(`Single file component can contain only one <${node2.tag}${isScriptSetup ? ` setup` : ``}> element`);
        err.loc = node2.loc;
        return err;
      }
      function createBlock(node2, source, pad2) {
        const type2 = node2.tag;
        let { start, end } = node2.loc;
        let content = "";
        if (node2.children.length) {
          start = node2.children[0].loc.start;
          end = node2.children[node2.children.length - 1].loc.end;
          content = source.slice(start.offset, end.offset);
        }
        const loc = {
          source: content,
          start,
          end
        };
        const attrs = {};
        const block = {
          type: type2,
          content,
          loc,
          attrs
        };
        if (pad2) {
          block.content = padContent(source, block, pad2) + block.content;
        }
        node2.props.forEach((p) => {
          if (p.type === 6) {
            attrs[p.name] = p.value ? p.value.content || true : true;
            if (p.name === "lang") {
              block.lang = p.value && p.value.content;
            } else if (p.name === "src") {
              block.src = p.value && p.value.content;
            } else if (type2 === "style") {
              if (p.name === "scoped") {
                block.scoped = true;
              } else if (p.name === "module") {
                block.module = attrs[p.name];
              }
            } else if (type2 === "script" && p.name === "setup") {
              block.setup = attrs.setup;
            }
          }
        });
        return block;
      }
      const splitRE = /\r?\n/g;
      const emptyRE = /^(?:\/\/)?\s*$/;
      const replaceRE = /./g;
      function generateSourceMap(filename, source, generated, sourceRoot, lineOffset) {
        const map2 = new sourceMap.SourceMapGenerator({
          file: filename.replace(/\\/g, "/"),
          sourceRoot: sourceRoot.replace(/\\/g, "/")
        });
        map2.setSourceContent(filename, source);
        generated.split(splitRE).forEach((line, index) => {
          if (!emptyRE.test(line)) {
            const originalLine = index + 1 + lineOffset;
            const generatedLine = index + 1;
            for (let i2 = 0; i2 < line.length; i2++) {
              if (!/\s/.test(line[i2])) {
                map2.addMapping({
                  source: filename,
                  original: {
                    line: originalLine,
                    column: i2
                  },
                  generated: {
                    line: generatedLine,
                    column: i2
                  }
                });
              }
            }
          }
        });
        return JSON.parse(map2.toString());
      }
      function padContent(content, block, pad2) {
        content = content.slice(0, block.loc.start.offset);
        if (pad2 === "space") {
          return content.replace(replaceRE, " ");
        } else {
          const offset = content.split(splitRE).length;
          const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
          return Array(offset).join(padChar);
        }
      }
      function hasSrc(node2) {
        return node2.props.some((p) => {
          if (p.type !== 6) {
            return false;
          }
          return p.name === "src";
        });
      }
      function isRelativeUrl(url2) {
        const firstChar = url2.charAt(0);
        return firstChar === "." || firstChar === "~" || firstChar === "@";
      }
      const externalRE = /^https?:\/\//;
      function isExternalUrl(url2) {
        return externalRE.test(url2);
      }
      const dataUrlRE = /^\s*data:/i;
      function isDataUrl(url2) {
        return dataUrlRE.test(url2);
      }
      function parseUrl(url2) {
        const firstChar = url2.charAt(0);
        if (firstChar === "~") {
          const secondChar = url2.charAt(1);
          url2 = url2.slice(secondChar === "/" ? 2 : 1);
        }
        return parseUriParts(url2);
      }
      function parseUriParts(urlString) {
        return url.parse(shared.isString(urlString) ? urlString : "", false, true);
      }
      const defaultAssetUrlOptions = {
        base: null,
        includeAbsolute: false,
        tags: {
          video: ["src", "poster"],
          source: ["src"],
          img: ["src"],
          image: ["xlink:href", "href"],
          use: ["xlink:href", "href"]
        }
      };
      const normalizeOptions = (options2) => {
        if (Object.keys(options2).some((key) => shared.isArray(options2[key]))) {
          return {
            ...defaultAssetUrlOptions,
            tags: options2
          };
        }
        return {
          ...defaultAssetUrlOptions,
          ...options2
        };
      };
      const createAssetUrlTransformWithOptions = (options2) => {
        return (node2, context) => transformAssetUrl(node2, context, options2);
      };
      const transformAssetUrl = (node2, context, options2 = defaultAssetUrlOptions) => {
        if (node2.type === 1) {
          if (!node2.props.length) {
            return;
          }
          const tags = options2.tags || defaultAssetUrlOptions.tags;
          const attrs = tags[node2.tag];
          const wildCardAttrs = tags["*"];
          if (!attrs && !wildCardAttrs) {
            return;
          }
          const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
          node2.props.forEach((attr, index) => {
            if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options2.includeAbsolute && !isRelativeUrl(attr.value.content)) {
              return;
            }
            const url2 = parseUrl(attr.value.content);
            if (options2.base && attr.value.content[0] === ".") {
              const base2 = parseUrl(options2.base);
              const protocol = base2.protocol || "";
              const host = base2.host ? protocol + "//" + base2.host : "";
              const basePath = base2.path || "/";
              attr.value.content = host + (path__default.posix || path__default).join(basePath, url2.path + (url2.hash || ""));
              return;
            }
            const exp2 = getImportsExpressionExp(url2.path, url2.hash, attr.loc, context);
            node2.props[index] = {
              type: 7,
              name: "bind",
              arg: compilerCore.createSimpleExpression(attr.name, true, attr.loc),
              exp: exp2,
              modifiers: [],
              loc: attr.loc
            };
          });
        }
      };
      function getImportsExpressionExp(path2, hash2, loc, context) {
        if (path2) {
          const existing = context.imports.find((i2) => i2.path === path2);
          if (existing) {
            return existing.exp;
          }
          const name2 = `_imports_${context.imports.length}`;
          const exp2 = compilerCore.createSimpleExpression(
            name2,
            false,
            loc,
            2
            /* CAN_HOIST */
          );
          context.imports.push({ exp: exp2, path: path2 });
          if (hash2 && path2) {
            return context.hoist(compilerCore.createSimpleExpression(
              `${name2} + '${hash2}'`,
              false,
              loc,
              2
              /* CAN_HOIST */
            ));
          } else {
            return exp2;
          }
        } else {
          return compilerCore.createSimpleExpression(
            `''`,
            false,
            loc,
            2
            /* CAN_HOIST */
          );
        }
      }
      const srcsetTags = ["img", "source"];
      const escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
      const createSrcsetTransformWithOptions = (options2) => {
        return (node2, context) => transformSrcset(node2, context, options2);
      };
      const transformSrcset = (node2, context, options2 = defaultAssetUrlOptions) => {
        if (node2.type === 1) {
          if (srcsetTags.includes(node2.tag) && node2.props.length) {
            node2.props.forEach((attr, index) => {
              if (attr.name === "srcset" && attr.type === 6) {
                if (!attr.value)
                  return;
                const value = attr.value.content;
                if (!value)
                  return;
                const imageCandidates = value.split(",").map((s) => {
                  const [url2, descriptor] = s.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
                  return { url: url2, descriptor };
                });
                for (let i2 = 0; i2 < imageCandidates.length; i2++) {
                  const { url: url2 } = imageCandidates[i2];
                  if (isDataUrl(url2)) {
                    imageCandidates[i2 + 1].url = url2 + "," + imageCandidates[i2 + 1].url;
                    imageCandidates.splice(i2, 1);
                  }
                }
                const hasQualifiedUrl = imageCandidates.some(({ url: url2 }) => {
                  return !isExternalUrl(url2) && !isDataUrl(url2) && (options2.includeAbsolute || isRelativeUrl(url2));
                });
                if (!hasQualifiedUrl) {
                  return;
                }
                if (options2.base) {
                  const base2 = options2.base;
                  const set = [];
                  imageCandidates.forEach(({ url: url2, descriptor }) => {
                    descriptor = descriptor ? ` ${descriptor}` : ``;
                    if (isRelativeUrl(url2)) {
                      set.push((path__default.posix || path__default).join(base2, url2) + descriptor);
                    } else {
                      set.push(url2 + descriptor);
                    }
                  });
                  attr.value.content = set.join(", ");
                  return;
                }
                const compoundExpression = compilerCore.createCompoundExpression([], attr.loc);
                imageCandidates.forEach(({ url: url2, descriptor }, index2) => {
                  if (!isExternalUrl(url2) && !isDataUrl(url2) && (options2.includeAbsolute || isRelativeUrl(url2))) {
                    const { path: path2 } = parseUrl(url2);
                    let exp2;
                    if (path2) {
                      const existingImportsIndex = context.imports.findIndex((i2) => i2.path === path2);
                      if (existingImportsIndex > -1) {
                        exp2 = compilerCore.createSimpleExpression(
                          `_imports_${existingImportsIndex}`,
                          false,
                          attr.loc,
                          2
                          /* CAN_HOIST */
                        );
                      } else {
                        exp2 = compilerCore.createSimpleExpression(
                          `_imports_${context.imports.length}`,
                          false,
                          attr.loc,
                          2
                          /* CAN_HOIST */
                        );
                        context.imports.push({ exp: exp2, path: path2 });
                      }
                      compoundExpression.children.push(exp2);
                    }
                  } else {
                    const exp2 = compilerCore.createSimpleExpression(
                      `"${url2}"`,
                      false,
                      attr.loc,
                      2
                      /* CAN_HOIST */
                    );
                    compoundExpression.children.push(exp2);
                  }
                  const isNotLast = imageCandidates.length - 1 > index2;
                  if (descriptor && isNotLast) {
                    compoundExpression.children.push(` + ' ${descriptor}, ' + `);
                  } else if (descriptor) {
                    compoundExpression.children.push(` + ' ${descriptor}'`);
                  } else if (isNotLast) {
                    compoundExpression.children.push(` + ', ' + `);
                  }
                });
                const hoisted = context.hoist(compoundExpression);
                hoisted.constType = 2;
                node2.props[index] = {
                  type: 7,
                  name: "bind",
                  arg: compilerCore.createSimpleExpression("srcset", true, attr.loc),
                  exp: hoisted,
                  modifiers: [],
                  loc: attr.loc
                };
              }
            });
          }
        }
      };
      function preprocess({ source, filename, preprocessOptions }, preprocessor) {
        let res = "";
        let err = null;
        preprocessor.render(source, { filename, ...preprocessOptions }, (_err, _res) => {
          if (_err)
            err = _err;
          res = _res;
        });
        if (err)
          throw err;
        return res;
      }
      function compileTemplate(options2) {
        const { preprocessLang, preprocessCustomRequire } = options2;
        const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : {} : false;
        if (preprocessor) {
          try {
            return doCompileTemplate({
              ...options2,
              source: preprocess(options2, preprocessor)
            });
          } catch (e) {
            return {
              code: `export default function render() {}`,
              source: options2.source,
              tips: [],
              errors: [e]
            };
          }
        } else if (preprocessLang) {
          return {
            code: `export default function render() {}`,
            source: options2.source,
            tips: [
              `Component ${options2.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
            ],
            errors: [
              `Component ${options2.filename} uses lang ${preprocessLang} for template, however it is not installed.`
            ]
          };
        } else {
          return doCompileTemplate(options2);
        }
      }
      function doCompileTemplate({ filename, id: id2, scoped, slotted, inMap, source, ssr = false, ssrCssVars, isProd = false, compiler = ssr ? CompilerSSR__namespace : CompilerDOM__namespace, compilerOptions = {}, transformAssetUrls }) {
        const errors2 = [];
        let nodeTransforms = [];
        if (shared.isObject(transformAssetUrls)) {
          const assetOptions = normalizeOptions(transformAssetUrls);
          nodeTransforms = [
            createAssetUrlTransformWithOptions(assetOptions),
            createSrcsetTransformWithOptions(assetOptions)
          ];
        } else if (transformAssetUrls !== false) {
          nodeTransforms = [transformAssetUrl, transformSrcset];
        }
        if (ssr && !ssrCssVars) {
          warnOnce(`compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.\`.`);
        }
        if (!id2) {
          warnOnce(`compileTemplate now requires the \`id\` option.\`.`);
          id2 = "";
        }
        const shortId = id2.replace(/^data-v-/, "");
        const longId = `data-v-${shortId}`;
        let { code: code2, ast, preamble, map: map2 } = compiler.compile(source, {
          mode: "module",
          prefixIdentifiers: true,
          hoistStatic: true,
          cacheHandlers: true,
          ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd) : "",
          scopeId: scoped ? longId : void 0,
          slotted,
          ...compilerOptions,
          nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
          filename,
          sourceMap: true,
          onError: (e) => errors2.push(e)
        });
        if (inMap) {
          if (map2) {
            map2 = mapLines(inMap, map2);
          }
          if (errors2.length) {
            patchErrors(errors2, source, inMap);
          }
        }
        return { code: code2, ast, preamble, source, errors: errors2, tips: [], map: map2 };
      }
      function mapLines(oldMap, newMap) {
        if (!oldMap)
          return newMap;
        if (!newMap)
          return oldMap;
        const oldMapConsumer = new sourceMap.SourceMapConsumer(oldMap);
        const newMapConsumer = new sourceMap.SourceMapConsumer(newMap);
        const mergedMapGenerator = new sourceMap.SourceMapGenerator();
        newMapConsumer.eachMapping((m) => {
          if (m.originalLine == null) {
            return;
          }
          const origPosInOldMap = oldMapConsumer.originalPositionFor({
            line: m.originalLine,
            column: m.originalColumn
          });
          if (origPosInOldMap.source == null) {
            return;
          }
          mergedMapGenerator.addMapping({
            generated: {
              line: m.generatedLine,
              column: m.generatedColumn
            },
            original: {
              line: origPosInOldMap.line,
              // use current column, since the oldMap produced by @vue/compiler-sfc
              // does not
              column: m.originalColumn
            },
            source: origPosInOldMap.source,
            name: origPosInOldMap.name
          });
        });
        const generator = mergedMapGenerator;
        oldMapConsumer.sources.forEach((sourceFile) => {
          generator._sources.add(sourceFile);
          const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
          if (sourceContent != null) {
            mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
          }
        });
        generator._sourceRoot = oldMap.sourceRoot;
        generator._file = oldMap.file;
        return generator.toJSON();
      }
      function patchErrors(errors2, source, inMap) {
        const originalSource = inMap.sourcesContent[0];
        const offset = originalSource.indexOf(source);
        const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
        errors2.forEach((err) => {
          if (err.loc) {
            err.loc.start.line += lineOffset;
            err.loc.start.offset += offset;
            if (err.loc.end !== err.loc.start) {
              err.loc.end.line += lineOffset;
              err.loc.end.offset += offset;
            }
          }
        });
      }
      const trimPlugin = () => {
        return {
          postcssPlugin: "vue-sfc-trim",
          Once(root2) {
            root2.walk(({ type: type2, raws }) => {
              if (type2 === "rule" || type2 === "atrule") {
                if (raws.before)
                  raws.before = "\n";
                if ("after" in raws && raws.after)
                  raws.after = "\n";
              }
            });
          }
        };
      };
      trimPlugin.postcss = true;
      const animationNameRE = /^(-\w+-)?animation-name$/;
      const animationRE = /^(-\w+-)?animation$/;
      const scopedPlugin = (id2 = "") => {
        const keyframes = /* @__PURE__ */ Object.create(null);
        const shortId = id2.replace(/^data-v-/, "");
        return {
          postcssPlugin: "vue-sfc-scoped",
          Rule(rule2) {
            processRule(id2, rule2);
          },
          AtRule(node2) {
            if (/-?keyframes$/.test(node2.name) && !node2.params.endsWith(`-${shortId}`)) {
              keyframes[node2.params] = node2.params = node2.params + "-" + shortId;
            }
          },
          OnceExit(root2) {
            if (Object.keys(keyframes).length) {
              root2.walkDecls((decl) => {
                if (animationNameRE.test(decl.prop)) {
                  decl.value = decl.value.split(",").map((v2) => keyframes[v2.trim()] || v2.trim()).join(",");
                }
                if (animationRE.test(decl.prop)) {
                  decl.value = decl.value.split(",").map((v2) => {
                    const vals = v2.trim().split(/\s+/);
                    const i2 = vals.findIndex((val) => keyframes[val]);
                    if (i2 !== -1) {
                      vals.splice(i2, 1, keyframes[vals[i2]]);
                      return vals.join(" ");
                    } else {
                      return v2;
                    }
                  }).join(",");
                }
              });
            }
          }
        };
      };
      const processedRules = /* @__PURE__ */ new WeakSet();
      function processRule(id2, rule2) {
        if (processedRules.has(rule2) || rule2.parent && rule2.parent.type === "atrule" && /-?keyframes$/.test(rule2.parent.name)) {
          return;
        }
        processedRules.add(rule2);
        rule2.selector = selectorParser__default((selectorRoot) => {
          selectorRoot.each((selector2) => {
            rewriteSelector(id2, selector2, selectorRoot);
          });
        }).processSync(rule2.selector);
      }
      function rewriteSelector(id2, selector2, selectorRoot, slotted = false) {
        let node2 = null;
        let shouldInject = true;
        selector2.each((n2) => {
          if (n2.type === "combinator" && (n2.value === ">>>" || n2.value === "/deep/")) {
            n2.value = " ";
            n2.spaces.before = n2.spaces.after = "";
            warn(`the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`);
            return false;
          }
          if (n2.type === "pseudo") {
            const { value } = n2;
            if (value === ":deep" || value === "::v-deep") {
              if (n2.nodes.length) {
                let last2 = n2;
                n2.nodes[0].each((ss) => {
                  selector2.insertAfter(last2, ss);
                  last2 = ss;
                });
                const prev = selector2.at(selector2.index(n2) - 1);
                if (!prev || !isSpaceCombinator(prev)) {
                  selector2.insertAfter(n2, selectorParser__default.combinator({
                    value: " "
                  }));
                }
                selector2.removeChild(n2);
              } else {
                warn(`::v-deep usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead.`);
                const prev = selector2.at(selector2.index(n2) - 1);
                if (prev && isSpaceCombinator(prev)) {
                  selector2.removeChild(prev);
                }
                selector2.removeChild(n2);
              }
              return false;
            }
            if (value === ":slotted" || value === "::v-slotted") {
              rewriteSelector(
                id2,
                n2.nodes[0],
                selectorRoot,
                true
                /* slotted */
              );
              let last2 = n2;
              n2.nodes[0].each((ss) => {
                selector2.insertAfter(last2, ss);
                last2 = ss;
              });
              selector2.removeChild(n2);
              shouldInject = false;
              return false;
            }
            if (value === ":global" || value === "::v-global") {
              selectorRoot.insertAfter(selector2, n2.nodes[0]);
              selectorRoot.removeChild(selector2);
              return false;
            }
          }
          if (n2.type !== "pseudo" && n2.type !== "combinator") {
            node2 = n2;
          }
        });
        if (node2) {
          node2.spaces.after = "";
        } else {
          selector2.first.spaces.before = "";
        }
        if (shouldInject) {
          const idToAdd = slotted ? id2 + "-s" : id2;
          selector2.insertAfter(
            // If node is null it means we need to inject [id] at the start
            // insertAfter can handle `null` here
            node2,
            selectorParser__default.attribute({
              attribute: idToAdd,
              value: idToAdd,
              raws: {},
              quoteMark: `"`
            })
          );
        }
      }
      function isSpaceCombinator(node2) {
        return node2.type === "combinator" && /^\s+$/.test(node2.value);
      }
      scopedPlugin.postcss = true;
      const scss = (source, map2, options2, load) => {
        const nodeSass = load("sass");
        const finalOptions = {
          ...options2,
          data: getSource(source, options2.filename, options2.additionalData),
          file: options2.filename,
          outFile: options2.filename,
          sourceMap: !!map2
        };
        try {
          const result2 = nodeSass.renderSync(finalOptions);
          const dependencies2 = result2.stats.includedFiles;
          if (map2) {
            return {
              code: result2.css.toString(),
              map: merge__default(map2, JSON.parse(result2.map.toString())),
              errors: [],
              dependencies: dependencies2
            };
          }
          return { code: result2.css.toString(), errors: [], dependencies: dependencies2 };
        } catch (e) {
          return { code: "", errors: [e], dependencies: [] };
        }
      };
      const sass = (source, map2, options2, load) => scss(source, map2, {
        ...options2,
        indentedSyntax: true
      }, load);
      const less = (source, map2, options2, load) => {
        const nodeLess = load("less");
        let result2;
        let error2 = null;
        nodeLess.render(getSource(source, options2.filename, options2.additionalData), { ...options2, syncImport: true }, (err, output) => {
          error2 = err;
          result2 = output;
        });
        if (error2)
          return { code: "", errors: [error2], dependencies: [] };
        const dependencies2 = result2.imports;
        if (map2) {
          return {
            code: result2.css.toString(),
            map: merge__default(map2, result2.map),
            errors: [],
            dependencies: dependencies2
          };
        }
        return {
          code: result2.css.toString(),
          errors: [],
          dependencies: dependencies2
        };
      };
      const styl = (source, map2, options2, load) => {
        const nodeStylus = load("stylus");
        try {
          const ref = nodeStylus(source);
          Object.keys(options2).forEach((key) => ref.set(key, options2[key]));
          if (map2)
            ref.set("sourcemap", { inline: false, comment: false });
          const result2 = ref.render();
          const dependencies2 = ref.deps();
          if (map2) {
            return {
              code: result2,
              map: merge__default(map2, ref.sourcemap),
              errors: [],
              dependencies: dependencies2
            };
          }
          return { code: result2, errors: [], dependencies: dependencies2 };
        } catch (e) {
          return { code: "", errors: [e], dependencies: [] };
        }
      };
      function getSource(source, filename, additionalData) {
        if (!additionalData)
          return source;
        if (shared.isFunction(additionalData)) {
          return additionalData(source, filename);
        }
        return additionalData + source;
      }
      const processors = {
        less,
        sass,
        scss,
        styl,
        stylus: styl
      };
      function compileStyle(options2) {
        return doCompileStyle({
          ...options2,
          isAsync: false
        });
      }
      function compileStyleAsync(options2) {
        return doCompileStyle({ ...options2, isAsync: true });
      }
      function doCompileStyle(options2) {
        const { filename, id: id2, scoped = false, trim: trim2 = true, isProd = false, modules = false, modulesOptions = {}, preprocessLang, postcssOptions, postcssPlugins } = options2;
        const preprocessor = preprocessLang && processors[preprocessLang];
        const preProcessedSource = preprocessor && preprocess$1(options2, preprocessor);
        const map2 = preProcessedSource ? preProcessedSource.map : options2.inMap || options2.map;
        const source = preProcessedSource ? preProcessedSource.code : options2.source;
        const shortId = id2.replace(/^data-v-/, "");
        const longId = `data-v-${shortId}`;
        const plugins = (postcssPlugins || []).slice();
        plugins.unshift(cssVarsPlugin({ id: shortId, isProd }));
        if (trim2) {
          plugins.push(trimPlugin());
        }
        if (scoped) {
          plugins.push(scopedPlugin(longId));
        }
        let cssModules;
        if (modules) {
          if (!options2.isAsync) {
            throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
          }
          plugins.push(build.exports({
            ...modulesOptions,
            getJSON: (_cssFileName, json) => {
              cssModules = json;
            }
          }));
        }
        const postCSSOptions = {
          ...postcssOptions,
          to: filename,
          from: filename
        };
        if (map2) {
          postCSSOptions.map = {
            inline: false,
            annotation: false,
            prev: map2
          };
        }
        let result2;
        let code2;
        let outMap;
        const dependencies2 = new Set(preProcessedSource ? preProcessedSource.dependencies : []);
        dependencies2.delete(filename);
        const errors2 = [];
        if (preProcessedSource && preProcessedSource.errors.length) {
          errors2.push(...preProcessedSource.errors);
        }
        const recordPlainCssDependencies = (messages) => {
          messages.forEach((msg) => {
            if (msg.type === "dependency") {
              dependencies2.add(msg.file);
            }
          });
          return dependencies2;
        };
        try {
          result2 = postcss__default(plugins).process(source, postCSSOptions);
          if (options2.isAsync) {
            return result2.then((result3) => ({
              code: result3.css || "",
              map: result3.map && result3.map.toJSON(),
              errors: errors2,
              modules: cssModules,
              rawResult: result3,
              dependencies: recordPlainCssDependencies(result3.messages)
            })).catch((error2) => ({
              code: "",
              map: void 0,
              errors: [...errors2, error2],
              rawResult: void 0,
              dependencies: dependencies2
            }));
          }
          recordPlainCssDependencies(result2.messages);
          code2 = result2.css;
          outMap = result2.map;
        } catch (e) {
          errors2.push(e);
        }
        return {
          code: code2 || ``,
          map: outMap && outMap.toJSON(),
          errors: errors2,
          rawResult: result2,
          dependencies: dependencies2
        };
      }
      function preprocess$1(options2, preprocessor) {
        return preprocessor(options2.source, options2.inMap || options2.map, {
          filename: options2.filename,
          ...options2.preprocessOptions
        }, options2.preprocessCustomRequire);
      }
      const defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/;
      const namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/;
      const exportDefaultClassRE = /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/;
      function rewriteDefault(input2, as, parserPlugins) {
        if (!hasDefaultExport(input2)) {
          return input2 + `
const ${as} = {}`;
        }
        let replaced;
        const classMatch = input2.match(exportDefaultClassRE);
        if (classMatch) {
          replaced = input2.replace(exportDefaultClassRE, "$1class $2") + `
const ${as} = ${classMatch[2]}`;
        } else {
          replaced = input2.replace(defaultExportRE, `$1const ${as} =`);
        }
        if (!hasDefaultExport(replaced)) {
          return replaced;
        }
        const s = new MagicString__default(input2);
        const ast = parser.parse(input2, {
          sourceType: "module",
          plugins: parserPlugins
        }).program.body;
        ast.forEach((node2) => {
          if (node2.type === "ExportDefaultDeclaration") {
            s.overwrite(node2.start, node2.declaration.start, `const ${as} = `);
          }
          if (node2.type === "ExportNamedDeclaration") {
            node2.specifiers.forEach((specifier) => {
              if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === "default") {
                const end = specifier.end;
                s.overwrite(specifier.start, input2.charAt(end) === "," ? end + 1 : end, ``);
                s.append(`
const ${as} = ${specifier.local.name}`);
              }
            });
          }
        });
        return s.toString();
      }
      function hasDefaultExport(input2) {
        return defaultExportRE.test(input2) || namedDefaultExportRE.test(input2);
      }
      const DEFINE_PROPS = "defineProps";
      const DEFINE_EMIT = "defineEmit";
      function compileScript(sfc, options2) {
        const { script, scriptSetup, source, filename } = sfc;
        if (scriptSetup) {
          warnExperimental(`<script setup>`, 227);
        }
        if (!options2) {
          options2 = { id: "" };
        }
        if (!options2.id) {
          warnOnce(`compileScript now requires passing the \`id\` option.
Upgrade your vite or vue-loader version for compatibility with the latest experimental proposals.`);
        }
        const scopeId = options2.id ? options2.id.replace(/^data-v-/, "") : "";
        const cssVars = sfc.cssVars;
        const hasInheritAttrsFlag = sfc.template && sfc.template.attrs["inherit-attrs"] === "false";
        const scriptLang = script && script.lang;
        const scriptSetupLang = scriptSetup && scriptSetup.lang;
        const isTS = scriptLang === "ts" || scriptSetupLang === "ts";
        const plugins = [...shared.babelParserDefaultPlugins, "jsx"];
        if (options2.babelParserPlugins)
          plugins.push(...options2.babelParserPlugins);
        if (isTS)
          plugins.push("typescript", "decorators-legacy");
        if (!scriptSetup) {
          if (!script) {
            throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);
          }
          if (scriptLang && scriptLang !== "ts") {
            return script;
          }
          try {
            const scriptAst2 = parser.parse(script.content, {
              plugins,
              sourceType: "module"
            }).program.body;
            const bindings = analyzeScriptBindings(scriptAst2);
            const needRewrite = cssVars.length || hasInheritAttrsFlag;
            let content = script.content;
            if (needRewrite) {
              content = rewriteDefault(content, `__default__`, plugins);
              if (cssVars.length) {
                content += genNormalScriptCssVarsCode(cssVars, bindings, scopeId, !!options2.isProd);
              }
              if (hasInheritAttrsFlag) {
                content += `__default__.inheritAttrs = false`;
              }
              content += `
export default __default__`;
            }
            return {
              ...script,
              content,
              bindings,
              scriptAst: scriptAst2
            };
          } catch (e) {
            return script;
          }
        }
        if (script && scriptLang !== scriptSetupLang) {
          throw new Error(`[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`);
        }
        if (scriptSetupLang && scriptSetupLang !== "ts") {
          return scriptSetup;
        }
        const defaultTempVar = `__default__`;
        const bindingMetadata = {};
        const helperImports = /* @__PURE__ */ new Set();
        const userImports = /* @__PURE__ */ Object.create(null);
        const userImportAlias = /* @__PURE__ */ Object.create(null);
        const setupBindings = /* @__PURE__ */ Object.create(null);
        const refBindings = /* @__PURE__ */ Object.create(null);
        const refIdentifiers = /* @__PURE__ */ new Set();
        const enableRefSugar = options2.refSugar !== false;
        let defaultExport;
        let hasDefinePropsCall = false;
        let hasDefineEmitCall = false;
        let propsRuntimeDecl;
        let propsTypeDecl;
        let propsIdentifier;
        let emitRuntimeDecl;
        let emitTypeDecl;
        let emitIdentifier;
        let hasAwait = false;
        let hasInlinedSsrRenderFn = false;
        const typeDeclaredProps = {};
        const typeDeclaredEmits = /* @__PURE__ */ new Set();
        const declaredTypes = {};
        const s = new MagicString__default(source);
        const startOffset = scriptSetup.loc.start.offset;
        const endOffset = scriptSetup.loc.end.offset;
        const scriptStartOffset = script && script.loc.start.offset;
        const scriptEndOffset = script && script.loc.end.offset;
        function helper(key) {
          helperImports.add(key);
          return `_${key}`;
        }
        function parse2(input2, options3, offset) {
          try {
            return parser.parse(input2, options3).program.body;
          } catch (e) {
            e.message = `[@vue/compiler-sfc] ${e.message}

${sfc.filename}
${shared.generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`;
            throw e;
          }
        }
        function error2(msg, node2, end = node2.end + startOffset) {
          throw new Error(`[@vue/compiler-sfc] ${msg}

${sfc.filename}
${shared.generateCodeFrame(source, node2.start + startOffset, end)}`);
        }
        function registerUserImport(source2, local, imported, isType) {
          if (source2 === "vue" && imported) {
            userImportAlias[imported] = local;
          }
          userImports[local] = {
            isType,
            imported: imported || "default",
            source: source2
          };
        }
        function processDefineProps(node2) {
          if (isCallOf(node2, DEFINE_PROPS)) {
            if (hasDefinePropsCall) {
              error2(`duplicate ${DEFINE_PROPS}() call`, node2);
            }
            hasDefinePropsCall = true;
            propsRuntimeDecl = node2.arguments[0];
            if (node2.typeParameters) {
              if (propsRuntimeDecl) {
                error2(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node2);
              }
              const typeArg = node2.typeParameters.params[0];
              if (typeArg.type === "TSTypeLiteral") {
                propsTypeDecl = typeArg;
              } else {
                error2(`type argument passed to ${DEFINE_PROPS}() must be a literal type.`, typeArg);
              }
            }
            return true;
          }
          return false;
        }
        function processDefineEmit(node2) {
          if (isCallOf(node2, DEFINE_EMIT)) {
            if (hasDefineEmitCall) {
              error2(`duplicate ${DEFINE_EMIT}() call`, node2);
            }
            hasDefineEmitCall = true;
            emitRuntimeDecl = node2.arguments[0];
            if (node2.typeParameters) {
              if (emitRuntimeDecl) {
                error2(`${DEFINE_EMIT}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node2);
              }
              const typeArg = node2.typeParameters.params[0];
              if (typeArg.type === "TSFunctionType" || typeArg.type === "TSTypeLiteral") {
                emitTypeDecl = typeArg;
              } else {
                error2(`type argument passed to ${DEFINE_EMIT}() must be a function type or a literal type with call signatures.`, typeArg);
              }
            }
            return true;
          }
          return false;
        }
        function checkInvalidScopeReference(node2, method2) {
          if (!node2)
            return;
          walkIdentifiers(node2, (id2) => {
            if (setupBindings[id2.name]) {
              error2(`\`${method2}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options requires initialization in the module scope, use a separate normal <script> to export the options instead.`, id2);
            }
          });
        }
        function processRefExpression(exp2, statement) {
          if (exp2.type === "AssignmentExpression") {
            const { left, right } = exp2;
            if (left.type === "Identifier") {
              registerRefBinding(left);
              s.prependRight(right.start + startOffset, `${helper("ref")}(`);
              s.appendLeft(right.end + startOffset, ")");
            } else if (left.type === "ObjectPattern") {
              for (let i2 = left.start; i2 > 0; i2--) {
                const char = source[i2 + startOffset];
                if (char === "(") {
                  s.remove(i2 + startOffset, i2 + startOffset + 1);
                  break;
                }
              }
              for (let i2 = left.end; i2 > 0; i2++) {
                const char = source[i2 + startOffset];
                if (char === ")") {
                  s.remove(i2 + startOffset, i2 + startOffset + 1);
                  break;
                }
              }
              processRefObjectPattern(left, statement);
            } else if (left.type === "ArrayPattern") {
              processRefArrayPattern(left, statement);
            }
          } else if (exp2.type === "SequenceExpression") {
            exp2.expressions.forEach((e) => processRefExpression(e, statement));
          } else if (exp2.type === "Identifier") {
            registerRefBinding(exp2);
            s.appendLeft(exp2.end + startOffset, ` = ${helper("ref")}()`);
          } else {
            error2(`ref: statements can only contain assignment expressions.`, exp2);
          }
        }
        function registerRefBinding(id2) {
          if (id2.name[0] === "$") {
            error2(`ref variable identifiers cannot start with $.`, id2);
          }
          refBindings[id2.name] = setupBindings[id2.name] = "setup-ref";
          refIdentifiers.add(id2);
        }
        function processRefObjectPattern(pattern, statement) {
          for (const p of pattern.properties) {
            let nameId;
            if (p.type === "ObjectProperty") {
              if (p.key.start === p.value.start) {
                nameId = p.key;
                s.appendLeft(nameId.end + startOffset, `: __${nameId.name}`);
                if (p.value.type === "AssignmentPattern") {
                  refIdentifiers.add(p.value.left);
                }
              } else {
                if (p.value.type === "Identifier") {
                  nameId = p.value;
                  s.prependRight(nameId.start + startOffset, `__`);
                } else if (p.value.type === "ObjectPattern") {
                  processRefObjectPattern(p.value, statement);
                } else if (p.value.type === "ArrayPattern") {
                  processRefArrayPattern(p.value, statement);
                } else if (p.value.type === "AssignmentPattern") {
                  nameId = p.value.left;
                  s.prependRight(nameId.start + startOffset, `__`);
                }
              }
            } else {
              nameId = p.argument;
              s.prependRight(nameId.start + startOffset, `__`);
            }
            if (nameId) {
              registerRefBinding(nameId);
              s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("ref")}(__${nameId.name});`);
            }
          }
        }
        function processRefArrayPattern(pattern, statement) {
          for (const e of pattern.elements) {
            if (!e)
              continue;
            let nameId;
            if (e.type === "Identifier") {
              nameId = e;
            } else if (e.type === "AssignmentPattern") {
              nameId = e.left;
            } else if (e.type === "RestElement") {
              nameId = e.argument;
            } else if (e.type === "ObjectPattern") {
              processRefObjectPattern(e, statement);
            } else if (e.type === "ArrayPattern") {
              processRefArrayPattern(e, statement);
            }
            if (nameId) {
              registerRefBinding(nameId);
              s.prependRight(nameId.start + startOffset, `__`);
              s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("ref")}(__${nameId.name});`);
            }
          }
        }
        let scriptAst;
        if (script) {
          scriptAst = parse2(script.content, {
            plugins,
            sourceType: "module"
          }, scriptStartOffset);
          for (const node2 of scriptAst) {
            if (node2.type === "ImportDeclaration") {
              for (const specifier of node2.specifiers) {
                const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
                registerUserImport(node2.source.value, specifier.local.name, imported, node2.importKind === "type");
              }
            } else if (node2.type === "ExportDefaultDeclaration") {
              defaultExport = node2;
              const start = node2.start + scriptStartOffset;
              s.overwrite(start, start + `export default`.length, `const ${defaultTempVar} =`);
            } else if (node2.type === "ExportNamedDeclaration" && node2.specifiers) {
              const defaultSpecifier = node2.specifiers.find((s2) => s2.exported.type === "Identifier" && s2.exported.name === "default");
              if (defaultSpecifier) {
                defaultExport = node2;
                if (node2.specifiers.length > 1) {
                  s.remove(defaultSpecifier.start + scriptStartOffset, defaultSpecifier.end + scriptStartOffset);
                } else {
                  s.remove(node2.start + scriptStartOffset, node2.end + scriptStartOffset);
                }
                if (node2.source) {
                  s.prepend(`import { ${defaultSpecifier.local.name} as ${defaultTempVar} } from '${node2.source.value}'
`);
                } else {
                  s.append(`
const ${defaultTempVar} = ${defaultSpecifier.local.name}
`);
                }
              }
            }
          }
        }
        const scriptSetupAst = parse2(scriptSetup.content, {
          plugins: [
            ...plugins,
            // allow top level await but only inside <script setup>
            "topLevelAwait"
          ],
          sourceType: "module"
        }, startOffset);
        for (const node2 of scriptSetupAst) {
          const start = node2.start + startOffset;
          let end = node2.end + startOffset;
          if (node2.trailingComments && node2.trailingComments.length > 0) {
            const lastCommentNode = node2.trailingComments[node2.trailingComments.length - 1];
            end = lastCommentNode.end + startOffset;
          }
          while (end <= source.length) {
            if (!/\s/.test(source.charAt(end))) {
              break;
            }
            end++;
          }
          if (node2.type === "LabeledStatement" && node2.label.name === "ref" && node2.body.type === "ExpressionStatement") {
            if (enableRefSugar) {
              warnExperimental(`ref: sugar`, 228);
              s.overwrite(node2.label.start + startOffset, node2.body.start + startOffset, "const ");
              processRefExpression(node2.body.expression, node2);
            } else {
              error2(`ref: sugar needs to be explicitly enabled via vite or vue-loader options.`, node2);
            }
          }
          if (node2.type === "ImportDeclaration") {
            s.move(start, end, 0);
            let removed = 0;
            const removeSpecifier = (i2) => {
              const removeLeft = i2 > removed;
              removed++;
              const current = node2.specifiers[i2];
              const next = node2.specifiers[i2 + 1];
              s.remove(removeLeft ? node2.specifiers[i2 - 1].end + startOffset : current.start + startOffset, next && !removeLeft ? next.start + startOffset : current.end + startOffset);
            };
            for (let i2 = 0; i2 < node2.specifiers.length; i2++) {
              const specifier = node2.specifiers[i2];
              const local = specifier.local.name;
              const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
              const source2 = node2.source.value;
              const existing = userImports[local];
              if (source2 === "vue" && (imported === DEFINE_PROPS || imported === DEFINE_EMIT)) {
                removeSpecifier(i2);
              } else if (existing) {
                if (existing.source === source2 && existing.imported === imported) {
                  removeSpecifier(i2);
                } else {
                  error2(`different imports aliased to same local name.`, specifier);
                }
              } else {
                registerUserImport(source2, local, imported, node2.importKind === "type");
              }
            }
            if (node2.specifiers.length && removed === node2.specifiers.length) {
              s.remove(node2.start + startOffset, node2.end + startOffset);
            }
          }
          if (node2.type === "ExpressionStatement" && (processDefineProps(node2.expression) || processDefineEmit(node2.expression))) {
            s.remove(node2.start + startOffset, node2.end + startOffset);
          }
          if (node2.type === "VariableDeclaration" && !node2.declare) {
            for (const decl of node2.declarations) {
              if (decl.init) {
                const isDefineProps = processDefineProps(decl.init);
                if (isDefineProps) {
                  propsIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
                }
                const isDefineEmit = processDefineEmit(decl.init);
                if (isDefineEmit) {
                  emitIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
                }
                if (isDefineProps || isDefineEmit)
                  if (node2.declarations.length === 1) {
                    s.remove(node2.start + startOffset, node2.end + startOffset);
                  } else {
                    s.remove(decl.start + startOffset, decl.end + startOffset);
                  }
              }
            }
          }
          if ((node2.type === "VariableDeclaration" || node2.type === "FunctionDeclaration" || node2.type === "ClassDeclaration") && !node2.declare) {
            walkDeclaration(node2, setupBindings, userImportAlias);
          }
          if (node2.type === "VariableDeclaration" && node2.declare) {
            s.remove(start, end);
          }
          if (node2.type.startsWith("TS") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type") {
            recordType(node2, declaredTypes);
            s.move(start, end, 0);
          }
          if (node2.type === "VariableDeclaration" && !node2.declare || node2.type.endsWith("Statement")) {
            estreeWalker.walk(node2, {
              enter(node3) {
                if (isFunction(node3)) {
                  this.skip();
                }
                if (node3.type === "AwaitExpression") {
                  hasAwait = true;
                }
              }
            });
          }
          if (node2.type === "ExportNamedDeclaration" && node2.exportKind !== "type" || node2.type === "ExportAllDeclaration" || node2.type === "ExportDefaultDeclaration") {
            error2(`<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`, node2);
          }
        }
        if (enableRefSugar && Object.keys(refBindings).length) {
          for (const node2 of scriptSetupAst) {
            if (node2.type !== "ImportDeclaration") {
              walkIdentifiers(node2, (id2, parent, parentStack) => {
                if (refBindings[id2.name] && !refIdentifiers.has(id2)) {
                  if (isStaticProperty(parent) && parent.shorthand) {
                    if (!parent.inPattern || isInDestructureAssignment(parent, parentStack)) {
                      s.appendLeft(id2.end + startOffset, `: ${id2.name}.value`);
                    }
                  } else {
                    s.appendLeft(id2.end + startOffset, ".value");
                  }
                } else if (id2.name[0] === "$" && refBindings[id2.name.slice(1)]) {
                  s.remove(id2.start + startOffset, id2.start + startOffset + 1);
                }
              });
            }
          }
        }
        if (propsTypeDecl) {
          extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
        }
        if (emitTypeDecl) {
          extractRuntimeEmits(emitTypeDecl, typeDeclaredEmits);
        }
        checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS);
        checkInvalidScopeReference(emitRuntimeDecl, DEFINE_PROPS);
        if (script) {
          if (startOffset < scriptStartOffset) {
            s.remove(0, startOffset);
            s.remove(endOffset, scriptStartOffset);
            s.remove(scriptEndOffset, source.length);
          } else {
            s.remove(0, scriptStartOffset);
            s.remove(scriptEndOffset, startOffset);
            s.remove(endOffset, source.length);
          }
        } else {
          s.remove(0, startOffset);
          s.remove(endOffset, source.length);
        }
        if (scriptAst) {
          Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst));
        }
        if (propsRuntimeDecl) {
          for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
            bindingMetadata[key] = "props";
          }
        }
        for (const key in typeDeclaredProps) {
          bindingMetadata[key] = "props";
        }
        for (const [key, { isType, imported, source: source2 }] of Object.entries(userImports)) {
          if (isType)
            continue;
          bindingMetadata[key] = imported === "default" && source2.endsWith(".vue") || source2 === "vue" ? "setup-const" : "setup-maybe-ref";
        }
        for (const key in setupBindings) {
          bindingMetadata[key] = setupBindings[key];
        }
        if (cssVars.length) {
          helperImports.add(CSS_VARS_HELPER);
          helperImports.add("unref");
          s.prependRight(startOffset, `
${genCssVarsCode(cssVars, bindingMetadata, scopeId, !!options2.isProd)}
`);
        }
        let args = `__props`;
        if (propsTypeDecl) {
          args += `: ${scriptSetup.content.slice(propsTypeDecl.start, propsTypeDecl.end)}`;
        }
        if (propsIdentifier) {
          s.prependRight(startOffset, `
const ${propsIdentifier} = __props`);
        }
        if (emitIdentifier) {
          args += emitIdentifier === `emit` ? `, { emit }` : `, { emit: ${emitIdentifier} }`;
          if (emitTypeDecl) {
            args += `: {
        emit: (${scriptSetup.content.slice(emitTypeDecl.start, emitTypeDecl.end)}),
        slots: any,
        attrs: any
      }`;
          }
        }
        let returned;
        if (options2.inlineTemplate) {
          if (sfc.template && !sfc.template.src) {
            if (options2.templateOptions && options2.templateOptions.ssr) {
              hasInlinedSsrRenderFn = true;
            }
            const { code: code2, ast, preamble, tips, errors: errors2 } = compileTemplate({
              filename,
              source: sfc.template.content,
              inMap: sfc.template.map,
              ...options2.templateOptions,
              id: scopeId,
              scoped: sfc.styles.some((s2) => s2.scoped),
              isProd: options2.isProd,
              ssrCssVars: sfc.cssVars,
              compilerOptions: {
                ...options2.templateOptions && options2.templateOptions.compilerOptions,
                inline: true,
                isTS,
                bindingMetadata
              }
            });
            if (tips.length) {
              tips.forEach(warnOnce);
            }
            const err = errors2[0];
            if (typeof err === "string") {
              throw new Error(err);
            } else if (err) {
              if (err.loc) {
                err.message += `

` + sfc.filename + "\n" + shared.generateCodeFrame(source, err.loc.start.offset, err.loc.end.offset) + `
`;
              }
              throw err;
            }
            if (preamble) {
              s.prepend(preamble);
            }
            if (ast && ast.helpers.includes(compilerCore.UNREF)) {
              helperImports.delete("unref");
            }
            returned = code2;
          } else {
            returned = `() => {}`;
          }
        } else {
          const allBindings = { ...setupBindings };
          for (const key in userImports) {
            if (!userImports[key].isType) {
              allBindings[key] = true;
            }
          }
          returned = `{ ${Object.keys(allBindings).join(", ")} }`;
        }
        s.appendRight(endOffset, `
return ${returned}
}

`);
        let runtimeOptions = `
  expose: [],`;
        if (hasInheritAttrsFlag) {
          runtimeOptions += `
  inheritAttrs: false,`;
        }
        if (hasInlinedSsrRenderFn) {
          runtimeOptions += `
  __ssrInlineRender: true,`;
        }
        if (propsRuntimeDecl) {
          runtimeOptions += `
  props: ${scriptSetup.content.slice(propsRuntimeDecl.start, propsRuntimeDecl.end).trim()},`;
        } else if (propsTypeDecl) {
          runtimeOptions += genRuntimeProps(typeDeclaredProps);
        }
        if (emitRuntimeDecl) {
          runtimeOptions += `
  emits: ${scriptSetup.content.slice(emitRuntimeDecl.start, emitRuntimeDecl.end).trim()},`;
        } else if (emitTypeDecl) {
          runtimeOptions += genRuntimeEmits(typeDeclaredEmits);
        }
        if (isTS) {
          const def2 = defaultExport ? `
  ...${defaultTempVar},` : ``;
          s.prependLeft(startOffset, `
export default ${helper(`defineComponent`)}({${def2}${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
`);
          s.appendRight(endOffset, `})`);
        } else {
          if (defaultExport) {
            s.prependLeft(startOffset, `
${hasAwait ? `async ` : ``}function setup(${args}) {
`);
            s.append(`
export default /*#__PURE__*/ Object.assign(${defaultTempVar}, {${runtimeOptions}
  setup
})
`);
          } else {
            s.prependLeft(startOffset, `
export default {${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
`);
            s.appendRight(endOffset, `}`);
          }
        }
        if (helperImports.size > 0) {
          s.prepend(`import { ${[...helperImports].map((h) => `${h} as _${h}`).join(", ")} } from 'vue'
`);
        }
        s.trim();
        return {
          ...scriptSetup,
          bindings: bindingMetadata,
          content: s.toString(),
          map: s.generateMap({
            source: filename,
            hires: true,
            includeContent: true
          }),
          scriptAst,
          scriptSetupAst
        };
      }
      function walkDeclaration(node2, bindings, userImportAlias) {
        if (node2.type === "VariableDeclaration") {
          const isConst = node2.kind === "const";
          for (const { id: id2, init: init2 } of node2.declarations) {
            const isDefineCall = !!(isConst && (isCallOf(init2, DEFINE_PROPS) || isCallOf(init2, DEFINE_EMIT)));
            if (id2.type === "Identifier") {
              let bindingType;
              const userReactiveBinding = userImportAlias["reactive"] || "reactive";
              if (isCallOf(init2, userReactiveBinding)) {
                bindingType = "setup-let";
              } else if (
                // if a declaration is a const literal, we can mark it so that
                // the generated render fn code doesn't need to unref() it
                isDefineCall || isConst && canNeverBeRef(init2, userReactiveBinding)
              ) {
                bindingType = "setup-const";
              } else if (isConst) {
                if (isCallOf(init2, userImportAlias["ref"] || "ref")) {
                  bindingType = "setup-ref";
                } else {
                  bindingType = "setup-maybe-ref";
                }
              } else {
                bindingType = "setup-let";
              }
              bindings[id2.name] = bindingType;
            } else if (id2.type === "ObjectPattern") {
              walkObjectPattern(id2, bindings, isConst, isDefineCall);
            } else if (id2.type === "ArrayPattern") {
              walkArrayPattern(id2, bindings, isConst, isDefineCall);
            }
          }
        } else if (node2.type === "FunctionDeclaration" || node2.type === "ClassDeclaration") {
          bindings[node2.id.name] = "setup-const";
        }
      }
      function walkObjectPattern(node2, bindings, isConst, isDefineCall = false) {
        for (const p of node2.properties) {
          if (p.type === "ObjectProperty") {
            if (p.key.type === "Identifier") {
              if (p.key === p.value) {
                bindings[p.key.name] = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
              } else {
                walkPattern(p.value, bindings, isConst, isDefineCall);
              }
            }
          } else {
            bindings[p.argument.name] = isConst ? "setup-const" : "setup-let";
          }
        }
      }
      function walkArrayPattern(node2, bindings, isConst, isDefineCall = false) {
        for (const e of node2.elements) {
          e && walkPattern(e, bindings, isConst, isDefineCall);
        }
      }
      function walkPattern(node2, bindings, isConst, isDefineCall = false) {
        if (node2.type === "Identifier") {
          bindings[node2.name] = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
        } else if (node2.type === "RestElement") {
          bindings[node2.argument.name] = isConst ? "setup-const" : "setup-let";
        } else if (node2.type === "ObjectPattern") {
          walkObjectPattern(node2, bindings, isConst);
        } else if (node2.type === "ArrayPattern") {
          walkArrayPattern(node2, bindings, isConst);
        } else if (node2.type === "AssignmentPattern") {
          if (node2.left.type === "Identifier") {
            bindings[node2.left.name] = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
          } else {
            walkPattern(node2.left, bindings, isConst);
          }
        }
      }
      function recordType(node2, declaredTypes) {
        if (node2.type === "TSInterfaceDeclaration") {
          declaredTypes[node2.id.name] = [`Object`];
        } else if (node2.type === "TSTypeAliasDeclaration") {
          declaredTypes[node2.id.name] = inferRuntimeType(node2.typeAnnotation, declaredTypes);
        } else if (node2.type === "ExportNamedDeclaration" && node2.declaration) {
          recordType(node2.declaration, declaredTypes);
        }
      }
      function extractRuntimeProps(node2, props, declaredTypes) {
        for (const m of node2.members) {
          if (m.type === "TSPropertySignature" && m.key.type === "Identifier") {
            props[m.key.name] = {
              key: m.key.name,
              required: !m.optional,
              type: m.typeAnnotation ? inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes) : [`null`]
            };
          }
        }
      }
      function inferRuntimeType(node2, declaredTypes) {
        switch (node2.type) {
          case "TSStringKeyword":
            return ["String"];
          case "TSNumberKeyword":
            return ["Number"];
          case "TSBooleanKeyword":
            return ["Boolean"];
          case "TSObjectKeyword":
            return ["Object"];
          case "TSTypeLiteral":
            return ["Object"];
          case "TSFunctionType":
            return ["Function"];
          case "TSArrayType":
          case "TSTupleType":
            return ["Array"];
          case "TSLiteralType":
            switch (node2.literal.type) {
              case "StringLiteral":
                return ["String"];
              case "BooleanLiteral":
                return ["Boolean"];
              case "NumericLiteral":
              case "BigIntLiteral":
                return ["Number"];
              default:
                return [`null`];
            }
          case "TSTypeReference":
            if (node2.typeName.type === "Identifier") {
              if (declaredTypes[node2.typeName.name]) {
                return declaredTypes[node2.typeName.name];
              }
              switch (node2.typeName.name) {
                case "Array":
                case "Function":
                case "Object":
                case "Set":
                case "Map":
                case "WeakSet":
                case "WeakMap":
                  return [node2.typeName.name];
                case "Record":
                case "Partial":
                case "Readonly":
                case "Pick":
                case "Omit":
                case "Exclude":
                case "Extract":
                case "Required":
                case "InstanceType":
                  return ["Object"];
              }
            }
            return [`null`];
          case "TSUnionType":
            return [
              ...new Set([].concat(node2.types.map((t2) => inferRuntimeType(t2, declaredTypes))))
            ];
          case "TSIntersectionType":
            return ["Object"];
          default:
            return [`null`];
        }
      }
      function genRuntimeProps(props) {
        const keys2 = Object.keys(props);
        if (!keys2.length) {
          return ``;
        }
        return `
  props: {
    ${keys2.map((key) => {
          const { type: type2, required } = props[key];
          return `${key}: { type: ${toRuntimeTypeString(type2)}, required: ${required} }`;
        }).join(",\n    ")}
  } as unknown as undefined,`;
      }
      function toRuntimeTypeString(types2) {
        return types2.some((t2) => t2 === "null") ? `null` : types2.length > 1 ? `[${types2.join(", ")}]` : types2[0];
      }
      function extractRuntimeEmits(node2, emits) {
        if (node2.type === "TSTypeLiteral") {
          for (let t2 of node2.members) {
            if (t2.type === "TSCallSignatureDeclaration") {
              extractEventNames(t2.parameters[0], emits);
            }
          }
          return;
        } else {
          extractEventNames(node2.parameters[0], emits);
        }
      }
      function extractEventNames(eventName, emits) {
        if (eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
          const typeNode = eventName.typeAnnotation.typeAnnotation;
          if (typeNode.type === "TSLiteralType") {
            emits.add(String(typeNode.literal.value));
          } else if (typeNode.type === "TSUnionType") {
            for (const t2 of typeNode.types) {
              if (t2.type === "TSLiteralType") {
                emits.add(String(t2.literal.value));
              }
            }
          }
        }
      }
      function genRuntimeEmits(emits) {
        return emits.size ? `
  emits: [${Array.from(emits).map((p) => JSON.stringify(p)).join(", ")}] as unknown as undefined,` : ``;
      }
      function markScopeIdentifier(node2, child, knownIds) {
        const { name: name2 } = child;
        if (node2.scopeIds && node2.scopeIds.has(name2)) {
          return;
        }
        if (name2 in knownIds) {
          knownIds[name2]++;
        } else {
          knownIds[name2] = 1;
        }
        (node2.scopeIds || (node2.scopeIds = /* @__PURE__ */ new Set())).add(name2);
      }
      function walkIdentifiers(root2, onIdentifier) {
        const parentStack = [];
        const knownIds = /* @__PURE__ */ Object.create(null);
        estreeWalker.walk(root2, {
          enter(node2, parent) {
            parent && parentStack.push(parent);
            if (node2.type === "Identifier") {
              if (!knownIds[node2.name] && isRefIdentifier(node2, parent, parentStack)) {
                onIdentifier(node2, parent, parentStack);
              }
            } else if (isFunction(node2)) {
              if (node2.body.type === "BlockStatement") {
                node2.body.body.forEach((p) => {
                  if (p.type === "VariableDeclaration") {
                    for (const decl of p.declarations) {
                      extractIdentifiers(decl.id).forEach((id2) => {
                        markScopeIdentifier(node2, id2, knownIds);
                      });
                    }
                  }
                });
              }
              node2.params.forEach((p) => estreeWalker.walk(p, {
                enter(child, parent2) {
                  if (child.type === "Identifier" && // do not record as scope variable if is a destructured key
                  !isStaticPropertyKey(child, parent2) && // do not record if this is a default value
                  // assignment of a destructured variable
                  !(parent2 && parent2.type === "AssignmentPattern" && parent2.right === child)) {
                    markScopeIdentifier(node2, child, knownIds);
                  }
                }
              }));
            } else if (node2.type === "ObjectProperty" && parent.type === "ObjectPattern") {
              node2.inPattern = true;
            }
          },
          leave(node2, parent) {
            parent && parentStack.pop();
            if (node2.scopeIds) {
              node2.scopeIds.forEach((id2) => {
                knownIds[id2]--;
                if (knownIds[id2] === 0) {
                  delete knownIds[id2];
                }
              });
            }
          }
        });
      }
      function isRefIdentifier(id2, parent, parentStack) {
        if ((parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id2) {
          return false;
        }
        if (isFunction(parent)) {
          if (parent.id === id2) {
            return false;
          }
          if (parent.params.includes(id2)) {
            return false;
          }
        }
        if (isStaticPropertyKey(id2, parent)) {
          return false;
        }
        if (parent.type === "ArrayPattern" && !isInDestructureAssignment(parent, parentStack)) {
          return false;
        }
        if ((parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && parent.property === id2 && !parent.computed) {
          return false;
        }
        if (id2.name === "arguments") {
          return false;
        }
        return true;
      }
      const isStaticProperty = (node2) => node2 && (node2.type === "ObjectProperty" || node2.type === "ObjectMethod") && !node2.computed;
      const isStaticPropertyKey = (node2, parent) => isStaticProperty(parent) && parent.key === node2;
      function isFunction(node2) {
        return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
      }
      function isCallOf(node2, name2) {
        return !!(node2 && node2.type === "CallExpression" && node2.callee.type === "Identifier" && node2.callee.name === name2);
      }
      function canNeverBeRef(node2, userReactiveImport) {
        if (isCallOf(node2, userReactiveImport)) {
          return true;
        }
        switch (node2.type) {
          case "UnaryExpression":
          case "BinaryExpression":
          case "ArrayExpression":
          case "ObjectExpression":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "UpdateExpression":
          case "ClassExpression":
          case "TaggedTemplateExpression":
            return true;
          case "SequenceExpression":
            return canNeverBeRef(node2.expressions[node2.expressions.length - 1], userReactiveImport);
          default:
            if (node2.type.endsWith("Literal")) {
              return true;
            }
            return false;
        }
      }
      function isInDestructureAssignment(parent, parentStack) {
        if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
          let i2 = parentStack.length;
          while (i2--) {
            const p = parentStack[i2];
            if (p.type === "AssignmentExpression") {
              const root2 = parentStack[0];
              return !(root2.type === "LabeledStatement" && root2.label.name === "ref");
            } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
              break;
            }
          }
        }
        return false;
      }
      function analyzeScriptBindings(ast) {
        for (const node2 of ast) {
          if (node2.type === "ExportDefaultDeclaration" && node2.declaration.type === "ObjectExpression") {
            return analyzeBindingsFromOptions(node2.declaration);
          }
        }
        return {};
      }
      function analyzeBindingsFromOptions(node2) {
        const bindings = {};
        Object.defineProperty(bindings, "__isScriptSetup", {
          enumerable: false,
          value: false
        });
        for (const property of node2.properties) {
          if (property.type === "ObjectProperty" && !property.computed && property.key.type === "Identifier") {
            if (property.key.name === "props") {
              for (const key of getObjectOrArrayExpressionKeys(property.value)) {
                bindings[key] = "props";
              }
            } else if (property.key.name === "inject") {
              for (const key of getObjectOrArrayExpressionKeys(property.value)) {
                bindings[key] = "options";
              }
            } else if (property.value.type === "ObjectExpression" && (property.key.name === "computed" || property.key.name === "methods")) {
              for (const key of getObjectExpressionKeys(property.value)) {
                bindings[key] = "options";
              }
            }
          } else if (property.type === "ObjectMethod" && property.key.type === "Identifier" && (property.key.name === "setup" || property.key.name === "data")) {
            for (const bodyItem of property.body.body) {
              if (bodyItem.type === "ReturnStatement" && bodyItem.argument && bodyItem.argument.type === "ObjectExpression") {
                for (const key of getObjectExpressionKeys(bodyItem.argument)) {
                  bindings[key] = property.key.name === "setup" ? "setup-maybe-ref" : "data";
                }
              }
            }
          }
        }
        return bindings;
      }
      function getObjectExpressionKeys(node2) {
        const keys2 = [];
        for (const prop of node2.properties) {
          if ((prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && !prop.computed) {
            if (prop.key.type === "Identifier") {
              keys2.push(prop.key.name);
            } else if (prop.key.type === "StringLiteral") {
              keys2.push(prop.key.value);
            }
          }
        }
        return keys2;
      }
      function getArrayExpressionKeys(node2) {
        const keys2 = [];
        for (const element of node2.elements) {
          if (element && element.type === "StringLiteral") {
            keys2.push(element.value);
          }
        }
        return keys2;
      }
      function getObjectOrArrayExpressionKeys(value) {
        if (value.type === "ArrayExpression") {
          return getArrayExpressionKeys(value);
        }
        if (value.type === "ObjectExpression") {
          return getObjectExpressionKeys(value);
        }
        return [];
      }
      function extractIdentifiers(param, nodes = []) {
        switch (param.type) {
          case "Identifier":
            nodes.push(param);
            break;
          case "MemberExpression":
            let object2 = param;
            while (object2.type === "MemberExpression") {
              object2 = object2.object;
            }
            nodes.push(object2);
            break;
          case "ObjectPattern":
            param.properties.forEach((prop) => {
              if (prop.type === "RestElement") {
                extractIdentifiers(prop.argument, nodes);
              } else {
                extractIdentifiers(prop.value, nodes);
              }
            });
            break;
          case "ArrayPattern":
            param.elements.forEach((element) => {
              if (element)
                extractIdentifiers(element, nodes);
            });
            break;
          case "RestElement":
            extractIdentifiers(param.argument, nodes);
            break;
          case "AssignmentPattern":
            extractIdentifiers(param.left, nodes);
            break;
        }
        return nodes;
      }
      compilerSfc_cjs.generateCodeFrame = compilerCore.generateCodeFrame;
      compilerSfc_cjs.MagicString = MagicString__default;
      compilerSfc_cjs.babelParse = parser.parse;
      compilerSfc_cjs.walk = estreeWalker.walk;
      compilerSfc_cjs.compileScript = compileScript;
      compilerSfc_cjs.compileStyle = compileStyle;
      compilerSfc_cjs.compileStyleAsync = compileStyleAsync;
      compilerSfc_cjs.compileTemplate = compileTemplate;
      compilerSfc_cjs.parse = parse$2;
      compilerSfc_cjs.rewriteDefault = rewriteDefault;
      compilerSfc_cjs.walkIdentifiers = walkIdentifiers;
      let { parse: parse$1 } = compilerSfc_cjs;
      var parse_1 = (code2) => {
        const ast = parse$1(code2, { filename: String(+/* @__PURE__ */ new Date()) }).descriptor;
        return ast;
      };
      const parse = parse_1;
      const jsCore$1 = core_1$2;
      const htmlCore$2 = core_1$1;
      const NodePath$2 = NodePath_1;
      const core$1 = {
        getAstsBySelector(ast, selector2, { parseOptions } = {}) {
          parseOptions = Object.assign({}, parseOptions);
          let newAst = null;
          if (selector2 == "<template></template>") {
            parseOptions.language = "html";
            parseOptions.rootLanguage = "vue";
            if (ast.templateAst) {
              newAst = ast.templateAst;
            } else {
              ast.templateAst = core$1.getTemplate(ast);
              newAst = ast.templateAst;
            }
          } else if (selector2 == "<script><\/script>") {
            parseOptions.language = "js";
            parseOptions.rootLanguage = "vue";
            if (ast.scriptAst) {
              newAst = ast.scriptAst;
            } else {
              ast.scriptAst = core$1.getScript(ast, { parseOptions });
              newAst = ast.scriptAst;
            }
          } else if (selector2 == "<script setup><\/script>") {
            parseOptions.language = "js";
            parseOptions.rootLanguage = "vue";
            if (ast.scriptSetupAst) {
              newAst = ast.scriptSetupAst;
            } else {
              ast.scriptSetupAst = core$1.getScript(ast, { isSetup: true, parseOptions });
              newAst = ast.scriptSetupAst;
            }
          }
          return { nodePathList: newAst ? [newAst] : [], matchWildCardList: [], extra: { parseOptions } };
        },
        getTemplate(ast) {
          if (ast.template) {
            const template = htmlCore$2.buildAstByAstStr(
              ast.template.content,
              {},
              {
                isProgram: true,
                parseOptions: { language: "html" }
              }
            );
            return new NodePath$2(template);
          } else {
            return void 0;
          }
        },
        getScript(ast, { isSetup = false, parseOptions } = {}) {
          let content;
          if (isSetup && ast.scriptSetup) {
            content = ast.scriptSetup.content;
          } else if (!isSetup && ast.script) {
            content = ast.script.content;
          }
          if (content) {
            const script = jsCore$1.buildAstByAstStr(
              content,
              {},
              {
                isProgram: true,
                parseOptions
              }
            );
            return new NodePath$2(script);
          } else {
            return void 0;
          }
        },
        buildAstByAstStr(str2, astPatialMap = {}, { isProgram = false, parseOptions } = {}) {
          try {
            const program = parse(str2, parseOptions);
            core$1.parseOptions = parseOptions;
            if (program) {
              if (isProgram) {
                return program;
              } else {
                if (program.template && program.template.ast) {
                  return program.template;
                } else
                  return null;
              }
            } else {
              return null;
            }
          } catch (e) {
            console.log("buildAstByAstStr failed:" + e);
          }
        }
      };
      var core_1 = core$1;
      var _indentString_4_0_0_indentString = (string2, count = 1, options2) => {
        options2 = {
          indent: " ",
          includeEmptyLines: false,
          ...options2
        };
        if (typeof string2 !== "string") {
          throw new TypeError(
            `Expected \`input\` to be a \`string\`, got \`${typeof string2}\``
          );
        }
        if (typeof count !== "number") {
          throw new TypeError(
            `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
          );
        }
        if (typeof options2.indent !== "string") {
          throw new TypeError(
            `Expected \`options.indent\` to be a \`string\`, got \`${typeof options2.indent}\``
          );
        }
        if (count === 0) {
          return string2;
        }
        const regex2 = options2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return string2.replace(regex2, options2.indent.repeat(count));
      };
      const indentString = _indentString_4_0_0_indentString;
      const jsGenerate = generate$8;
      const htmlGenerate$1 = serializeNode_1;
      var generate$1 = function toString2(sfcDescriptor, options2 = {}) {
        let { template, script, scriptSetup, styles = [], customBlocks = [], templateAst, scriptAst, scriptSetupAst } = sfcDescriptor;
        if (templateAst && templateAst.node) {
          template.content = htmlGenerate$1(templateAst.node);
        }
        if (scriptAst && scriptAst.node) {
          script.content = jsGenerate(scriptAst.node);
        }
        if (scriptSetupAst && scriptSetupAst.node) {
          scriptSetup.content = jsGenerate(scriptSetupAst.node);
        }
        const indents = Object.assign(
          {
            template: 2,
            script: 0,
            style: 0
          },
          options2.indents
        );
        return [template, script, scriptSetup, ...styles, ...customBlocks].filter((block) => block != null).sort((a, b2) => a.start - b2.start).map((block) => {
          const openTag = makeOpenTag(block);
          const closeTag2 = makeCloseTag(block);
          return Object.assign({}, block, {
            openTag,
            closeTag: closeTag2,
            startOfOpenTag: block.start - openTag.length,
            endOfOpenTag: block.start,
            startOfCloseTag: block.end,
            endOfCloseTag: block.end + closeTag2.length
          });
        }).reduce((sfcCode, block, index, array) => {
          const first = index === 0;
          let newlinesBefore = 0;
          if (first) {
            newlinesBefore = block.startOfOpenTag;
          } else {
            const prevBlock = array[index - 1];
            newlinesBefore = block.startOfOpenTag - prevBlock.endOfCloseTag;
          }
          newlinesBefore = newlinesBefore || 1;
          return sfcCode + "\n".repeat(newlinesBefore) + block.openTag + indentString(block.content, indents[block.type] || 0) + block.closeTag;
        }, "");
      };
      function makeOpenTag(block) {
        let source = "<" + block.type;
        source += Object.keys(block.attrs).sort().map((name2) => {
          const value = block.attrs[name2];
          if (value === true) {
            return name2;
          } else {
            return `${name2}="${value}"`;
          }
        }).map((attr) => " " + attr).join("");
        return source + ">";
      }
      function makeCloseTag(block) {
        return `</${block.type}>
`;
      }
      const generate = generate$8;
      const htmlGenerate = serializeNode_1;
      const vueGenerate = generate$1;
      const core = core_1$2;
      const htmlCore$1 = core_1$1;
      const vueCore$1 = core_1;
      const NodePath$1 = NodePath_1;
      const filterProp = filterProp$2;
      const { isObject } = util$2;
      const languageMap = {
        "js": {
          generate,
          core
        },
        "html": {
          generate: htmlGenerate,
          core: htmlCore$1
        },
        "vue": {
          generate: vueGenerate,
          core: vueCore$1
        }
      };
      class AST$1 {
        constructor(nodePath2, { parseOptions, match, rootNode } = {}) {
          if (nodePath2) {
            this[0] = {
              nodePath: nodePath2,
              match
            };
          }
          this.rootNode = rootNode;
          this.expando = "g" + ("" + Math.random()).replace(/\D/g, "") + "g";
          this.parseOptions = parseOptions;
        }
        get node() {
          return this[0] ? this[0].nodePath.node : null;
        }
        get value() {
          return this[0] ? this[0].nodePath.value : null;
        }
        get match() {
          return this[0] ? this[0].match : [];
        }
        get isHtml() {
          return this.parseOptions && (this.parseOptions.html || this.parseOptions.language == "html");
        }
        get language() {
          return this.parseOptions && this.parseOptions.language || "js";
        }
        get core() {
          return languageMap[this.language].core;
        }
        get _index() {
          initParent(this);
          return this[0]._index;
        }
        get length() {
          let i2 = 0;
          while (this[i2]) {
            i2++;
          }
          return i2;
        }
        each(callback) {
          let i2 = 0;
          const newAST = cloneAST(this);
          while (this[i2]) {
            const { nodePath: nodePath2, match } = this[i2];
            const eachNode = new AST$1(nodePath2, { parseOptions: this.parseOptions, match, rootNode: this.rootNode });
            callback(eachNode, i2);
            newAST[i2] = eachNode[0] || null;
            i2++;
          }
          return newAST;
        }
        find(selector2, options2 = {}) {
          if (!selector2) {
            throw new Error("find failed! first argument should not be null!");
          }
          if (!this[0]) {
            return this;
          }
          const { nodePath: nodePath2 } = this[0];
          const pOptions = options2.parseOptions || this.parseOptions;
          const { nodePathList, matchWildCardList, extra = {} } = this.core.getAstsBySelector(
            nodePath2.node,
            selector2,
            {
              strictSequence: options2.ignoreSequence === false,
              parseOptions: pOptions,
              expando: this.expando,
              deep: options2.deep
            }
          );
          const newAST = cloneAST(this);
          if (!newAST.rootNode) {
            newAST.rootNode = this[0].nodePath;
          }
          nodePathList.forEach((nodePath3, i2) => {
            if (this.language == "js") {
              let theNodePath = nodePath3;
              while (theNodePath.parentPath) {
                if (theNodePath.parentPath && theNodePath.parentPath.name == "root") {
                  if (theNodePath.parentPath.node.type != "File") {
                    theNodePath.parentPath = this[0].nodePath;
                  }
                  break;
                }
                theNodePath = theNodePath.parentPath;
              }
            }
            newAST[i2] = { nodePath: nodePath3, parseOptions: extra.parseOptions || pOptions, match: matchWildCardList[i2] };
          });
          if (extra.parseOptions) {
            newAST.parseOptions = extra.parseOptions;
          }
          return newAST;
        }
        parent(option) {
          let level = 0;
          if (typeof option == "number") {
            level = option;
          }
          if (!this[0]) {
            return this;
          }
          initParent(this);
          let parent = [this[0].parentList[level]];
          function parentMatch(full, partial) {
            return Object.keys(partial).every((prop) => {
              if (!full || !partial)
                return false;
              if (!full[prop])
                return false;
              if (isObject(partial[prop])) {
                return parentMatch(full[prop], partial[prop]);
              } else {
                return full[prop] == partial[prop];
              }
            });
          }
          if (isObject(option)) {
            parent = [];
            this[0].parentList.forEach((p) => {
              if (parentMatch(p.node, option)) {
                parent.push(p);
              }
            });
          }
          const newAST = cloneAST(this);
          if (parent[0]) {
            parent.forEach((p, i2) => {
              newAST[i2] = { nodePath: p, parseOptions: this.parseOptions };
            });
            return newAST;
          } else {
            return this;
          }
        }
        parents() {
          if (!this[0]) {
            return this;
          }
          initParent(this);
          const { parentList } = this[0];
          const newAST = cloneAST(this);
          parentList.forEach((nodePath2, i2) => {
            newAST[i2] = { nodePath: nodePath2, parseOptions: this.parseOptions, match: null };
          });
          return newAST;
        }
        root(option) {
          if (!this.rootNode) {
            return this;
          }
          const newAST = cloneAST(this);
          newAST[0] = { nodePath: this.rootNode };
          newAST.rootNode = null;
          if (this.parseOptions && this.parseOptions.rootLanguage == "vue") {
            if (option == "template") {
              newAST[0] = { nodePath: this.rootNode.node.templateAst };
            } else if (option == "script") {
              newAST[0] = { nodePath: this.rootNode.node.scriptAst };
            } else {
              newAST.parseOptions = Object.assign(
                {},
                this.parseOptions,
                { language: "vue", rootLanguage: void 0 }
              );
            }
          }
          return newAST;
        }
        has(selector2, options2) {
          return !!this.find(selector2, options2)[0];
        }
        siblings() {
          if (!this[0]) {
            return this;
          }
          initSiblings(this);
          const siblings = this[0].siblings || [];
          const newAST = cloneAST(this);
          siblings.forEach((sibling, i2) => {
            newAST[i2] = sibling;
          });
          return newAST;
        }
        prevAll() {
          if (!this[0]) {
            return this;
          }
          initSiblings(this);
          const prevAll = this[0].prevAll || [];
          const newAST = cloneAST(this);
          prevAll.forEach((prev, i2) => {
            newAST[i2] = prev;
          });
          return newAST;
        }
        prev() {
          if (!this[0]) {
            return this;
          }
          initSiblings(this);
          const prevAll = this[0].prevAll || [];
          const newAST = cloneAST(this);
          newAST[0] = prevAll[prevAll.length - 1];
          return newAST;
        }
        nextAll() {
          if (!this[0]) {
            return this;
          }
          initSiblings(this);
          const nextAll = this[0].nextAll || [];
          const newAST = cloneAST(this);
          nextAll.forEach((next, i2) => {
            newAST[i2] = next;
          });
          return newAST;
        }
        next() {
          if (!this[0]) {
            return this;
          }
          initSiblings(this);
          const nextAll = this[0].nextAll || [];
          const newAST = cloneAST(this);
          newAST[0] = nextAll[0];
          return newAST;
        }
        eq(index) {
          index = index || 0;
          const { nodePath: nodePath2, match } = this[index] || {};
          const newAST = cloneAST(this);
          newAST[0] = { nodePath: nodePath2, parseOptions: this.parseOptions, match };
          return newAST;
        }
        attr(arg1, arg2) {
          if (!this[0] || !this[0].nodePath || !this[0].nodePath.node) {
            return this;
          }
          let attrMap = {};
          if (arg2) {
            if (typeof arg1 == "string") {
              attrMap = { [arg1]: arg2 };
            } else {
              throw new Error("attr failed! args[0] should be string!");
            }
          } else {
            if (typeof arg1 == "string") {
              return getAttrValue(this[0].nodePath.node, arg1);
            } else if (typeof arg1 == "object") {
              attrMap = arg1;
            }
          }
          setAttrValue(this[0].nodePath.node, attrMap);
          return this;
        }
        child(attrName) {
          if (!this[0] || !this[0].nodePath || !this[0].nodePath.node) {
            return this;
          }
          const keyList = attrName.split(".");
          let currentNode = this.node;
          let nodePath2 = this[0].nodePath;
          this[0].nodePath.parentPath;
          let newNodeAST;
          let deep = 0;
          if (this.node.program) {
            nodePath2 = nodePath2.get("program", "body", "0");
            currentNode = currentNode.program.body[0];
          }
          keyList.forEach((attr) => {
            const node2 = currentNode[attr];
            if (node2) {
              if (this.language == "js") {
                newNodeAST = cloneAST(this);
                nodePath2 = nodePath2.get(attr);
                newNodeAST[0] = { nodePath: nodePath2, parseOptions: this.parseOptions };
              } else {
                newNodeAST = cloneAST(this);
                nodePath2 = new NodePath$1(currentNode[attr], nodePath2, nodePath2);
                newNodeAST[0] = { nodePath: nodePath2, parseOptions: this.parseOptions };
              }
              currentNode = node2;
              deep++;
            }
          });
          if (deep == keyList.length) {
            return newNodeAST;
          } else {
            return null;
          }
        }
        clone() {
          if (!this[0]) {
            return this;
          }
          let nodePath2;
          if (this.isHtml) {
            let resetParent = function(node2) {
              for (let key in node2) {
                if (key == "parentRef") {
                  node2[key] = parentRefList[node2[key]];
                } else if (isObject(node2[key])) {
                  if (Array.isArray(node2[key])) {
                    node2[key].forEach((n2) => {
                      resetParent(n2);
                    });
                  } else {
                    resetParent(node2[key]);
                  }
                }
              }
            }, markParent = function(node2) {
              for (let key in node2) {
                if (key == "parentRef") {
                  parentRefList.push(node2[key]);
                  node2[key] = parentRefList.length - 1;
                } else if (isObject(node2[key])) {
                  if (Array.isArray(node2[key])) {
                    node2[key].forEach((n2) => {
                      markParent(n2);
                    });
                  } else {
                    markParent(node2[key]);
                  }
                }
              }
            };
            const parentRefList = [];
            markParent(this[0].nodePath.node);
            const newNode = JSON.parse(JSON.stringify(this[0].nodePath.node));
            resetParent(newNode);
            resetParent(this[0].nodePath.node);
            nodePath2 = new NodePath$1(
              newNode,
              this[0].nodePath.parent,
              this[0].nodePath.parentPath
            );
          } else {
            const node2 = {};
            filterProp(this[0].nodePath.node, node2, [
              "computed",
              "range",
              "leadingComments",
              "shorthand",
              "extra",
              "static",
              "typeParameters",
              "tokens"
            ]);
            nodePath2 = new NodePath$1(
              // JSON.parse(JSON.stringify(this[0].nodePath.node)), 
              JSON.parse(JSON.stringify(node2)),
              this[0].nodePath.parent,
              this[0].nodePath.parentPath
            );
          }
          const { match } = this[0];
          const newAST = cloneAST(this);
          newAST[0] = { nodePath: nodePath2, parseOptions: this.parseOptions, match };
          return newAST;
        }
        replace(selector2, replacer2, { ignoreSequence, parseOptions } = {}) {
          if (!this[0]) {
            return this;
          }
          parseOptions = parseOptions || this.parseOptions;
          this.core.replaceSelBySel(this[0].nodePath, selector2, replacer2, ignoreSequence === false, parseOptions, this.expando);
          return this;
        }
        replaceBy(replacer2) {
          if (!this[0]) {
            return this.root();
          }
          if (replacer2[0] && replacer2[0].nodePath) {
            replacer2 = replacer2[0].nodePath.node;
          }
          if (typeof replacer2 == "string") {
            replacer2 = this.core.buildAstByAstStr(replacer2);
          }
          if (replacer2.type == "File") {
            replacer2 = replacer2.program.body[0];
          }
          let i2 = 0;
          while (this[i2]) {
            this.core.replaceAstByAst(this[i2].nodePath, replacer2, this._index);
            i2++;
          }
          return this;
        }
        insertSiblingNode(node2, type2) {
          if (!this[0]) {
            return this;
          }
          if (!node2.type && !node2.nodeType) {
            throw new Error("insert failed! Unexpected node for insert!");
          }
          if (node2.type && node2.type.match("Comment")) {
            node2.trailing = type2 == "after";
            node2.leading = type2 == "before";
            this.insertChildNode(
              "comments",
              node2,
              type2 == "after" ? "append" : "prepend"
            );
            return;
          }
          initParent(this);
          if (this.isHtml) {
            let p;
            let index = -1;
            if (this.node.nodeType == "document") {
              p = this.node.content.children;
              index = type2 == "before" ? 0 : p.length - 1;
            } else {
              const parent = this.parent();
              p = parent.attr("content.children") || [];
              p.forEach((item, i2) => {
                if (item == this.node) {
                  index = i2;
                }
              });
            }
            if (type2 == "before") {
              p.splice(index, 0, node2);
            } else {
              p.splice(index + 1, 0, node2);
            }
          } else {
            const parentList = this[0].parentList;
            if ((!parentList || parentList.length == 0) && this.node.type == "File") {
              if (type2 == "before") {
                this.attr("program.body").unshift(node2);
              } else {
                this.attr("program.body").push(node2);
              }
              return;
            }
            let getArrayParent = false;
            let i2 = 0;
            let selfPathNode = this[0].nodePath.value;
            let selfIndex = -1;
            while (!getArrayParent) {
              if (!parentList[i2] || !parentList[i2].value) {
                getArrayParent = true;
              } else if (Array.isArray(parentList[i2].value)) {
                getArrayParent = true;
                parentList[i2].value.forEach((nodePath2, index) => {
                  if (nodePath2 == selfPathNode) {
                    selfIndex = index;
                  }
                });
                if (type2 == "after") {
                  parentList[i2].value.splice(selfIndex + 1, 0, node2);
                } else {
                  parentList[i2].value.splice(selfIndex, 0, node2);
                }
              }
              selfPathNode = parentList[i2].value;
              i2++;
            }
          }
        }
        after(node2) {
          if (!node2) {
            throw new Error("after failed! Unexpected node for insert!");
          }
          if (typeof node2 == "string") {
            node2 = this.core.buildAstByAstStr(node2);
          }
          if (node2[0] && node2[0].nodePath) {
            node2 = node2[0].nodePath.value;
          }
          if (node2.type == "File") {
            if (node2.program.body.length > 0) {
              node2.program.body.forEach((item) => {
                this.insertSiblingNode(item, "after");
              });
              return this;
            } else {
              return this;
            }
          }
          if (!Array.isArray(node2)) {
            node2 = [node2];
          }
          node2.forEach((n2) => {
            this.insertSiblingNode(n2, "after");
          });
          return this;
        }
        before(node2) {
          if (!node2) {
            throw new Error("before failed! Unexpected node for insert!");
          }
          if (typeof node2 == "string") {
            node2 = this.core.buildAstByAstStr(node2);
          }
          if (node2[0] && node2[0].type == "Decorator") {
            this.node.decorators = (this.node.decorators || []).concat(node2);
            return this;
          }
          if (node2[0] && node2[0].nodePath) {
            node2 = node2[0].nodePath.value;
          }
          if (node2.type == "File") {
            if (node2.program.body.length > 0) {
              node2.program.body.reverse().forEach((item) => {
                this.insertSiblingNode(item, "before");
              });
              return this;
            } else {
              return this;
            }
          }
          if (!Array.isArray(node2)) {
            node2 = [node2];
          }
          node2.reverse().forEach((n2) => {
            this.insertSiblingNode(n2, "before");
          });
          return this;
        }
        insertChildNode(attr, node2, type2) {
          if (!this[0] || !this[0].nodePath) {
            return;
          }
          let selfNode = this[0].nodePath.value;
          let bodyIndex = selfNode.program && type2 == "append" ? selfNode.program.body.length - 1 : 0;
          if (!Array.isArray(selfNode)) {
            if (attr == "content.children") {
              selfNode.content.children = selfNode.content.children || [];
              selfNode = selfNode.content.children;
            } else if (selfNode.program && selfNode.program.body) {
              if (attr == "program.body") {
                selfNode = selfNode.program.body;
              } else {
                selfNode.program.body[bodyIndex][attr] = selfNode.program.body[bodyIndex][attr] || [];
                selfNode = selfNode.program.body[bodyIndex][attr];
              }
            } else {
              selfNode[attr] = selfNode[attr] || [];
              selfNode = selfNode[attr];
              if (!Array.isArray(selfNode)) {
                selfNode = selfNode.body;
              }
            }
          }
          if (node2.type == "File" && node2.program.body) {
            node2 = node2.program.body[bodyIndex];
            if (!node2)
              return;
          }
          if (selfNode) {
            if (type2 == "append") {
              selfNode.push(node2);
            } else {
              selfNode.unshift(node2);
            }
          }
        }
        append(attr, node2) {
          if (!attr) {
            return this;
          }
          if (this.isHtml) {
            node2 = attr;
            attr = "content.children";
          }
          if (!node2) {
            node2 = attr;
            attr = "program.body";
          }
          if (typeof node2 == "string") {
            node2 = this.core.buildAstByAstStr(node2);
          }
          if (node2[0] && node2[0].nodePath) {
            node2 = node2[0].nodePath.value;
          }
          if (!Array.isArray(node2)) {
            node2 = [node2];
          }
          node2.forEach((n2) => {
            this.insertChildNode(attr, n2, "append");
          });
          return this;
        }
        prepend(attr, node2) {
          if (this.isHtml) {
            node2 = attr;
            attr = "content.children";
          }
          if (!node2) {
            node2 = attr;
            attr = "program.body";
          }
          if (typeof node2 == "string") {
            node2 = this.core.buildAstByAstStr(node2);
          }
          if (node2[0] && node2[0].nodePath) {
            node2 = node2[0].nodePath.value;
          }
          if (!Array.isArray(node2)) {
            node2 = [node2];
          }
          node2.reverse().forEach((n2) => {
            this.insertChildNode(attr, n2, "prepend");
          });
          return this;
        }
        empty() {
          this.each((item) => {
            if (item.language == "html") {
              if (Array.isArray(item.attr("content.children"))) {
                item.attr("content.children", []);
              }
            } else if (item.language == "js") {
              if (Array.isArray(item[0].nodePath.value)) {
                item[0].nodePath.value = [];
              } else if (item.node.type == "File") {
                item.attr("program.body", []);
              }
            }
          });
          return this;
        }
        remove(selector2, options2 = {}) {
          if (!this[0]) {
            return this.root();
          }
          if (typeof selector2 == "string" || Array.isArray(selector2)) {
            const pOptions = options2.parseOptions || this.parseOptions;
            let i2 = 0;
            while (this[i2]) {
              this.core.removeAst(this.node, selector2, {
                strictSequence: options2.ignoreSequence === false,
                parseOptions: pOptions,
                expando: this.expando
              });
              i2++;
            }
          } else {
            let i2 = 0;
            while (this[i2]) {
              this.core.remove(this[i2].nodePath);
              i2++;
            }
          }
          return this.root();
        }
        generate({ isPretty = false } = {}) {
          if (!this[0]) {
            return "";
          }
          if (this.language == "js") {
            return generate(this[0].nodePath.node, isPretty);
          } else {
            return languageMap[this.language].generate(this[0].nodePath.value);
          }
        }
      }
      function cloneAST(ast) {
        const newAST = new AST$1("", { parseOptions: ast.parseOptions, rootNode: ast.rootNode });
        if (ast.sfc) {
          newAST.sfc = ast.sfc;
        }
        return newAST;
      }
      function getAttrValue(node2, attr) {
        const keyList = attr.split(".");
        let currentNode = node2;
        let deep = 0;
        keyList.forEach((attr2) => {
          if (currentNode[attr2]) {
            currentNode = currentNode[attr2];
            deep++;
          }
        });
        if (deep == keyList.length) {
          return currentNode;
        } else {
          return null;
        }
      }
      function initParent(ast) {
        if (ast.isHtml) {
          ast[0].parentList = ast.core.getParentListByAst(ast[0].nodePath);
          ast[0]._index = ast[0].parentList[0] ? ast[0].parentList[0].node.content.children.indexOf(ast[0].nodePath.node) : 0;
        } else {
          ast[0].parentList = core.getParentListByAst(ast[0].nodePath);
        }
        return ast[0].parentList;
      }
      function initSiblings(ast) {
        if (ast.language == "html") {
          const parent = ast.parent();
          const siblings = (parent.attr("content.children") || []).map((node2, index) => {
            return {
              _index: index,
              nodePath: new NodePath$1(node2, parent[0].nodePath, parent[0].nodePath),
              parseOptions: ast.parseOptions
            };
          });
          ast[0].siblings = siblings;
          ast[0].prevAll = siblings.filter((s) => s._index < ast._index);
          ast[0].nextAll = siblings.filter((s) => s._index > ast._index);
        } else {
          const parentList = initParent(ast);
          if (!parentList || parentList.length == 0) {
            return;
          }
          const parseOptions = ast.parseOptions;
          let getArrayParent = false;
          let i2 = 0;
          const siblings = [];
          const prevAll = [];
          const nextAll = [];
          let selfPathNode = ast[0].nodePath.value;
          while (!getArrayParent) {
            if (!parentList[i2] || !parentList[i2].value) {
              getArrayParent = true;
            } else if (Array.isArray(parentList[i2].value)) {
              getArrayParent = true;
              let isPrev = true;
              let childIndex = 0;
              while (parentList[i2].__childCache[childIndex]) {
                const nodePath2 = parentList[i2].__childCache[childIndex];
                if (nodePath2.value == selfPathNode) {
                  isPrev = false;
                } else {
                  siblings.push({ nodePath: nodePath2, parseOptions });
                  if (isPrev) {
                    prevAll.push({ nodePath: nodePath2, parseOptions });
                  } else {
                    nextAll.push({ nodePath: nodePath2, parseOptions });
                  }
                }
                childIndex++;
              }
              ast[0].siblings = siblings;
              ast[0].prevAll = prevAll;
              ast[0].nextAll = nextAll;
            }
            selfPathNode = parentList[i2].value;
            i2++;
          }
        }
      }
      function setAttrValue(node2, attrMap) {
        for (const key in attrMap) {
          const value = attrMap[key];
          const keyList = key.split(".");
          let currentNode = node2;
          keyList.forEach((attr, index) => {
            if (index == keyList.length - 1) {
              currentNode[attr] = value;
            } else if (currentNode[attr]) {
              currentNode = currentNode[attr];
            }
          });
        }
      }
      var Ast = AST$1;
      const fs$1 = require$$0;
      const code = function(filename = "src/code/input.js") {
        return fs$1.readFileSync(filename);
      };
      var readFile = code;
      const fs = require$$0;
      const writeCode = function(code2, filename = "src/code/output.js", showLog = true) {
        fs.writeFileSync(filename, code2);
        if (showLog) {
          console.log(`write code to ${filename} success!`);
        }
      };
      var writeFile$1 = writeCode;
      var name = "gogocode";
      var version = "1.0.55";
      var description = "The simplest tool to parse/transform/generate code on ast";
      var keywords = [
        "babel",
        "jscodeshift",
        "acorn",
        "babylon",
        "recast",
        "babel-generator",
        "babel-template",
        "babel-traverse",
        "babel-types",
        "esprima",
        "html-ast-transform",
        "htmlparser-to-html",
        "htmlparser2",
        "parse5",
        "ast"
      ];
      var main$1 = "index.js";
      var browser = "umd/gogocode.js";
      var types = "types/index.d.ts";
      var scripts = {
        test: "jest --coverage",
        build: "rollup -c",
        prepublishOnly: "npm run build && npm run test"
      };
      var repository = {
        type: "git",
        url: "git@github.com:thx/gogocode.git"
      };
      var author = "yexi";
      var license = "MIT";
      var devDependencies = {
        rollup: "^2.70.1",
        "@rollup/plugin-commonjs": "^21.0.2",
        "@rollup/plugin-json": "^4.1.0",
        "@rollup/plugin-node-resolve": "^13.1.3",
        "rollup-plugin-polyfill-node": "^0.8.0",
        "rollup-plugin-terser": "^7.0.2",
        jest: "^26.6.3",
        lerna: "^3.22.1",
        typescript: "^3.5.2"
      };
      var dependencies = {
        "@babel/parser": "^7.7.7",
        glob: "^7.1.6",
        "hyntax-yx": "^1.0.3",
        "indent-string": "^4.0.0",
        "recast-yx": "^0.18.11",
        "vue3-browser-compiler-yx": "^1.0.4"
      };
      var jest = {
        collectCoverage: true,
        coverageDirectory: "./coverage/",
        collectCoverageFrom: [
          "src/**/*.js",
          "index.js",
          "!**/node_modules/**",
          "!src/browser.js",
          "!src/run-html-plugin.js",
          "!src/run-js-plugin.js",
          "!src/serialize-node.js",
          "!src/file-tool/read-file.js",
          "!src/file-tool/write-file.js",
          "!src/js-core/build-node.js",
          "!src/js-core/get-absolute-value.js"
        ],
        testPathIgnorePatterns: [
          "/node_modules/"
        ]
      };
      var require$$7 = {
        name,
        version,
        description,
        keywords,
        main: main$1,
        browser,
        types,
        scripts,
        repository,
        author,
        license,
        devDependencies,
        dependencies,
        jest
      };
      const jsCore = core_1$2;
      const htmlCore = core_1$1;
      const vueCore = core_1;
      const NodePath = NodePath_1;
      const AST = Ast;
      const loadFile = readFile;
      const writeFile = writeFile$1;
      const pkg = require$$7;
      const langCoreMap = {
        "vue": vueCore,
        "html": htmlCore,
        "js": jsCore
      };
      function getCore(parseOptions = {}) {
        let core2 = jsCore;
        if (parseOptions.language && langCoreMap[parseOptions.language]) {
          core2 = langCoreMap[parseOptions.language];
        }
        if (parseOptions.html) {
          core2 = htmlCore;
          parseOptions.language = "html";
        }
        return core2;
      }
      const main = (code2, options2 = {}) => {
        code2 = code2 || "";
        let node2;
        let nodePath2;
        let parseOptions;
        let astFragment;
        let isProgram = options2.isProgram === void 0 || options2.isProgram === true;
        if (typeof options2.parseOptions == "object") {
          parseOptions = options2.parseOptions;
        }
        if (typeof options2.astFragment == "object") {
          astFragment = options2.astFragment;
        }
        if (typeof code2 == "string") {
          try {
            const core2 = getCore(parseOptions);
            node2 = core2.buildAstByAstStr(
              code2,
              astFragment,
              {
                parseOptions,
                isProgram
              }
            );
          } catch (e) {
            return {
              src: code2,
              error: `Only correct js / html / vue could be parse successfully, please check the code or parseOptions!`
            };
          }
          nodePath2 = new NodePath(node2);
        } else if (code2.nodeType) {
          nodePath2 = new NodePath(code2);
        } else if (code2.type) {
          nodePath2 = new NodePath(code2);
        } else if (code2.node && code2.parent) {
          nodePath2 = code2;
        } else {
          throw new Error("$ failed! invalid input! accept code / ast node / nodePath");
        }
        let ast = new AST(nodePath2, { parseOptions, rootNode: nodePath2 });
        return ast;
      };
      main.loadFile = (filePath, { parseOptions } = {}) => {
        const code2 = loadFile(filePath).toString();
        return main(code2, { parseOptions });
      };
      main.writeFile = writeFile;
      main.version = pkg.version;
      var $$1 = main;
      const $ = $$1;
      var gogocodeCore = $;
      return gogocodeCore;
    });
  }
});
export default require_gogocode();
/*! Bundled license information:

gogocode/umd/gogocode.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
//# sourceMappingURL=gogocode.js.map
